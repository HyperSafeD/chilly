{"version":3,"sources":["turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/react-native/environment.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/store.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/requiredFunds.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/modes/relay.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Base64.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/call.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/viem/Key.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/schema/request.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Provider.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/Transport.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/userAgent.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Value.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/modes/reactNative.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/index.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/WebAuthnP256.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/experimental/erc7821/utils/encodeCalls.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/viem/Account.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/TypedData.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Siwe.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/mode.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/tokens.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/AbiError.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/Storage.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/viem/ContractActions.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/urlString.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/experimental/erc7821/utils/getExecuteError.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/P256.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/experimental/erc7821/errors.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/RpcResponse.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/erc8010.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/experimental/erc7821/utils/encodeExecuteData.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/react-native/utils.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/modes/dialog.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/Dialog.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/Porto.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/viem/RelayActions.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/Chains.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/permissions.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/_generated/chains.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/experimental/erc7821/constants.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/Messenger.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/WebCryptoP256.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/promise.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/permissionsRequest.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/siwe.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/internal/webauthn.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/Mode.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/viem/RelayClient.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/provider.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/internal/uid.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/utils.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/core/internal/_generated/contracts/IthacaAccount.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/porto/src/viem/internal/relayActions.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/PersonalMessage.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/RpcSchema.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/RpcRequest.ts"],"sourcesContent":["import type * as AuthSession from 'expo-auth-session'\nimport type * as WebBrowser from 'expo-web-browser'\n\nlet environment: ReactNativeEnvironment\n\nexport const isEnvironmentConfigured = () => environment !== undefined\n\nexport const reactNative = {\n  get environment() {\n    if (!environment)\n      throw new Error('React Native environment is not configured')\n    return environment\n  },\n  set environment(env) {\n    environment = env\n  },\n} satisfies {\n  environment: ReactNativeEnvironment\n}\n\nexport type AuthSessionOpenOptions = WebBrowser.AuthSessionOpenOptions\n\nexport type ReactNativeEnvironment = {\n  redirectUri?:\n    | {\n        /**\n         * the app scheme, usually defined in `app.json` / `app.config.ts`\n         * run `npx uri-scheme list` to get your app's scheme\n         */\n        scheme: string\n        /**\n         * the path to redirect to\n         *\n         * @default '/'\n         */\n        path?: string\n      }\n    | undefined\n  makeRedirectUri: typeof AuthSession.makeRedirectUri\n  openAuthSessionAsync: typeof WebBrowser.openAuthSessionAsync\n  dismissAuthSession: typeof WebBrowser.dismissAuthSession\n  maybeCompleteAuthSession?: typeof WebBrowser.maybeCompleteAuthSession\n}\n","import type * as Porto from '../Porto.js'\n\nexport async function waitForHydration(store: Porto.Store) {\n  if (store.persist.hasHydrated()) return\n  await new Promise((resolve) => {\n    store.persist.onFinishHydration(() => resolve(true))\n    setTimeout(() => resolve(true), 100)\n  })\n}\n","import * as Value from 'ox/Value'\nimport type * as Capabilities_relay from './relay/schema/capabilities.js'\nimport type * as Capabilities from './schema/capabilities.js'\nimport type * as Token from './schema/token.js'\n\n/**\n * Transforms into Relay-formatted required funds.\n *\n * @param requiredFunds - The required funds object to convert.\n * @param options - The options for the conversion.\n * @returns The converted required funds object.\n */\n// TODO: perhaps Relay should support `Capabilities.requiredFunds.Request` format.\nexport function toRelay(\n  requiredFunds: toRelay.Value,\n  options: toRelay.Options,\n): toRelay.ReturnType {\n  const { tokens } = options\n\n  const interopTokens = tokens.filter((token) => token.interop)\n\n  return requiredFunds.map((requiredFund) => {\n    if (requiredFund.address) return requiredFund\n\n    const interopToken = interopTokens.find(\n      (token) => token.symbol === requiredFund.symbol,\n    )\n    if (!interopToken)\n      throw new Error(`interop token not found: ${requiredFund.symbol}`)\n\n    return {\n      address: interopToken.address,\n      value: Value.from(requiredFund.value, interopToken.decimals),\n    }\n  })\n}\n\nexport namespace toRelay {\n  export type Value = Capabilities.requiredFunds.Request\n\n  export type Options = {\n    tokens: readonly Token.Token[]\n  }\n  export type ReturnType = Capabilities_relay.requiredFunds.Request\n}\n","import * as Bytes from 'ox/Bytes'\nimport * as Hash from 'ox/Hash'\nimport * as Hex from 'ox/Hex'\nimport * as Json from 'ox/Json'\nimport * as PersonalMessage from 'ox/PersonalMessage'\nimport * as Provider from 'ox/Provider'\nimport * as PublicKey from 'ox/PublicKey'\nimport * as RpcResponse from 'ox/RpcResponse'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport * as TypedData from 'ox/TypedData'\nimport * as WebAuthnP256 from 'ox/WebAuthnP256'\nimport { waitForCallsStatus } from 'viem/actions'\nimport * as Account from '../../../viem/Account.js'\nimport * as ContractActions from '../../../viem/ContractActions.js'\nimport * as RelayActions_internal from '../../../viem/internal/relayActions.js'\nimport * as Key from '../../../viem/Key.js'\nimport * as RelayActions from '../../../viem/RelayActions.js'\nimport * as Erc8010 from '../erc8010.js'\nimport * as Mode from '../mode.js'\nimport * as PermissionsRequest from '../permissionsRequest.js'\nimport * as RequiredFunds from '../requiredFunds.js'\nimport * as Siwe from '../siwe.js'\nimport * as Tokens from '../tokens.js'\nimport * as U from '../utils.js'\n\n/**\n * Mode for a WebAuthn-based environment that interacts with the Porto\n * Relay. Account management, signing, and execution is coordinated\n * between the library and the Relay.\n *\n * @param parameters - Parameters.\n * @returns Mode.\n */\nexport function relay(parameters: relay.Parameters = {}) {\n  const config = parameters\n  const { mock, multichain = true, webAuthn } = config\n\n  let address_internal: Hex.Hex | undefined\n  let email_internal: string | undefined\n\n  const keystoreHost = (() => {\n    if (config.keystoreHost === 'self') return undefined\n    if (\n      typeof window !== 'undefined' &&\n      window.location?.hostname === 'localhost'\n    )\n      return undefined\n    return config.keystoreHost\n  })()\n\n  return Mode.from({\n    actions: {\n      async addFunds() {\n        throw new Provider.UnsupportedMethodError()\n      },\n\n      async createAccount(parameters) {\n        const {\n          admins,\n          email,\n          label,\n          permissions,\n          internal,\n          signInWithEthereum,\n        } = parameters\n        const { client } = internal\n\n        const eoa = Account.fromPrivateKey(Secp256k1.randomPrivateKey())\n\n        const feeTokens = await Tokens.getTokens(client)\n\n        const adminKey = !mock\n          ? await Key.createWebAuthnP256({\n              createFn: webAuthn?.createFn,\n              label:\n                label ||\n                `${eoa.address.slice(0, 8)}\\u2026${eoa.address.slice(-6)}`,\n              rpId: keystoreHost,\n              userId: Bytes.from(eoa.address),\n            })\n          : Key.createHeadlessWebAuthnP256()\n        const sessionKey = await PermissionsRequest.toKey(permissions, {\n          chainId: client.chain.id,\n          feeTokens,\n        })\n\n        const adminKeys = admins?.map((admin) => Key.from(admin))\n\n        const account = await RelayActions.upgradeAccount(client, {\n          account: eoa,\n          authorizeKeys: [\n            adminKey,\n            ...(adminKeys ?? []),\n            ...(sessionKey ? [sessionKey] : []),\n          ],\n        })\n\n        address_internal = eoa.address\n\n        if (email && label)\n          await RelayActions.setEmail(client, {\n            email: label,\n            walletAddress: account.address,\n          })\n\n        const signInWithEthereum_response = await (async () => {\n          if (!signInWithEthereum) return undefined\n\n          const message = await Siwe.buildMessage(client, signInWithEthereum, {\n            address: account.address,\n          })\n          const signature = await Account.sign(eoa, {\n            payload: PersonalMessage.getSignPayload(Hex.fromString(message)),\n          })\n          const signature_erc8010 = await Erc8010.wrap(client, {\n            address: account.address,\n            signature,\n          })\n\n          return { message, signature: signature_erc8010 }\n        })()\n\n        return {\n          account: {\n            ...account,\n            signInWithEthereum: signInWithEthereum_response,\n          },\n        }\n      },\n\n      async getAccountVersion(parameters) {\n        const { address, internal } = parameters\n        const { client } = internal\n\n        const { contracts } = await RelayActions.getCapabilities(client)\n        const { accountImplementation } = contracts\n\n        const latest = await ContractActions.getEip712Domain(client, {\n          account: Account.from(accountImplementation),\n        }).then((x) => x.version)\n\n        const current = await ContractActions.getEip712Domain(client, {\n          account: address,\n        })\n          .then((x) => x.version)\n          // TODO: get counterfactual account version via Relay.\n          .catch(() => latest)\n\n        if (!current || !latest) throw new Error('version not found.')\n\n        return { current, latest }\n      },\n\n      async getAssets(parameters) {\n        const { account, chainFilter, assetFilter, assetTypeFilter, internal } =\n          parameters\n        const { client } = internal\n\n        const result = await RelayActions.getAssets(client, {\n          account,\n          assetFilter,\n          assetTypeFilter,\n          chainFilter,\n        })\n\n        return result\n      },\n\n      async getCallsStatus(parameters) {\n        const { id, internal } = parameters\n        const { client } = internal\n\n        const result = await RelayActions_internal.getCallsStatus(client, {\n          id,\n        })\n\n        return {\n          atomic: true,\n          chainId: Hex.fromNumber(client.chain.id),\n          id,\n          receipts: result.receipts?.map((receipt) => ({\n            blockHash: receipt.blockHash,\n            blockNumber: Hex.fromNumber(receipt.blockNumber),\n            gasUsed: Hex.fromNumber(receipt.gasUsed),\n            logs: receipt.logs,\n            status: receipt.status,\n            transactionHash: receipt.transactionHash,\n          })),\n          status: result.status,\n          version: '1.0',\n        }\n      },\n\n      async getCapabilities(parameters) {\n        const { chainIds, internal } = parameters\n        const { client } = internal\n\n        const base = {\n          atomic: {\n            status: 'supported',\n          },\n          atomicBatch: {\n            supported: true,\n          },\n          feeToken: {\n            supported: true,\n            tokens: [],\n          },\n          merchant: {\n            supported: true,\n          },\n          permissions: {\n            supported: true,\n          },\n          requiredFunds: {\n            supported: Boolean(multichain),\n            tokens: [],\n          },\n        } as const\n\n        const capabilities = await RelayActions.getCapabilities(client, {\n          chainIds: chainIds ? chainIds.map((id) => Hex.toNumber(id)) : 'all',\n          raw: true,\n        })\n\n        return Object.entries(capabilities).reduce(\n          (acc, [chainId, capabilities]) => ({\n            // biome-ignore lint/performance/noAccumulatingSpread: _\n            ...acc,\n            [chainId]: {\n              ...base,\n              ...capabilities,\n              feeToken: {\n                supported: true,\n                tokens: capabilities.fees.tokens,\n              },\n              requiredFunds: {\n                supported: Boolean(multichain),\n                tokens: multichain\n                  ? capabilities.fees.tokens.filter((token) => token.interop)\n                  : [],\n              },\n            },\n          }),\n          {} as Record<Hex.Hex, typeof base>,\n        ) as Record<Hex.Hex, typeof base>\n      },\n\n      async getKeys(parameters) {\n        const { account, chainIds, internal } = parameters\n        const { client } = internal\n\n        const keys = await RelayActions.getKeys(client, {\n          account,\n          chainIds,\n        })\n\n        return U.uniqBy(\n          [...keys, ...(account.keys ?? [])],\n          (key) => key.publicKey,\n        )\n      },\n\n      async grantAdmin(parameters) {\n        const { account, internal } = parameters\n        const { client } = internal\n\n        const authorizeKey = Key.from(parameters.key, {\n          chainId: client.chain.id,\n        })\n\n        const feeToken = await Tokens.resolveFeeToken(client, {\n          addressOrSymbol: parameters.feeToken,\n          store: internal.store,\n        })\n\n        const { id } = await RelayActions.sendCalls(client, {\n          account,\n          authorizeKeys: [authorizeKey],\n          feeToken: feeToken?.address,\n          webAuthn,\n        })\n        await waitForCallsStatus(client, {\n          id,\n          pollingInterval: 500,\n        })\n\n        return { key: authorizeKey }\n      },\n\n      async grantPermissions(parameters) {\n        const { account, internal, permissions } = parameters\n        const { client } = internal\n\n        const feeTokens = await Tokens.getTokens(client)\n\n        // Parse permissions request into a structured key.\n        const authorizeKey = await PermissionsRequest.toKey(permissions, {\n          chainId: client.chain.id,\n          feeTokens,\n        })\n        if (!authorizeKey) throw new Error('key to authorize not found.')\n\n        const adminKey = account.keys?.find(\n          (key) => key.role === 'admin' && key.privateKey,\n        )\n        if (!adminKey) throw new Error('admin key not found.')\n\n        const { context, digest } = await RelayActions.prepareCalls(client, {\n          account,\n          authorizeKeys: [authorizeKey],\n          key: adminKey,\n          preCalls: true,\n        })\n        const signature = await Key.sign(adminKey, {\n          address: null,\n          payload: digest,\n        })\n        await RelayActions.sendPreparedCalls(client, {\n          context,\n          key: adminKey,\n          signature,\n        })\n\n        return { key: authorizeKey }\n      },\n\n      async loadAccounts(parameters) {\n        const { internal, permissions, signInWithEthereum } = parameters\n        const { client } = internal\n\n        const feeTokens = await Tokens.getTokens(client)\n\n        const authorizeKey = await PermissionsRequest.toKey(permissions, {\n          chainId: client.chain.id,\n          feeTokens,\n        })\n\n        // Prepare calls to sign over the session key or SIWE message to authorize.\n        // TODO: figure out with relay if we can prepare the \"precall\" here also.\n        // prepareCalls requires the EOA address, but we don't know it here.\n        const { digest, digestType, message } = await (async () => {\n          if (signInWithEthereum && parameters.address) {\n            const message = await Siwe.buildMessage(\n              client,\n              signInWithEthereum,\n              {\n                address: parameters.address,\n              },\n            )\n            return {\n              context: undefined,\n              digest: PersonalMessage.getSignPayload(Hex.fromString(message)),\n              digestType: 'siwe',\n              message,\n            } as const\n          }\n          return {\n            context: undefined,\n            digest: '0x',\n            message: undefined,\n          } as const\n        })()\n\n        const { address, credentialId, webAuthnSignature } =\n          await (async () => {\n            if (mock) {\n              if (!address_internal)\n                throw new Error('address_internal not found.')\n              return {\n                address: address_internal,\n                credentialId: undefined,\n              } as const\n            }\n\n            // If the address and credentialId are provided, we can skip the\n            // WebAuthn discovery step.\n            if (parameters.address && parameters.key)\n              return {\n                address: parameters.address,\n                credentialId: parameters.key.credentialId,\n              }\n\n            // Discovery step. We need to do this to extract the key id\n            // to query for the Account.\n            // We will also optionally sign over a digest to authorize\n            // a session key if the user has provided one.\n            const webAuthnSignature = await WebAuthnP256.sign({\n              challenge: digest,\n              getFn: webAuthn?.getFn,\n              rpId: keystoreHost,\n            })\n            const response = webAuthnSignature.raw\n              .response as AuthenticatorAssertionResponse\n\n            const address = Bytes.toHex(new Uint8Array(response.userHandle!))\n            const credentialId = webAuthnSignature.raw.id\n\n            return { address, credentialId, webAuthnSignature }\n          })()\n\n        const keys = await RelayActions.getKeys(client, {\n          account: address,\n          chainIds: [client.chain.id],\n        })\n\n        // Instantiate the account based off the extracted address and keys.\n        const account = Account.from({\n          address,\n          keys: [...keys, ...(authorizeKey ? [authorizeKey] : [])].map(\n            (key, i) => {\n              // Assume that the first key is the admin WebAuthn key.\n              if (i === 0) {\n                if (key.type === 'webauthn-p256')\n                  return Key.fromWebAuthnP256({\n                    ...key,\n                    credential: {\n                      id: credentialId!,\n                      publicKey: PublicKey.fromHex(key.publicKey),\n                    },\n                    id: address,\n                    rpId: keystoreHost,\n                  })\n              }\n              return key\n            },\n          ),\n        })\n\n        const adminKey = Account.getKey(account, { role: 'admin' })!\n\n        // Get the signature of the authorize session key pre-call.\n        const signature = await (async () => {\n          // If we don't have a digest, we never signed over anything.\n          if (digest === '0x') return undefined\n\n          // If we signed to authorize the session key at credential\n          // discovery, we will need to form the signature and store it\n          // as a signed pre-call.\n          if (webAuthnSignature)\n            return Key.wrapSignature(\n              Key.serializeWebAuthnSignature(webAuthnSignature),\n              {\n                keyType: 'webauthn-p256',\n                publicKey: adminKey.publicKey,\n              },\n            )\n\n          // Otherwise, we will sign over the digest for authorizing\n          // the session key.\n          return await Key.sign(adminKey, {\n            address: account.address,\n            payload: digest,\n          })\n        })()\n\n        // Prepare and send the authorize key pre-call.\n        if (authorizeKey) {\n          const { context, digest } = await RelayActions.prepareCalls(client, {\n            account,\n            authorizeKeys: [authorizeKey],\n            preCalls: true,\n          })\n          const signature = await Key.sign(adminKey, {\n            address: null,\n            payload: digest,\n          })\n          await RelayActions.sendPreparedCalls(client, {\n            context,\n            key: adminKey,\n            signature,\n          })\n        }\n\n        const signInWithEthereum_response = await (async () => {\n          if (!signInWithEthereum) return undefined\n\n          if (digestType === 'siwe' && message && signature) {\n            const signature_erc8010 = await Erc8010.wrap(client, {\n              address: account.address,\n              signature,\n            })\n            return { message, signature: signature_erc8010 }\n          }\n\n          {\n            const message = await Siwe.buildMessage(\n              client,\n              signInWithEthereum,\n              {\n                address: account.address,\n              },\n            )\n            const signature = await Account.sign(account, {\n              payload: PersonalMessage.getSignPayload(Hex.fromString(message)),\n              role: 'admin',\n            })\n            const signature_erc8010 = await Erc8010.wrap(client, {\n              address: account.address,\n              signature,\n            })\n            return {\n              message,\n              signature: signature_erc8010,\n            }\n          }\n        })()\n\n        return {\n          accounts: [\n            {\n              ...account,\n              signInWithEthereum: signInWithEthereum_response,\n            },\n          ],\n        }\n      },\n\n      async prepareCalls(parameters) {\n        const { account, calls, internal, merchantUrl } = parameters\n        const { client } = internal\n\n        // Try and extract an authorized key to sign the calls with.\n        const key =\n          parameters.key ??\n          (await Mode.getAuthorizedExecuteKey({\n            account,\n            calls,\n          }))\n        if (!key) throw new Error('cannot find authorized key to sign with.')\n\n        const [tokens, feeToken] = await Promise.all([\n          Tokens.getTokens(client),\n          Tokens.resolveFeeToken(client, {\n            addressOrSymbol: parameters.feeToken,\n            store: internal.store,\n          }),\n        ])\n\n        const requiredFunds = RequiredFunds.toRelay(\n          parameters.requiredFunds ?? [],\n          {\n            tokens,\n          },\n        )\n\n        const { capabilities, context, digest, typedData } =\n          await RelayActions.prepareCalls(client, {\n            account,\n            calls,\n            feeToken: feeToken?.address,\n            key,\n            merchantUrl,\n            requiredFunds: multichain ? requiredFunds : undefined,\n          })\n\n        const quotes = context.quote?.quotes ?? []\n        const outputQuote = quotes[quotes.length - 1]\n\n        return {\n          account,\n          capabilities: {\n            ...capabilities,\n            quote: context.quote as any,\n          },\n          chainId: client.chain.id,\n          context: {\n            ...context,\n            account,\n            calls,\n            nonce: outputQuote?.intent.nonce,\n          },\n          digest,\n          key,\n          typedData,\n        }\n      },\n\n      async prepareUpgradeAccount(parameters) {\n        const { address, email, label, internal, permissions } = parameters\n        const { client } = internal\n\n        const [tokens, feeToken] = await Promise.all([\n          Tokens.getTokens(client),\n          Tokens.resolveFeeToken(client, {\n            store: internal.store,\n          }),\n        ])\n\n        const adminKey = !mock\n          ? await Key.createWebAuthnP256({\n              createFn: webAuthn?.createFn,\n              label:\n                label || `${address.slice(0, 8)}\\u2026${address.slice(-6)}`,\n              rpId: keystoreHost,\n              userId: Bytes.from(address),\n            })\n          : Key.createHeadlessWebAuthnP256()\n        const sessionKey = await PermissionsRequest.toKey(permissions, {\n          chainId: client.chain.id,\n          feeTokens: tokens,\n        })\n\n        const { context, digests } = await RelayActions.prepareUpgradeAccount(\n          client,\n          {\n            address,\n            authorizeKeys: [adminKey, ...(sessionKey ? [sessionKey] : [])],\n            feeToken: feeToken?.address,\n          },\n        )\n\n        if (email) email_internal = label\n\n        return {\n          context,\n          digests,\n        }\n      },\n\n      async revokeAdmin(parameters) {\n        const { account, id, internal } = parameters\n        const { client } = internal\n\n        const key = account.keys?.find((key) => key.id === id)\n        if (!key) return\n\n        // Cannot revoke the only WebAuthn key left\n        if (\n          key.type === 'webauthn-p256' &&\n          account.keys?.filter((key) => key.type === 'webauthn-p256').length ===\n            1\n        )\n          throw new Error('revoke the only WebAuthn key left.')\n\n        try {\n          const feeToken = await Tokens.resolveFeeToken(client, {\n            addressOrSymbol: parameters.feeToken,\n            store: internal.store,\n          })\n          const { id } = await RelayActions.sendCalls(client, {\n            account,\n            feeToken: feeToken?.address,\n            revokeKeys: [key],\n            webAuthn,\n          })\n          await waitForCallsStatus(client, {\n            id,\n          })\n        } catch (e) {\n          const error = e as RelayActions.sendCalls.ErrorType\n          if (\n            error.name === 'Rpc.ExecutionError' &&\n            error.abiError?.name === 'KeyDoesNotExist'\n          )\n            return\n          throw e\n        }\n      },\n\n      async revokePermissions(parameters) {\n        const { account, id, internal } = parameters\n        const { client } = internal\n\n        const key = account.keys?.find((key) => key.id === id)\n        if (!key) return\n\n        // We shouldn't be able to revoke the admin keys.\n        if (key.role === 'admin') throw new Error('cannot revoke admins.')\n\n        try {\n          const feeToken = await Tokens.resolveFeeToken(client, {\n            addressOrSymbol: parameters.feeToken,\n            store: internal.store,\n          })\n          const { id } = await RelayActions.sendCalls(client, {\n            account,\n            feeToken: feeToken?.address,\n            revokeKeys: [key],\n            webAuthn,\n          })\n          await waitForCallsStatus(client, {\n            id,\n          })\n        } catch (e) {\n          const error = e as RelayActions.sendCalls.ErrorType\n          if (\n            error.name === 'Rpc.ExecutionError' &&\n            error.abiError?.name === 'KeyDoesNotExist'\n          )\n            return\n          throw e\n        }\n      },\n\n      async sendCalls(parameters) {\n        const { account, asTxHash, calls, chainId, internal, merchantUrl } =\n          parameters\n        const { client } = internal\n\n        // Try and extract an authorized key to sign the calls with.\n        const key = await Mode.getAuthorizedExecuteKey({\n          account,\n          calls,\n          permissionsId: parameters.permissionsId,\n        })\n\n        // Resolve fee token to use.\n        const [tokens, feeToken] = await Promise.all([\n          Tokens.getTokens(client),\n          Tokens.resolveFeeToken(client, {\n            addressOrSymbol: parameters.feeToken,\n            store: internal.store,\n          }),\n        ])\n\n        const requiredFunds = RequiredFunds.toRelay(\n          parameters.requiredFunds ?? [],\n          {\n            tokens,\n          },\n        )\n\n        // Execute the calls (with the key if provided, otherwise it will\n        // fall back to an admin key).\n        const result = await RelayActions.sendCalls(client, {\n          account,\n          calls,\n          feeToken: feeToken?.address,\n          key,\n          merchantUrl,\n          requiredFunds: multichain ? requiredFunds : undefined,\n          webAuthn,\n          ...(chainId ? { chain: { id: chainId } } : {}),\n        })\n\n        if (asTxHash) {\n          const { id, receipts, status } = await waitForCallsStatus(client, {\n            id: result.id,\n            pollingInterval: 500,\n          })\n          if (!receipts?.[0]) {\n            if (status === 'success')\n              throw new Provider.UnknownBundleIdError({\n                message: 'Call bundle with id: ' + id + ' not found.',\n              })\n            throw new RpcResponse.TransactionRejectedError({\n              message: 'Transaction failed under call bundle id: ' + id + '.',\n            })\n          }\n          return {\n            id: receipts[0].transactionHash,\n          }\n        }\n\n        return result\n      },\n\n      async sendPreparedCalls(parameters) {\n        const { context, key, internal, signature } = parameters\n        const { client } = internal\n\n        const { id } = await RelayActions.sendPreparedCalls(client, {\n          context: context as never,\n          key,\n          signature,\n        })\n\n        return id\n      },\n\n      async signPersonalMessage(parameters) {\n        const { account, data, internal } = parameters\n        const { client } = internal\n\n        // Only admin keys can sign personal messages.\n        const key = account.keys?.find(\n          (key) => key.role === 'admin' && key.privateKey,\n        )\n        if (!key) throw new Error('cannot find admin key to sign with.')\n\n        const signature = await Account.sign(account, {\n          key,\n          payload: PersonalMessage.getSignPayload(data),\n          webAuthn,\n        })\n\n        return Erc8010.wrap(client, { address: account.address, signature })\n      },\n\n      async signTypedData(parameters) {\n        const { account, internal } = parameters\n        const { client } = internal\n\n        // Only admin keys can sign typed data.\n        const key = account.keys?.find(\n          (key) => key.role === 'admin' && key.privateKey,\n        )\n        if (!key) throw new Error('cannot find admin key to sign with.')\n\n        const data = Json.parse(parameters.data)\n        const isOrchestrator = data.domain?.name === 'Orchestrator'\n        const signature = await Account.sign(account, {\n          key,\n          payload: TypedData.getSignPayload(data),\n          // If the domain is the Orchestrator, we don't need to replay-safe sign.\n          replaySafe: !isOrchestrator,\n          webAuthn,\n        })\n\n        return isOrchestrator\n          ? signature\n          : Erc8010.wrap(client, { address: account.address, signature })\n      },\n\n      async upgradeAccount(parameters) {\n        const { account, context, internal, signatures } = parameters\n        const { client } = internal\n\n        await RelayActions.upgradeAccount(client, {\n          context: context as any,\n          signatures,\n        })\n\n        if (email_internal)\n          await RelayActions.setEmail(client, {\n            email: email_internal,\n            walletAddress: account.address,\n          })\n\n        return { account }\n      },\n\n      async verifyEmail(parameters) {\n        const { account, chainId, email, token, internal, walletAddress } =\n          parameters\n        const { client } = internal\n\n        // Only allow admin keys can sign message.\n        const key = account.keys?.find(\n          (key) => key.role === 'admin' && key.privateKey,\n        )\n        if (!key) throw new Error('cannot find admin key to sign with.')\n\n        const signature = await Account.sign(account, {\n          key,\n          payload: Hash.keccak256(Hex.fromString(`${email}${token}`)),\n          webAuthn,\n        })\n\n        return await RelayActions.verifyEmail(client, {\n          chainId,\n          email,\n          signature,\n          token,\n          walletAddress,\n        })\n      },\n    },\n    config: parameters,\n    name: 'rpc',\n  })\n}\n\nexport declare namespace relay {\n  type Parameters = {\n    /**\n     * Keystore host (WebAuthn relying party).\n     * @default 'self'\n     */\n    keystoreHost?: 'self' | (string & {}) | undefined\n    /**\n     * Mock mode. Testing purposes only.\n     * @default false\n     * @internal @deprecated\n     */\n    mock?: boolean | undefined\n    /**\n     * Whether to support multichain.\n     * @default true\n     */\n    multichain?: boolean | undefined\n    /**\n     * WebAuthn configuration.\n     */\n    webAuthn?:\n      | {\n          createFn?:\n            | WebAuthnP256.createCredential.Options['createFn']\n            | undefined\n          getFn?: WebAuthnP256.sign.Options['getFn'] | undefined\n        }\n      | undefined\n  }\n}\n","import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\nconst decoder = /*#__PURE__*/ new TextDecoder()\n\nconst integerToCharacter = /*#__PURE__*/ Object.fromEntries(\n  Array.from(\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  ).map((a, i) => [i, a.charCodeAt(0)]),\n)\n\nconst characterToInteger = /*#__PURE__*/ {\n  ...Object.fromEntries(\n    Array.from(\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    ).map((a, i) => [a.charCodeAt(0), i]),\n  ),\n  ['='.charCodeAt(0)]: 0,\n  ['-'.charCodeAt(0)]: 62,\n  ['_'.charCodeAt(0)]: 63,\n} as Record<number, number>\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The byte array to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromBytes(value: Bytes.Bytes, options: fromBytes.Options = {}) {\n  const { pad = true, url = false } = options\n\n  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4)\n\n  for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {\n    const y = (value[j]! << 16) + (value[j + 1]! << 8) + (value[j + 2]! | 0)\n    encoded[i] = integerToCharacter[y >> 18]!\n    encoded[i + 1] = integerToCharacter[(y >> 12) & 0x3f]!\n    encoded[i + 2] = integerToCharacter[(y >> 6) & 0x3f]!\n    encoded[i + 3] = integerToCharacter[y & 0x3f]!\n  }\n\n  const k = value.length % 3\n  const end = Math.floor(value.length / 3) * 4 + (k && k + 1)\n  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end))\n  if (pad && k === 1) base64 += '=='\n  if (pad && k === 2) base64 += '='\n  if (url) base64 = base64.replaceAll('+', '-').replaceAll('/', '_')\n  return base64\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The hex value to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromHex(value: Hex.Hex, options: fromHex.Options = {}) {\n  return fromBytes(Bytes.fromHex(value), options)\n}\n\nexport declare namespace fromHex {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world')\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world', { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello wod', { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The string to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromString(value: string, options: fromString.Options = {}) {\n  return fromBytes(Bytes.fromString(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.toBytes('aGVsbG8gd29ybGQ=')\n * // @log: Uint8Array([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(value: string): Bytes.Bytes {\n  const base64 = value.replace(/=+$/, '')\n\n  const size = base64.length\n\n  const decoded = new Uint8Array(size + 3)\n  encoder.encodeInto(base64 + '===', decoded)\n\n  for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {\n    const x =\n      (characterToInteger[decoded[i]!]! << 18) +\n      (characterToInteger[decoded[i + 1]!]! << 12) +\n      (characterToInteger[decoded[i + 2]!]! << 6) +\n      characterToInteger[decoded[i + 3]!]!\n    decoded[j] = x >> 16\n    decoded[j + 1] = (x >> 8) & 0xff\n    decoded[j + 2] = x & 0xff\n  }\n\n  const decodedSize = (size >> 2) * 3 + (size % 4 && (size % 4) - 1)\n  return new Uint8Array(decoded.buffer, 0, decodedSize)\n}\n\nexport declare namespace toBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.toHex('aGVsbG8gd29ybGQ=')\n * // @log: 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Hex.Hex}.\n */\nexport function toHex(value: string): Hex.Hex {\n  return Hex.fromBytes(toBytes(value))\n}\n\nexport declare namespace toHex {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.toString('aGVsbG8gd29ybGQ=')\n * // @log: 'hello world'\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded string.\n */\nexport function toString(value: string): string {\n  return Bytes.toString(toBytes(value))\n}\n\nexport declare namespace toString {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n","import * as AbiFunction from 'ox/AbiFunction'\nimport type * as Address from 'ox/Address'\nimport type * as Hex from 'ox/Hex'\nimport * as Key from '../../viem/Key.js'\nimport * as IthacaAccount from './_generated/contracts/IthacaAccount.js'\n\n/** Stub address for self-execution. */\nexport const selfAddress = '0x2323232323232323232323232323232323232323'\n\nexport type Call = {\n  to: Address.Address\n  value?: bigint | undefined\n  data?: Hex.Hex | undefined\n}\n\n/**\n * Instantiates values to populate a call to authorize a key.\n *\n * @param parameters - Parameters.\n * @returns Instantiated values.\n */\nexport function authorize(parameters: authorize.Parameters) {\n  const { key } = parameters\n  return {\n    data: AbiFunction.encodeData(\n      AbiFunction.fromAbi(IthacaAccount.abi, 'authorize'),\n      [Key.serialize(key)],\n    ),\n    to: selfAddress,\n  } as const satisfies Call\n}\n\nexport declare namespace authorize {\n  export type Parameters = {\n    /** Key to authorize. */\n    key: Key.Key\n  }\n}\n\nexport const anyHash =\n  '0x3232323232323232323232323232323232323232323232323232323232323232'\nexport const anyTarget = '0x3232323232323232323232323232323232323232'\nexport const anySelector = '0x32323232'\n\n/**\n * Instantiates values to populate a call to set the label of a delegated account.\n *\n * @param parameters - Parameters.\n * @returns Instantiated values.\n */\nexport function setCanExecute(parameters: setCanExecute.Parameters = {}) {\n  const {\n    enabled = true,\n    key,\n    selector = anySelector,\n    to = anyTarget,\n  } = parameters\n  const hash = key ? key.hash : anyHash\n\n  return {\n    data: AbiFunction.encodeData(\n      AbiFunction.fromAbi(IthacaAccount.abi, 'setCanExecute'),\n      [hash, to, selector, enabled],\n    ),\n    to: selfAddress,\n  } as const satisfies Call\n}\n\nexport declare namespace setCanExecute {\n  export type Parameters = {\n    /** Whether to enable execution. */\n    enabled?: boolean | undefined\n    /** Key to authorize. */\n    key?: Key.Key | undefined\n    /** Target to authorize. */\n    to?: Address.Address | undefined\n    /** Function selector to authorize. */\n    selector?: Hex.Hex | undefined\n  }\n}\n\n/**\n * Instantiates values to populate a call to set the label of a delegated account.\n *\n * @param parameters - Parameters.\n * @returns Instantiated values.\n */\nexport function setLabel(parameters: setLabel.Parameters) {\n  const { label } = parameters\n  return {\n    data: AbiFunction.encodeData(\n      AbiFunction.fromAbi(IthacaAccount.abi, 'setLabel'),\n      [label],\n    ),\n    to: selfAddress,\n  } as const satisfies Call\n}\n\nexport declare namespace setLabel {\n  export type Parameters = {\n    /** Label to set. */\n    label: string\n  }\n}\n\n/**\n * Instantiates values to populate a call to set the spend limit of a key.\n *\n * @param parameters - Parameters.\n * @returns Instantiated values.\n */\nexport function setSpendLimit(parameters: setSpendLimit.Parameters) {\n  const { key, period, limit } = parameters\n  const token = parameters.token ?? '0x0000000000000000000000000000000000000000'\n  return {\n    data: AbiFunction.encodeData(\n      AbiFunction.fromAbi(IthacaAccount.abi, 'setSpendLimit'),\n      [key.hash, token, Key.toSerializedSpendPeriod[period], limit],\n    ),\n    to: selfAddress,\n  } as const satisfies Call\n}\n\nexport declare namespace setSpendLimit {\n  export type Parameters = {\n    /** Key to set the spend limit of. */\n    key: Key.Key\n    /** Limit to set. */\n    limit: bigint\n    /** Period to set. */\n    period: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'\n    /** Token to set. */\n    token?: Address.Address | undefined\n  }\n}\n\n/**\n * Instantiates values to populate a call to set the signature checker approval of a key.\n *\n * @param parameters - Parameters.\n * @returns Instantiated values.\n */\nexport function setSignatureCheckerApproval(\n  parameters: setSignatureCheckerApproval.Parameters,\n) {\n  const { address, key, enabled } = parameters\n  return {\n    data: AbiFunction.encodeData(\n      AbiFunction.fromAbi(IthacaAccount.abi, 'setSignatureCheckerApproval'),\n      [key.hash, address, enabled],\n    ),\n    to: selfAddress,\n  } as const satisfies Call\n}\n\nexport declare namespace setSignatureCheckerApproval {\n  export type Parameters = {\n    /** Contract address to authorize. */\n    address: Address.Address\n    /** Whether the key can verify signatures. */\n    enabled: boolean\n    /** Key to apply the signature verification to. */\n    key: Key.Key\n  }\n}\n\n/**\n * Instantiates values to populate a call to remove the spend limit of a key.\n *\n * @param parameters - Parameters.\n * @returns Instantiated values.\n */\nexport function removeSpendLimit(parameters: removeSpendLimit.Parameters) {\n  const { key, token, period } = parameters\n  return {\n    data: AbiFunction.encodeData(\n      AbiFunction.fromAbi(IthacaAccount.abi, 'removeSpendLimit'),\n      [key.hash, token, Key.toSerializedSpendPeriod[period]],\n    ),\n    to: selfAddress,\n  } as const satisfies Call\n}\n\nexport declare namespace removeSpendLimit {\n  export type Parameters = {\n    /** Key to set the spend limit of. */\n    key: Key.Key\n    /** Period to set. */\n    period: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'\n    /** Token to set. */\n    token: Address.Address\n  }\n}\n\n/**\n * Instantiates values to populate a call to revoke a key.\n *\n * @param parameters - Parameters.\n * @returns Instantiated values.\n */\nexport function revoke(parameters: revoke.Parameters) {\n  const { keyHash } = parameters\n  return {\n    data: AbiFunction.encodeData(\n      AbiFunction.fromAbi(IthacaAccount.abi, 'revoke'),\n      [keyHash],\n    ),\n    to: selfAddress,\n  } as const satisfies Call\n}\n\nexport declare namespace revoke {\n  export type Parameters = {\n    /** Key hash to revoke. */\n    keyHash: Hex.Hex\n  }\n}\n\n/**\n * Instantiates values to populate a call to upgrade the proxy account.\n *\n * @param parameters - Parameters.\n * @returns Instantiated values.\n */\nexport function upgradeProxyAccount(\n  parameters: upgradeProxyAccount.Parameters,\n) {\n  const { address, to = selfAddress } = parameters\n  return {\n    data: AbiFunction.encodeData(\n      AbiFunction.fromAbi(IthacaAccount.abi, 'upgradeProxyAccount'),\n      [address],\n    ),\n    to,\n  } as const satisfies Call\n}\n\nexport declare namespace upgradeProxyAccount {\n  export type Parameters = {\n    /** The account to upgrade to. */\n    address: Address.Address\n    /** The address to upgrade the address to. */\n    to?: Address.Address | undefined\n  }\n}\n","import * as AbiFunction from 'ox/AbiFunction'\nimport * as AbiParameters from 'ox/AbiParameters'\nimport * as Address from 'ox/Address'\nimport * as Bytes from 'ox/Bytes'\nimport * as Hash from 'ox/Hash'\nimport * as Hex from 'ox/Hex'\nimport * as Json from 'ox/Json'\nimport * as P256 from 'ox/P256'\nimport * as PublicKey from 'ox/PublicKey'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport * as Signature from 'ox/Signature'\nimport * as TypedData from 'ox/TypedData'\nimport * as Value from 'ox/Value'\nimport * as WebAuthnP256 from 'ox/WebAuthnP256'\nimport * as WebCryptoP256 from 'ox/WebCryptoP256'\nimport { zeroAddress } from 'viem'\nimport * as Call from '../core/internal/call.js'\nimport type * as RelayKey_schema from '../core/internal/relay/schema/key.js'\nimport type * as RelayPermission_schema from '../core/internal/relay/schema/permission.js'\nimport type * as Key_schema from '../core/internal/schema/key.js'\nimport type * as Tokens from '../core/internal/tokens.js'\nimport type {\n  Compute,\n  ExactPartial,\n  Mutable,\n  OneOf,\n  PartialBy,\n  RequiredBy,\n  UnionOmit,\n  UnionRequiredBy,\n} from '../core/internal/types.js'\nimport type * as Storage from '../core/Storage.js'\n\ntype PrivateKeyFn = () => Hex.Hex\n\nexport type BaseKey<\n  type extends string = string,\n  privateKey = unknown,\n> = Compute<\n  Key_schema.WithPermissions & {\n    /** Whether the key will need its digest (SHA256) prehashed when signing. */\n    prehash?: boolean | undefined\n    /** Private key. */\n    privateKey?: privateKey | undefined\n    /** Key type. */\n    type: type\n  }\n>\n\nexport type Key = OneOf<\n  AddressKey | P256Key | Secp256k1Key | WebCryptoKey | WebAuthnKey\n>\nexport type AddressKey = BaseKey<'address'>\nexport type P256Key = BaseKey<'p256', PrivateKeyFn>\nexport type Secp256k1Key = BaseKey<'secp256k1', PrivateKeyFn>\nexport type WebCryptoKey = BaseKey<'p256', CryptoKey>\nexport type WebAuthnKey = BaseKey<\n  'webauthn-p256',\n  OneOf<\n    | {\n        credential: Pick<WebAuthnP256.P256Credential, 'id' | 'publicKey'>\n        rpId: string | undefined\n      }\n    | {\n        privateKey: PrivateKeyFn\n      }\n  >\n>\n\nexport type Permissions = Key_schema.Permissions\n\n/** RPC (relay-compatible) format of a key. */\nexport type Relay = RelayKey_schema.WithPermissions\n\n/** Serialized (contract-compatible) format of a key. */\nexport type Serialized = {\n  expiry: number\n  isSuperAdmin: boolean\n  keyType: number\n  publicKey: Hex.Hex\n}\n\nexport type SpendPermissions = Key_schema.SpendPermissions\nexport type SpendPermission = SpendPermissions[number]\n\n/** Relay key type to key type mapping. */\nexport const fromRelayKeyType = {\n  p256: 'p256',\n  secp256k1: 'secp256k1',\n  webauthnp256: 'webauthn-p256',\n} as const\n\n/** Relay key role to key role mapping. */\nexport const fromRelayKeyRole = {\n  admin: 'admin',\n  normal: 'session',\n} as const\n\n/** Serialized (contract-compatible) key type to key type mapping. */\nexport const fromSerializedKeyType = {\n  0: 'p256',\n  1: 'webauthn-p256',\n  2: 'secp256k1',\n} as const\n\n/** Serialized (contract-compatible) spend period to period mapping. */\nexport const fromSerializedSpendPeriod = {\n  0: 'minute',\n  1: 'hour',\n  2: 'day',\n  3: 'week',\n  4: 'month',\n  5: 'year',\n} as const\n\n/** Key type to Relay key type mapping. */\nexport const toRelayKeyType = {\n  address: 'secp256k1',\n  p256: 'p256',\n  secp256k1: 'secp256k1',\n  'webauthn-p256': 'webauthnp256',\n} as const\n\n/** Key role to Relay key role mapping. */\nexport const toRelayKeyRole = {\n  admin: 'admin',\n  session: 'normal',\n} as const\n\n/** Key type to serialized (contract-compatible) key type mapping. */\nexport const toSerializedKeyType = {\n  address: 2,\n  p256: 0,\n  secp256k1: 2,\n  'webauthn-p256': 1,\n} as const\n\n/** Period to serialized (contract-compatible) spend period mapping. */\nexport const toSerializedSpendPeriod = {\n  day: 2,\n  hour: 1,\n  minute: 0,\n  month: 4,\n  week: 3,\n  year: 5,\n} as const\n\n/**\n * Creates a random P256 key.\n *\n * @example\n * ```ts\n * import * as Key from './key.js'\n *\n * // Admin Key\n * const key = Key.createP256()\n *\n * // Session Key\n * const key = Key.createP256({\n *   expiry: 1714857600,\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns P256 key.\n */\nexport function createP256(parameters: createP256.Parameters = {}) {\n  const privateKey = P256.randomPrivateKey()\n  return fromP256({\n    ...parameters,\n    privateKey,\n  })\n}\n\nexport declare namespace createP256 {\n  type Parameters = Pick<\n    fromP256.Parameters,\n    'expiry' | 'feeToken' | 'permissions' | 'role'\n  >\n}\n\n/**\n * Creates a random Secp256k1 key.\n *\n * @example\n * ```ts\n * import * as Key from './key.js'\n *\n * // Admin Key\n * const key = Key.createSecp256k1()\n *\n * // Session Key\n * const key = Key.createSecp256k1({\n *   expiry: 1714857600,\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns Secp256k1 key.\n */\nexport function createSecp256k1(parameters: createSecp256k1.Parameters = {}) {\n  const privateKey = Secp256k1.randomPrivateKey()\n  return fromSecp256k1({\n    ...parameters,\n    privateKey,\n  })\n}\n\nexport declare namespace createSecp256k1 {\n  type Parameters = Pick<\n    fromSecp256k1.Parameters,\n    'expiry' | 'feeToken' | 'permissions' | 'role'\n  >\n}\n\n/**\n * Creates a WebAuthnP256 key.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n * import * as Key from './key.js'\n *\n * // Admin Key\n * const key = Key.createWebAuthnP256({\n *   label: 'My Key',\n *   userId: Bytes.from('0x0000000000000000000000000000000000000000'),\n * })\n *\n * // Session Key\n * const key = Key.createWebAuthnP256({\n *   expiry: 1714857600,\n *   label: 'My Key',\n *   role: 'session',\n *   userId: Bytes.from('0x0000000000000000000000000000000000000000'),\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns WebAuthnP256 key.\n */\nexport async function createWebAuthnP256(\n  parameters: createWebAuthnP256.Parameters,\n) {\n  const { createFn, label, rpId, userId } = parameters\n\n  const credential = await WebAuthnP256.createCredential({\n    authenticatorSelection: {\n      requireResidentKey: true,\n      residentKey: 'required',\n      userVerification: 'required',\n    },\n    createFn,\n    extensions: {\n      credProps: true,\n    },\n    rp: rpId\n      ? {\n          id: rpId,\n          name: rpId,\n        }\n      : undefined,\n    user: {\n      displayName: label,\n      id: new Uint8Array(userId ?? Bytes.fromString(label)),\n      name: label,\n    },\n  })\n\n  return fromWebAuthnP256({\n    ...parameters,\n    credential: {\n      id: credential.id,\n      publicKey: credential.publicKey,\n    },\n    id: userId\n      ? Bytes.toHex(userId)\n      : PublicKey.toHex(credential.publicKey, {\n          includePrefix: false,\n        }),\n  })\n}\n\nexport declare namespace createWebAuthnP256 {\n  type Parameters = Pick<\n    fromWebAuthnP256.Parameters,\n    'expiry' | 'feeToken' | 'permissions' | 'role'\n  > & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?: WebAuthnP256.createCredential.Options['createFn'] | undefined\n    /** Label. */\n    label: string\n    /** Relying Party ID. */\n    rpId?: string | undefined\n    /** User ID. */\n    userId?: Bytes.Bytes | undefined\n  }\n}\n\n/**\n * Creates a random WebAuthn-wrapped P256 key.\n *\n * @example\n * ```ts\n * import * as Key from './key.js'\n *\n * // Admin Key\n * const key = Key.createHeadlessWebAuthnP256()\n *\n * // Session Key\n * const key = Key.createHeadlessWebAuthnP256({\n *   expiry: 1714857600,\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns P256 key.\n */\nexport function createHeadlessWebAuthnP256(\n  parameters: createHeadlessWebAuthnP256.Parameters = {},\n) {\n  const privateKey = P256.randomPrivateKey()\n  return fromHeadlessWebAuthnP256({\n    ...parameters,\n    privateKey,\n  })\n}\n\nexport declare namespace createHeadlessWebAuthnP256 {\n  type Parameters = Pick<\n    fromHeadlessWebAuthnP256.Parameters,\n    'expiry' | 'feeToken' | 'permissions' | 'role'\n  >\n}\n\n/**\n * Creates a random WebCryptoP256 key.\n *\n * @example\n * ```ts\n * import * as Key from './key.js'\n *\n * // Admin Key\n * const key = Key.createWebCryptoP256()\n *\n * // Session Key\n * const key = Key.createWebCryptoP256({\n *   expiry: 1714857600,\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns WebCryptoP256 key.\n */\nexport async function createWebCryptoP256(\n  parameters: createWebCryptoP256.Parameters = {},\n) {\n  const keyPair = await WebCryptoP256.createKeyPair()\n  return fromWebCryptoP256({\n    ...parameters,\n    keyPair,\n  })\n}\n\nexport declare namespace createWebCryptoP256 {\n  type Parameters = Pick<\n    fromWebCryptoP256.Parameters,\n    'expiry' | 'feeToken' | 'permissions' | 'role'\n  >\n}\n\n/**\n * Deserializes a key from its serialized format.\n *\n * @example\n * ```ts\n * import * as Key from './key.js'\n *\n * const key = Key.deserialize({\n *   expiry: 0,\n *   isSuperAdmin: false,\n *   keyType: 0,\n *   publicKey: '0x04ec0effa5f2f378cbf7fd2fa7ca1e8dc51cf777c129fa1c00a0e9a9205f2e511ff3f20b34a4e0b50587d055c0e0fad33d32cf1147d3bb2538fbab0d15d8e65008',\n * })\n * ```\n *\n * @param serialized - Serialized key.\n * @returns Key.\n */\nexport function deserialize(\n  serialized: Serialized,\n  options: deserialize.Options = {},\n): Key {\n  const { chainId } = options\n  const publicKey = serialized.publicKey\n  const type = (fromSerializedKeyType as any)[serialized.keyType]\n  return from({\n    chainId,\n    expiry: serialized.expiry,\n    publicKey,\n    role: serialized.isSuperAdmin ? 'admin' : 'session',\n    type,\n  })\n}\n\nexport declare namespace deserialize {\n  type Options = {\n    chainId?: number | undefined\n  }\n}\n\n/**\n * Instantiates a key from its parameters.\n *\n * @example\n * ```ts\n * import { P256 } from 'ox'\n * import * as Key from './key.js'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n *\n * const key = Key.from({\n *   expiry: 0,\n *   publicKey,\n *   async sign({ payload }) {\n *     return P256.sign({ payload, privateKey })\n *   },\n *   type: 'p256',\n * })\n * ```\n *\n * @param key - Key.\n * @returns Key.\n */\nexport function from<type extends Key['type']>(\n  key: from.Value<type>,\n  options: from.Options = {},\n): Extract<Key, { type: type }> {\n  const { chainId = key.chainId } = options\n  const { expiry = 0, id, prehash = false, role = 'admin', type } = key\n\n  const publicKey = (() => {\n    const publicKey = key.publicKey\n    if (publicKey === '0x') return publicKey\n    if (type === 'secp256k1' || type === 'address') {\n      const isAddress =\n        Hex.size(publicKey) === 20 ||\n        Hex.toBigInt(Hex.slice(publicKey, 0, 12)) === 0n\n      const address = isAddress\n        ? Hex.slice(publicKey, -20)\n        : Address.fromPublicKey(PublicKey.fromHex(publicKey))\n      return address\n    }\n    return publicKey\n  })()\n\n  return {\n    ...key,\n    chainId,\n    expiry,\n    hash: hash({\n      publicKey,\n      type,\n    }),\n    id: (id ?? publicKey).toLowerCase() as Hex.Hex,\n    prehash,\n    publicKey: publicKey.toLowerCase() as Hex.Hex,\n    role,\n    type,\n  } satisfies BaseKey<string> as never\n}\n\nexport declare namespace from {\n  type Value<type extends Key['type'] = Key['type']> = OneOf<\n    UnionRequiredBy<ExactPartial<UnionOmit<Key, 'hash'>>, 'publicKey'> & {\n      type: type | Key['type']\n    }\n  >\n\n  type Options = {\n    chainId?: number | undefined\n  }\n}\n\n/**\n * Instantiates a P256 key from its parameters.\n *\n * @example\n * ```ts\n * import { P256 } from 'ox'\n * import * as Key from './key.js'\n *\n * // Admin Key\n * const key = Key.fromP256({\n *   privateKey: P256.randomPrivateKey(),\n * })\n *\n * // Session Key\n * const key = Key.fromP256({\n *   expiry: 1714857600,\n *   privateKey: P256.randomPrivateKey(),\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns P256 key.\n */\nexport function fromP256(parameters: fromP256.Parameters) {\n  const { chainId, expiry, feeToken, permissions, privateKey, role } =\n    parameters\n  const publicKey = PublicKey.toHex(P256.getPublicKey({ privateKey }), {\n    includePrefix: false,\n  })\n  return from({\n    chainId,\n    expiry,\n    feeToken,\n    permissions,\n    privateKey() {\n      return privateKey\n    },\n    publicKey,\n    role,\n    type: 'p256',\n  })\n}\n\nexport declare namespace fromP256 {\n  type Parameters = Pick<\n    from.Value,\n    'chainId' | 'expiry' | 'feeToken' | 'permissions' | 'role'\n  > & {\n    /** P256 private key. */\n    privateKey: Hex.Hex\n  }\n}\n\n/**\n * Converts a Relay-formatted key to a key.\n *\n * @example\n * TODO\n *\n * @param relayKey - Relay key.\n * @returns Key.\n */\nexport function fromRelay(relayKey: Relay, options: { chainId: number }): Key {\n  const { chainId } = options\n  const { publicKey } = relayKey\n\n  const isAddress =\n    Hex.size(publicKey) === 20 ||\n    Hex.toBigInt(Hex.slice(publicKey, 0, 12)) === 0n\n\n  const permissions: {\n    calls?: Mutable<Key_schema.CallPermissions> | undefined\n    spend?: Mutable<Key_schema.SpendPermissions> | undefined\n  } = {}\n\n  for (const permission of relayKey.permissions) {\n    if (permission.type === 'call') {\n      permissions.calls ??= []\n      permissions.calls.push({\n        signature: permission.selector,\n        to: permission.to === Call.anyTarget ? undefined : permission.to,\n      })\n    }\n    if (permission.type === 'spend') {\n      permissions.spend ??= []\n      permissions.spend.push({\n        limit: permission.limit,\n        period: permission.period,\n        token: permission.token as Address.Address,\n      })\n    }\n  }\n\n  return from({\n    chainId,\n    expiry: relayKey.expiry,\n    permissions: permissions as Permissions,\n    publicKey: relayKey.publicKey,\n    role: fromRelayKeyRole[relayKey.role],\n    type: isAddress ? 'address' : fromRelayKeyType[relayKey.type],\n  })\n}\n\n/**\n * Instantiates a Secp256k1 key from its parameters.\n *\n * @example\n * ```ts\n * import { Secp256k1 } from 'ox'\n * import * as Key from './key.js'\n *\n * // Admin Key\n * const key = Key.fromSecp256k1({\n *   privateKey: Secp256k1.randomPrivateKey(),\n * })\n *\n * // Session Key\n * const key = Key.fromSecp256k1({\n *   expiry: 1714857600,\n *   privateKey: Secp256k1.randomPrivateKey(),\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns Secp256k1 key.\n */\nexport function fromSecp256k1(parameters: fromSecp256k1.Parameters) {\n  const { privateKey, role } = parameters\n  const publicKey = (() => {\n    if (parameters.publicKey) return parameters.publicKey\n    if (privateKey)\n      return Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n    return parameters.address.toLowerCase() as Hex.Hex\n  })()\n  return from({\n    expiry: parameters.expiry ?? 0,\n    feeToken: parameters.feeToken,\n    permissions: parameters.permissions,\n    privateKey: privateKey ? () => privateKey : undefined,\n    publicKey,\n    role,\n    type: 'secp256k1',\n  } as Secp256k1Key)\n}\n\nexport declare namespace fromSecp256k1 {\n  type Parameters = Pick<\n    from.Value,\n    'expiry' | 'feeToken' | 'permissions' | 'role'\n  > &\n    OneOf<\n      | {\n          /** Ethereum address. */\n          address: Address.Address\n        }\n      | {\n          /** Secp256k1 public key. */\n          publicKey: Hex.Hex\n        }\n      | {\n          /** Secp256k1 private key. */\n          privateKey: Hex.Hex\n        }\n    >\n}\n\n/**\n * Instantiates a WebAuthnP256 key from its parameters.\n *\n * @example\n * ```ts\n * import { WebAuthnP256 } from 'ox'\n * import * as Key from './key.js'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'My Key' })\n *\n * // Admin Key\n * const key = Key.fromWebAuthnP256({\n *   credential,\n * })\n *\n * // Session Key\n * const key = Key.fromWebAuthnP256({\n *   expiry: 1714857600,\n *   credential,\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns WebAuthnP256 key.\n */\nexport function fromWebAuthnP256(parameters: fromWebAuthnP256.Parameters) {\n  const { credential, id, rpId } = parameters\n  const publicKey = PublicKey.toHex(credential.publicKey, {\n    includePrefix: false,\n  })\n  return from({\n    chainId: parameters.chainId,\n    expiry: parameters.expiry ?? 0,\n    feeToken: parameters.feeToken,\n    id,\n    permissions: parameters.permissions,\n    privateKey: {\n      credential,\n      rpId,\n    },\n    publicKey,\n    role: parameters.role,\n    type: 'webauthn-p256',\n  })\n}\n\nexport declare namespace fromWebAuthnP256 {\n  type Parameters = Pick<\n    from.Value,\n    'chainId' | 'expiry' | 'feeToken' | 'id' | 'permissions' | 'role'\n  > & {\n    /** WebAuthnP256 Credential. */\n    credential: Pick<WebAuthnP256.P256Credential, 'id' | 'publicKey'>\n    /** Relying Party ID. */\n    rpId?: string | undefined\n  }\n}\n\n/**\n * Instantiates a WebAuthn-wrapped P256 key from its parameters.\n *\n * @example\n * ```ts\n * import { P256 } from 'ox'\n * import * as Key from './key.js'\n *\n * const privateKey = P256.randomPrivateKey()\n *\n * // Admin Key\n * const key = Key.fromHeadlessWebAuthnP256({\n *   privateKey,\n * })\n *\n * // Session Key\n * const key = Key.fromHeadlessWebAuthnP256({\n *   expiry: 1714857600,\n *   privateKey,\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns WebAuthn-wrapped P256 key.\n */\nexport function fromHeadlessWebAuthnP256(\n  parameters: fromHeadlessWebAuthnP256.Parameters,\n) {\n  const { privateKey } = parameters\n  const publicKey = PublicKey.toHex(P256.getPublicKey({ privateKey }), {\n    includePrefix: false,\n  })\n  return from({\n    chainId: parameters.chainId,\n    expiry: parameters.expiry ?? 0,\n    feeToken: parameters.feeToken,\n    permissions: parameters.permissions,\n    privateKey: {\n      privateKey() {\n        return privateKey\n      },\n    },\n    publicKey,\n    role: parameters.role,\n    type: 'webauthn-p256',\n  })\n}\n\nexport declare namespace fromHeadlessWebAuthnP256 {\n  type Parameters = Pick<\n    from.Value,\n    'chainId' | 'expiry' | 'feeToken' | 'permissions' | 'role'\n  > & {\n    /** P256 private key. */\n    privateKey: Hex.Hex\n  }\n}\n\n/**\n * Instantiates a WebCryptoP256 key from its parameters.\n *\n * @example\n * ```ts\n * import { WebCryptoP256 } from 'ox'\n * import * as Key from './key.js'\n *\n * const keyPair = await WebCryptoP256.createKeyPair()\n *\n * // Admin Key\n * const key = Key.fromWebCryptoP256({\n *   keyPair,\n * })\n *\n * // Session Key\n * const key = Key.fromWebCryptoP256({\n *   expiry: 1714857600,\n *   keyPair,\n *   role: 'session',\n * })\n * ```\n *\n * @param parameters - Key parameters.\n * @returns WebCryptoP256 key.\n */\nexport function fromWebCryptoP256(parameters: fromWebCryptoP256.Parameters) {\n  const { chainId, expiry, feeToken, keyPair, permissions, role } = parameters\n  const { privateKey } = keyPair\n  const publicKey = PublicKey.toHex(keyPair.publicKey, {\n    includePrefix: false,\n  })\n  return from({\n    chainId,\n    expiry,\n    feeToken,\n    permissions,\n    prehash: true,\n    privateKey,\n    publicKey,\n    role,\n    type: 'p256',\n  })\n}\n\nexport declare namespace fromWebCryptoP256 {\n  type Parameters = Pick<\n    from.Value,\n    'chainId' | 'expiry' | 'feeToken' | 'permissions' | 'role'\n  > & {\n    /** P256 private key. */\n    keyPair: Awaited<ReturnType<typeof WebCryptoP256.createKeyPair>>\n  }\n}\n\n/**\n * Hashes a key.\n *\n * @example\n * ```ts\n * import * as Key from './key.js'\n *\n * const key = Key.createP256()\n *\n * const hash = Key.hash(key)\n * ```\n *\n * @param key - Key.\n * @returns Hashed key.\n */\nexport function hash(key: Pick<Key, 'publicKey' | 'type'>): Hex.Hex {\n  const { type } = key\n  const publicKey = serializePublicKey(key.publicKey)\n  return Hash.keccak256(\n    AbiParameters.encode(\n      [{ type: 'uint8' }, { type: 'bytes32' }],\n      [toSerializedKeyType[type], Hash.keccak256(publicKey)],\n    ),\n  )\n}\n\n/**\n * Serializes a public key.\n *\n * @param publicKey - Public key.\n * @returns Serialized public key.\n */\nexport function serializePublicKey(publicKey: Hex.Hex): Hex.Hex {\n  return Hex.size(publicKey) < 32 ? Hex.padLeft(publicKey, 32) : publicKey\n}\n\n/**\n * Serializes a key to a contract-compatible format.\n *\n * @example\n * ```ts\n * import * as Key from './key.js'\n *\n * const key = Key.createP256()\n *\n * const serialized = Key.serialize(key)\n * ```\n *\n * @param key - Key.\n * @returns Serialized key.\n */\nexport function serialize(key: Key): Serialized {\n  const { expiry = 0, publicKey, role, type } = key\n  return {\n    expiry,\n    isSuperAdmin: role === 'admin',\n    keyType: toSerializedKeyType[type],\n    publicKey: serializePublicKey(publicKey),\n  }\n}\n\nexport async function sign(key: Key, parameters: sign.Parameters) {\n  const { address, storage, webAuthn, wrap = true } = parameters\n  const { privateKey, publicKey, type: keyType } = key\n\n  if (!privateKey)\n    throw new Error(\n      'Key does not have a private key to sign with.\\n\\nKey:\\n' +\n        Json.stringify(key, null, 2),\n    )\n\n  const payload = (() => {\n    if (!address) return parameters.payload\n    return TypedData.getSignPayload({\n      domain: { verifyingContract: address },\n      message: {\n        digest: parameters.payload,\n      },\n      primaryType: 'ERC1271Sign',\n      types: {\n        ERC1271Sign: [{ name: 'digest', type: 'bytes32' }],\n      },\n    })\n  })()\n\n  const [signature, prehash] = await (async () => {\n    if (keyType === 'p256') {\n      const { privateKey } = key\n      if (typeof privateKey === 'function')\n        return [\n          Signature.toHex(P256.sign({ payload, privateKey: privateKey() })),\n          false,\n        ]\n      if (privateKey instanceof CryptoKey) {\n        const signature = Signature.toHex(\n          await WebCryptoP256.sign({ payload, privateKey }),\n        )\n        return [signature, true]\n      }\n    }\n    if (keyType === 'secp256k1') {\n      return [\n        Signature.toHex(Secp256k1.sign({ payload, privateKey: privateKey() })),\n        false,\n      ]\n    }\n    if (keyType === 'webauthn-p256') {\n      if (privateKey.privateKey) {\n        const { payload: wrapped, metadata } = WebAuthnP256.getSignPayload({\n          challenge: payload,\n          origin: 'https://ithaca.xyz',\n          rpId: 'ithaca.xyz',\n        })\n        const { r, s } = P256.sign({\n          hash: true,\n          payload: wrapped,\n          privateKey: privateKey.privateKey(),\n        })\n        const signature = serializeWebAuthnSignature({\n          metadata,\n          signature: { r, s },\n        })\n        return [signature, false]\n      }\n\n      const { credential, rpId } = privateKey\n\n      const cacheKey = `porto.webauthnVerified.${key.hash}`\n      const now = Date.now()\n      const verificationTimeout = 10 * 60 * 1_000 // 10 minutes in milliseconds\n\n      let requireVerification = true\n      if (storage) {\n        const lastVerified = await storage.getItem<number>(cacheKey)\n        requireVerification =\n          !lastVerified || now - lastVerified > verificationTimeout\n      }\n\n      const {\n        signature: { r, s },\n        raw,\n        metadata,\n      } = await WebAuthnP256.sign({\n        challenge: payload,\n        credentialId: credential.id,\n        getFn: webAuthn?.getFn,\n        rpId,\n        userVerification: requireVerification ? 'required' : 'preferred',\n      })\n\n      const response = raw.response as AuthenticatorAssertionResponse\n      if (!response?.userHandle)\n        throw new Error('No user handle in response', {\n          cause: { response },\n        })\n      const id = Bytes.toHex(new Uint8Array(response.userHandle!))\n      if (key.id && Address.validate(key.id) && !Address.isEqual(key.id, id))\n        throw new Error(\n          `supplied webauthn key \"${key.id}\" does not match signature webauthn key \"${id}\"`,\n          { cause: { id, key } },\n        )\n\n      if (requireVerification && storage) await storage.setItem(cacheKey, now)\n\n      const signature = serializeWebAuthnSignature({\n        metadata,\n        signature: { r, s },\n      })\n      return [signature, false]\n    }\n    throw new Error(\n      `Key type \"${keyType}\" is not supported.\\n\\nKey:\\n` +\n        Json.stringify(key, null, 2),\n    )\n  })()\n\n  if (wrap)\n    return wrapSignature(signature, {\n      keyType,\n      prehash,\n      publicKey,\n    })\n  return signature\n}\n\nexport declare namespace sign {\n  type Parameters = {\n    /**\n     * Address to use for replay-safe signing.\n     * `null` if replay-safe signing is not needed (e.g. signing call bundles).\n     */\n    address: Address.Address | null\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex\n    /**\n     * Storage to use for keytype-specific caching (e.g. WebAuthn user verification).\n     */\n    storage?: Storage.Storage | undefined\n    /**\n     * WebAuthn configuration.\n     */\n    webAuthn?:\n      | {\n          createFn?: WebAuthnP256.createCredential.Options['createFn']\n          getFn?: WebAuthnP256.sign.Options['getFn']\n        }\n      | undefined\n    /**\n     * Whether to wrap the signature with key metadata.\n     * @default true\n     */\n    wrap?: boolean | undefined\n  }\n}\n\n/**\n * Converts a key to a Relay-compatible format.\n *\n * @example\n * TODO\n *\n * @param key - Key.\n * @returns Relay key.\n */\nexport function toRelay(\n  key: toRelay.Value,\n  options: toRelay.Options = {},\n): RequiredBy<Relay, 'prehash'> {\n  const { expiry = 0, prehash = false, publicKey, role = 'admin', type } = key\n  const { feeTokens, orchestrator } = options\n\n  // biome-ignore lint/complexity/useFlatMap: i know\n  const permissions = Object.entries(\n    resolvePermissions(key, {\n      feeTokens,\n    }),\n  )\n    // biome-ignore lint/suspicious/useIterableCallbackReturn: _\n    .map(([key, v]) => {\n      if (key === 'calls') {\n        const calls = v as Key_schema.CallPermissions\n        return calls.map(({ signature, to }) => {\n          const selector = (() => {\n            if (!signature) return Call.anySelector\n            if (Hex.validate(signature)) return signature\n            return AbiFunction.getSelector(signature)\n          })()\n          return {\n            selector,\n            to: to ?? Call.anyTarget,\n            type: 'call',\n          } as const satisfies RelayPermission_schema.CallPermission\n        })\n      }\n      if (key === 'feeToken') return\n      if (key === 'spend') {\n        const value = v as Key_schema.SpendPermissions\n        return value.map(({ limit, period, token }) => {\n          return {\n            limit,\n            period,\n            token,\n            type: 'spend',\n          } as const satisfies RelayPermission_schema.SpendPermission\n        })\n      }\n\n      throw new Error(`Invalid permission type \"${key}\".`)\n    })\n    .flat()\n    .filter(Boolean) as RelayPermission_schema.Permission[]\n\n  if (key.role === 'session' && orchestrator)\n    permissions.push({\n      selector: Call.anySelector,\n      to: orchestrator,\n      type: 'call',\n    })\n\n  return {\n    expiry,\n    permissions: permissions ?? [],\n    prehash,\n    publicKey: serializePublicKey(publicKey),\n    role: toRelayKeyRole[role],\n    type: toRelayKeyType[type],\n  }\n}\n\nexport declare namespace toRelay {\n  type Value = PartialBy<\n    Pick<\n      Key,\n      'expiry' | 'prehash' | 'permissions' | 'publicKey' | 'role' | 'type'\n    >,\n    'expiry' | 'role'\n  >\n\n  type Options = {\n    /** Fee tokens. */\n    feeTokens?: readonly Tokens.Token[] | undefined\n    /** Orchestrator address. */\n    orchestrator?: Address.Address | undefined\n  }\n}\n\n/**\n * Resolves the permissions for the permissions request, and if needed, adds\n * the fee limit to the spend permissions.\n *\n * @param request - Permissions request.\n * @param options - Options.\n * @returns Resolved permissions.\n */\nexport function resolvePermissions(\n  key: Pick<Key, 'feeToken' | 'permissions'>,\n  options: resolvePermissions.Options,\n) {\n  const { permissions } = key\n\n  const calls = permissions?.calls ? [...permissions.calls] : []\n  const spend = permissions?.spend ? [...permissions.spend] : []\n\n  const feeTokens = options.feeTokens?.filter((token) => token.feeToken)\n  if (feeTokens && feeTokens.length > 0) {\n    const feeToken = getFeeToken(key, {\n      feeTokens,\n    })\n\n    if (feeToken) {\n      let index = -1\n      let minPeriod: number = toSerializedSpendPeriod.year\n\n      for (let i = 0; i < spend.length; i++) {\n        const s = spend[i]!\n        if (s.token && Address.isEqual(feeToken.address, s.token)) {\n          index = i\n          break\n        }\n        if (!s.token && feeToken.address === zeroAddress) {\n          index = i\n          break\n        }\n\n        const period = toSerializedSpendPeriod[s.period]\n        if (period < minPeriod) minPeriod = period\n      }\n\n      // If there is a token assigned to a spend permission and the fee token\n      // is the same, update the limit to account for the fee.\n      if (index !== -1) {\n        spend[index] = {\n          ...spend[index]!,\n          limit: spend[index]!.limit + feeToken.value,\n        }\n        // Assign this as the first spend permission, as it will be used\n        // as the fee token for call bundles that use this key.\n        spend.unshift(spend.splice(index, 1)[0]!)\n      }\n      // Update the spend permissions to account for the fee token.\n      // The fee token permission must be assigned as the first spend\n      // permission as it will be used as the fee token for call bundles\n      // that use this key.\n      else if (typeof minPeriod === 'number')\n        spend.unshift({\n          limit: feeToken.value,\n          period:\n            fromSerializedSpendPeriod[\n              minPeriod as keyof typeof fromSerializedSpendPeriod\n            ],\n          token: feeToken.address,\n        })\n    }\n  }\n\n  return { ...permissions, calls, spend }\n}\n\nexport declare namespace resolvePermissions {\n  export type Options = {\n    feeTokens?: Tokens.Tokens | null | undefined\n  }\n}\n\n/**\n * Gets the fee limit (in units of the fee token) to be used for the\n * authorized permissions.\n *\n * @param request - The permissions request to get the fee limit for.\n * @param options - Options.\n * @returns Fee limit (in units of the fee token).\n */\nexport function getFeeToken(\n  key: Pick<Key, 'feeToken' | 'permissions'>,\n  options: getFeeToken.Options,\n): getFeeToken.ReturnType {\n  const { feeTokens } = options\n\n  if (!key.feeToken) return undefined\n\n  const feeToken = feeTokens.find((token) => {\n    if (key.feeToken!.symbol === token.symbol) return true\n    if (!key.feeToken!.symbol) return token.address === zeroAddress\n    if (key.feeToken!.symbol === 'native') return token.address === zeroAddress\n    return false\n  })\n  if (!feeToken) return undefined\n\n  const value = Value.from(key.feeToken.limit, feeToken.decimals)\n\n  return {\n    ...feeToken,\n    value,\n  }\n}\n\nexport declare namespace getFeeToken {\n  export type Options = {\n    feeTokens: Tokens.Tokens\n  }\n\n  export type ReturnType =\n    | (Tokens.Token & {\n        value: bigint\n      })\n    | undefined\n}\n\n///////////////////////////////////////////////////////////////////////////\n// Internal\n///////////////////////////////////////////////////////////////////////////\n\nexport function serializeWebAuthnSignature(\n  options: serializeWebAuthnSignature.Options,\n) {\n  const { metadata, signature } = options\n  return AbiParameters.encode(\n    AbiParameters.from([\n      'struct WebAuthnAuth { bytes authenticatorData; string clientDataJSON; uint256 challengeIndex; uint256 typeIndex; bytes32 r; bytes32 s; }',\n      'WebAuthnAuth auth',\n    ]),\n    [\n      {\n        authenticatorData: metadata.authenticatorData,\n        challengeIndex: BigInt(metadata.challengeIndex),\n        clientDataJSON: metadata.clientDataJSON,\n        r: Hex.fromNumber(signature.r, { size: 32 }),\n        s: Hex.fromNumber(signature.s, { size: 32 }),\n        typeIndex: BigInt(metadata.typeIndex),\n      },\n    ],\n  )\n}\n\nexport declare namespace serializeWebAuthnSignature {\n  type Options = {\n    metadata: WebAuthnP256.SignMetadata\n    signature: Signature.Signature<false>\n  }\n}\n\nexport function wrapSignature(\n  signature: Hex.Hex,\n  options: wrapSignature.Options,\n) {\n  const { keyType: type, prehash = false, publicKey } = options\n\n  const keyHash = hash({ publicKey, type })\n  return AbiParameters.encodePacked(\n    ['bytes', 'bytes32', 'bool'],\n    [signature, keyHash, prehash],\n  )\n}\n\ndeclare namespace wrapSignature {\n  type Options = {\n    keyType: Key['type']\n    prehash?: boolean | undefined\n    publicKey: Hex.Hex\n  }\n}\n","import * as RpcResponse from 'ox/RpcResponse'\nimport * as z from 'zod/mini'\nimport type { UnionToTuple } from '../types.js'\nimport * as RpcRequest from './rpc.js'\nimport * as u from './utils.js'\n\nexport * from './rpc.js'\n\nexport const Request = z.discriminatedUnion('method', [\n  RpcRequest.account_verifyEmail.Request,\n  RpcRequest.wallet_addFunds.Request,\n  RpcRequest.eth_accounts.Request,\n  RpcRequest.eth_chainId.Request,\n  RpcRequest.eth_requestAccounts.Request,\n  RpcRequest.eth_sendTransaction.Request,\n  RpcRequest.eth_signTypedData_v4.Request,\n  RpcRequest.wallet_getAccountVersion.Request,\n  RpcRequest.wallet_getAdmins.Request,\n  RpcRequest.wallet_getPermissions.Request,\n  RpcRequest.wallet_grantAdmin.Request,\n  RpcRequest.wallet_grantPermissions.Request,\n  RpcRequest.wallet_prepareUpgradeAccount.Request,\n  RpcRequest.wallet_revokeAdmin.Request,\n  RpcRequest.wallet_revokePermissions.Request,\n  RpcRequest.wallet_upgradeAccount.Request,\n  RpcRequest.personal_sign.Request,\n  RpcRequest.porto_ping.Request,\n  RpcRequest.wallet_connect.Request,\n  RpcRequest.wallet_disconnect.Request,\n  RpcRequest.wallet_getAssets.Request,\n  RpcRequest.wallet_getCallsStatus.Request,\n  RpcRequest.wallet_getCapabilities.Request,\n  RpcRequest.wallet_getKeys.Request,\n  RpcRequest.wallet_prepareCalls.Request,\n  RpcRequest.wallet_sendCalls.Request,\n  RpcRequest.wallet_sendPreparedCalls.Request,\n  RpcRequest.wallet_switchEthereumChain.Request,\n  RpcRequest.wallet_verifySignature.Request,\n])\nexport type Request = WithDecoded<typeof Request>\n\nexport function validate<schema extends z.ZodMiniType>(\n  schema: schema,\n  value: unknown,\n): WithDecoded<schema> {\n  const result = z.safeParse(schema, value)\n\n  if (result.error) {\n    const issue = result.error.issues.at(0)\n    if (\n      issue?.code === 'invalid_union' &&\n      (issue as any).note === 'No matching discriminator'\n    )\n      throw new RpcResponse.MethodNotSupportedError()\n    throw new RpcResponse.InvalidParamsError(u.toValidationError(result.error))\n  }\n\n  return {\n    ...(value as any),\n    _decoded: result.data,\n  } as never\n}\n\n/** @internal */\nexport type WithDecoded<\n  schema extends z.ZodMiniType,\n  input = UnionToTuple<z.input<schema>>,\n> = input extends [infer head extends { method: string }, ...infer tail]\n  ?\n      | (head & {\n          _decoded: Extract<\n            schema['_zod']['output'],\n            { method: head['method'] }\n          >\n        })\n      | WithDecoded<schema, tail>\n  : never\n\n/** @internal */\nexport const schemaWithJsonRpc = <schema extends z.ZodMiniType>(\n  schema: schema,\n) =>\n  z.intersection(\n    schema,\n    z.object({\n      _returnType: z.unknown(),\n      id: z.number(),\n      jsonrpc: z.literal('2.0'),\n    }),\n  )\n","import { EventEmitter } from 'eventemitter3'\nimport type * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute, IsNarrowable, IsNever } from './internal/types.js'\nimport * as RpcResponse from './RpcResponse.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** Options for a {@link ox#Provider.Provider}. */\nexport type Options = {\n  /**\n   * Whether to include event functions (`on`, `removeListener`) on the Provider.\n   *\n   * @default true\n   */\n  includeEvents?: boolean | undefined\n  /**\n   * RPC Schema to use for the Provider's `request` function.\n   * See {@link ox#RpcSchema.(from:function)} for more.\n   *\n   * @default `RpcSchema.Generic`\n   */\n  schema?: RpcSchema.Generic | undefined\n}\n\n/** Root type for an EIP-1193 Provider. */\nexport type Provider<\n  options extends Options | undefined = undefined,\n  ///\n  _schema extends RpcSchema.Generic = options extends {\n    schema: infer schema extends RpcSchema.Generic\n  }\n    ? schema\n    : RpcSchema.Default,\n> = Compute<\n  {\n    request: RequestFn<_schema>\n  } & (options extends { includeEvents: true } | undefined\n    ? {\n        on: EventListenerFn\n        removeListener: EventListenerFn\n      }\n    : {})\n>\n\n/** Type for an EIP-1193 Provider's event emitter. */\nexport type Emitter = Compute<EventEmitter<EventMap>>\n\n/** EIP-1193 Provider's `request` function. */\nexport type RequestFn<schema extends RpcSchema.Generic = RpcSchema.Generic> = <\n  methodName extends RpcSchema.MethodNameGeneric,\n>(\n  parameters: RpcSchema_internal.ExtractRequestOpaque<schema, methodName>,\n) => Promise<RpcSchema.ExtractReturnType<schema, methodName>>\n\n/** Type for an EIP-1193 Provider's event listener functions (`on`, `removeListener`, etc). */\nexport type EventListenerFn = <event extends keyof EventMap>(\n  event: event,\n  listener: EventMap[event],\n) => void\n\nexport type ConnectInfo = {\n  chainId: string\n}\n\nexport type Message = {\n  type: string\n  data: unknown\n}\n\nexport class ProviderRpcError extends Error {\n  override name = 'ProviderRpcError'\n\n  code: number\n  details: string\n\n  constructor(code: number, message: string) {\n    super(message)\n    this.code = code\n    this.details = message\n  }\n}\n\nexport type EventMap = {\n  accountsChanged: (accounts: readonly Address.Address[]) => void\n  chainChanged: (chainId: string) => void\n  connect: (connectInfo: ConnectInfo) => void\n  disconnect: (error: ProviderRpcError) => void\n  message: (message: Message) => void\n}\n\n/** The user rejected the request. */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static readonly code = 4001\n  override readonly code = 4001\n  override readonly name = 'Provider.UserRejectedRequestError'\n\n  constructor({\n    message = 'The user rejected the request.',\n  }: { message?: string | undefined } = {}) {\n    super(4001, message)\n  }\n}\n\n/** The requested method and/or account has not been authorized by the user. */\nexport class UnauthorizedError extends ProviderRpcError {\n  static readonly code = 4100\n  override readonly code = 4100\n  override readonly name = 'Provider.UnauthorizedError'\n\n  constructor({\n    message = 'The requested method and/or account has not been authorized by the user.',\n  }: { message?: string | undefined } = {}) {\n    super(4100, message)\n  }\n}\n\n/** The provider does not support the requested method. */\nexport class UnsupportedMethodError extends ProviderRpcError {\n  static readonly code = 4200\n  override readonly code = 4200\n  override readonly name = 'Provider.UnsupportedMethodError'\n\n  constructor({\n    message = 'The provider does not support the requested method.',\n  }: { message?: string | undefined } = {}) {\n    super(4200, message)\n  }\n}\n\n/** The provider is disconnected from all chains. */\nexport class DisconnectedError extends ProviderRpcError {\n  static readonly code = 4900\n  override readonly code = 4900\n  override readonly name = 'Provider.DisconnectedError'\n\n  constructor({\n    message = 'The provider is disconnected from all chains.',\n  }: { message?: string | undefined } = {}) {\n    super(4900, message)\n  }\n}\n\n/** The provider is not connected to the requested chain. */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static readonly code = 4901\n  override readonly code = 4901\n  override readonly name = 'Provider.ChainDisconnectedError'\n\n  constructor({\n    message = 'The provider is not connected to the requested chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4901, message)\n  }\n}\n\n/** An error occurred when attempting to switch chain. */\nexport class SwitchChainError extends ProviderRpcError {\n  static readonly code = 4902\n  override readonly code = 4902\n  override readonly name = 'Provider.SwitchChainError'\n\n  constructor({\n    message = 'An error occurred when attempting to switch chain.',\n  }: { message?: string | undefined } = {}) {\n    super(4902, message)\n  }\n}\n\n/** This Wallet does not support a capability that was not marked as optional. */\nexport class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {\n  static readonly code = 5700\n  override readonly code = 5700\n  override readonly name = 'Provider.UnsupportedNonOptionalCapabilityError'\n\n  constructor({\n    message = 'This Wallet does not support a capability that was not marked as optional.',\n  }: { message?: string | undefined } = {}) {\n    super(5700, message)\n  }\n}\n\n/** This Wallet does not support the requested chain ID. */\nexport class UnsupportedChainIdError extends ProviderRpcError {\n  static readonly code = 5710\n  override readonly code = 5710\n  override readonly name = 'Provider.UnsupportedChainIdError'\n\n  constructor({\n    message = 'This Wallet does not support the requested chain ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5710, message)\n  }\n}\n\n/** There is already a bundle submitted with this ID. */\nexport class DuplicateIdError extends ProviderRpcError {\n  static readonly code = 5720\n  override readonly code = 5720\n  override readonly name = 'Provider.DuplicateIdError'\n\n  constructor({\n    message = 'There is already a bundle submitted with this ID.',\n  }: { message?: string | undefined } = {}) {\n    super(5720, message)\n  }\n}\n\n/** This bundle id is unknown / has not been submitted. */\nexport class UnknownBundleIdError extends ProviderRpcError {\n  static readonly code = 5730\n  override readonly code = 5730\n  override readonly name = 'Provider.UnknownBundleIdError'\n\n  constructor({\n    message = 'This bundle id is unknown / has not been submitted.',\n  }: { message?: string | undefined } = {}) {\n    super(5730, message)\n  }\n}\n\n/** The call bundle is too large for the Wallet to process. */\nexport class BundleTooLargeError extends ProviderRpcError {\n  static readonly code = 5740\n  override readonly code = 5740\n  override readonly name = 'Provider.BundleTooLargeError'\n\n  constructor({\n    message = 'The call bundle is too large for the Wallet to process.',\n  }: { message?: string | undefined } = {}) {\n    super(5740, message)\n  }\n}\n\n/** The Wallet can support atomicity after an upgrade, but the user rejected the upgrade. */\nexport class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {\n  static readonly code = 5750\n  override readonly code = 5750\n  override readonly name = 'Provider.AtomicReadyWalletRejectedUpgradeError'\n\n  constructor({\n    message = 'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.',\n  }: { message?: string | undefined } = {}) {\n    super(5750, message)\n  }\n}\n\n/** The wallet does not support atomic execution but the request requires it. */\nexport class AtomicityNotSupportedError extends ProviderRpcError {\n  static readonly code = 5760\n  override readonly code = 5760\n  override readonly name = 'Provider.AtomicityNotSupportedError'\n\n  constructor({\n    message = 'The wallet does not support atomic execution but the request requires it.',\n  }: { message?: string | undefined } = {}) {\n    super(5760, message)\n  }\n}\n\n/**\n * Creates an EIP-1193 flavored event emitter to be injected onto a Provider.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox' // [!code focus]\n *\n * // 1. Instantiate a Provider Emitter. // [!code focus]\n * const emitter = Provider.createEmitter() // [!code focus]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider. // [!code focus]\n *   ...emitter, // [!code focus]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events. // [!code focus]\n * emitter.emit('accountsChanged', ['0x...']) // [!code focus]\n * ```\n *\n * @returns An event emitter.\n */\nexport function createEmitter(): Emitter {\n  const emitter = new EventEmitter<EventMap>()\n\n  return {\n    get eventNames() {\n      return emitter.eventNames.bind(emitter)\n    },\n    get listenerCount() {\n      return emitter.listenerCount.bind(emitter)\n    },\n    get listeners() {\n      return emitter.listeners.bind(emitter)\n    },\n    addListener: emitter.addListener.bind(emitter),\n    emit: emitter.emit.bind(emitter),\n    off: emitter.off.bind(emitter),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter),\n    removeAllListeners: emitter.removeAllListeners.bind(emitter),\n    removeListener: emitter.removeListener.bind(emitter),\n  }\n}\n\nexport declare namespace createEmitter {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates an [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193) {@link ox#Provider.Provider}\n * from an arbitrary [EIP-1193 Provider](https://eips.ethereum.org/EIPS/eip-1193) interface.\n *\n * @example\n * ### Instantiating with RPC Transport\n *\n * Ox's {@link ox#RpcTransport} is EIP-1193 compliant, and can be used to instantiate an EIP-1193 Provider. This means you can use any HTTP RPC endpoint as an EIP-1193 Provider.\n *\n * ```ts twoslash\n * import { Provider, RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n * const provider = Provider.from(transport)\n * ```\n *\n * @example\n * ### Instantiating with External Providers\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from an\n * external EIP-1193 Provider like `window.ethereum`.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Provider } from 'ox'\n *\n * const provider = Provider.from(window.ethereum)\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * :::tip\n *\n * There are also libraries that distribute EIP-1193 Provider objects that you can use with `Provider.from`:\n *\n * - [`@walletconnect/ethereum-provider`](https://www.npmjs.com/package/\\@walletconnect/ethereum-provider)\n *\n * - [`@coinbase/wallet-sdk`](https://www.npmjs.com/package/\\@coinbase/wallet-sdk)\n *\n * - [`@metamask/detect-provider`](https://www.npmjs.com/package/\\@metamask/detect-provider)\n *\n * - [`@safe-global/safe-apps-provider`](https://github.com/safe-global/safe-apps-sdk/tree/main/packages/safe-apps-provider)\n *\n * - [`mipd`](https://github.com/wevm/mipd): EIP-6963 Multi Injected Providers\n *\n * :::\n *\n * @example\n * ### Instantiating a Custom Provider\n *\n * The example below demonstrates how we can instantiate a typed EIP-1193 Provider from a\n * HTTP `fetch` JSON-RPC request. You can use this pattern to integrate with any asynchronous JSON-RPC\n * transport, including WebSockets and IPC.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * const blockNumber = await provider.request({ method: 'eth_blockNumber' })\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using the {@link ox#RpcSchema.(from:function)} type.\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Instantiating a Provider with Events\n *\n * The example below demonstrates how to instantiate a Provider with your own EIP-1193 flavored event emitter.\n *\n * This example is useful for Wallets that distribute an EIP-1193 Provider (e.g. webpage injection via `window.ethereum`).\n *\n * ```ts twoslash\n * // @noErrors\n * import { Provider, RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Instantiate a Provider Emitter.\n * const emitter = Provider.createEmitter() // [!code ++]\n *\n * const store = RpcRequest.createStore()\n *\n * const provider = Provider.from({\n *   // 2. Pass the Emitter to the Provider.\n *   ...emitter, // [!code ++]\n *   async request(args) {\n *     return await fetch('https://1.rpc.thirdweb.com', {\n *       body: JSON.stringify(store.prepare(args)),\n *       method: 'POST',\n *       headers: {\n *         'Content-Type': 'application/json',\n *       },\n *     })\n *       .then((res) => res.json())\n *       .then(RpcResponse.parse)\n *   },\n * })\n *\n * // 3. Emit Provider Events.\n * emitter.emit('accountsChanged', ['0x...']) // [!code ++]\n * ```\n *\n * @param provider - The EIP-1193 provider to convert.\n * @returns An typed EIP-1193 Provider.\n */\nexport function from<\n  const provider extends Provider | unknown,\n  options extends Options | undefined = undefined,\n>(\n  provider: provider | Provider<{ schema: RpcSchema.Generic }>,\n  options?: options | Options,\n): Provider<options>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(provider: any, options: Options = {}): Provider<Options> {\n  const { includeEvents = true } = options\n  if (!provider) throw new IsUndefinedError()\n  return {\n    ...(includeEvents\n      ? {\n          on: provider.on?.bind(provider),\n          removeListener: provider.removeListener?.bind(provider),\n        }\n      : {}),\n    async request(args) {\n      try {\n        const result = await provider.request(args)\n        if (\n          result &&\n          typeof result === 'object' &&\n          'jsonrpc' in (result as { jsonrpc?: unknown })\n        )\n          return RpcResponse.parse(result) as never\n        return result\n      } catch (error) {\n        throw parseError(error)\n      }\n    },\n  }\n}\n\nexport declare namespace from {\n  type ErrorType = IsUndefinedError | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a Provider error instance.\n *\n * @example\n * ```ts twoslash\n * import { Provider } from 'ox'\n *\n * const error = Provider.parseError({ code: 4200, message: 'foo' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - The error object to parse.\n * @returns An error instance.\n */\nexport function parseError<\n  const error extends RpcResponse.ErrorObject | Error | unknown,\n>(\n  error: error | Error | RpcResponse.ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = RpcResponse.parseError(error)\n  if (error_ instanceof RpcResponse.InternalError) {\n    if (!error_.data) return error_ as never\n\n    const { code } = error_.data as RpcResponse.ErrorObject\n    if (code === DisconnectedError.code)\n      return new DisconnectedError(error_) as never\n    if (code === ChainDisconnectedError.code)\n      return new ChainDisconnectedError(error_) as never\n    if (code === UserRejectedRequestError.code)\n      return new UserRejectedRequestError(error_) as never\n    if (code === UnauthorizedError.code)\n      return new UnauthorizedError(error_) as never\n    if (code === UnsupportedMethodError.code)\n      return new UnsupportedMethodError(error_) as never\n    if (code === SwitchChainError.code)\n      return new SwitchChainError(error_) as never\n    if (code === AtomicReadyWalletRejectedUpgradeError.code)\n      return new AtomicReadyWalletRejectedUpgradeError(error_) as never\n    if (code === AtomicityNotSupportedError.code)\n      return new AtomicityNotSupportedError(error_) as never\n    if (code === BundleTooLargeError.code)\n      return new BundleTooLargeError(error_) as never\n    if (code === UnknownBundleIdError.code)\n      return new UnknownBundleIdError(error_) as never\n    if (code === DuplicateIdError.code)\n      return new DuplicateIdError(error_) as never\n    if (code === UnsupportedChainIdError.code)\n      return new UnsupportedChainIdError(error_) as never\n    if (code === UnsupportedNonOptionalCapabilityError.code)\n      return new UnsupportedNonOptionalCapabilityError(error_) as never\n  }\n  return error_ as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends RpcResponse.ErrorObject | unknown,\n    //\n    error = errorObject extends RpcResponse.ErrorObject\n      ?\n          | (errorObject['code'] extends DisconnectedError['code']\n              ? DisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DisconnectedError\n              : never)\n          | (errorObject['code'] extends ChainDisconnectedError['code']\n              ? ChainDisconnectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ChainDisconnectedError\n              : never)\n          | (errorObject['code'] extends UserRejectedRequestError['code']\n              ? UserRejectedRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UserRejectedRequestError\n              : never)\n          | (errorObject['code'] extends UnauthorizedError['code']\n              ? UnauthorizedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnauthorizedError\n              : never)\n          | (errorObject['code'] extends UnsupportedMethodError['code']\n              ? UnsupportedMethodError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedMethodError\n              : never)\n          | (errorObject['code'] extends SwitchChainError['code']\n              ? SwitchChainError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? SwitchChainError\n              : never)\n          | (errorObject['code'] extends AtomicReadyWalletRejectedUpgradeError['code']\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicReadyWalletRejectedUpgradeError\n              : never)\n          | (errorObject['code'] extends AtomicityNotSupportedError['code']\n              ? AtomicityNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? AtomicityNotSupportedError\n              : never)\n          | (errorObject['code'] extends BundleTooLargeError['code']\n              ? BundleTooLargeError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BundleTooLargeError\n              : never)\n          | (errorObject['code'] extends UnknownBundleIdError['code']\n              ? UnknownBundleIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnknownBundleIdError\n              : never)\n          | (errorObject['code'] extends DuplicateIdError['code']\n              ? DuplicateIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? DuplicateIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedChainIdError['code']\n              ? UnsupportedChainIdError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedChainIdError\n              : never)\n          | (errorObject['code'] extends UnsupportedNonOptionalCapabilityError['code']\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? UnsupportedNonOptionalCapabilityError\n              : never)\n      : RpcResponse.parseError.ReturnType<RpcResponse.ErrorObject>,\n  > = IsNever<error> extends true\n    ? RpcResponse.parseError.ReturnType<errorObject>\n    : error\n}\n\n/** Thrown when the provider is undefined. */\nexport class IsUndefinedError extends Errors.BaseError {\n  override readonly name = 'Provider.IsUndefinedError'\n\n  constructor() {\n    super('`provider` is undefined.')\n  }\n}\n","import { createTransport, type Transport } from 'viem'\n\nexport { fallback, http, type Transport, webSocket } from 'viem'\n\nexport const relayUrls = {\n  anvil: { http: 'http://localhost:9119' },\n  prod: { http: 'https://rpc.porto.sh' },\n  stg: { http: 'https://stg-rpc.porto.sh' },\n} as const\n\nexport function relayProxy(\n  transports: relayProxy.Value,\n): relayProxy.ReturnType {\n  return (config) => {\n    const transport_public = transports.public(config)\n    const transport_relay = transports.relay(config)\n\n    return createTransport({\n      key: relayProxy.type,\n      name: 'Relay Proxy',\n      async request({ method, params }, options) {\n        if (isRelay(method))\n          return transport_relay.request({ method, params }, options) as never\n        return transport_public.request({ method, params }, options) as never\n      },\n      type: relayProxy.type,\n    })\n  }\n}\n\nexport namespace relayProxy {\n  export const type = 'relayProxy'\n\n  export type Value = { public: Transport; relay: Transport }\n\n  export type ReturnType = Transport<typeof type>\n}\n\n/** @internal */\nfunction isRelay(method: string) {\n  if (method.startsWith('wallet_')) return true\n  if (method.startsWith('account_')) return true\n  if (method === 'health') return true\n  return false\n}\n","declare global {\n  interface Navigator {\n    userAgentData?: {\n      mobile?: boolean\n    }\n  }\n}\n\nexport function isSafari() {\n  const ua = navigator.userAgent.toLowerCase()\n  return ua.includes('safari') && !ua.includes('chrome')\n}\n\nexport function isFirefox() {\n  const ua = navigator.userAgent.toLowerCase()\n  return (\n    (ua.includes('firefox') || ua.includes('fxios')) &&\n    !ua.includes('seamonkey')\n  )\n}\n\nexport function isMobile() {\n  if (window.navigator?.userAgentData?.mobile) return true\n\n  return (\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Browser_detection_using_the_user_agent#alternatives_to_ua_sniffing\n    navigator.maxTouchPoints > 1 ||\n    /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(\n      navigator.userAgent,\n    ) ||\n    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(\n      navigator.userAgent.slice(0, 4),\n    )\n  )\n}\n","import * as Errors from './Errors.js'\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */\nexport const exponents = {\n  wei: 0,\n  gwei: 9,\n  szabo: 12,\n  finney: 15,\n  ether: 18,\n} as const\n\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */\nexport function format(value: bigint, decimals = 0) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */\nexport function formatEther(\n  wei: bigint,\n  unit: 'wei' | 'gwei' | 'szabo' | 'finney' = 'wei',\n) {\n  return format(wei, exponents.ether - exponents[unit])\n}\n\nexport declare namespace formatEther {\n  type ErrorType = format.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return format(wei, exponents.gwei - exponents[unit])\n}\n\nexport declare namespace formatGwei {\n  type ErrorType = format.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */\nexport function from(value: string, decimals = 0) {\n  if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n    throw new InvalidDecimalNumberError({ value })\n\n  let [integer = '', fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) integer = integer.slice(1)\n\n  // trim trailing zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    if (Math.round(Number(`.${fraction}`)) === 1)\n      integer = `${BigInt(integer) + 1n}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [\n      fraction.slice(0, decimals - 1),\n      fraction.slice(decimals - 1, decimals),\n      fraction.slice(decimals),\n    ]\n\n    const rounded = Math.round(Number(`${unit}.${right}`))\n    if (rounded > 9)\n      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0')\n    else fraction = `${left}${rounded}`\n\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1)\n      integer = `${BigInt(integer) + 1n}`\n    }\n\n    fraction = fraction.slice(0, decimals)\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n\nexport declare namespace from {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nexport function fromEther(\n  ether: string,\n  unit: 'wei' | 'gwei' | 'szabo' | 'finney' = 'wei',\n) {\n  return from(ether, exponents.ether - exponents[unit])\n}\n\nexport declare namespace fromEther {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nexport function fromGwei(gwei: string, unit: 'wei' = 'wei') {\n  return from(gwei, exponents.gwei - exponents[unit])\n}\n\nexport declare namespace fromGwei {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */\nexport class InvalidDecimalNumberError extends Errors.BaseError {\n  override readonly name = 'Value.InvalidDecimalNumberError'\n  constructor({ value }: { value: string }) {\n    super(`Value \\`${value}\\` is not a valid decimal number.`)\n  }\n}\n","import * as Dialog from '../../Dialog.js'\nimport { isReactNative } from '../../react-native/utils.js'\nimport * as Mode from '../mode.js'\nimport * as Relay from '../modes/relay.js'\nimport { dialog } from './dialog.js'\n\nexport function reactNative(parameters: reactNative.Parameters = {}) {\n  if (!isReactNative())\n    return (\n      parameters.fallback ??\n      Mode.from({ actions: Relay.relay().actions, name: 'relay' })\n    )\n\n  const { redirectUri, requestOptions, ...baseParameters } = parameters\n\n  return Mode.from({\n    ...dialog({\n      ...baseParameters,\n      renderer: Dialog.authSession({ redirectUri, requestOptions }),\n    }),\n    name: 'reactNative',\n  })\n}\n\nexport declare namespace reactNative {\n  export type Parameters =\n    | (Omit<dialog.Parameters, 'renderer'> & Dialog.authSession.Options)\n    | undefined\n}\n","export * as Chains from './core/Chains.js'\nexport * as Dialog from './core/Dialog.js'\nexport {\n  /** @internal @deprecated export required for inference. */\n  from,\n  /** @internal @deprecated export required for inference. */\n  type Provider,\n} from './core/internal/provider.js'\nexport * as Messenger from './core/Messenger.js'\nexport * as Mode from './core/Mode.js'\nexport * as Porto from './core/Porto.js'\nexport * as RpcSchema from './core/RpcSchema.js'\nexport * as Storage from './core/Storage.js'\nexport * as Transport from './core/Transport.js'\nexport * as Account from './viem/Account.js'\nexport * as Key from './viem/Key.js'\nexport * as RelayActions from './viem/RelayActions.js'\n","import * as Base64 from './Base64.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, OneOf } from './internal/types.js'\nimport * as internal from './internal/webauthn.js'\nimport * as P256 from './P256.js'\nimport type * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** A WebAuthn-flavored P256 credential. */\nexport type P256Credential = {\n  id: string\n  publicKey: PublicKey.PublicKey\n  raw: internal.PublicKeyCredential\n}\n\n/** Metadata for a WebAuthn P256 signature. */\nexport type SignMetadata = Compute<{\n  authenticatorData: Hex.Hex\n  challengeIndex: number\n  clientDataJSON: string\n  typeIndex: number\n  userVerificationRequired: boolean\n}>\n\nexport const createChallenge = Uint8Array.from([\n  105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n])\n\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nexport async function createCredential(\n  options: createCredential.Options,\n): Promise<P256Credential> {\n  const {\n    createFn = window.navigator.credentials.create.bind(\n      window.navigator.credentials,\n    ),\n    ...rest\n  } = options\n  const creationOptions = getCredentialCreationOptions(rest)\n  try {\n    const credential = (await createFn(\n      creationOptions,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialCreationFailedError()\n\n    const response = credential.response as AuthenticatorAttestationResponse\n    const publicKey = await internal.parseCredentialPublicKey(response)\n\n    return {\n      id: credential.id,\n      publicKey,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialCreationFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace createCredential {\n  type Options = getCredentialCreationOptions.Options & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?:\n      | ((\n          options?: internal.CredentialCreationOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ErrorType =\n    | getCredentialCreationOptions.ErrorType\n    | internal.parseCredentialPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nexport function getAuthenticatorData(\n  options: getAuthenticatorData.Options = {},\n): Hex.Hex {\n  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options\n  const rpIdHash = Hash.sha256(Hex.fromString(rpId))\n  const flag_bytes = Hex.fromNumber(flag, { size: 1 })\n  const signCount_bytes = Hex.fromNumber(signCount, { size: 4 })\n  return Hex.concat(rpIdHash, flag_bytes, signCount_bytes)\n}\n\nexport declare namespace getAuthenticatorData {\n  type Options = {\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nexport function getClientDataJSON(options: getClientDataJSON.Options): string {\n  const {\n    challenge,\n    crossOrigin = false,\n    extraClientData,\n    origin = window.location.origin,\n  } = options\n\n  return JSON.stringify({\n    type: 'webauthn.get',\n    challenge: Base64.fromHex(challenge, { url: true, pad: false }),\n    origin,\n    crossOrigin,\n    ...extraClientData,\n  })\n}\n\nexport declare namespace getClientDataJSON {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nexport function getCredentialCreationOptions(\n  options: getCredentialCreationOptions.Options,\n): internal.CredentialCreationOptions {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required',\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    extensions,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title,\n    },\n    user,\n  } = options\n  const name = (user?.name ?? name_)!\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge,\n      ...(excludeCredentialIds\n        ? {\n            excludeCredentials: excludeCredentialIds?.map((id) => ({\n              id: Base64.toBytes(id),\n              type: 'public-key',\n            })),\n          }\n        : {}),\n      pubKeyCredParams: [\n        {\n          type: 'public-key',\n          alg: -7, // p256\n        },\n      ],\n      ...(extensions && { extensions }),\n      rp,\n      user: {\n        id: user?.id ?? Hash.keccak256(Bytes.fromString(name), { as: 'Bytes' }),\n        name,\n        displayName: user?.displayName ?? name,\n      },\n    },\n  }\n}\n\nexport declare namespace getCredentialCreationOptions {\n  type Options = {\n    /**\n     * A string specifying the relying party's preference for how the attestation statement\n     * (i.e., provision of verifiable evidence of the authenticity of the authenticator and its data)\n     * is conveyed during credential creation.\n     */\n    attestation?:\n      | internal.PublicKeyCredentialCreationOptions['attestation']\n      | undefined\n    /**\n     * An object whose properties are criteria used to filter out the potential authenticators\n     * for the credential creation operation.\n     */\n    authenticatorSelection?:\n      | internal.PublicKeyCredentialCreationOptions['authenticatorSelection']\n      | undefined\n    /**\n     * An `ArrayBuffer`, `TypedArray`, or `DataView` used as a cryptographic challenge.\n     */\n    challenge?:\n      | internal.PublicKeyCredentialCreationOptions['challenge']\n      | undefined\n    /**\n     * List of credential IDs to exclude from the creation. This property can be used\n     * to prevent creation of a credential if it already exists.\n     */\n    excludeCredentialIds?: readonly string[] | undefined\n    /**\n     * List of Web Authentication API credentials to use during creation or authentication.\n     */\n    extensions?:\n      | internal.PublicKeyCredentialCreationOptions['extensions']\n      | undefined\n    /**\n     * An object describing the relying party that requested the credential creation\n     */\n    rp?:\n      | {\n          id: string\n          name: string\n        }\n      | undefined\n    /**\n     * A numerical hint, in milliseconds, which indicates the time the calling web app is willing to wait for the creation operation to complete.\n     */\n    timeout?: internal.PublicKeyCredentialCreationOptions['timeout'] | undefined\n  } & OneOf<\n    | {\n        /** Name for the credential (user.name). */\n        name: string\n      }\n    | {\n        /**\n         * An object describing the user account for which the credential is generated.\n         */\n        user: {\n          displayName?: string\n          id?: BufferSource\n          name: string\n        }\n      }\n  >\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nexport function getCredentialRequestOptions(\n  options: getCredentialRequestOptions.Options,\n): internal.CredentialRequestOptions {\n  const {\n    credentialId,\n    challenge,\n    extensions,\n    rpId = window.location.hostname,\n    userVerification = 'required',\n  } = options\n  return {\n    publicKey: {\n      ...(credentialId\n        ? {\n            allowCredentials: Array.isArray(credentialId)\n              ? credentialId.map((id) => ({\n                  id: Base64.toBytes(id),\n                  type: 'public-key',\n                }))\n              : [\n                  {\n                    id: Base64.toBytes(credentialId),\n                    type: 'public-key',\n                  },\n                ],\n          }\n        : {}),\n      challenge: Bytes.fromHex(challenge),\n      ...(extensions && { extensions }),\n      rpId,\n      userVerification,\n    },\n  }\n}\n\nexport declare namespace getCredentialRequestOptions {\n  type Options = {\n    /** The credential ID to use. */\n    credentialId?: string | string[] | undefined\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** List of Web Authentication API credentials to use during creation or authentication. */\n    extensions?:\n      | internal.PublicKeyCredentialRequestOptions['extensions']\n      | undefined\n    /** The relying party identifier to use. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** The user verification requirement. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Base64.toBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nexport function getSignPayload(\n  options: getSignPayload.Options,\n): getSignPayload.ReturnType {\n  const {\n    challenge,\n    crossOrigin,\n    extraClientData,\n    flag,\n    origin,\n    rpId,\n    signCount,\n    userVerification = 'required',\n  } = options\n\n  const authenticatorData = getAuthenticatorData({\n    flag,\n    rpId,\n    signCount,\n  })\n  const clientDataJSON = getClientDataJSON({\n    challenge,\n    crossOrigin,\n    extraClientData,\n    origin,\n  })\n  const clientDataJSONHash = Hash.sha256(Hex.fromString(clientDataJSON))\n\n  const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n  const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n  const metadata = {\n    authenticatorData,\n    clientDataJSON,\n    challengeIndex,\n    typeIndex,\n    userVerificationRequired: userVerification === 'required',\n  }\n\n  const payload = Hex.concat(authenticatorData, clientDataJSONHash)\n\n  return { metadata, payload }\n}\n\nexport declare namespace getSignPayload {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** If set to `true`, the payload will be hashed before being returned. */\n    hash?: boolean | undefined\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n    /** The user verification requirement that the authenticator will enforce. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    payload: Hex.Hex\n  }\n\n  type ErrorType =\n    | Hash.sha256.ErrorType\n    | Hex.concat.ErrorType\n    | Hex.fromString.ErrorType\n    | getAuthenticatorData.ErrorType\n    | getClientDataJSON.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nexport async function sign(options: sign.Options): Promise<sign.ReturnType> {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = options\n  const requestOptions = getCredentialRequestOptions(rest)\n  try {\n    const credential = (await getFn(\n      requestOptions,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialRequestFailedError()\n    const response = credential.response as AuthenticatorAssertionResponse\n\n    const clientDataJSON = String.fromCharCode(\n      ...new Uint8Array(response.clientDataJSON),\n    )\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n    const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n    const signature = internal.parseAsn1Signature(\n      new Uint8Array(response.signature),\n    )\n\n    return {\n      metadata: {\n        authenticatorData: Hex.fromBytes(\n          new Uint8Array(response.authenticatorData),\n        ),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired:\n          requestOptions.publicKey!.userVerification === 'required',\n      },\n      signature,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialRequestFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace sign {\n  type Options = getCredentialRequestOptions.Options & {\n    /**\n     * Credential request function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.get\n     */\n    getFn?:\n      | ((\n          options?: internal.CredentialRequestOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    raw: internal.PublicKeyCredential\n    signature: Signature.Signature<false>\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | getCredentialRequestOptions.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nexport function verify(options: verify.Options): boolean {\n  const { challenge, hash = true, metadata, publicKey, signature } = options\n  const {\n    authenticatorData,\n    challengeIndex,\n    clientDataJSON,\n    typeIndex,\n    userVerificationRequired,\n  } = metadata\n\n  const authenticatorDataBytes = Bytes.fromHex(authenticatorData)\n\n  // Check length of `authenticatorData`.\n  if (authenticatorDataBytes.length < 37) return false\n\n  const flag = authenticatorDataBytes[32]!\n\n  // Verify that the UP bit of the flags in authData is set.\n  if ((flag & 0x01) !== 0x01) return false\n\n  // If user verification was determined to be required, verify that\n  // the UV bit of the flags in authData is set. Otherwise, ignore the\n  // value of the UV flag.\n  if (userVerificationRequired && (flag & 0x04) !== 0x04) return false\n\n  // If the BE bit of the flags in authData is not set, verify that\n  // the BS bit is not set.\n  if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false\n\n  // Check that response is for an authentication assertion\n  const type = '\"type\":\"webauthn.get\"'\n  if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1))\n    return false\n\n  // Check that hash is in the clientDataJSON.\n  const match = clientDataJSON\n    .slice(Number(challengeIndex))\n    .match(/^\"challenge\":\"(.*?)\"/)\n  if (!match) return false\n\n  // Validate the challenge in the clientDataJSON.\n  const [_, challenge_extracted] = match\n  if (Hex.fromBytes(Base64.toBytes(challenge_extracted!)) !== challenge)\n    return false\n\n  const clientDataJSONHash = Hash.sha256(Bytes.fromString(clientDataJSON), {\n    as: 'Bytes',\n  })\n  const payload = Bytes.concat(authenticatorDataBytes, clientDataJSONHash)\n\n  return P256.verify({\n    hash,\n    payload,\n    publicKey,\n    signature,\n  })\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** The challenge to verify. */\n    challenge: Hex.Hex\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** The public key to verify the signature with. */\n    publicKey: PublicKey.PublicKey\n    /** The signature to verify. */\n    signature: Signature.Signature<false>\n    /** The metadata to verify the signature with. */\n    metadata: SignMetadata\n  }\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.fromHex.ErrorType\n    | P256.verify.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a WebAuthn P256 credential creation fails. */\nexport class CredentialCreationFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialCreationFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to create credential.', {\n      cause,\n    })\n  }\n}\n\n/** Thrown when a WebAuthn P256 credential request fails. */\nexport class CredentialRequestFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialRequestFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to request credential.', {\n      cause,\n    })\n  }\n}\n","import * as AbiParameters from 'ox/AbiParameters'\n\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\n\nexport type EncodeCallsErrorType =\n  | AbiParameters.encode.ErrorType\n  | AbiParameters.from.ErrorType\n  | EncodeFunctionDataErrorType\n  | ErrorType\n\nexport function encodeCalls(\n  calls_: Calls<readonly unknown[]>,\n  opData?: Hex | undefined,\n) {\n  const calls = calls_.map((call_) => {\n    const call = call_ as Call\n    return {\n      data: call.abi ? encodeFunctionData(call) : (call.data ?? '0x'),\n      value: call.value ?? 0n,\n      target: call.to,\n    }\n  })\n\n  return AbiParameters.encode(\n    AbiParameters.from([\n      'struct Call { address target; uint256 value; bytes data; }',\n      'Call[] calls',\n      ...(opData ? ['bytes opData'] : []),\n    ]),\n    [calls, ...(opData ? [opData] : [])] as any,\n  )\n}\n","import * as Address from 'ox/Address'\nimport type * as Hex from 'ox/Hex'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport * as Signature from 'ox/Signature'\nimport * as TypedData from 'ox/TypedData'\nimport type * as WebAuthnP256 from 'ox/WebAuthnP256'\nimport {\n  hashMessage,\n  hashTypedData,\n  type LocalAccount,\n  type PartialBy,\n} from 'viem'\nimport { toAccount } from 'viem/accounts'\nimport type { Assign, Compute } from '../core/internal/types.js'\nimport type * as Storage from '../core/Storage.js'\nimport * as Key from './Key.js'\n\nexport type Account<\n  source extends 'porto' | 'privateKey' = 'porto' | 'privateKey',\n> = LocalAccount<source> & {\n  keys?: readonly Key.Key[] | undefined\n  sign: NonNullable<LocalAccount['sign']>\n}\n\n/**\n * Instantiates a delegated account.\n *\n * @param account - Account to instantiate.\n * @returns An instantiated delegated account.\n */\nexport function from<const account extends from.Parameters>(\n  parameters: from.Parameters<account>,\n): Compute<from.ReturnType<account>> {\n  const account = (\n    typeof parameters === 'string' ? { address: parameters } : parameters\n  ) as from.AccountParameter\n  const source = account.sign ? 'privateKey' : 'porto'\n\n  const {\n    address,\n    sign: sign_,\n    signMessage,\n    signTransaction,\n    signTypedData,\n    type,\n  } = toAccount({\n    address: account.address,\n    sign({ hash }) {\n      if (source === 'porto')\n        throw new Error('`sign` not supported on porto accounts.')\n      if (!account.sign) throw new Error('`sign` not supported.')\n      return account.sign({ hash })\n    },\n    signMessage({ message }) {\n      return this.sign!({\n        hash: hashMessage(message),\n      })\n    },\n    signTransaction() {\n      throw new Error('`signTransaction` not supported on porto accounts.')\n    },\n    signTypedData(typedData) {\n      return this.sign!({\n        hash: hashTypedData(typedData),\n      })\n    },\n  })\n  return {\n    address,\n    keys: account.keys ?? undefined,\n    sign: sign_,\n    signMessage,\n    signTransaction,\n    signTypedData,\n    source,\n    type,\n  } as never\n}\n\nexport declare namespace from {\n  type AccountParameter = PartialBy<\n    Pick<Account, 'address' | 'keys' | 'sign'>,\n    'sign'\n  >\n\n  type Parameters<\n    account extends Address.Address | AccountParameter =\n      | Address.Address\n      | AccountParameter,\n  > = account | Address.Address | AccountParameter\n\n  type ReturnType<\n    account extends Address.Address | AccountParameter =\n      | Address.Address\n      | AccountParameter,\n  > = Readonly<\n    Assign<\n      Account,\n      account extends AccountParameter ? account : { address: account }\n    > & {\n      source: account extends { sign: NonNullable<LocalAccount['sign']> }\n        ? 'privateKey'\n        : 'porto'\n    }\n  >\n}\n\n/**\n * Instantiates a delegated account from a private key.\n *\n * @param privateKey - Private key.\n * @param options - Options.\n * @returns An instantiated delegated account.\n */\nexport function fromPrivateKey<\n  const options extends fromPrivateKey.Options = fromPrivateKey.Options,\n>(\n  privateKey: Hex.Hex,\n  options: options | fromPrivateKey.Options = {},\n): Compute<fromPrivateKey.ReturnType<options>> {\n  const { keys } = options\n  const address = Address.fromPublicKey(Secp256k1.getPublicKey({ privateKey }))\n  return from({\n    address,\n    keys,\n    async sign({ hash }) {\n      return Signature.toHex(\n        Secp256k1.sign({\n          payload: hash,\n          privateKey,\n        }),\n      )\n    },\n    source: 'privateKey',\n  }) as fromPrivateKey.ReturnType<options>\n}\n\nexport declare namespace fromPrivateKey {\n  type Options = {\n    /**\n     * Keys to instantiate.\n     */\n    keys?: readonly Key.Key[] | undefined\n  }\n\n  type ReturnType<options extends Options = Options> = Readonly<\n    (Omit<Account, 'keys'> &\n      (options['keys'] extends readonly Key.Key[]\n        ? { keys: options['keys'] }\n        : { keys?: Account['keys'] })) & { source: 'privateKey' }\n  >\n}\n\nexport function getKey(\n  account: Account,\n  parameters: getKey.Parameters = {},\n): Key.Key | undefined {\n  const { key, role } = parameters\n\n  if (key === null) return undefined\n\n  // Extract from `key` parameter.\n  if (typeof key === 'object') return key\n\n  // Extract from `account.keys` (with optional `key` index).\n  if (account.keys && account.keys.length > 0) {\n    if (typeof key === 'number') return account.keys[key]\n    return account.keys.find(\n      (key) => key.privateKey && (!role || key.role === role),\n    )\n  }\n\n  return undefined\n}\n\nexport declare namespace getKey {\n  type Parameters = {\n    key?: number | Key.Key | null | undefined\n    role?: Key.Key['role'] | undefined\n  }\n}\n\n/**\n * Extracts a signing key from a delegated account and signs a payload.\n *\n * @example\n * TODO\n *\n * @param parameters - Parameters.\n * @returns Signature.\n */\nexport async function sign(\n  account: Account,\n  parameters: sign.Parameters,\n): Promise<Compute<Hex.Hex>> {\n  const { storage, replaySafe = true, wrap = true, webAuthn } = parameters\n\n  const key = getKey(account, parameters)\n\n  const payload = (() => {\n    if (!replaySafe) return parameters.payload\n    return TypedData.getSignPayload({\n      domain: { verifyingContract: account.address },\n      message: {\n        digest: parameters.payload,\n      },\n      primaryType: 'ERC1271Sign',\n      types: {\n        ERC1271Sign: [{ name: 'digest', type: 'bytes32' }],\n      },\n    })\n  })()\n\n  const sign = (() => {\n    if (!key) {\n      if (account.source === 'privateKey') return account.sign\n      return undefined\n    }\n    return ({ hash }: { hash: Hex.Hex }) =>\n      Key.sign(key, {\n        address: null,\n        payload: hash,\n        storage,\n        webAuthn,\n        wrap,\n      })\n  })()\n\n  // If the account has no valid signing key, then we cannot sign the payload.\n  if (!sign) throw new Error('cannot find key to sign with.')\n\n  // Sign the payload.\n  return await sign({ hash: payload })\n}\n\nexport declare namespace sign {\n  type Parameters = {\n    /**\n     * Key to sign the payloads with.\n     *\n     * - If number, the key at the index will be used.\n     * - If `Key.Key`, the provided key will be used.\n     * - If `null`, the account's root signing key will be used.\n     * - If not provided, a key will be extracted from the `account`.\n     */\n    key?: number | Key.Key | null | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex\n    /**\n     * Whether to use replay-safe signing.\n     * `false` if replay-safe signing is not needed (e.g. signing call bundles).\n     */\n    replaySafe?: boolean\n    /**\n     * Role to extract the key from the `account` for signing.\n     */\n    role?: Key.Key['role'] | undefined\n    /**\n     * Storage to use for keytype-specific caching (e.g. WebAuthn user verification).\n     */\n    storage?: Storage.Storage | undefined\n    /**\n     * Whether to wrap the signature with key metadata.\n     */\n    wrap?: boolean | undefined\n    /**\n     * WebAuthn helpers for non-browser environments (e.g., React Native passkeys).\n     */\n    webAuthn?:\n      | {\n          createFn?:\n            | WebAuthnP256.createCredential.Options['createFn']\n            | undefined\n          getFn?: WebAuthnP256.sign.Options['getFn'] | undefined\n        }\n      | undefined\n  }\n}\n","import type * as abitype from 'abitype'\nimport * as AbiParameters from './AbiParameters.js'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\n\nexport type TypedData = abitype.TypedData\nexport type Domain = abitype.TypedDataDomain\nexport type Parameter = abitype.TypedDataParameter\n\n// TODO: Make reusable for Viem?\nexport type Definition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = primaryType extends 'EIP712Domain'\n  ? EIP712DomainDefinition<typedData, primaryType>\n  : MessageDefinition<typedData, primaryType, primaryTypes>\n\nexport type EIP712DomainDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends 'EIP712Domain' = 'EIP712Domain',\n  ///\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n> = {\n  types?: typedData | undefined\n} & {\n  primaryType:\n    | 'EIP712Domain'\n    | (primaryType extends 'EIP712Domain' ? primaryType : never)\n  domain: schema extends { EIP712Domain: infer domain }\n    ? domain\n    : Compute<Domain>\n  message?: undefined\n}\n\nexport type MessageDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n  message = schema[primaryType extends keyof schema\n    ? primaryType\n    : keyof schema],\n> = {\n  types: typedData\n} & {\n  primaryType:\n    | primaryTypes // show all values\n    | (primaryType extends primaryTypes ? primaryType : never) // infer value\n  domain?:\n    | (schema extends { EIP712Domain: infer domain } ? domain : Compute<Domain>)\n    | undefined\n  message: { [_: string]: any } extends message // Check if message was inferred\n    ? Record<string, unknown>\n    : message\n}\n\n/**\n * Asserts that [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.assert({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function assert<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): void {\n  const { domain, message, primaryType, types } =\n    value as unknown as assert.Value\n\n  const validateData = (\n    struct: readonly Parameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(Solidity.integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        Hex.fromNumber(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_ ?? '', 10) / 8,\n        })\n      }\n\n      if (\n        type === 'address' &&\n        typeof value === 'string' &&\n        !Address.validate(value)\n      )\n        throw new Address.InvalidAddressError({\n          address: value,\n          cause: new Address.InvalidInputError(),\n        })\n\n      const bytesMatch = type.match(Solidity.bytesRegex)\n      if (bytesMatch) {\n        const [, size] = bytesMatch\n        if (size && Hex.size(value as Hex.Hex) !== Number.parseInt(size, 10))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size, 10),\n            givenSize: Hex.size(value as Hex.Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport declare namespace assert {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | Address.InvalidAddressError\n    | BytesSizeMismatchError\n    | InvalidPrimaryTypeError\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Creates [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator) for the provided domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.domainSeparator({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: '0x9911ee4f58a7059a8f5385248040e6984d80e2c849500fe6a4d11c4fa98c2af3'\n * ```\n *\n * @param domain - The domain for which to create the domain separator.\n * @returns The domain separator.\n */\nexport function domainSeparator(domain: Domain): Hex.Hex {\n  return hashDomain({\n    domain,\n  })\n}\n\nexport declare namespace domainSeparator {\n  type ErrorType = hashDomain.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `0x19  0x01  domainSeparator  hashStruct(message)`.\n *\n * @example\n * ```ts twoslash\n * import { TypedData, Hash } from 'ox'\n *\n * const data = TypedData.encode({ // [!code focus:33]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n * // @log: '0x19012fdf3441fcaf4f30c7e16292b258a5d7054a4e2e00dbd7b7d2f467f2b8fb9413c52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e'\n * // @log: (0x19  0x01  domainSeparator  hashStruct(message))\n *\n * const hash = Hash.keccak256(data)\n * ```\n *\n * @param value - The Typed Data to encode.\n * @returns The encoded Typed Data.\n */\nexport function encode<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  const { domain = {}, message, primaryType } = value as encode.Value\n\n  const types = {\n    EIP712Domain: extractEip712DomainTypes(domain),\n    ...value.types,\n  } as TypedData\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  assert({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  // Typed Data Format: `0x19  0x01  domainSeparator  hashStruct(message)`\n  const parts: Hex.Hex[] = ['0x19', '0x01']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types,\n      }),\n    )\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types,\n      }),\n    )\n\n  return Hex.concat(...parts)\n}\n\nexport declare namespace encode {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | extractEip712DomainTypes.ErrorType\n    | hashDomain.ErrorType\n    | hashStruct.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for the provided primaryType.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.encodeType({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n * })\n * // @log: 'Foo(address address,string name,string foo)'\n * ```\n *\n * @param value - The Typed Data schema.\n * @returns The encoded type.\n */\nexport function encodeType(value: encodeType.Value): string {\n  const { primaryType, types } = value\n\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${(types[type] ?? [])\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\nexport declare namespace encodeType {\n  type Value = {\n    primaryType: string\n    types: TypedData\n  }\n\n  type ErrorType = findTypeDependencies.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Gets [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for EIP-721 domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.extractEip712DomainTypes({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: [\n * // @log:   { 'name': 'name', 'type': 'string' },\n * // @log:   { 'name': 'version', 'type': 'string' },\n * // @log:   { 'name': 'chainId', 'type': 'uint256' },\n * // @log:   { 'name': 'verifyingContract', 'type': 'address' },\n * // @log: ]\n * ```\n *\n * @param domain - The EIP-712 domain.\n * @returns The EIP-712 domain schema.\n */\nexport function extractEip712DomainTypes(\n  domain: Domain | undefined,\n): Parameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as Parameter[]\n}\n\nexport declare namespace extractEip712DomainTypes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The typed data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  return Hash.keccak256(encode(value))\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashDomain({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n * })\n * // @log: '0x6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1'\n * ```\n *\n * @param value - The Typed Data domain and types.\n * @returns The hashed domain.\n */\nexport function hashDomain(value: hashDomain.Value): Hex.Hex {\n  const { domain, types } = value\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types: {\n      ...types,\n      EIP712Domain: types?.EIP712Domain || extractEip712DomainTypes(domain),\n    },\n  })\n}\n\nexport declare namespace hashDomain {\n  type Value = {\n    /** The Typed Data domain. */\n    domain: Domain\n    /** The Typed Data types. */\n    types?:\n      | {\n          EIP712Domain?: readonly Parameter[] | undefined\n          [key: string]: readonly Parameter[] | undefined\n        }\n      | undefined\n  }\n\n  type ErrorType = hashStruct.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) struct.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashStruct({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n *   data: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: '0x996fb3b6d48c50312d69abdd4c1b6fb02057c85aa86bb8d04c6f023326a168ce'\n * ```\n *\n * @param value - The Typed Data struct to hash.\n * @returns The hashed Typed Data struct.\n */\nexport function hashStruct(value: hashStruct.Value): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return Hash.keccak256(encoded)\n}\n\nexport declare namespace hashStruct {\n  type Value = {\n    /** The Typed Data struct to hash. */\n    data: Record<string, unknown>\n    /** The primary type of the Typed Data struct. */\n    primaryType: string\n    /** The types of the Typed Data struct. */\n    types: TypedData\n  }\n\n  type ErrorType =\n    | encodeData.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema into string.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.serialize({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: \"{\"domain\":{},\"message\":{\"address\":\"0xb9cab4f0e46f7f6b1024b5a7463734fa68e633f9\",\"name\":\"jxom\",\"foo\":\"0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9\"},\"primaryType\":\"Foo\",\"types\":{\"Foo\":[{\"name\":\"address\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"foo\",\"type\":\"string\"}]}}\"\n * ```\n *\n * @param value - The Typed Data schema to serialize.\n * @returns The serialized Typed Data schema. w\n */\nexport function serialize<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: serialize.Value<typedData, primaryType>): string {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = value as unknown as serialize.Value\n\n  const normalizeData = (\n    struct: readonly Parameter[],\n    value: Record<string, unknown>,\n  ) => {\n    const data = { ...value }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!domain_) return {}\n    const type = types.EIP712Domain ?? extractEip712DomainTypes(domain_)\n    return normalizeData(type, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    if (!types[primaryType]) return {}\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return Json.stringify({ domain, message, primaryType, types }, (_, value) => {\n    if (typeof value === 'bigint') return value.toString()\n    return value\n  })\n}\n\nexport declare namespace serialize {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType = Json.stringify.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * const valid = TypedData.validate({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: true\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function validate<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): boolean {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/** Thrown when the bytes size of a typed data value does not match the expected size. */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  override readonly name = 'TypedData.BytesSizeMismatchError'\n\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\n/** Thrown when the domain is invalid. */\nexport class InvalidDomainError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidDomainError'\n\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${Json.stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\n/** Thrown when the primary type of a typed data value is invalid. */\nexport class InvalidPrimaryTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidPrimaryTypeError'\n\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\n/** Thrown when the struct type is not a valid type. */\nexport class InvalidStructTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidStructTypeError'\n\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n    })\n  }\n}\n\n/** @internal */\nexport function encodeData(value: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encodedTypes: AbiParameters.Parameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType] ?? []) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return AbiParameters.encode(encodedTypes, encodedValues)\n}\n\n/** @internal */\nexport declare namespace encodeData {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | encodeField.ErrorType\n    | hashType.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function hashType(value: {\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { primaryType, types } = value\n  const encodedHashType = Hex.fromString(encodeType({ primaryType, types }))\n  return Hash.keccak256(encodedHashType)\n}\n\n/** @internal */\nexport declare namespace hashType {\n  type ErrorType =\n    | Hex.fromString.ErrorType\n    | encodeType.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeField(properties: {\n  types: TypedData\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameters.Parameter, value: Hex.Hex] {\n  let { types, name, type, value } = properties\n\n  if (types[type] !== undefined)\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, Hash.keccak256(value, { as: 'Hex' })]\n  }\n\n  if (type === 'string')\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(Bytes.fromString(value), { as: 'Hex' }),\n    ]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameters.Parameter, any][]).map(\n      (item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n    )\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(\n        AbiParameters.encode(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n\n/** @internal */\nexport declare namespace encodeField {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function findTypeDependencies(\n  value: {\n    primaryType: string\n    types: TypedData\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const { primaryType: primaryType_, types } = value\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined)\n    return results\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType])\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  return results\n}\n\n/** @internal */\nexport declare namespace findTypeDependencies {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","import * as Address from './Address.js'\nimport * as Errors from './Errors.js'\nimport type { ExactPartial } from './internal/types.js'\nimport { uid } from './internal/uid.js'\n\nexport const domainRegex =\n  /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/\n\nexport const ipRegex =\n  /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/\n\nexport const localhostRegex = /^localhost(:[0-9]{1,5})?$/\n\nexport const nonceRegex = /^[a-zA-Z0-9]{8,}$/\n\nexport const schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/\n\n// https://regexr.com/80gdj\nexport const prefixRegex =\n  /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?<address>0x[a-fA-F0-9]{40})\\n\\n(?:(?<statement>.*)\\n\\n)?/\n\n// https://regexr.com/80gf9\nexport const suffixRegex =\n  /(?:URI: (?<uri>.+))\\n(?:Version: (?<version>.+))\\n(?:Chain ID: (?<chainId>\\d+))\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\n(?:Issued At: (?<issuedAt>.+))(?:\\nExpiration Time: (?<expirationTime>.+))?(?:\\nNot Before: (?<notBefore>.+))?(?:\\nRequest ID: (?<requestId>.+))?/\n\n/** [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message fields. */\nexport type Message = {\n  /**\n   * The Ethereum address performing the signing.\n   */\n  address: Address.Address\n  /**\n   * The [EIP-155](https://eips.ethereum.org/EIPS/eip-155) Chain ID to which the session is bound,\n   */\n  chainId: number\n  /**\n   * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) authority that is requesting the signing.\n   */\n  domain: string\n  /**\n   * Time when the signed authentication message is no longer valid.\n   */\n  expirationTime?: Date | undefined\n  /**\n   * Time when the message was generated, typically the current time.\n   */\n  issuedAt?: Date | undefined\n  /**\n   * A random string typically chosen by the relying party and used to prevent replay attacks.\n   */\n  nonce: string\n  /**\n   * Time when the signed authentication message will become valid.\n   */\n  notBefore?: Date | undefined\n  /**\n   * A system-specific identifier that may be used to uniquely refer to the sign-in request.\n   */\n  requestId?: string | undefined\n  /**\n   * A list of information or references to information the user wishes to have resolved as part of authentication by the relying party.\n   */\n  resources?: string[] | undefined\n  /**\n   * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) URI scheme of the origin of the request.\n   */\n  scheme?: string | undefined\n  /**\n   * A human-readable ASCII assertion that the user will sign.\n   */\n  statement?: string | undefined\n  /**\n   * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) URI referring to the resource that is the subject of the signing (as in the subject of a claim).\n   */\n  uri: string\n  /**\n   * The current version of the SIWE Message.\n   */\n  version: '1'\n}\n\n/**\n * Creates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @log: \"example.com wants you to sign in with your Ethereum account:\n * // @log: 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n * // @log:\n * // @log:\n * // @log: URI: https://example.com/path\n * // @log: Version: 1\n * // @log: Chain ID: 1\n * // @log: Nonce: foobarbaz\n * // @log: Issued At: 2023-02-01T00:00:00.000Z\"\n * ```\n *\n * @param value - Values to use when creating EIP-4361 formatted message.\n * @returns EIP-4361 formatted message.\n */\nexport function createMessage(value: Message): string {\n  const {\n    chainId,\n    domain,\n    expirationTime,\n    issuedAt = new Date(),\n    nonce,\n    notBefore,\n    requestId,\n    resources,\n    scheme,\n    uri,\n    version,\n  } = value\n\n  // Validate fields\n  {\n    // Required fields\n    if (chainId !== Math.floor(chainId))\n      throw new InvalidMessageFieldError({\n        field: 'chainId',\n        metaMessages: [\n          '- Chain ID must be a EIP-155 chain ID.',\n          '- See https://eips.ethereum.org/EIPS/eip-155',\n          '',\n          `Provided value: ${chainId}`,\n        ],\n      })\n    if (\n      !(\n        domainRegex.test(domain) ||\n        ipRegex.test(domain) ||\n        localhostRegex.test(domain)\n      )\n    )\n      throw new InvalidMessageFieldError({\n        field: 'domain',\n        metaMessages: [\n          '- Domain must be an RFC 3986 authority.',\n          '- See https://www.rfc-editor.org/rfc/rfc3986',\n          '',\n          `Provided value: ${domain}`,\n        ],\n      })\n    if (!nonceRegex.test(nonce))\n      throw new InvalidMessageFieldError({\n        field: 'nonce',\n        metaMessages: [\n          '- Nonce must be at least 8 characters.',\n          '- Nonce must be alphanumeric.',\n          '',\n          `Provided value: ${nonce}`,\n        ],\n      })\n    if (!isUri(uri))\n      throw new InvalidMessageFieldError({\n        field: 'uri',\n        metaMessages: [\n          '- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.',\n          '- See https://www.rfc-editor.org/rfc/rfc3986',\n          '',\n          `Provided value: ${uri}`,\n        ],\n      })\n    if (version !== '1')\n      throw new InvalidMessageFieldError({\n        field: 'version',\n        metaMessages: [\n          \"- Version must be '1'.\",\n          '',\n          `Provided value: ${version}`,\n        ],\n      })\n\n    // Optional fields\n    if (scheme && !schemeRegex.test(scheme))\n      throw new InvalidMessageFieldError({\n        field: 'scheme',\n        metaMessages: [\n          '- Scheme must be an RFC 3986 URI scheme.',\n          '- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1',\n          '',\n          `Provided value: ${scheme}`,\n        ],\n      })\n    const statement = value.statement\n    if (statement?.includes('\\n'))\n      throw new InvalidMessageFieldError({\n        field: 'statement',\n        metaMessages: [\n          \"- Statement must not include '\\\\n'.\",\n          '',\n          `Provided value: ${statement}`,\n        ],\n      })\n  }\n\n  // Construct message\n  const address = Address.from(value.address, { checksum: true })\n  const origin = (() => {\n    if (scheme) return `${scheme}://${domain}`\n    return domain\n  })()\n  const statement = (() => {\n    if (!value.statement) return ''\n    return `${value.statement}\\n`\n  })()\n  const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`\n\n  let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}\\nNonce: ${nonce}\\nIssued At: ${issuedAt.toISOString()}`\n\n  if (expirationTime)\n    suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`\n  if (notBefore) suffix += `\\nNot Before: ${notBefore.toISOString()}`\n  if (requestId) suffix += `\\nRequest ID: ${requestId}`\n  if (resources) {\n    let content = '\\nResources:'\n    for (const resource of resources) {\n      if (!isUri(resource))\n        throw new InvalidMessageFieldError({\n          field: 'resources',\n          metaMessages: [\n            '- Every resource must be a RFC 3986 URI.',\n            '- See https://www.rfc-editor.org/rfc/rfc3986',\n            '',\n            `Provided value: ${resource}`,\n          ],\n        })\n      content += `\\n- ${resource}`\n    }\n    suffix += content\n  }\n\n  return `${prefix}\\n${suffix}`\n}\n\nexport declare namespace createMessage {\n  type ErrorType =\n    | Address.from.ErrorType\n    | InvalidMessageFieldError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates random [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) nonce.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.generateNonce()\n * // @log: '65ed4681d4efe0270b923ff5f4b097b1c95974dc33aeebecd5724c42fd86dfd25dc70b27ef836b2aa22e68f19ebcccc1'\n * ```\n *\n * @returns Random nonce.\n */\nexport function generateNonce(): string {\n  return uid(96)\n}\n\n/**\n * Check if the given URI is a valid [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) URI.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.isUri('https://example.com/foo')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `false` if invalid, otherwise the valid URI.\n */\n// based on https://github.com/ogt/valid-url\nexport function isUri(value: string): false | string {\n  // check for illegal characters\n  if (/[^a-z0-9:/?#[\\]@!$&'()*+,;=.\\-_~%]/i.test(value)) return false\n\n  // check for hex escapes that aren't complete\n  if (/%[^0-9a-f]/i.test(value)) return false\n  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return false\n\n  // from RFC 3986\n  const splitted = splitUri(value)\n  const scheme = splitted[1]\n  const authority = splitted[2]\n  const path = splitted[3]\n  const query = splitted[4]\n  const fragment = splitted[5]\n\n  // scheme and path are required, though the path can be empty\n  if (!(scheme?.length && path && path.length >= 0)) return false\n\n  // if authority is present, the path must be empty or begin with a /\n  if (authority?.length) {\n    if (!(path.length === 0 || /^\\//.test(path))) return false\n  } else {\n    // if authority is not present, the path must not start with //\n    if (/^\\/\\//.test(path)) return false\n  }\n\n  // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n  if (!/^[a-z][a-z0-9+\\-.]*$/.test(scheme.toLowerCase())) return false\n\n  let out = ''\n  // re-assemble the URL per section 5.3 in RFC 3986\n  out += `${scheme}:`\n  if (authority?.length) out += `//${authority}`\n\n  out += path\n\n  if (query?.length) out += `?${query}`\n  if (fragment?.length) out += `#${fragment}`\n\n  return out\n}\n\nfunction splitUri(value: string) {\n  return value.match(\n    /(?:([^:/?#]+):)?(?:\\/\\/([^/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/,\n  )!\n}\n\n/**\n * [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message into message fields object.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.parseMessage(`example.com wants you to sign in with your Ethereum account:\n * 0xA0Cf798816D4b9b9866b5330EEa46a18382f251e\n *\n * I accept the ExampleOrg Terms of Service: https://example.com/tos\n *\n * URI: https://example.com/path\n * Version: 1\n * Chain ID: 1\n * Nonce: foobarbaz\n * Issued At: 2023-02-01T00:00:00.000Z`)\n * // @log: {\n * // @log:   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * // @log:   chainId: 1,\n * // @log:   domain: 'example.com',\n * // @log:   issuedAt: '2023-02-01T00:00:00.000Z',\n * // @log:   nonce: 'foobarbaz',\n * // @log:   statement: 'I accept the ExampleOrg Terms of Service: https://example.com/tos',\n * // @log:   uri: 'https://example.com/path',\n * // @log:   version: '1',\n * // @log: }\n * ```\n *\n * @param message - [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message.\n * @returns Message fields object.\n */\nexport function parseMessage(message: string): ExactPartial<Message> {\n  const { scheme, statement, ...prefix } = (message.match(prefixRegex)\n    ?.groups ?? {}) as {\n    address: Address.Address\n    domain: string\n    scheme?: string\n    statement?: string\n  }\n  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } =\n    (message.match(suffixRegex)?.groups ?? {}) as {\n      chainId: string\n      expirationTime?: string\n      issuedAt?: string\n      nonce: string\n      notBefore?: string\n      requestId?: string\n      uri: string\n      version: '1'\n    }\n  const resources = message.split('Resources:')[1]?.split('\\n- ').slice(1)\n  return {\n    ...prefix,\n    ...suffix,\n    ...(chainId ? { chainId: Number(chainId) } : {}),\n    ...(expirationTime ? { expirationTime: new Date(expirationTime) } : {}),\n    ...(issuedAt ? { issuedAt: new Date(issuedAt) } : {}),\n    ...(notBefore ? { notBefore: new Date(notBefore) } : {}),\n    ...(requestId ? { requestId } : {}),\n    ...(resources ? { resources } : {}),\n    ...(scheme ? { scheme } : {}),\n    ...(statement ? { statement } : {}),\n  }\n}\n\n/**\n * Validates [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.validateMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: 'example.com',\n *   message: {\n *     address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *     chainId: 1,\n *     domain: 'example.com',\n *     nonce: 'foobarbaz',\n *     uri: 'https://example.com/path',\n *     version: '1',\n *   },\n *   nonce: 'foobarbaz',\n * })\n * // @log: true\n * ```\n *\n * @param value - Values to use when validating EIP-4361 formatted message.\n * @returns Whether the message is valid.\n */\nexport function validateMessage(value: validateMessage.Value): boolean {\n  const { address, domain, message, nonce, scheme, time = new Date() } = value\n\n  if (domain && message.domain !== domain) return false\n  if (nonce && message.nonce !== nonce) return false\n  if (scheme && message.scheme !== scheme) return false\n\n  if (message.expirationTime && time >= message.expirationTime) return false\n  if (message.notBefore && time < message.notBefore) return false\n\n  try {\n    if (!message.address) return false\n    if (address && !Address.isEqual(message.address, address)) return false\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nexport declare namespace validateMessage {\n  interface Value {\n    /**\n     * Ethereum address to check against.\n     */\n    address?: Address.Address | undefined\n    /**\n     * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) authority to check against.\n     */\n    domain?: string | undefined\n    /**\n     * EIP-4361 message fields.\n     */\n    message: ExactPartial<Message>\n    /**\n     * Random string to check against.\n     */\n    nonce?: string | undefined\n    /**\n     * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) URI scheme to check against.\n     */\n    scheme?: string | undefined\n    /**\n     * Current time to check optional `expirationTime` and `notBefore` fields.\n     *\n     * @default new Date()\n     */\n    time?: Date | undefined\n  }\n}\n\n/**\n * Thrown when a field in a SIWE Message is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Siwe } from 'ox'\n *\n * Siwe.createMessage({\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   chainId: 1.1,\n *   domain: 'example.com',\n *   nonce: 'foobarbaz',\n *   uri: 'https://example.com/path',\n *   version: '1',\n * })\n * // @error: Siwe.InvalidMessageFieldError: Invalid Sign-In with Ethereum message field \"chainId\".\n * // @error: - Chain ID must be a EIP-155 chain ID.\n * // @error: - See https://eips.ethereum.org/EIPS/eip-155\n * // @error: Provided value: 1.1\n * ```\n */\nexport class InvalidMessageFieldError extends Errors.BaseError {\n  override readonly name = 'Siwe.InvalidMessageFieldError'\n\n  constructor(parameters: {\n    field: string\n    metaMessages?: string[] | undefined\n  }) {\n    const { field, metaMessages } = parameters\n    super(`Invalid Sign-In with Ethereum message field \"${field}\".`, {\n      metaMessages,\n    })\n  }\n}\n","import * as AbiItem from 'ox/AbiItem'\nimport type * as Address from 'ox/Address'\nimport * as Hex from 'ox/Hex'\nimport type * as z from 'zod/mini'\n\nimport type * as Account from '../../viem/Account.js'\nimport type * as Key from '../../viem/Key.js'\nimport type { RelayClient } from '../../viem/RelayClient.js'\nimport type * as Chains from '../Chains.js'\nimport type * as RpcSchema from '../RpcSchema.js'\nimport * as Call from './call.js'\nimport type * as PermissionsRequest from './permissionsRequest.js'\nimport type * as Porto from './porto.js'\nimport type * as Capabilities from './schema/capabilities.js'\nimport type * as RpcRequest from './schema/request.js'\nimport type * as Token from './schema/token.js'\nimport type { Assign, PartialBy } from './types.js'\n\nexport type ActionsInternal<\n  chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n    Chains.Chain,\n    ...Chains.Chain[],\n  ],\n> = Pick<Porto.Internal<chains>, 'config' | 'store'> & {\n  /** Viem Client. */\n  client: RelayClient\n  /** RPC Request. */\n  request: RpcRequest.Request\n}\n\ntype PrepareCallsContext = {\n  calls?: readonly Call.Call[] | undefined\n  nonce?: bigint | undefined\n  [key: string]: unknown\n}\n\nexport type Mode = {\n  actions: {\n    addFunds: (parameters: {\n      /** Address to add funds to. */\n      address: Address.Address\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Token to add funds to. */\n      token?: Address.Address | undefined\n      /** Amount to add. */\n      value?: string | undefined\n    }) => Promise<{ id: Hex.Hex }>\n\n    createAccount: (parameters: {\n      /** Admins to grant. */\n      admins?: readonly Pick<Key.Key, 'publicKey' | 'type'>[] | undefined\n      /** Whether to link `label` to account address as email. */\n      email?: boolean | undefined\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Label to associate with the WebAuthn credential. */\n      label?: string | undefined\n      /** Permissions to grant. */\n      permissions?: PermissionsRequest.PermissionsRequest | undefined\n      /** Adds support for offchain authentication using ERC-4361. */\n      signInWithEthereum?: Capabilities.signInWithEthereum.Request | undefined\n    }) => Promise<{\n      /** Account. */\n      account: Account.Account & {\n        signInWithEthereum?:\n          | {\n              message: string\n              signature: Hex.Hex\n            }\n          | undefined\n      }\n    }>\n\n    disconnect?:\n      | ((parameters: {\n          /** Internal properties. */\n          internal: ActionsInternal\n        }) => Promise<void>)\n      | undefined\n\n    getAccountVersion: (parameters: {\n      /** Address of the account to get the version of. */\n      address: Address.Address\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<{\n      /** Latest version. */\n      latest: string\n      /** Current version. */\n      current: string\n    }>\n\n    getAssets: (\n      parameters: RpcRequest.wallet_getAssets.Parameters & {\n        /** Internal properties. */\n        internal: ActionsInternal\n      },\n    ) => Promise<RpcSchema.wallet_getAssets.Response>\n\n    getCallsStatus: (parameters: {\n      /** ID of the calls to get the status of. */\n      id: Hex.Hex\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<z.input<typeof RpcSchema.wallet_getCallsStatus.Response>>\n\n    getCapabilities: (parameters: {\n      /** Chain IDs to get the capabilities for. */\n      chainIds?: readonly Hex.Hex[] | undefined\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<z.input<typeof RpcSchema.wallet_getCapabilities.Response>>\n\n    getKeys: (parameters: {\n      /** Account to get the keys for. */\n      account: Account.Account\n      /** Chain IDs to get the keys for. */\n      chainIds?: readonly number[] | undefined\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<readonly Key.Key[]>\n\n    grantAdmin: (parameters: {\n      /** Account to grant admin for. */\n      account: Account.Account\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Fee token to use for execution. If not provided, the native token (e.g. ETH) will be used. */\n      feeToken?: Token.Symbol | Address.Address | undefined\n      /** Key to authorize as an admin. */\n      key: Key.from.Value\n    }) => Promise<{\n      /** Key the admin is granted to. */\n      key: Key.Key\n    }>\n\n    grantPermissions: (parameters: {\n      /** Account to grant permissions for. */\n      account: Account.Account\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Permissions to grant. */\n      permissions?: PermissionsRequest.PermissionsRequest | undefined\n    }) => Promise<{\n      /** Key the permissions are granted to. */\n      key: Key.Key\n    }>\n\n    loadAccounts: (parameters: {\n      /** Address of the account to load. */\n      address?: Hex.Hex | undefined\n      /** Key to use to load an existing account. */\n      key?:\n        | {\n            /** Credential ID. May be `undefined` when the key is not a WebAuthn credential. */\n            credentialId?: string | undefined\n            /** Public key. */\n            publicKey: Hex.Hex\n          }\n        | undefined\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Permissions to grant. */\n      permissions?: PermissionsRequest.PermissionsRequest | undefined\n      /** Adds support for offchain authentication using ERC-4361. */\n      signInWithEthereum?: Capabilities.signInWithEthereum.Request | undefined\n    }) => Promise<{\n      /** Accounts. */\n      accounts: readonly (Account.Account & {\n        signInWithEthereum?:\n          | {\n              message: string\n              signature: Hex.Hex\n            }\n          | undefined\n      })[]\n    }>\n\n    prepareCalls: (parameters: {\n      /** Account to execute the calls with. */\n      account: Account.Account\n      /** Calls to execute. */\n      calls: readonly Call.Call[]\n      /** Key that will be used to sign over the digest. */\n      key?: Pick<Key.Key, 'prehash' | 'publicKey' | 'type'> | undefined\n      /** Fee token to use for execution. If not provided, the native token (e.g. ETH) will be used. */\n      feeToken?: Token.Symbol | Address.Address | undefined\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Merchant RPC URL. */\n      merchantUrl?: string | undefined\n      /** Required funds to execute the calls. */\n      requiredFunds?:\n        | RpcSchema.wallet_prepareCalls.Capabilities['requiredFunds']\n        | undefined\n    }) => Promise<{\n      /** Account to execute the calls with. */\n      account: Account.Account\n      /** Chain ID. */\n      chainId?: number | undefined\n      /** Capabilities. */\n      capabilities?:\n        | RpcSchema.wallet_prepareCalls.Response['capabilities']\n        | undefined\n      /** Context for `sendPreparedCalls` */\n      context: PrepareCallsContext\n      /** Digest to sign. */\n      digest: Hex.Hex\n      /** Key that will sign over the digest. */\n      key: Pick<Key.Key, 'prehash' | 'publicKey' | 'type'>\n      /** EIP-712 typed data. */\n      typedData: RpcSchema.wallet_prepareCalls.Response['typedData']\n    }>\n\n    prepareUpgradeAccount: (parameters: {\n      /** Address of the account to import. */\n      address: Address.Address\n      /** Whether to link `label` to account address as email. */\n      email?: boolean | undefined\n      /** Label to associate with the account. */\n      label?: string | undefined\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Permissions to grant. */\n      permissions?: PermissionsRequest.PermissionsRequest | undefined\n    }) => Promise<{\n      /** Digests to sign. */\n      digests: {\n        auth: Hex.Hex\n        exec: Hex.Hex\n      }\n      /** Filled context for the `createAccount` implementation. */\n      context: unknown\n    }>\n\n    revokeAdmin: (parameters: {\n      /** Account to revoke the permissions for. */\n      account: Account.Account\n      /** Fee token to use for execution. If not provided, the native token (e.g. ETH) will be used. */\n      feeToken?: Token.Symbol | Address.Address | undefined\n      /** ID of the admin to revoke. */\n      id: Hex.Hex\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<void>\n\n    revokePermissions: (parameters: {\n      /** Account to revoke the permissions for. */\n      account: Account.Account\n      /** Fee token to use for execution. If not provided, the native token (e.g. ETH) will be used. */\n      feeToken?: Token.Symbol | Address.Address | undefined\n      /** ID of the permissions to revoke. */\n      id: Hex.Hex\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<void>\n\n    sendCalls: (parameters: {\n      /** Account to execute the calls with. */\n      account: Account.Account\n      /** Whether the returned bundle identifier is the transaction hash. */\n      asTxHash?: boolean | undefined\n      /** Calls to execute. */\n      calls: readonly Call.Call[]\n      /** Chain ID to execute the calls on. */\n      chainId?: number | undefined\n      /** Fee token to use for execution. If not provided, the native token (e.g. ETH) will be used. */\n      feeToken?: Token.Symbol | Address.Address | undefined\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Required funds to execute the calls. */\n      requiredFunds?:\n        | RpcSchema.wallet_prepareCalls.Capabilities['requiredFunds']\n        | undefined\n      /** Permissions ID to use to execute the calls. */\n      permissionsId?: Hex.Hex | null | undefined\n      /** Merchant RPC URL. */\n      merchantUrl?: string | undefined\n    }) => Promise<{ id: Hex.Hex }>\n\n    sendPreparedCalls: (parameters: {\n      /** Account. */\n      account: Account.Account\n      /** Context. */\n      context: PrepareCallsContext\n      /** Key. */\n      key: Pick<Key.Key, 'prehash' | 'publicKey' | 'type'>\n      /** Signature for execution. */\n      signature: Hex.Hex\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<Hex.Hex>\n\n    signPersonalMessage: (parameters: {\n      /** Account to sign the message with. */\n      account: Account.Account\n      /** Data to sign. */\n      data: Hex.Hex\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<Hex.Hex>\n\n    signTypedData: (parameters: {\n      /** Account to sign the message with. */\n      account: Account.Account\n      /** Data to sign. */\n      data: string\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<Hex.Hex>\n\n    switchChain?:\n      | ((parameters: {\n          /** Chain ID to switch to. */\n          chainId: number\n          /** Internal properties. */\n          internal: ActionsInternal\n        }) => Promise<void>)\n      | undefined\n\n    upgradeAccount: (parameters: {\n      /** Account to upgrade. */\n      account: Account.Account\n      /** Preparation context (from `prepareUpgradeAccount`). */\n      context: unknown\n      /** Internal properties. */\n      internal: ActionsInternal\n      /** Preparation signatures (from `prepareUpgradeAccount`). */\n      signatures: {\n        auth: Hex.Hex\n        exec: Hex.Hex\n      }\n    }) => Promise<{\n      /** Account. */\n      account: Account.Account\n    }>\n\n    verifyEmail: (parameters: {\n      /** Account to sign the email + token with. */\n      account: Account.Account\n      /** Chain ID to verify against. */\n      chainId: number\n      /** Email to link to wallet address. */\n      email: string\n      /** Generated token value. */\n      token: string\n      /** Wallet address to link to email. */\n      walletAddress: Address.Address\n      /** Internal properties. */\n      internal: ActionsInternal\n    }) => Promise<null>\n  }\n  config?: unknown | undefined\n  name: string\n  setup: (parameters: {\n    /** Internal properties. */\n    internal: Porto.Internal\n  }) => () => void\n}\n\n/**\n * Instantiates a mode.\n *\n * @param mode - Mode.\n * @returns Mode.\n */\nexport function from<const mode extends from.Parameters>(\n  mode: mode | from.Parameters,\n): Assign<Mode, mode> {\n  return {\n    ...mode,\n    setup: mode.setup ?? (() => () => {}),\n  } as never\n}\n\nexport declare namespace from {\n  type Parameters = PartialBy<Mode, 'setup'>\n}\n\n/**\n * Returns the calls needed to authorize the given keys (and permissions).\n *\n * @param keys - Keys to authorize.\n * @returns Calls to authorize the given keys.\n */\nexport function getAuthorizeCalls(\n  keys: readonly Key.Key[],\n): readonly Call.Call[] {\n  return keys.flatMap((key) => {\n    const { permissions, role } = key\n\n    const permissionCalls: Call.Call[] = []\n\n    // Set call scopes.\n    if (permissions?.calls)\n      permissionCalls.push(\n        ...permissions.calls.map((scope) => {\n          const selector = (() => {\n            if (!scope.signature) return undefined\n            if (scope.signature.startsWith('0x'))\n              return scope.signature as Hex.Hex\n            return AbiItem.getSelector(scope.signature)\n          })()\n          return Call.setCanExecute({\n            key,\n            selector,\n            to: scope.to,\n          })\n        }),\n      )\n    else if (role === 'session')\n      permissionCalls.push(Call.setCanExecute({ key }))\n\n    // Set spend limits.\n    if (permissions?.spend)\n      permissionCalls.push(\n        ...permissions.spend.map((spend) =>\n          Call.setSpendLimit({ key, ...spend }),\n        ),\n      )\n    // If no spend limits are provided for a session, set a default of 0\n    // (account cannot spend ERC20, ERC721, ETH, etc).\n    else if (role === 'session')\n      permissionCalls.push(\n        Call.setSpendLimit({ key, limit: 0n, period: 'year' }),\n      )\n\n    // Set authorized contracts for signature verification.\n    if (permissions?.signatureVerification) {\n      const { addresses } = permissions.signatureVerification\n      permissionCalls.push(\n        ...addresses.map((address) =>\n          Call.setSignatureCheckerApproval({\n            address,\n            enabled: true,\n            key,\n          }),\n        ),\n      )\n    }\n\n    return [Call.authorize({ key }), ...permissionCalls]\n  })\n}\n\n/**\n *\n * @param parameters\n * @returns\n */\nexport async function getAuthorizedExecuteKey(parameters: {\n  account: Account.Account\n  calls: readonly Call.Call[]\n  permissionsId?: Hex.Hex | null | undefined\n}): Promise<Key.Key | undefined> {\n  const { account, calls, permissionsId } = parameters\n\n  // If a key is provided, use it.\n  if (typeof permissionsId !== 'undefined') {\n    if (permissionsId === null) return undefined\n    const key = account.keys?.find(\n      (key) => key.publicKey === permissionsId && key.privateKey,\n    )\n    if (!key)\n      throw new Error(`permission (id: ${permissionsId}) does not exist.`)\n    return key\n  }\n\n  // Otherwise, try and find a valid session key.\n  const sessionKey = account.keys?.find((key) => {\n    if (!key.privateKey) return false\n    if (key.role !== 'session') return false\n    if (key.expiry < BigInt(Math.floor(Date.now() / 1000))) return false\n\n    // Check if every call is covered by a call permission.\n    const hasValidScope = calls.every((call) =>\n      key.permissions?.calls?.some((scope) => {\n        if (scope.to && scope.to !== call.to) return false\n        if (scope.signature) {\n          if (!call.data) return false\n          const selector = Hex.slice(call.data, 0, 4)\n          if (Hex.validate(scope.signature)) return scope.signature === selector\n          if (AbiItem.getSelector(scope.signature) !== selector) return false\n        }\n        return true\n      }),\n    )\n    if (hasValidScope) return true\n\n    return false\n  })\n\n  // Fall back to an admin key.\n  const adminKey = account.keys?.find(\n    (key) => key.role === 'admin' && key.privateKey,\n  )\n\n  return sessionKey ?? adminKey\n}\n","import * as Address from 'ox/Address'\nimport { type Client, type Transport, zeroAddress } from 'viem'\nimport type { GetChainParameter } from '../../viem/internal/utils.js'\nimport * as RelayActions from '../../viem/RelayActions.js'\nimport type * as Chains from '../Chains.js'\nimport type { State, Store } from '../Porto.js'\nimport type * as Token from './schema/token.js'\n\nexport type { Token } from './schema/token.js'\nexport type Tokens = readonly Token.Token[]\n\n/**\n * Fetches all supported tokens for a given chain.\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Tokens.\n */\nexport async function getTokens<chain extends Chains.Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters?: getTokens.Parameters<chain>,\n): Promise<getTokens.ReturnType> {\n  const { chain = client.chain } = parameters ?? {}\n\n  const tokens = await RelayActions.getCapabilities(client, {\n    chainId: chain?.id,\n  }).then((capabilities) => capabilities.fees.tokens)\n\n  return tokens\n}\n\nexport declare namespace getTokens {\n  export type Parameters<\n    chain extends Chains.Chain | undefined = Chains.Chain | undefined,\n  > = GetChainParameter<chain>\n\n  export type ReturnType = readonly Token.Token[]\n}\n\n/**\n * Fetches a token for a given chain, provided an address or symbol.\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Token.\n */\nexport async function getToken<chain extends Chains.Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getToken.Parameters<chain>,\n): Promise<getToken.ReturnType> {\n  const { addressOrSymbol } = parameters\n  const tokens = await getTokens(client, parameters)\n  return tokens.find(getToken.predicate(addressOrSymbol))\n}\n\nexport namespace getToken {\n  export type Parameters<\n    chain extends Chains.Chain | undefined = Chains.Chain | undefined,\n  > = getTokens.Parameters<chain> & {\n    addressOrSymbol: Token.Symbol | Address.Address\n  }\n\n  export type ReturnType = Token.Token | undefined\n\n  export function predicate(addressOrSymbol: Token.Symbol | Address.Address) {\n    return (token: Token.Token) => {\n      if (!addressOrSymbol) return false\n      if (Address.validate(addressOrSymbol))\n        return Address.isEqual(token.address, addressOrSymbol)\n      if (addressOrSymbol === 'native') return token.address === zeroAddress\n      return addressOrSymbol === token.symbol\n    }\n  }\n}\n\n/**\n * Resolves the fee token to use. Resolves the provided address or symbol,\n * or the defaults to the fee token stored in state.\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Fee token.\n */\nexport async function resolveFeeToken<chain extends Chains.Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters?: resolveFeeToken.Parameters<chain> | undefined,\n): Promise<resolveFeeToken.ReturnType> {\n  const { chain = client.chain, store } = parameters ?? {}\n  const state = (store?.getState() ?? {}) as State\n  const addressOrSymbol = parameters?.addressOrSymbol ?? state.feeToken\n\n  const feeTokens = await getTokens(client, { chain: chain! }).then((tokens) =>\n    tokens.filter((token) => token.feeToken),\n  )\n  const feeToken = feeTokens?.find((feeToken) => {\n    if (!addressOrSymbol) return false\n    if (addressOrSymbol === 'native' && feeToken.address === zeroAddress)\n      return true\n    if (\n      Address.validate(addressOrSymbol) &&\n      Address.isEqual(feeToken.address, addressOrSymbol)\n    )\n      return true\n    return addressOrSymbol === feeToken.symbol\n  })\n\n  return feeToken\n}\n\nexport declare namespace resolveFeeToken {\n  export type Parameters<\n    chain extends Chains.Chain | undefined = Chains.Chain | undefined,\n  > = getTokens.Parameters<chain> & {\n    /**\n     * Fee token to resolve.\n     */\n    addressOrSymbol?: Token.Symbol | Address.Address | undefined\n    /**\n     * Porto store.\n     */\n    store?: Store<any> | undefined\n  }\n\n  export type ReturnType = Token.Token | undefined\n}\n","import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiError.js'\nimport type * as AbiItem_internal from './internal/abiItem.js'\nimport type { IsNarrowable, IsNever } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with an `error` type. */\nexport type AbiError = abitype.AbiError & {\n  hash?: Hex.Hex | undefined\n  overloads?: readonly AbiError[] | undefined\n}\n\n/** @internal */\nexport function decode<\n  const abiError extends AbiError,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiError: abiError,\n  data: Hex.Hex,\n  options?: decode.Options<as> | undefined,\n): decode.ReturnType<abiError, as>\n/**\n * ABI-decodes the provided error input (`inputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function reverts (e.g. a JSON-RPC error response).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from('error InvalidSignature(uint r, uint s, uint8 yParity)')\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001')\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * You can extract an ABI Error from a JSON ABI with {@link ox#AbiError.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...]) // [!code hl]\n * const error = AbiError.fromAbi(abi, 'InvalidSignature') // [!code hl]\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001')\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * You can pass the error `data` to the `name` property of {@link ox#AbiError.(fromAbi:function)} to extract and infer the error by its 4-byte selector:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const data = '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001'\n *\n * const abi = Abi.from([...])\n * const error = AbiError.fromAbi(abi, data) // [!code hl]\n *\n * const value = AbiError.decode(error, data)\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object as a parameter to {@link ox#AbiError.(decode:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const value = AbiError.decode(\n *   abi, // [!code hl]\n *   'InvalidSignature', // [!code hl]\n *   '0x...'\n * )\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiError.decode` to decode the revert error of an `approve` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Abi, AbiError, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     inputs: [\n *       { name: 'to', type: 'address' },\n *       { name: 'tokenId', type: 'uint256' },\n *     ],\n *     name: 'approve',\n *     outputs: [],\n *     stateMutability: 'nonpayable',\n *     type: 'function',\n *   },\n *   // ...\n * ])\n * const approve = AbiFunction.fromAbi(abi, 'approve')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n *\n * try {\n *   // 3. Attempt to perform the the Contract Call.\n *   await window.ethereum!.request({\n *     method: 'eth_call',\n *     params: [\n *       {\n *         data,\n *         to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       },\n *     ],\n *   })\n * } catch (e) { // [!code focus]\n *   // 4. Extract and decode the Error. // [!code focus]\n *   const error = AbiError.fromAbi(abi, e.data) // [!code focus]\n *   const value = AbiError.decode(error, e.data) // [!code focus]\n *   console.error(`${error.name}(${value})`) // [!code focus]\n * // @error:   Error(ERC721: approve caller is not owner nor approved for all)\n * } // [!code focus]\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiError - The ABI Error to decode.\n * @param data - The error data.\n * @param options - Decoding options.\n * @returns The decoded error.\n */\nexport function decode<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  as extends 'Object' | 'Array' = 'Array',\n  //\n  abiError extends AbiError = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiError\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  data: Hex.Hex,\n  options?: decode.Options<as> | undefined,\n): decode.ReturnType<abiError, as>\nexport function decode<\n  const abiError extends AbiError,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiError: abiError | AbiError,\n  data: Hex.Hex,\n  options?: decode.Options<as> | undefined,\n): decode.ReturnType<abiError, as>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        data: Hex.Hex,\n        options?: decode.Options | undefined,\n      ]\n    | [abiError: AbiError, data: Hex.Hex, options?: decode.Options | undefined]\n): decode.ReturnType {\n  const [abiError, data, options = {}] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, data, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        Hex.Hex,\n        decode.Options | undefined,\n      ]\n      return [fromAbi(abi, name), data, options]\n    }\n    return parameters as [AbiError, Hex.Hex, decode.Options | undefined]\n  })()\n  if (Hex.size(data) < 4) throw new AbiItem.InvalidSelectorSizeError({ data })\n  if (abiError.inputs.length === 0) return undefined\n\n  const values = AbiParameters.decode(\n    abiError.inputs,\n    Hex.slice(data, 4),\n    options,\n  )\n  if (values && Object.keys(values).length === 1) {\n    if (Array.isArray(values)) return values[0]\n    return Object.values(values)[0]\n  }\n  return values\n}\n\nexport declare namespace decode {\n  type Options<as extends 'Object' | 'Array' = 'Array'> = {\n    /**\n     * Whether the decoded values should be returned as an `Object` or `Array`.\n     *\n     * @default \"Array\"\n     */\n    as?: as | 'Array' | 'Object' | undefined\n  }\n\n  type ReturnType<\n    abiError extends AbiError = AbiError,\n    as extends 'Object' | 'Array' = 'Array',\n  > = IsNarrowable<abiError, AbiError> extends true\n    ? abiError['inputs'] extends readonly []\n      ? undefined\n      : abiError['inputs'] extends readonly [\n            infer type extends abitype.AbiParameter,\n          ]\n        ? abitype.AbiParameterToPrimitiveType<type>\n        : AbiParameters.decode.ReturnType<\n              abiError['inputs'],\n              as\n            > extends infer types\n          ? types extends readonly []\n            ? undefined\n            : types extends readonly [infer type]\n              ? type\n              : types\n          : never\n    : unknown | readonly unknown[] | undefined\n\n  type ErrorType =\n    | AbiParameters.decode.ErrorType\n    | Hex.size.ErrorType\n    | typeof AbiItem.InvalidSelectorSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided error input (`inputs`), prefixed with the 4 byte error selector.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from(\n *   'error InvalidSignature(uint r, uint s, uint8 yParity)'\n * )\n *\n * const data = AbiError.encode( // [!code focus]\n *   error, // [!code focus]\n *   [1n, 2n, 0] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object and an error name as parameters to `AbiError.encode`.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiError.encode(\n *   abi, // [!code hl]\n *   'InvalidSignature', // [!code hl]\n *   [1n, 2n, 0]\n * )\n * ```\n *\n * @param abiError - ABI Error to encode\n * @param args - Error arguments\n * @returns ABI-encoded error name and arguments\n */\nexport function encode<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  abiError extends AbiError = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiError\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  ...args: encode.Args<abiError>\n): encode.ReturnType\nexport function encode<const abiError extends AbiError>(\n  abiError: abiError,\n  ...args: encode.Args<abiError>\n): encode.ReturnType\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        ...args: readonly unknown[],\n      ]\n    | [abiError: AbiError, ...args: readonly unknown[]]\n) {\n  const [abiError, args] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, ...args] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        ...(readonly unknown[]),\n      ]\n      return [fromAbi(abi, name), args]\n    }\n    const [abiError, ...args] = parameters as [\n      AbiError,\n      ...(readonly unknown[]),\n    ]\n    return [abiError, args]\n  })()\n\n  const selector = getSelector(abiError)\n\n  const data =\n    args.length > 0\n      ? AbiParameters.encode(abiError.inputs, (args as any)[0])\n      : undefined\n\n  return data ? Hex.concat(selector, data) : selector\n}\n\nexport declare namespace encode {\n  type Args<abiError extends AbiError = AbiError> = IsNarrowable<\n    abiError,\n    AbiError\n  > extends true\n    ? abitype.AbiParametersToPrimitiveTypes<\n        abiError['inputs']\n      > extends readonly []\n      ? []\n      : [abitype.AbiParametersToPrimitiveTypes<abiError['inputs']>]\n    : readonly unknown[]\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Formats an {@link ox#AbiError.AbiError} into a **Human Readable ABI Error**.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const formatted = AbiError.format({\n *   type: 'error',\n *   name: 'Example',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiError - The ABI Error to format.\n * @returns The formatted ABI Error.\n */\nexport function format<const abiError extends AbiError>(\n  abiError: abiError | AbiError,\n): abitype.FormatAbiItem<abiError> {\n  return abitype.formatAbiItem(abiError) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Error** or **Human Readable ABI Error** into a typed {@link ox#AbiError.AbiError}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from({\n *   inputs: [{ name: 'v', type: 'uint8' }],\n *   name: 'BadSignatureV',\n *   type: 'error',\n * })\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from(\n *   'error BadSignatureV(uint8 v)' // [!code hl]\n * )\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from([\n *   'struct Signature { uint8 v; }', // [!code hl]\n *   'error BadSignatureV(Signature signature)',\n * ])\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiError - The ABI Error to parse.\n * @returns Typed ABI Error.\n */\nexport function from<\n  const abiError extends AbiError | string | readonly string[],\n>(\n  abiError: (abiError | AbiError | string | readonly string[]) &\n    (\n      | (abiError extends string ? internal.Signature<abiError> : never)\n      | (abiError extends readonly string[]\n          ? internal.Signatures<abiError>\n          : never)\n      | AbiError\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiError> {\n  return AbiItem.from(abiError as AbiError, options) as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted function (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<abiError extends AbiError | string | readonly string[]> =\n    AbiItem.from.ReturnType<abiError>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiError.AbiError} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Errors can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiError.fromAbi(abi, 'BadSignatureV') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Errors can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiError.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Error from JSON-RPC error data.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: AbiItem.fromAbi.Options<\n    abi,\n    name,\n    args,\n    AbiItem_internal.ExtractArgs<abi, name>\n  >,\n): fromAbi.ReturnType<abi, name, args> {\n  if (name === 'Error') return solidityError as never\n  if (name === 'Panic') return solidityPanic as never\n  if (Hex.validate(name, { strict: false })) {\n    const selector = Hex.slice(name, 0, 4)\n    if (selector === solidityErrorSelector) return solidityError as never\n    if (selector === solidityPanicSelector) return solidityPanic as never\n  }\n\n  const item = AbiItem.fromAbi(abi, name, options as any)\n  if (item.type !== 'error')\n    throw new AbiItem.NotFoundError({ name, type: 'error' })\n  return item as never\n}\n\nexport declare namespace fromAbi {\n  type ReturnType<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | AbiItem_internal.ExtractArgs<abi, name>\n      | undefined = AbiItem_internal.ExtractArgs<abi, name>,\n  > = IsNarrowable<name, Name<abi>> extends true\n    ?\n        | (name extends 'Error' ? typeof solidityError : never)\n        | (name extends 'Panic'\n            ? typeof solidityPanic\n            : never) extends infer result\n      ? IsNever<result> extends true\n        ? AbiItem.fromAbi.ReturnType<abi, name, args, AbiError>\n        : result\n      : never\n    :\n        | AbiItem.fromAbi.ReturnType<abi, name, args, AbiError>\n        | typeof solidityError\n        | typeof solidityPanic\n\n  type ErrorType = AbiItem.fromAbi.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiError.AbiError}.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const selector = AbiError.getSelector('error BadSignatureV(uint8 v)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const selector = AbiError.getSelector({\n *   inputs: [{ name: 'v', type: 'uint8' }],\n *   name: 'BadSignatureV',\n *   type: 'error'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the error signature.\n */\nexport function getSelector(abiItem: string | AbiError): Hex.Hex {\n  return AbiItem.getSelector(abiItem)\n}\n\nexport declare namespace getSelector {\n  type ErrorType = AbiItem.getSelector.ErrorType | Errors.GlobalErrorType\n}\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmetic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as Record<number, string>\n\nexport const solidityError = /*#__PURE__*/ from({\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n})\n\nexport const solidityErrorSelector = '0x08c379a0'\n\nexport const solidityPanic = /*#__PURE__*/ from({\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint8',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n})\n\nexport const solidityPanicSelector = '0x4e487b71'\n\n/**\n * Extracts an {@link ox#AbiError.AbiError} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'error Bar(uint256)',\n * ])\n *\n * type Foo = AbiError.FromAbi<typeof abi, 'Foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = abitype.ExtractAbiError<abi, name>\n\n/**\n * Extracts the names of all {@link ox#AbiError.AbiError} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'error Bar(uint256)',\n * ])\n *\n * type names = AbiError.Name<typeof abi>\n * //   ^?\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<abi extends Abi.Abi> =\n  | abitype.ExtractAbiErrorNames<abi>\n  | 'Panic'\n  | 'Error'\n","import { createStore, del, get, set } from 'idb-keyval'\nimport * as Json from 'ox/Json'\n\nimport type { MaybePromise } from './internal/types.js'\nimport * as Utils from './internal/utils.js'\n\nexport type Storage = {\n  getItem: <value>(name: string) => MaybePromise<value | null>\n  removeItem: (name: string) => MaybePromise<void>\n  setItem: (name: string, value: unknown) => MaybePromise<void>\n  sizeLimit: number\n  storages?: readonly Storage[] | undefined\n}\n\nexport function from(storage: Storage): Storage {\n  return storage\n}\n\nexport function combine(...storages: readonly Storage[]): Storage {\n  return {\n    async getItem<value>(name: string) {\n      const results = await Promise.allSettled(\n        storages.map((x) => x.getItem(name)),\n      )\n      const result = results.find(\n        (x) => x.status === 'fulfilled' && x.value !== null,\n      )\n      if (result?.status !== 'fulfilled') return null\n      if (result.value === null) return null\n      return result.value as value\n    },\n    async removeItem(name) {\n      await Promise.allSettled(storages.map((x) => x.removeItem(name)))\n    },\n    async setItem(name, value) {\n      await Promise.allSettled(storages.map((x) => x.setItem(name, value)))\n    },\n    sizeLimit: Math.min(...storages.map((x) => x.sizeLimit)),\n    storages,\n  }\n}\n\nexport function idb() {\n  const store =\n    typeof indexedDB !== 'undefined' ? createStore('porto', 'store') : undefined\n  return from({\n    async getItem(name) {\n      const value = await get(name, store)\n      if (value === null) return null\n      return value\n    },\n    async removeItem(name) {\n      await del(name, store)\n    },\n    async setItem(name, value) {\n      await set(name, Utils.normalizeValue(value), store)\n    },\n    sizeLimit: 1024 * 1024 * 50, // 50MB\n  })\n}\n\nexport function localStorage() {\n  return from({\n    async getItem(name) {\n      const item = window.localStorage.getItem(name)\n      if (item === null) return null\n      try {\n        return Json.parse(item)\n      } catch {\n        return null\n      }\n    },\n    async removeItem(name) {\n      window.localStorage.removeItem(name)\n    },\n    async setItem(name, value) {\n      window.localStorage.setItem(name, Json.stringify(value))\n    },\n    sizeLimit: 1024 * 1024 * 5, // 5MB\n  })\n}\n\nexport function cookie() {\n  return from({\n    async getItem(name) {\n      const value = document.cookie\n        .split('; ')\n        .find((x) => x.startsWith(`${name}=`))\n      if (!value) return null\n      try {\n        return Json.parse(value.substring(name.length + 1))\n      } catch {\n        return null\n      }\n    },\n    async removeItem(name) {\n      // biome-ignore lint/suspicious/noDocumentCookie: do what i want\n      document.cookie = `${name}=;max-age=-1;path=/`\n    },\n    async setItem(name, value) {\n      // biome-ignore lint/suspicious/noDocumentCookie: do what i want\n      document.cookie = `${name}=${Json.stringify(value)};path=/;samesite=None;secure;max-age=31536000`\n    },\n    sizeLimit: 1024 * 4, // 4kB\n  })\n}\n\nexport function memory() {\n  const store = new Map<string, any>()\n  return from({\n    getItem(name) {\n      return store.get(name) ?? null\n    },\n    removeItem(name) {\n      store.delete(name)\n    },\n    setItem(name, value) {\n      store.set(name, value)\n    },\n    sizeLimit: Number.POSITIVE_INFINITY,\n  })\n}\n","import * as AbiError from 'ox/AbiError'\nimport * as AbiParameters from 'ox/AbiParameters'\nimport type * as Address from 'ox/Address'\nimport * as Authorization from 'ox/Authorization'\nimport * as Errors from 'ox/Errors'\nimport * as Hex from 'ox/Hex'\nimport * as Signature from 'ox/Signature'\nimport * as TypedData from 'ox/TypedData'\nimport {\n  type Account as Account_viem,\n  type Authorization as Authorization_viem,\n  BaseError,\n  type Chain,\n  type Client,\n  encodeFunctionData,\n  parseAbi,\n  type SendTransactionParameters,\n  type Transport,\n} from 'viem'\nimport {\n  call,\n  getEip712Domain as getEip712Domain_viem,\n  prepareAuthorization,\n  readContract,\n  sendTransaction,\n} from 'viem/actions'\nimport {\n  type EncodeExecuteDataParameters,\n  encodeExecuteData,\n  getExecuteError as getExecuteError_viem,\n} from 'viem/experimental/erc7821'\nimport * as IthacaAccount from '../core/internal/_generated/contracts/IthacaAccount.js'\nimport * as Call from '../core/internal/call.js'\nimport type { OneOf } from '../core/internal/types.js'\nimport type * as Storage from '../core/Storage.js'\nimport * as Account from './Account.js'\nimport type { GetAccountParameter } from './internal/utils.js'\nimport * as Key from './Key.js'\n\nexport {\n  abi,\n  code,\n} from '../core/internal/_generated/contracts/IthacaAccount.js'\n\n/**\n * Executes a set of calls on a delegated account.\n *\n * @example\n * TODO\n *\n * @param client - Client.\n * @param parameters - Execution parameters.\n * @returns Transaction hash.\n */\nexport async function execute<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: execute.Parameters<calls, account>,\n): Promise<execute.ReturnType> {\n  const { account = client.account } = parameters\n\n  const account_ = account ? Account.from(account) : undefined\n  if (!account_) throw new Error('account is required.')\n\n  // Block expression to obtain the execution request and signatures.\n  const { request, signatures } = await (async () => {\n    const { nonce, key, signatures, storage } = parameters\n\n    // If an execution has been prepared, we can early return the request and signatures.\n    if (nonce && signatures) return { request: parameters, signatures }\n\n    // Otherwise, we need to prepare the execution (compute digests and sign over them).\n    const { digests, request } = await prepareExecute(client, {\n      ...parameters,\n      account: account_,\n    })\n\n    const exec = await Account.sign(account_, {\n      key: digests.auth ? null : key,\n      payload: digests.exec,\n      replaySafe: false,\n      storage,\n    })\n    const auth = await (async () => {\n      if (!digests.auth) return undefined\n      if (account_.source !== 'privateKey')\n        throw new Error('cannot sign authorization without root key.')\n      return account_.sign?.({\n        hash: digests.auth,\n      })\n    })()\n\n    return {\n      request,\n      signatures: {\n        auth,\n        exec,\n      },\n    }\n  })()\n\n  const { authorization, calls, executor, nonce } = request\n\n  // If an authorization signature is provided, it means that we will need to designate\n  // the EOA to the delegation contract. We will need to construct an authorization list\n  // to do so.\n  const authorizationList = (() => {\n    if (!signatures.auth) return undefined\n    const signature = Signature.from(signatures.auth)\n    return [\n      {\n        ...authorization,\n        r: Hex.fromNumber(signature.r),\n        s: Hex.fromNumber(signature.s),\n        yParity: signature.yParity,\n      },\n    ]\n  })()\n\n  // Structure the operation data to be passed to EIP-7821 execution.\n  // The operation data contains the nonce of the execution, as well as the\n  // signature.\n  const opData = AbiParameters.encodePacked(\n    ['uint256', 'bytes'],\n    [nonce, signatures.exec],\n  )\n\n  try {\n    return await sendTransaction(client, {\n      account: typeof executor === 'undefined' ? null : executor,\n      authorizationList,\n      data: encodeExecuteData({ calls, opData }),\n      to: account_.address,\n    } as SendTransactionParameters)\n  } catch (e) {\n    parseExecutionError(e, { calls })\n    throw e\n  }\n}\n\nexport declare namespace execute {\n  export type Parameters<\n    calls extends readonly unknown[] = readonly unknown[],\n    account extends Account.Account | undefined = Account.Account | undefined,\n  > = Pick<EncodeExecuteDataParameters<calls>, 'calls'> &\n    GetAccountParameter<account> & {\n      /**\n       * Contract address to delegate to.\n       */\n      delegation?: Address.Address | undefined\n      /**\n       * The executor of the execute transaction.\n       *\n       * - `Account`: execution will be attempted with the specified account.\n       * - `undefined`: the transaction will be filled by the JSON-RPC server.\n       */\n      executor?: Account_viem | undefined\n      /**\n       * Storage to use for keytype-specific caching (e.g. WebAuthn user verification).\n       */\n      storage?: Storage.Storage | undefined\n    } & OneOf<\n      | {\n          /**\n           * EIP-7702 Authorization to use for delegation.\n           */\n          authorization?: Authorization_viem | undefined\n          /**\n           * Nonce to use for execution that will be invalidated by the delegated account.\n           */\n          nonce: bigint\n          /**\n           * Signature for execution. Required if the `executor` is not the EOA.\n           */\n          signatures: {\n            auth?: Hex.Hex | undefined\n            exec: Hex.Hex\n          }\n        }\n      | {\n          /**\n           * Key to use for execution.\n           */\n          key?: number | Key.Key | undefined\n        }\n      | {}\n    >\n\n  export type ReturnType = Hex.Hex\n}\n\n/**\n * Returns the EIP-712 domain for a delegated account. Used for the execution\n * signing payload.\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns EIP-712 domain.\n */\nexport async function getEip712Domain<\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getEip712Domain.Parameters<account>,\n): Promise<TypedData.Domain> {\n  const { account = client.account } = parameters\n  const account_ = account ? Account.from(account) : undefined\n  if (!account_) throw new Error('account is required.')\n\n  const {\n    domain: { name, version },\n  } = await getEip712Domain_viem(client, {\n    address: account_.address,\n  })\n\n  if (!client.chain) throw new Error('client.chain is required')\n  return {\n    chainId: client.chain.id,\n    name,\n    verifyingContract: account_.address,\n    version,\n  }\n}\n\nexport declare namespace getEip712Domain {\n  export type Parameters<\n    account extends Account.Account | undefined = Account.Account | undefined,\n  > = GetAccountParameter<account>\n}\n\n/**\n * Returns the key at the given index.\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Key.\n */\nexport async function keyAt<\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: keyAt.Parameters<account>,\n) {\n  const { account = client.account, index } = parameters\n\n  const account_ = account ? Account.from(account) : undefined\n  if (!account_) throw new Error('account is required.')\n\n  const key = await readContract(client, {\n    abi: IthacaAccount.abi,\n    address: account_.address,\n    args: [BigInt(index)],\n    functionName: 'keyAt',\n  })\n\n  return Key.deserialize(key, { chainId: client.chain?.id ?? 0 })\n}\n\nexport declare namespace keyAt {\n  export type Parameters<\n    account extends Account.Account | undefined = Account.Account | undefined,\n  > = GetAccountParameter<account> & {\n    /**\n     * Index of the key to extract.\n     */\n    index: number\n  }\n}\n\n/**\n * Prepares the payloads to sign over and fills the request to execute a set of calls.\n *\n * @example\n * TODO\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Prepared properties.\n */\nexport async function prepareExecute<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: prepareExecute.Parameters<calls, account>,\n): Promise<prepareExecute.ReturnType<calls>> {\n  const { account = client.account, delegation, executor, ...rest } = parameters\n\n  const account_ = account ? Account.from(account) : undefined\n  if (!account_) throw new Error('account is required.')\n\n  const calls = parameters.calls.map((call: any) => ({\n    data: call.data ?? '0x',\n    to: call.to === Call.selfAddress ? account_.address : call.to,\n    value: call.value ?? 0n,\n  }))\n\n  const nonce = Hex.toBigInt(\n    Hex.concat(\n      // multichain flag (0 = single chain, 0xc1d0 = multi-chain) // TODO: enable multi-chain\n      Hex.fromNumber(0, { size: 2 }),\n      // sequence key\n      Hex.random(22),\n      // sequential nonce\n      Hex.fromNumber(0, { size: 8 }),\n    ),\n  )\n\n  // Compute the signing payloads for execution and EIP-7702 authorization (optional).\n  const [executePayload, [authorization, authorizationPayload]] =\n    await Promise.all([\n      getExecuteDigest(client, {\n        account: account_,\n        calls,\n        delegation,\n        nonce,\n      }),\n\n      // Only need to compute an authorization payload if we are delegating to an EOA.\n      (async () => {\n        if (!delegation) return []\n\n        const authorization = await prepareAuthorization(client, {\n          account: account_.address,\n          // chainId: 0,\n          contractAddress: delegation,\n          executor,\n        })\n        return [\n          authorization,\n          Authorization.getSignPayload({\n            address: authorization.address,\n            chainId: authorization.chainId,\n            nonce: BigInt(authorization.nonce),\n          }),\n        ]\n      })(),\n    ])\n\n  return {\n    digests: {\n      auth: authorizationPayload,\n      exec: executePayload.digest,\n    },\n    request: {\n      ...rest,\n      account: account_,\n      authorization,\n      calls,\n      executor,\n      nonce,\n    },\n    typedData: executePayload.typedData,\n  } as never\n}\n\nexport declare namespace prepareExecute {\n  export type Parameters<\n    calls extends readonly unknown[] = readonly unknown[],\n    account extends Account.Account | undefined = Account.Account | undefined,\n  > = Pick<execute.Parameters<calls, account>, 'calls'> &\n    GetAccountParameter<account> & {\n      /**\n       * Contract address to delegate to.\n       */\n      delegation?: Address.Address | undefined\n      /**\n       * The executor of the execute transaction.\n       *\n       * - `Account`: execution will be attempted with the specified account.\n       * - `undefined`: the transaction will be filled by the JSON-RPC server.\n       */\n      executor?: Account_viem | undefined\n    }\n\n  export type ReturnType<\n    calls extends readonly unknown[] = readonly unknown[],\n  > = {\n    digests: {\n      auth?: Hex.Hex | undefined\n      exec: Hex.Hex\n    }\n    request: Omit<Parameters<calls>, 'account' | 'delegation'> & {\n      account: Account.Account\n      authorization?: Authorization_viem | undefined\n      nonce: bigint\n    }\n    typedData: TypedData.Definition\n  }\n}\n\nexport function parseExecutionError<const calls extends readonly unknown[]>(\n  e: unknown,\n  { calls }: { calls?: execute.Parameters<calls>['calls'] | undefined } = {},\n) {\n  if (!(e instanceof BaseError)) return\n\n  const getAbiError = (error: BaseError) => {\n    const cause = error.walk((e) => 'data' in (e as BaseError))\n    if (!cause) return undefined\n\n    let data: Hex.Hex | undefined\n    if (cause instanceof BaseError) {\n      const [, match] = cause.details?.match(/\"(0x[0-9a-f]{8})\"/) || []\n      if (match) data = match as Hex.Hex\n    }\n\n    if (!data) {\n      if (!('data' in cause)) return undefined\n      if (cause.data instanceof BaseError) return getAbiError(cause.data)\n      if (typeof cause.data !== 'string') return undefined\n      if (cause.data === '0x') return undefined\n      data = cause.data as Hex.Hex\n    }\n\n    try {\n      if (data === '0xd0d5039b') return AbiError.from('error Unauthorized()')\n      return AbiError.fromAbi(\n        [...IthacaAccount.abi, AbiError.from('error CallError()')],\n        data,\n      )\n    } catch {\n      return undefined\n    }\n  }\n  const error = getExecuteError_viem(e as BaseError, {\n    calls: (calls ?? []) as any,\n  })\n  const abiError = getAbiError(error)\n  if (error === e && !abiError) return\n  throw new ExecutionError(Object.assign(error, { abiError }))\n}\n\nexport declare namespace parseExecutionError {\n  export type ErrorType = ExecutionError | Errors.GlobalErrorType\n}\n\n/** Thrown when the execution fails. */\nexport class ExecutionError extends Errors.BaseError<BaseError> {\n  override readonly name = 'AccountContract.ExecutionError'\n\n  abiError?: AbiError.AbiError | undefined\n\n  constructor(cause: BaseError & { abiError?: AbiError.AbiError | undefined }) {\n    super('An error occurred while executing calls.', {\n      cause,\n      metaMessages: [cause.abiError && 'Reason: ' + cause.abiError.name].filter(\n        Boolean,\n      ),\n    })\n\n    this.abiError = cause.abiError\n  }\n}\n\nexport type Decorator<\n  account extends Account.Account | undefined = Account.Account | undefined,\n> = {\n  /**\n   * Executes a set of calls on a delegated account.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - Client.\n   * @param parameters - Execution parameters.\n   * @returns Transaction hash.\n   */\n  execute: <const calls extends readonly unknown[]>(\n    parameters: execute.Parameters<calls, account>,\n  ) => Promise<execute.ReturnType>\n  /**\n   * Returns the EIP-712 domain for a delegated account. Used for the execution\n   * signing payload.\n   *\n   * @param client - Client.\n   * @param parameters - Parameters.\n   * @returns EIP-712 domain.\n   */\n  getEip712Domain: (\n    parameters: getEip712Domain.Parameters<account>,\n  ) => Promise<TypedData.Domain>\n  /**\n   * Returns the key at the given index.\n   *\n   * @param client - Client.\n   * @param parameters - Parameters.\n   * @returns Key.\n   */\n  keyAt: (parameters: keyAt.Parameters<account>) => Promise<Key.Key>\n  /**\n   * Prepares the payloads to sign over and fills the request to execute a set of calls.\n   *\n   * @param client - Client.\n   * @param parameters - Parameters.\n   * @returns Prepared properties.\n   */\n  prepareExecute: <calls extends readonly unknown[] = readonly unknown[]>(\n    parameters: prepareExecute.Parameters<calls, account>,\n  ) => Promise<prepareExecute.ReturnType<calls>>\n}\n\nexport function decorator<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(client: Client<transport, chain, account>): Decorator<account> {\n  return {\n    execute: (parameters) => execute(client, parameters),\n    getEip712Domain: (parameters) => getEip712Domain(client, parameters),\n    keyAt: (parameters) => keyAt(client, parameters),\n    prepareExecute: (parameters) => prepareExecute(client, parameters),\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////\n// Internal\n///////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nasync function getExecuteDigest<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getExecuteDigest.Parameters<calls>,\n): Promise<{ digest: Hex.Hex; typedData: TypedData.Definition }> {\n  const { account = client.account, delegation, nonce } = parameters\n\n  const account_ = account ? Account.from(account) : undefined\n  if (!account_) throw new Error('account is required.')\n\n  // Structure calls into EIP-7821 execution format.\n  const calls = parameters.calls.map((call: any) => ({\n    data: call.data ?? '0x',\n    to: call.to === Call.selfAddress ? account_.address : call.to,\n    value: call.value ?? 0n,\n  }))\n\n  const address = await (async () => {\n    if (!delegation) return account_.address\n    const { data } = await call(client, {\n      data: encodeFunctionData({\n        abi: parseAbi(['function implementation() view returns (address)']),\n        functionName: 'implementation',\n      }),\n      to: delegation!,\n    } as never).catch(() => ({ data: undefined }))\n    if (!data) throw new Error('delegation address not found.')\n    return Hex.slice(data, 12)\n  })()\n\n  const domain = await getEip712Domain(client, { account: address })\n\n  const multichain = nonce & 1n\n\n  if (!client.chain) throw new Error('chain is required.')\n\n  const typedData = {\n    domain: {\n      chainId: client.chain.id,\n      name: domain.name,\n      verifyingContract: account_.address,\n      version: domain.version,\n    },\n    message: {\n      calls,\n      multichain: Boolean(multichain),\n      nonce,\n    },\n    primaryType: 'Execute',\n    types: {\n      Call: [\n        { name: 'to', type: 'address' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n      ],\n      Execute: [\n        { name: 'multichain', type: 'bool' },\n        { name: 'calls', type: 'Call[]' },\n        { name: 'nonce', type: 'uint256' },\n      ],\n    },\n  } as const\n\n  return {\n    digest: TypedData.getSignPayload(typedData),\n    typedData,\n  }\n}\n\nexport declare namespace getExecuteDigest {\n  export type Parameters<\n    calls extends readonly unknown[] = readonly unknown[],\n  > = {\n    /**\n     * The delegated account to execute the calls on.\n     */\n    account: Account.Account\n    /**\n     * Contract address to delegate to.\n     */\n    delegation?: Address.Address | undefined\n    /**\n     * Calls to execute.\n     */\n    calls: calls\n    /**\n     * Nonce to use for execution that will be invalidated by the delegated account.\n     */\n    nonce: bigint\n    /**\n     * Nonce salt.\n     */\n    nonceSalt?: bigint | undefined\n  }\n}\n","export function toAbsolute(url: string | undefined) {\n  if (!url) return undefined\n  if (url.startsWith('/')) return `${window.location.origin}${url}`\n  return url\n}\n","import type { Abi, Narrow } from 'abitype'\nimport * as AbiError from 'ox/AbiError'\n\nimport type { BaseError } from '../../../errors/base.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { decodeErrorResult } from '../../../utils/abi/decodeErrorResult.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../../utils/errors/getContractError.js'\nimport {\n  FunctionSelectorNotRecognizedError,\n  type FunctionSelectorNotRecognizedErrorType,\n} from '../errors.js'\n\nexport type GetExecuteErrorParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Calls to execute. */\n  calls: Calls<Narrow<calls>>\n}\n\nexport type GetExecuteErrorReturnType =\n  | FunctionSelectorNotRecognizedErrorType\n  | GetContractErrorReturnType\n\nexport function getExecuteError<const calls extends readonly unknown[]>(\n  e: BaseError,\n  parameters: GetExecuteErrorParameters<calls>,\n): GetExecuteErrorReturnType {\n  const error = e.walk((e) => 'data' in (e as Error)) as\n    | (BaseError & { data?: Hex | undefined })\n    | undefined\n\n  if (!error?.data) return e as never\n  if (\n    error.data ===\n    AbiError.getSelector(AbiError.from('error FnSelectorNotRecognized()'))\n  )\n    return new FunctionSelectorNotRecognizedError() as never\n\n  let matched: Call | null = null\n  for (const c of parameters.calls) {\n    const call = c as Call\n    if (!call.abi) continue\n    try {\n      const matches = Boolean(\n        decodeErrorResult({\n          abi: call.abi,\n          data: error.data!,\n        }),\n      )\n      if (!matches) continue\n      matched = call\n    } catch {}\n  }\n  if (matched)\n    return getContractError(error as BaseError, {\n      abi: matched.abi as Abi,\n      address: matched.to,\n      args: matched.args,\n      functionName: matched.functionName,\n    })\n\n  return e as never\n}\n","import { secp256r1 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Entropy from './internal/entropy.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** Re-export of noble/curves P256 utilities. */\nexport const noble = secp256r1\n\n/**\n * Creates a new P256 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey: PublicKey.PublicKey\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256r1.ProjectivePoint.fromPrivateKey(\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = P256.createKeyPair()\n * const { publicKey: publicKeyB } = P256.createKeyPair()\n *\n * const sharedSecret = P256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const point = secp256r1.ProjectivePoint.fromHex(\n    PublicKey.toHex(publicKey).slice(2),\n  )\n  const privateKeyHex =\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2)\n  const sharedPoint = point.multiply(\n    secp256r1.utils.normPrivateKeyToScalar(privateKeyHex),\n  )\n  const sharedSecret = sharedPoint.toRawBytes(true) // compressed format\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256r1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256r1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const payload_ =\n    payload instanceof Uint8Array ? Hex.fromBytes(payload) : payload\n  const point = signature_.recoverPublicKey(payload_.substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256r1.sign(\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    privateKey instanceof Uint8Array ? privateKey : Bytes.fromHex(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     * If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const { privateKey, publicKey } = P256.createKeyPair()\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { hash, payload, publicKey, signature } = options\n  return secp256r1.verify(\n    signature,\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    PublicKey.toHex(publicKey).substring(2),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<boolean>\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","import { BaseError } from '../../errors/base.js'\n\nexport type ExecuteUnsupportedErrorType = ExecuteUnsupportedError & {\n  name: 'ExecuteUnsupportedError'\n}\nexport class ExecuteUnsupportedError extends BaseError {\n  constructor() {\n    super('ERC-7821 execution is not supported.', {\n      name: 'ExecuteUnsupportedError',\n    })\n  }\n}\n\nexport type FunctionSelectorNotRecognizedErrorType =\n  FunctionSelectorNotRecognizedError & {\n    name: 'FunctionSelectorNotRecognizedError'\n  }\nexport class FunctionSelectorNotRecognizedError extends BaseError {\n  constructor() {\n    super('Function is not recognized.', {\n      metaMessages: [\n        'This could be due to any of the following:',\n        '  - The contract does not have the function,',\n        '  - The address is not a contract.',\n      ],\n      name: 'FunctionSelectorNotRecognizedError',\n    })\n  }\n}\n","import type { Errors, RpcRequest } from '../index.js'\nimport type {\n  Compute,\n  IsNarrowable,\n  IsNever,\n  OneOf,\n  UnionPartialBy,\n} from './internal/types.js'\n\n/** A JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcResponse<\n  result = unknown,\n  error extends ErrorObject = ErrorObject,\n> = Compute<\n  {\n    id: number\n    jsonrpc: '2.0'\n  } & OneOf<{ result: result } | { error: error }>\n>\n\n/** JSON-RPC error object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#error_object). */\nexport type ErrorObject = {\n  code: number\n  message: string\n  data?: unknown | undefined\n}\n\n/**\n * A type-safe interface to instantiate a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object).\n *\n * @example\n * ### Instantiating a Response Object\n *\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const response = RpcResponse.from({\n *   id: 0,\n *   jsonrpc: '2.0',\n *   result: '0x69420',\n * })\n * ```\n *\n * @example\n * ### Type-safe Instantiation\n *\n * If you have a JSON-RPC request object, you can use it to strongly-type the response. If a `request` is provided,\n * then the `id` and `jsonrpc` properties will be overridden with the values from the request.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const request = RpcRequest.from({ id: 0, method: 'eth_blockNumber' })\n *\n * const response = RpcResponse.from(\n *   { result: '0x69420' },\n *   { request },\n * )\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function from<\n  request extends RpcRequest.RpcRequest | undefined = undefined,\n  const response =\n    | (request extends RpcRequest.RpcRequest\n        ? request['_returnType']\n        : RpcResponse)\n    | unknown,\n>(\n  response: from.Response<request, response>,\n  options?: from.Options<request>,\n): Compute<from.ReturnType<response>>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function from(response: RpcResponse, options: any = {}): RpcResponse {\n  const { request } = options\n  return {\n    ...response,\n    id: response.id ?? request?.id,\n    jsonrpc: response.jsonrpc ?? request.jsonrpc,\n  }\n}\n\nexport declare namespace from {\n  type Response<\n    request extends RpcRequest.RpcRequest | undefined = undefined,\n    response = unknown,\n  > = response &\n    (request extends RpcRequest.RpcRequest\n      ? UnionPartialBy<RpcResponse<request['_returnType']>, 'id' | 'jsonrpc'>\n      : RpcResponse)\n\n  type Options<\n    request extends RpcRequest.RpcRequest | undefined =\n      | RpcRequest.RpcRequest\n      | undefined,\n  > = {\n    request?: request | RpcRequest.RpcRequest | undefined\n  }\n\n  type ReturnType<response> = IsNarrowable<response, RpcResponse> extends true\n    ? RpcResponse\n    : response & Readonly<{ id: number; jsonrpc: '2.0' }>\n}\n\n/**\n * A type-safe interface to parse a JSON-RPC response object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#response_object), and extract the result.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Create a request store.\n * const store = RpcRequest.createStore()\n *\n * // 2. Get a request object.\n * const request = store.prepare({\n *   method: 'eth_getBlockByNumber',\n *   params: ['0x1', false],\n * })\n *\n * // 3. Send the JSON-RPC request via HTTP.\n * const block = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 4. Parse the JSON-RPC response into a type-safe result. // [!code focus]\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code focus]\n *\n * block // [!code focus]\n * // ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::tip\n *\n * If you don't need the return type, you can omit the options entirely.\n *\n * ```ts twoslash\n * // @noErrors\n * import { RpcResponse } from 'ox'\n *\n * const block = await fetch('https://1.rpc.thirdweb.com', {})\n *  .then((response) => response.json())\n *  .then((response) => RpcResponse.parse(response, { request })) // [!code --]\n *  .then(RpcResponse.parse) // [!code ++]\n * ```\n * :::\n *\n * @example\n * ### Raw Mode\n *\n * If `raw` is `true`, the response will be returned as an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n *\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n *\n * const response = RpcResponse.parse({}, {\n *   request,\n *   raw: true, // [!code hl]\n * })\n *\n * response.result\n * //       ^?\n *\n *\n * response.error\n * //       ^?\n *\n *\n * ```\n *\n * @param response - Opaque JSON-RPC response object.\n * @param options - Parsing options.\n * @returns Typed JSON-RPC result, or response object (if `raw` is `true`).\n */\nexport function parse<\n  const response extends RpcResponse | unknown,\n  returnType,\n  raw extends boolean = false,\n>(\n  response: response,\n  options: parse.Options<returnType, raw> = {},\n): parse.ReturnType<\n  unknown extends response\n    ? returnType\n    : response extends RpcResponse\n      ? response extends { result: infer result }\n        ? result\n        : never\n      : returnType,\n  raw\n> {\n  const { raw = false } = options\n  const response_ = response as RpcResponse\n  if (raw) return response as never\n  if (response_.error) throw parseError(response_.error)\n  return response_.result as never\n}\n\nexport declare namespace parse {\n  type Options<returnType, raw extends boolean = false> = {\n    /**\n     * JSON-RPC Method that was used to make the request. Used for typing the response.\n     */\n    request?:\n      | {\n          _returnType: returnType\n        }\n      | RpcRequest.RpcRequest\n      | undefined\n    /**\n     * Enables raw mode  responses will return an object with `result` and `error` properties instead of returning the `result` directly and throwing errors.\n     *\n     * - `true`: a JSON-RPC response object will be returned with `result` and `error` properties.\n     * - `false`: the JSON-RPC response object's `result` property will be returned directly, and JSON-RPC Errors will be thrown.\n     *\n     * @default false\n     */\n    raw?: raw | boolean | undefined\n  }\n\n  type ReturnType<returnType, raw extends boolean = false> = Compute<\n    raw extends true ? RpcResponse<returnType> : returnType\n  >\n\n  type ErrorType =\n    | ParseError\n    | InvalidInputError\n    | ResourceNotFoundError\n    | ResourceUnavailableError\n    | TransactionRejectedError\n    | MethodNotSupportedError\n    | LimitExceededError\n    | VersionNotSupportedError\n    | InvalidRequestError\n    | MethodNotFoundError\n    | InvalidParamsError\n    | InternalError\n    | BaseErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an error into a RPC Error instance.\n *\n * @example\n * ```ts twoslash\n * import { RpcResponse } from 'ox'\n *\n * const error = RpcResponse.parseError({ code: -32000, message: 'unsupported method' })\n *\n * error\n * // ^?\n *\n * ```\n *\n * @param error - Error.\n * @returns RPC Error instance.\n */\nexport function parseError<const error extends Error | ErrorObject | unknown>(\n  error: error | Error | ErrorObject,\n): parseError.ReturnType<error> {\n  const error_ = error as Error | ErrorObject\n\n  if (error_ instanceof Error && !('code' in error_))\n    return new InternalError({\n      cause: error_,\n      data: error_,\n      message: error_.message,\n      stack: error_.stack,\n    }) as never\n\n  const { code } = error_\n  if (code === InternalError.code)\n    return new InternalError(error_ as never) as never\n  if (code === InvalidInputError.code)\n    return new InvalidInputError(error_) as never\n  if (code === InvalidParamsError.code)\n    return new InvalidParamsError(error_) as never\n  if (code === InvalidRequestError.code)\n    return new InvalidRequestError(error_) as never\n  if (code === LimitExceededError.code)\n    return new LimitExceededError(error_) as never\n  if (code === MethodNotFoundError.code)\n    return new MethodNotFoundError(error_) as never\n  if (code === MethodNotSupportedError.code)\n    return new MethodNotSupportedError(error_) as never\n  if (code === ParseError.code) return new ParseError(error_) as never\n  if (code === ResourceNotFoundError.code)\n    return new ResourceNotFoundError(error_) as never\n  if (code === ResourceUnavailableError.code)\n    return new ResourceUnavailableError(error_) as never\n  if (code === TransactionRejectedError.code)\n    return new TransactionRejectedError(error_) as never\n  if (code === VersionNotSupportedError.code)\n    return new VersionNotSupportedError(error_) as never\n  return new InternalError({\n    cause: error_ instanceof Error ? error_ : undefined,\n    data: error_,\n    message: error_.message,\n    stack: error_ instanceof Error ? error_.stack : undefined,\n  }) as never\n}\n\nexport declare namespace parseError {\n  type ReturnType<\n    errorObject extends ErrorObject | unknown,\n    //\n    error = errorObject extends ErrorObject\n      ?\n          | (errorObject['code'] extends InternalError['code']\n              ? InternalError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InternalError\n              : never)\n          | (errorObject['code'] extends InvalidInputError['code']\n              ? InvalidInputError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidInputError\n              : never)\n          | (errorObject['code'] extends ResourceNotFoundError['code']\n              ? ResourceNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceNotFoundError\n              : never)\n          | (errorObject['code'] extends ResourceUnavailableError['code']\n              ? ResourceUnavailableError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ResourceUnavailableError\n              : never)\n          | (errorObject['code'] extends TransactionRejectedError['code']\n              ? TransactionRejectedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? TransactionRejectedError\n              : never)\n          | (errorObject['code'] extends ParseError['code']\n              ? ParseError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? ParseError\n              : never)\n          | (errorObject['code'] extends MethodNotSupportedError['code']\n              ? MethodNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotSupportedError\n              : never)\n          | (errorObject['code'] extends LimitExceededError['code']\n              ? LimitExceededError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? LimitExceededError\n              : never)\n          | (errorObject['code'] extends VersionNotSupportedError['code']\n              ? VersionNotSupportedError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? VersionNotSupportedError\n              : never)\n          | (errorObject['code'] extends InvalidRequestError['code']\n              ? InvalidRequestError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidRequestError\n              : never)\n          | (errorObject['code'] extends MethodNotFoundError['code']\n              ? MethodNotFoundError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? MethodNotFoundError\n              : never)\n          | (errorObject['code'] extends InvalidParamsError['code']\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? InvalidParamsError\n              : never)\n          | (IsNarrowable<errorObject['code'], number> extends false\n              ? BaseError\n              : never)\n      : parseError.ReturnType<ErrorObject>,\n  > = IsNever<error> extends true ? BaseError : error\n}\n\nexport type BaseErrorType = BaseError & { name: 'BaseError' }\n\n/** Thrown when a JSON-RPC error has occurred. */\nexport class BaseError extends Error {\n  override name = 'RpcResponse.BaseError'\n\n  override readonly cause: Error | undefined\n  override readonly stack: string\n  readonly code: number\n  readonly data?: unknown | undefined\n\n  constructor(\n    errorObject: ErrorObject & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    },\n  ) {\n    const { cause, code, message, data, stack } = errorObject\n\n    super(message, { cause })\n\n    this.cause = cause\n    this.code = code\n    this.data = data\n    this.stack = stack ?? ''\n  }\n}\n\n/** Thrown when the input to a JSON-RPC method is invalid. */\nexport class InvalidInputError extends BaseError {\n  static readonly code = -32000\n  override readonly code = -32000\n  override readonly name = 'RpcResponse.InvalidInputError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidInputError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Missing or invalid parameters.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is not found. */\nexport class ResourceNotFoundError extends BaseError {\n  static readonly code = -32001\n  override readonly code = -32001\n  override readonly name = 'RpcResponse.ResourceNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not found.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC resource is unavailable. */\nexport class ResourceUnavailableError extends BaseError {\n  static readonly code = -32002\n  override readonly code = -32002\n  override readonly name = 'RpcResponse.ResourceUnavailableError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ResourceUnavailableError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Requested resource not available.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC transaction is rejected. */\nexport class TransactionRejectedError extends BaseError {\n  static readonly code = -32003\n  override readonly code = -32003\n  override readonly name = 'RpcResponse.TransactionRejectedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: TransactionRejectedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Transaction creation failed.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not supported. */\nexport class MethodNotSupportedError extends BaseError {\n  static readonly code = -32004\n  override readonly code = -32004\n  override readonly name = 'RpcResponse.MethodNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method is not implemented.',\n    })\n  }\n}\n\n/** Thrown when a rate-limit is exceeded. */\nexport class LimitExceededError extends BaseError {\n  static readonly code = -32005\n  override readonly code = -32005\n  override readonly name = 'RpcResponse.LimitExceededError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: LimitExceededError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Rate limit exceeded.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC version is not supported. */\nexport class VersionNotSupportedError extends BaseError {\n  static readonly code = -32006\n  override readonly code = -32006\n  override readonly name = 'RpcResponse.VersionNotSupportedError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: VersionNotSupportedError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'JSON-RPC version not supported.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC request is invalid. */\nexport class InvalidRequestError extends BaseError {\n  static readonly code = -32600\n  override readonly code = -32600\n  override readonly name = 'RpcResponse.InvalidRequestError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidRequestError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Input is not a valid JSON-RPC request.',\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC method is not found. */\nexport class MethodNotFoundError extends BaseError {\n  static readonly code = -32601\n  override readonly code = -32601\n  override readonly name = 'RpcResponse.MethodNotFoundError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: MethodNotFoundError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Method does not exist.',\n    })\n  }\n}\n\n/** Thrown when the parameters to a JSON-RPC method are invalid. */\nexport class InvalidParamsError extends BaseError {\n  static readonly code = -32602\n  override readonly code = -32602\n  override readonly name = 'RpcResponse.InvalidParamsError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: InvalidParamsError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Invalid method parameters.',\n    })\n  }\n}\n\n/** Thrown when an internal JSON-RPC error has occurred. */\nexport class InternalError extends BaseError {\n  static readonly code = -32603\n  override readonly code = -32603\n  override readonly name = 'RpcResponse.InternalError'\n\n  constructor(\n    parameters: Partial<Omit<ErrorObject, 'code'>> & {\n      cause?: Error | undefined\n      stack?: string | undefined\n    } = {},\n  ) {\n    super({\n      cause: parameters.cause,\n      code: InternalError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Internal JSON-RPC error.',\n      stack: parameters.stack,\n    })\n  }\n}\n\n/** Thrown when a JSON-RPC response is invalid. */\nexport class ParseError extends BaseError {\n  static readonly code = -32700\n  override readonly code = -32700\n  override readonly name = 'RpcResponse.ParseError'\n\n  constructor(parameters: Partial<Omit<ErrorObject, 'code'>> = {}) {\n    super({\n      code: ParseError.code,\n      data: parameters.data,\n      message: parameters.message ?? 'Failed to parse JSON-RPC response.',\n    })\n  }\n}\n","import type * as Address from 'ox/Address'\nimport * as SignatureErc8010 from 'ox/erc8010/SignatureErc8010'\nimport type * as Hex from 'ox/Hex'\nimport type { Client } from 'viem'\nimport * as RelayActions from '../../viem/RelayActions.js'\n\n/**\n * Wraps a signature in ERC-8010 format to enable pre-delegated signature verification.\n *\n * @param client - The client to use.\n * @param parameters - The parameters for the wrap function.\n * @returns The wrapped signature.\n */\nexport async function wrap(client: Client, parameters: wrap.Parameters) {\n  const { address } = parameters\n\n  // Obtain the account's authorization and init data.\n  const { authorization, data, to } = await RelayActions.getAuthorization(\n    client,\n    {\n      address,\n    },\n  )\n\n  // Wrap the signature.\n  return SignatureErc8010.wrap({\n    authorization: {\n      ...authorization,\n      nonce: BigInt(authorization.nonce),\n      r: BigInt(authorization.r),\n      s: BigInt(authorization.s),\n    },\n    data,\n    signature: parameters.signature,\n    to,\n  })\n}\n\nexport namespace wrap {\n  export type Parameters = {\n    address: Address.Address\n    signature: Hex.Hex\n  }\n}\n","import type { Narrow } from 'abitype'\n\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport { abi, executionMode } from '../constants.js'\nimport { type EncodeCallsErrorType, encodeCalls } from './encodeCalls.js'\n\nexport type EncodeExecuteDataParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Calls to execute. */\n  calls: Calls<Narrow<calls>>\n  /** Additional data to include for execution. */\n  opData?: Hex | undefined\n}\n\nexport type EncodeExecuteDataReturnType = Hex\n\nexport type EncodeExecuteDataErrorType =\n  | EncodeCallsErrorType\n  | EncodeFunctionDataErrorType\n  | ErrorType\n\nexport function encodeExecuteData<const calls extends readonly unknown[]>(\n  parameters: EncodeExecuteDataParameters<calls>,\n): EncodeExecuteDataReturnType {\n  const { calls, opData } = parameters\n\n  const encodedCalls = encodeCalls(calls, opData)\n  const mode = opData ? executionMode.opData : executionMode.default\n\n  return encodeFunctionData({\n    abi,\n    functionName: 'execute',\n    args: [mode, encodedCalls],\n  })\n}\n","export function isReactNative() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative')\n    return true\n\n  if (\n    typeof window !== 'undefined' &&\n    Object.hasOwn(window, 'ReactNativeWebView')\n  )\n    return true\n\n  if (\n    typeof globalThis !== 'undefined' &&\n    Object.hasOwn(globalThis, 'HermesEngine')\n  )\n    return true\n\n  return false\n}\n","import type * as Address from 'ox/Address'\nimport * as Hex from 'ox/Hex'\nimport * as Provider from 'ox/Provider'\nimport * as RpcRequest from 'ox/RpcRequest'\nimport * as RpcResponse from 'ox/RpcResponse'\nimport * as RpcSchema from 'ox/RpcSchema'\nimport { waitForCallsStatus } from 'viem/actions'\nimport * as z from 'zod/mini'\nimport type { ThemeFragment } from '../../../theme/Theme.js'\nimport * as Account from '../../../viem/Account.js'\nimport * as Key from '../../../viem/Key.js'\nimport * as Dialog from '../../Dialog.js'\nimport type { QueuedRequest } from '../../Porto.js'\nimport * as RpcSchema_porto from '../../RpcSchema.js'\nimport type { Storage } from '../../Storage.js'\nimport * as Mode from '../mode.js'\nimport * as Permissions from '../permissions.js'\nimport * as PermissionsRequest from '../permissionsRequest.js'\nimport type * as Porto from '../porto.js'\nimport type * as Token from '../schema/token.js'\nimport * as Siwe from '../siwe.js'\nimport * as U from '../utils.js'\nimport { relay } from './relay.js'\n\nexport function dialog(parameters: dialog.Parameters = {}) {\n  const {\n    fallback = relay(),\n    host = Dialog.hostUrls.prod,\n    renderer = Dialog.iframe(),\n    theme,\n    themeController,\n  } = parameters\n\n  const listeners = new Set<(requestQueue: readonly QueuedRequest[]) => void>()\n  const requestStore = RpcRequest.createStore()\n\n  // Function to instantiate a provider for the dialog. This\n  // will be used to queue up requests for the dialog and\n  // handle responses.\n  function getProvider(store: Porto.Internal['store']) {\n    return Provider.from(\n      {\n        async request(r) {\n          const request = requestStore.prepare(r as any)\n\n          // When we receive a request, we need to add it to the queue.\n          store.setState((x) => {\n            const account = x.accounts[0]\n            const adminKey = account?.keys?.find(\n              (key) => key.role === 'admin' && key.type === 'webauthn-p256',\n            )\n            return {\n              ...x,\n              requestQueue: [\n                ...x.requestQueue,\n                {\n                  account: account\n                    ? {\n                        address: account.address,\n                        key: adminKey\n                          ? {\n                              credentialId: (adminKey as any)?.credentialId,\n                              publicKey: adminKey.publicKey,\n                            }\n                          : undefined,\n                      }\n                    : undefined,\n                  request,\n                  status: 'pending',\n                },\n              ],\n            }\n          })\n\n          // We need to wait for the request to be resolved.\n          return new Promise((resolve, reject) => {\n            const listener = (requestQueue: readonly QueuedRequest[]) => {\n              // Find the request in the queue based off its JSON-RPC identifier.\n              const queued = requestQueue.find(\n                (x) => x.request.id === request.id,\n              )\n\n              // If the request is not found and the queue is empty, reject the request\n              // as it will never be resolved (likely cancelled or dialog closed).\n              if (!queued && requestQueue.length === 0) {\n                listeners.delete(listener)\n                reject(new Provider.UserRejectedRequestError())\n                return\n              }\n\n              // If request not found but queue has other requests, wait for next update.\n              if (!queued) return\n\n              // If request found but not yet resolved, wait for next update.\n              if (queued.status !== 'success' && queued.status !== 'error')\n                return\n\n              // We have a response, we can unsubscribe from the listener.\n              listeners.delete(listener)\n\n              // If the request was successful, resolve with the result.\n              if (queued.status === 'success') resolve(queued.result as any)\n              // Otherwise, reject with EIP-1193 Provider error.\n              else reject(Provider.parseError(queued.error))\n\n              // Remove the request from the queue.\n              store.setState((x) => ({\n                ...x,\n                requestQueue: x.requestQueue.filter(\n                  (x) => x.request.id !== request.id,\n                ),\n              }))\n            }\n\n            listeners.add(listener)\n          })\n        },\n      },\n      { schema: RpcSchema.from<RpcSchema_porto.Schema>() },\n    )\n  }\n\n  return Mode.from({\n    actions: {\n      async addFunds(parameters) {\n        const { internal } = parameters\n        const { request, store } = internal\n\n        if (request.method !== 'wallet_addFunds')\n          throw new Error('Cannot add funds for method: ' + request.method)\n\n        const provider = getProvider(store)\n        return await provider.request(request)\n      },\n\n      async createAccount(parameters) {\n        const { internal } = parameters\n        const { client, config, request, store } = internal\n        const { storage } = config\n\n        const provider = getProvider(store)\n\n        const account = await (async () => {\n          if (request.method === 'wallet_connect') {\n            // Extract the capabilities from the request.\n            const [{ capabilities, chainIds }] = request._decoded.params ?? [{}]\n\n            const authUrl = getAuthUrl(\n              capabilities?.signInWithEthereum?.authUrl ?? config.authUrl,\n              { storage },\n            )\n\n            const signInWithEthereum =\n              request.params?.[0]?.capabilities?.signInWithEthereum\n\n            // Parse the authorize key into a structured key.\n            const key = await PermissionsRequest.toKey(\n              capabilities?.grantPermissions,\n              {\n                chainId: client.chain.id,\n              },\n            )\n\n            // Convert the key into a permission.\n            const permissionsRequest = key\n              ? z.encode(\n                  PermissionsRequest.Schema,\n                  PermissionsRequest.fromKey(key),\n                )\n              : undefined\n\n            // Send a request off to the dialog to create an account.\n            const { accounts } = await provider.request({\n              ...request,\n              params: [\n                {\n                  capabilities: {\n                    ...request.params?.[0]?.capabilities,\n                    grantPermissions: permissionsRequest,\n                    signInWithEthereum:\n                      authUrl || signInWithEthereum\n                        ? {\n                            ...signInWithEthereum,\n                            authUrl: authUrl!,\n                          }\n                        : undefined,\n                  },\n                  chainIds: chainIds?.map((chainId) => Hex.fromNumber(chainId)),\n                },\n              ],\n            })\n\n            const [account] = accounts\n            if (!account) throw new Error('no account found.')\n\n            // Build keys to assign onto the account.\n            const adminKeys = account.capabilities?.admins\n              ?.map((admin) => Key.from(admin, { chainId: client.chain.id }))\n              .filter(Boolean) as readonly Key.Key[] | undefined\n\n            const sessionKeys = account.capabilities?.permissions\n              ?.map((permission) => {\n                try {\n                  const key_permission = Permissions.toKey(\n                    z.decode(Permissions.Schema, permission),\n                  )\n                  if (key_permission.id === key?.id)\n                    return {\n                      ...key_permission,\n                      ...key,\n                      permissions: key_permission.permissions,\n                    }\n                  return key_permission\n                } catch {\n                  return undefined\n                }\n              })\n              .filter(Boolean) as readonly Key.Key[] | undefined\n\n            const signInWithEthereum_response = await (async () => {\n              if (!account.capabilities?.signInWithEthereum) return\n              const { message, signature } =\n                account.capabilities.signInWithEthereum\n\n              if (!authUrl)\n                return {\n                  message,\n                  signature,\n                }\n\n              const { token } = await Siwe.authenticate({\n                address: account.address,\n                authUrl,\n                message,\n                publicKey: account.capabilities?.admins?.[0]?.publicKey,\n                signature,\n              })\n              return {\n                message,\n                signature,\n                token,\n              }\n            })()\n\n            return {\n              ...Account.from({\n                address: account.address,\n                keys: [...(adminKeys ?? []), ...(sessionKeys ?? [])],\n              }),\n              signInWithEthereum: signInWithEthereum_response,\n            }\n          }\n\n          throw new Error(\n            `Account creation not supported on method: ${request.method}`,\n          )\n        })()\n\n        return {\n          account,\n        }\n      },\n\n      async disconnect(parameters) {\n        const { internal } = parameters\n        const { config } = internal\n        const { storage } = config\n\n        const authUrl_storage =\n          (await storage.getItem<Siwe.AuthUrl | undefined>('porto.authUrl')) ||\n          undefined\n        const authUrl = getAuthUrl(config.authUrl ?? authUrl_storage, {\n          storage,\n        })\n\n        if (authUrl)\n          await fetch(authUrl.logout, {\n            credentials: 'include',\n            method: 'POST',\n          }).catch(() => {})\n      },\n\n      async getAccountVersion(parameters) {\n        const { internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_getAccountVersion')\n          throw new Error('Cannot get version for method: ' + request.method)\n\n        if (!renderer.supportsHeadless)\n          return fallback.actions.getAccountVersion(parameters)\n\n        const provider = getProvider(store)\n        const result = await provider.request(request)\n        return result\n      },\n\n      async getAssets(parameters) {\n        const { internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_getAssets')\n          throw new Error('Cannot get assets for method: ' + request.method)\n\n        if (!renderer.supportsHeadless)\n          return fallback.actions.getAssets(parameters)\n\n        const provider = getProvider(store)\n        const result = await provider.request(request)\n        return z.decode(RpcSchema_porto.wallet_getAssets.Response, result)\n      },\n\n      async getCallsStatus(parameters) {\n        const { internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_getCallsStatus')\n          throw new Error('Cannot get status for method: ' + request.method)\n\n        if (!renderer.supportsHeadless)\n          return fallback.actions.getCallsStatus(parameters)\n\n        const provider = getProvider(store)\n        const result = await provider.request(request)\n        return result\n      },\n\n      async getCapabilities(parameters) {\n        const { internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_getCapabilities')\n          throw new Error(\n            'Cannot get capabilities for method: ' + request.method,\n          )\n\n        if (!renderer.supportsHeadless)\n          return fallback.actions.getCapabilities(parameters)\n\n        const provider = getProvider(store)\n        const result = await provider.request(request)\n        return result\n      },\n\n      async getKeys(parameters) {\n        const { account, chainIds, internal } = parameters\n        const { store } = internal\n\n        const keys = await (async () => {\n          if (!renderer.supportsHeadless)\n            return fallback.actions.getKeys(parameters)\n\n          const provider = getProvider(store)\n          const result = await provider.request({\n            method: 'wallet_getKeys',\n            params: [\n              z.encode(RpcSchema_porto.wallet_getKeys.Parameters, {\n                address: account.address,\n                chainIds,\n              }),\n            ],\n          })\n\n          return z.decode(RpcSchema_porto.wallet_getKeys.Response, result)\n        })()\n\n        return U.uniqBy(\n          [...keys, ...(account.keys ?? [])],\n          (key) => key.publicKey,\n        )\n      },\n\n      async grantAdmin(parameters) {\n        const { internal } = parameters\n        const { request, store } = internal\n\n        if (request.method !== 'wallet_grantAdmin')\n          throw new Error(\n            'Cannot authorize admin for method: ' + request.method,\n          )\n\n        const [params] = request._decoded.params\n\n        const key = Key.from(params.key)\n        if (!key) throw new Error('no key found.')\n\n        const feeToken = await resolveFeeToken(internal, parameters)\n\n        // Send a request off to the dialog to authorize the admin.\n        const provider = getProvider(store)\n        await provider.request({\n          method: 'wallet_grantAdmin',\n          params: [\n            {\n              ...request.params?.[0],\n              capabilities: {\n                ...request.params?.[0]?.capabilities,\n                feeToken,\n              },\n            },\n          ],\n        })\n\n        return { key }\n      },\n\n      async grantPermissions(parameters) {\n        const { internal } = parameters\n        const { client, request, store } = internal\n\n        if (request.method !== 'wallet_grantPermissions')\n          throw new Error(\n            'Cannot grant permissions for method: ' + request.method,\n          )\n\n        const [{ address, ...permissions }] = request._decoded.params\n\n        // Parse permissions request into a structured key.\n        const key = await PermissionsRequest.toKey(permissions, {\n          chainId: client.chain.id,\n        })\n        if (!key) throw new Error('no key found.')\n\n        const permissionsRequest = z.encode(\n          PermissionsRequest.Schema,\n          PermissionsRequest.fromKey(key),\n        )\n\n        // Send a request off to the dialog to grant the permissions.\n        const provider = getProvider(store)\n        await provider.request({\n          method: 'wallet_grantPermissions',\n          params: [permissionsRequest],\n        })\n\n        return { key }\n      },\n\n      async loadAccounts(parameters) {\n        const { internal } = parameters\n        const { client, config, store } = internal\n        const { storage } = config\n\n        const provider = getProvider(store)\n\n        const request = internal.request as z.input<\n          typeof RpcSchema_porto.wallet_connect.Request\n        > & {\n          _decoded: RpcSchema_porto.wallet_connect.Request\n        }\n\n        if (\n          request.method !== 'wallet_connect' &&\n          request.method !== 'eth_requestAccounts'\n        )\n          throw new Error('Cannot load accounts for method: ' + request.method)\n\n        const accounts = await (async () => {\n          const [params] = request._decoded.params ?? []\n          const { capabilities } = params ?? {}\n\n          const authUrl = getAuthUrl(\n            capabilities?.signInWithEthereum?.authUrl ?? config.authUrl,\n            { storage },\n          )\n\n          const signInWithEthereum =\n            request.params?.[0]?.capabilities?.signInWithEthereum\n\n          // Parse provided (RPC) key into a structured key.\n          const key = await PermissionsRequest.toKey(\n            capabilities?.grantPermissions,\n            {\n              chainId: client.chain.id,\n            },\n          )\n\n          // Convert the key into a permissions request.\n          const permissionsRequest = key\n            ? z.encode(\n                PermissionsRequest.Schema,\n                PermissionsRequest.fromKey(key),\n              )\n            : undefined\n\n          // Send a request to the dialog.\n          const { accounts } = await provider.request({\n            method: 'wallet_connect',\n            params: [\n              {\n                ...request.params?.[0],\n                capabilities: {\n                  ...request.params?.[0]?.capabilities,\n                  grantPermissions: permissionsRequest,\n                  signInWithEthereum:\n                    authUrl || signInWithEthereum\n                      ? {\n                          ...signInWithEthereum,\n                          authUrl: authUrl!,\n                        }\n                      : undefined,\n                },\n              },\n            ],\n          })\n\n          return Promise.all(\n            accounts.map(async (account) => {\n              const adminKeys = account.capabilities?.admins\n                ?.map((key) => Key.from(key))\n                .filter(Boolean) as readonly Key.Key[] | undefined\n              const sessionKeys = account.capabilities?.permissions\n                ?.map((permission) => {\n                  try {\n                    const key_permission = Permissions.toKey(\n                      z.decode(Permissions.Schema, permission),\n                    )\n                    if (key_permission.id === key?.id)\n                      return {\n                        ...key_permission,\n                        ...key,\n                        permissions: key_permission.permissions,\n                      }\n                    return key_permission\n                  } catch {\n                    return undefined\n                  }\n                })\n                .filter(Boolean) as readonly Key.Key[] | undefined\n\n              const signInWithEthereum_response = await (async () => {\n                if (!account.capabilities?.signInWithEthereum) return\n                const { message, signature } =\n                  account.capabilities.signInWithEthereum\n\n                if (!authUrl)\n                  return {\n                    message,\n                    signature,\n                  }\n\n                const { token } = await Siwe.authenticate({\n                  address: account.address,\n                  authUrl,\n                  message,\n                  publicKey: account.capabilities?.admins?.[0]?.publicKey,\n                  signature,\n                })\n                return {\n                  message,\n                  signature,\n                  token,\n                }\n              })()\n\n              return {\n                ...Account.from({\n                  address: account.address,\n                  keys: [...(adminKeys ?? []), ...(sessionKeys ?? [])],\n                }),\n                signInWithEthereum: signInWithEthereum_response,\n              } as const\n            }),\n          )\n        })()\n\n        return {\n          accounts,\n        }\n      },\n\n      async prepareCalls(parameters) {\n        const { account, internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_prepareCalls')\n          throw new Error('Cannot prepare calls for method: ' + request.method)\n\n        if (!renderer.supportsHeadless)\n          return fallback.actions.prepareCalls(parameters)\n\n        const feeToken = await resolveFeeToken(internal, parameters)\n\n        const provider = getProvider(store)\n        const result = z.decode(\n          RpcSchema_porto.wallet_prepareCalls.Response,\n          await provider.request({\n            ...request,\n            params: [\n              {\n                ...request.params?.[0],\n                capabilities: {\n                  ...request.params?.[0]?.capabilities,\n                  feeToken,\n                },\n              },\n            ],\n          }),\n        )\n\n        return {\n          account,\n          chainId: Number(result.chainId),\n          context: result.context as any,\n          digest: result.digest,\n          key: result.key,\n          typedData: result.typedData,\n        }\n      },\n\n      async prepareUpgradeAccount(parameters) {\n        const { internal } = parameters\n        const { client, store, request } = internal\n\n        if (request.method !== 'wallet_prepareUpgradeAccount')\n          throw new Error(\n            'Cannot prepare upgrade for method: ' + request.method,\n          )\n\n        if (!renderer.supportsHeadless)\n          return fallback.actions.prepareUpgradeAccount(parameters)\n\n        // Extract the capabilities from the request.\n        const [{ capabilities }] = request._decoded.params ?? [{}]\n\n        // Parse the authorize key into a structured key.\n        const key = await PermissionsRequest.toKey(\n          capabilities?.grantPermissions,\n          {\n            chainId: client.chain.id,\n          },\n        )\n\n        // Convert the key into a permission.\n        const permissionsRequest = key\n          ? z.encode(PermissionsRequest.Schema, PermissionsRequest.fromKey(key))\n          : undefined\n\n        // Send a request off to the dialog to prepare the upgrade.\n        const provider = getProvider(store)\n        const { context, digests } = await provider.request({\n          ...request,\n          params: [\n            {\n              ...request.params?.[0],\n              capabilities: {\n                ...request.params?.[0]?.capabilities,\n                grantPermissions: permissionsRequest,\n              },\n            },\n          ],\n        })\n\n        type Context = { account: Account.Account }\n        const keys = (context as Context).account.keys?.map((k) => {\n          if (k.id === key?.id) return { ...k, ...key }\n          return k\n        })\n\n        return {\n          context: {\n            ...(context as Context),\n            account: { ...(context as Context).account, keys },\n          },\n          digests,\n        }\n      },\n\n      async revokeAdmin(parameters) {\n        const { account, id, internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_revokeAdmin')\n          throw new Error('Cannot revoke admin for method: ' + request.method)\n\n        const key = account.keys?.find((key) => key.id === id)\n        if (!key) return\n\n        // Cannot revoke the only WebAuthn key left\n        if (\n          key.type === 'webauthn-p256' &&\n          account.keys?.filter((key) => key.type === 'webauthn-p256').length ===\n            1\n        )\n          throw new Error('revoke the only WebAuthn key left.')\n\n        const feeToken = await resolveFeeToken(internal, parameters)\n\n        const provider = getProvider(store)\n        return await provider.request({\n          ...request,\n          params: [\n            {\n              ...request.params?.[0],\n              capabilities: {\n                ...request.params?.[0]?.capabilities,\n                feeToken,\n              },\n            },\n          ],\n        })\n      },\n\n      async revokePermissions(parameters) {\n        const { account, id, internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_revokePermissions')\n          throw new Error(\n            'Cannot revoke permissions for method: ' + request.method,\n          )\n\n        const key = account.keys?.find((key) => key.id === id)\n        if (!key) return\n\n        // We shouldn't be able to revoke admins.\n        if (key.role === 'admin') throw new Error('cannot revoke permissions.')\n\n        const provider = getProvider(store)\n        return await provider.request(request)\n      },\n\n      async sendCalls(parameters) {\n        const {\n          account,\n          asTxHash,\n          calls,\n          chainId,\n          internal,\n          merchantUrl,\n          requiredFunds,\n        } = parameters\n        const { client, store, request } = internal\n\n        const provider = getProvider(store)\n\n        const feeToken = await resolveFeeToken(internal, parameters)\n\n        // Try and extract an authorized key to sign the calls with.\n        const key = await Mode.getAuthorizedExecuteKey({\n          account,\n          calls,\n          permissionsId: parameters.permissionsId,\n        })\n\n        // If a session key is found, try execute the calls with it\n        // without sending a request to the dialog. If the key does not\n        // have permission to execute the calls, fall back to the dialog.\n        if (key && key.role === 'session') {\n          if (!renderer.supportsHeadless)\n            return fallback.actions.sendCalls(parameters)\n\n          try {\n            // TODO: use eventual Viem Action.\n            const req = await provider.request(\n              z.encode(RpcSchema_porto.wallet_prepareCalls.Request, {\n                method: 'wallet_prepareCalls',\n                params: [\n                  {\n                    calls,\n                    capabilities: {\n                      ...(request._decoded.method === 'wallet_sendCalls'\n                        ? request._decoded.params?.[0]?.capabilities\n                        : undefined),\n                      feeToken,\n                      merchantUrl,\n                      requiredFunds,\n                    },\n                    chainId,\n                    from: account.address,\n                    key,\n                  },\n                ],\n              }),\n            )\n\n            const quotes = req.capabilities?.quote?.quotes ?? []\n            const hasFeeDeficit = quotes.some((quote, index) => {\n              const isMultichainDestination =\n                index === quotes.length - 1 && quotes.length > 1\n              if (isMultichainDestination) return false\n              return Hex.toBigInt(quote.feeTokenDeficit) > 0n\n            })\n            if (hasFeeDeficit) throw new Error('insufficient funds')\n\n            const signature = await Key.sign(key, {\n              address: null,\n              payload: req.digest,\n              wrap: false,\n            })\n\n            // TODO: use eventual Viem Action.\n            const result = await provider.request({\n              method: 'wallet_sendPreparedCalls',\n              params: [\n                {\n                  ...req,\n                  signature,\n                },\n              ],\n            })\n\n            const response = result[0]\n            if (!response) throw new Error('id not found')\n\n            if (asTxHash) {\n              const { id, receipts, status } = await waitForCallsStatus(\n                client,\n                {\n                  id: response.id,\n                  pollingInterval: 500,\n                },\n              )\n              if (!receipts?.[0]) {\n                if (status === 'success')\n                  throw new Provider.UnknownBundleIdError({\n                    message: 'Call bundle with id: ' + id + ' not found.',\n                  })\n                throw new RpcResponse.TransactionRejectedError({\n                  message:\n                    'Transaction failed under call bundle id: ' + id + '.',\n                })\n              }\n              return {\n                id: receipts[0].transactionHash,\n              }\n            }\n\n            return response\n          } catch {}\n        }\n\n        if (request.method === 'eth_sendTransaction') {\n          // Send a transaction request to the dialog.\n          const id = await provider.request({\n            ...request,\n            params: [\n              {\n                ...request.params?.[0],\n                // @ts-expect-error\n                capabilities: {\n                  feeToken,\n                  merchantUrl,\n                },\n                ...(chainId ? { chainId: Hex.fromNumber(chainId) } : {}),\n              },\n            ],\n          })\n\n          return { id }\n        }\n\n        if (request.method === 'wallet_sendCalls') {\n          // Send calls request to the dialog.\n          const result = await provider.request({\n            method: 'wallet_sendCalls',\n            params: [\n              {\n                ...request.params?.[0],\n                capabilities: {\n                  ...request.params?.[0]?.capabilities,\n                  feeToken,\n                  merchantUrl,\n                },\n                ...(chainId ? { chainId: Hex.fromNumber(chainId) } : {}),\n              },\n            ],\n          })\n\n          return result\n        }\n\n        throw new Error('Cannot execute for method: ' + request.method)\n      },\n\n      async sendPreparedCalls(parameters) {\n        const { internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_sendPreparedCalls')\n          throw new Error(\n            'Cannot send prepared calls for method: ' + request.method,\n          )\n\n        if (!renderer.supportsHeadless)\n          return fallback.actions.sendPreparedCalls(parameters)\n\n        const provider = getProvider(store)\n        const result = await provider.request(request)\n\n        const id = result[0]?.id\n        if (!id) throw new Error('id not found')\n\n        return id\n      },\n\n      async signPersonalMessage(parameters) {\n        const { internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'personal_sign')\n          throw new Error(\n            'Cannot sign personal message for method: ' + request.method,\n          )\n\n        const provider = getProvider(store)\n        return await provider.request(request)\n      },\n\n      async signTypedData(parameters) {\n        const { internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'eth_signTypedData_v4')\n          throw new Error(\n            'Cannot sign typed data for method: ' + request.method,\n          )\n\n        const provider = getProvider(store)\n        return await provider.request(request)\n      },\n\n      async switchChain(parameters) {\n        const { internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_switchEthereumChain')\n          throw new Error('Cannot switch chain for method: ' + request.method)\n\n        if (!renderer.supportsHeadless) return\n\n        const provider = getProvider(store)\n        return await provider.request(request)\n      },\n\n      async upgradeAccount(parameters) {\n        const { account, internal } = parameters\n        const { store, request } = internal\n\n        if (request.method !== 'wallet_upgradeAccount')\n          throw new Error(\n            'Cannot upgrade account for method: ' + request.method,\n          )\n\n        const provider = getProvider(store)\n        await provider.request(request)\n\n        return { account }\n      },\n\n      async verifyEmail(parameters) {\n        const { internal } = parameters\n        const { request, store } = internal\n\n        if (request.method !== 'account_verifyEmail')\n          throw new Error('Cannot verify email for method: ' + request.method)\n\n        const provider = getProvider(store)\n        return await provider.request(request)\n      },\n    },\n    config: parameters,\n    name: 'dialog',\n    setup(parameters) {\n      const { internal } = parameters\n      const { store } = internal\n\n      const dialog = renderer.setup({\n        host,\n        internal,\n        theme,\n        themeController,\n      })\n\n      const unsubscribe = store.subscribe(\n        (x) => x.requestQueue,\n        (requestQueue) => {\n          for (const listener of listeners) listener(requestQueue)\n\n          const requests = requestQueue\n            .map((x) => (x.status === 'pending' ? x : undefined))\n            .filter(Boolean) as readonly QueuedRequest[]\n          dialog.syncRequests(requests).catch(() => {})\n          if (requests.length === 0) dialog.close()\n        },\n      )\n\n      return () => {\n        unsubscribe()\n        dialog.destroy()\n      }\n    },\n  })\n}\n\nexport declare namespace dialog {\n  type Parameters = {\n    /**\n     * Mode to fall back to if the renderer does not support background\n     * operations (e.g. popups and web views).\n     *\n     * @default `Mode.relay()`\n     */\n    fallback?: Mode.Mode | undefined\n    /**\n     * URL of the dialog embed.\n     * @default 'http://id.porto.sh/dialog'\n     */\n    host?: string | undefined\n    /**\n     * Dialog renderer.\n     * @default Dialog.iframe()\n     */\n    renderer?: Dialog.Dialog | undefined\n    /**\n     * Theme to apply to the dialog.\n     * @default undefined\n     */\n    theme?: ThemeFragment | undefined\n    /**\n     * Theme controller.\n     * @default undefined\n     */\n    themeController?: Dialog.ThemeController | undefined\n  }\n}\n\nexport async function resolveFeeToken(\n  internal: Mode.ActionsInternal,\n  parameters?: {\n    feeToken?: Token.Symbol | Address.Address | undefined\n  },\n) {\n  const {\n    config: { feeToken },\n  } = internal\n  const { feeToken: overrideFeeToken } = parameters ?? {}\n  return overrideFeeToken ?? feeToken\n}\n\nfunction getAuthUrl(\n  apiUrl: string | Siwe.AuthUrl | undefined,\n  { storage }: { storage: Storage },\n) {\n  if (!apiUrl) return undefined\n\n  const authUrl = Siwe.resolveAuthUrl(\n    apiUrl,\n    typeof window !== 'undefined' ? window.location.origin : undefined,\n  )\n\n  // Store the resolved auth URL for future use (e.g., disconnect)\n  if (authUrl) storage.setItem('porto.authUrl', authUrl)\n\n  return authUrl\n}\n","import type { RpcRequest, RpcResponse } from 'ox'\nimport * as Json from 'ox/Json'\nimport * as Provider from 'ox/Provider'\nimport type { ThemeFragment } from '../theme/Theme.js'\nimport * as IO from './internal/intersectionObserver.js'\nimport { logger } from './internal/logger.js'\nimport type { Internal } from './internal/porto.js'\nimport * as UserAgent from './internal/userAgent.js'\nimport * as Messenger from './Messenger.js'\nimport type { QueuedRequest, Store } from './Porto.js'\nimport * as ReactNativeEnvironment from './react-native/environment.js'\nimport { isReactNative } from './react-native/utils.js'\n\nconst AuthSessionStatus = {\n  cancel: 'cancel',\n  error: 'error',\n  success: 'success',\n  unknown: 'unknown',\n} as const\n\ntype AuthSessionStatus =\n  (typeof AuthSessionStatus)[keyof typeof AuthSessionStatus]\n\nexport const hostUrls = {\n  local: 'http://localhost:5175/dialog/',\n  prod: 'https://id.porto.sh/dialog',\n  stg: 'https://stg.id.porto.sh/dialog',\n} as const\n\n/** Dialog interface. */\nexport type Dialog = {\n  name: string\n  setup: (parameters: {\n    host: string\n    internal: Internal\n    theme?: ThemeFragment | undefined\n    themeController?: ThemeController | undefined\n  }) => {\n    close: () => void\n    destroy: () => void\n    open: (parameters: any) => void\n    secure: () => Promise<{\n      frame: boolean\n      host: boolean\n      protocol: boolean\n    }>\n    syncRequests: (requests: readonly QueuedRequest[]) => Promise<void>\n  }\n  supportsHeadless: boolean\n}\n\n/**\n * Instantiates a dialog.\n *\n * @param dialog - Dialog.\n * @returns Instantiated dialog.\n */\nexport function from<const dialog extends Dialog>(dialog: dialog): dialog {\n  return dialog\n}\n\n/**\n * Instantiates an iframe dialog.\n *\n * @returns iframe dialog.\n */\nexport function iframe(options: iframe.Options = {}) {\n  const { skipProtocolCheck, skipUnsupported } = options\n\n  // Safari does not support WebAuthn credential creation in iframes.\n  // Fall back to popup dialog.\n  // Tracking: https://github.com/WebKit/standards-positions/issues/304\n  const includesUnsupported = (\n    requests: readonly RpcRequest.RpcRequest[] | undefined,\n  ) =>\n    !skipUnsupported &&\n    UserAgent.isSafari() &&\n    requests?.some((x) =>\n      ['wallet_connect', 'eth_requestAccounts'].includes(x.method),\n    )\n\n  if (typeof window === 'undefined') return noop()\n  return from({\n    name: 'iframe',\n    setup(parameters) {\n      const { host, internal, theme, themeController } = parameters\n      const { store } = internal\n\n      const fallback = popup().setup(parameters)\n\n      let open = false\n\n      const hostUrl = new URL(host)\n\n      const root = document.createElement('dialog')\n      root.dataset.porto = ''\n\n      root.setAttribute('role', 'dialog')\n      root.setAttribute('aria-closed', 'true')\n      root.setAttribute('aria-label', 'Porto Wallet')\n      root.setAttribute('hidden', 'until-found')\n\n      Object.assign(root.style, {\n        background: 'transparent',\n        border: '0',\n        outline: '0',\n        padding: '0',\n        position: 'fixed',\n      })\n\n      document.body.appendChild(root)\n\n      const iframe = document.createElement('iframe')\n      iframe.setAttribute('data-testid', 'porto')\n      const iframeAllow = [\n        'payment',\n        `publickey-credentials-get ${hostUrl.origin}`,\n        `publickey-credentials-create ${hostUrl.origin}`,\n      ]\n\n      if (!UserAgent.isFirefox()) iframeAllow.push('clipboard-write')\n\n      iframe.setAttribute('allow', iframeAllow.join('; '))\n      iframe.setAttribute('tabindex', '0')\n      iframe.setAttribute(\n        'sandbox',\n        'allow-forms allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox',\n      )\n      iframe.setAttribute('src', getDialogUrl(host))\n      iframe.setAttribute('title', 'Porto')\n      Object.assign(iframe.style, {\n        backgroundColor: 'transparent',\n        border: '0',\n        colorScheme: 'light dark',\n        height: '100%',\n        left: '0',\n        position: 'fixed',\n        top: '0',\n        width: '100%',\n      })\n\n      const style = document.createElement('style')\n      style.innerHTML = `\n        dialog[data-porto]::backdrop {\n          background: transparent!important;\n        }\n      `\n\n      root.appendChild(style)\n      root.appendChild(iframe)\n\n      const messenger = Messenger.bridge({\n        from: Messenger.fromWindow(window, { targetOrigin: hostUrl.origin }),\n        to: Messenger.fromWindow(iframe.contentWindow!, {\n          targetOrigin: hostUrl.origin,\n        }),\n        waitForReady: true,\n      })\n\n      themeController?._setup(messenger, true)\n\n      const drawerModeQuery = window.matchMedia('(max-width: 460px)')\n      const onDrawerModeChange = () => {\n        messenger.send('__internal', {\n          type: 'resize',\n          // 460 = drawer mode, 461 = floating mode\n          width: drawerModeQuery.matches ? 460 : 461,\n        })\n      }\n      drawerModeQuery.addEventListener('change', onDrawerModeChange)\n\n      messenger.on('ready', (options) => {\n        const chainIds = parameters.internal.store.getState().chainIds\n\n        // Derive the compatible chain IDs between the dialog and the application.\n        let compatibleChainIds = chainIds.filter((id) =>\n          options.chainIds.includes(id),\n        )\n\n        // If the consumer has no compatible chain IDs with the dialog,\n        // fall back to the dialog's chain IDs.\n        if (compatibleChainIds.length === 0)\n          compatibleChainIds = options.chainIds as [number, ...number[]]\n\n        store.setState((x) => ({\n          ...x,\n          chainIds: compatibleChainIds as [number, ...number[]],\n        }))\n\n        messenger.send('__internal', {\n          chainIds: compatibleChainIds,\n          mode: 'iframe',\n          referrer: getReferrer(),\n          theme,\n          type: 'init',\n        })\n\n        onDrawerModeChange()\n      })\n\n      messenger.on('rpc-response', (response) => {\n        if (includesUnsupported([response._request])) {\n          // reload iframe to rehydrate storage state if an\n          // unsupported request routed via another renderer.\n          const src = iframe.src\n          iframe.src = src\n        }\n        handleResponse(store, response)\n      })\n      messenger.on('__internal', (payload) => {\n        if (payload.type === 'switch' && payload.mode === 'popup') {\n          fallback.open()\n          fallback.syncRequests(store.getState().requestQueue)\n        }\n      })\n\n      let bodyStyle: CSSStyleDeclaration | null = null\n\n      // store the opening element to restore the focus\n      let opener: HTMLElement | null = null\n\n      const onBlur = () => handleBlur(store)\n      const onEscape = (event: KeyboardEvent) => {\n        if (event.key === 'Escape') handleBlur(store)\n      }\n\n      // 1password extension adds `inert` attribute to `dialog` and inserts\n      // itself (`<com-1password-notification />`) there rendering itself unusable:\n      // watch for `inert` on `dialog` and remove it\n      const inertObserver = new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n          if (mutation.type !== 'attributes') continue\n          const name = mutation.attributeName\n          if (!name) continue\n          if (name !== 'inert') continue\n          root.removeAttribute(name)\n        }\n      })\n      inertObserver.observe(root, {\n        attributeOldValue: true,\n        attributes: true,\n      })\n\n      // dialog/page interactivity (no visibility change)\n      let dialogActive = false\n      const activatePage = () => {\n        if (!dialogActive) return\n        dialogActive = false\n\n        root.removeEventListener('click', onBlur)\n        document.removeEventListener('keydown', onEscape)\n        root.style.pointerEvents = 'none'\n        opener?.focus()\n        opener = null\n\n        Object.assign(document.body.style, bodyStyle ?? '')\n        // firefox: explicitly restore/clear `overflow` directly\n        document.body.style.overflow = bodyStyle?.overflow ?? ''\n      }\n      const activateDialog = () => {\n        if (dialogActive) return\n        dialogActive = true\n\n        root.addEventListener('click', onBlur)\n        document.addEventListener('keydown', onEscape)\n        iframe.focus()\n        root.style.pointerEvents = 'auto'\n\n        bodyStyle = Object.assign({}, document.body.style)\n        document.body.style.overflow = 'hidden'\n      }\n\n      // dialog visibility\n      let visible = false\n      const showDialog = () => {\n        if (visible) return\n        visible = true\n\n        if (document.activeElement instanceof HTMLElement)\n          opener = document.activeElement\n\n        root.removeAttribute('hidden')\n        root.removeAttribute('aria-closed')\n        root.showModal()\n      }\n      const hideDialog = () => {\n        if (!visible) return\n        visible = false\n        root.setAttribute('hidden', 'true')\n        root.setAttribute('aria-closed', 'true')\n        root.close()\n\n        // 1password extension sometimes adds `inert` attribute to `dialog`\n        // siblings and does not clean up remove when `dialog` closes\n        // (after `<com-1password-notification />` closes)\n        for (const sibling of root.parentNode\n          ? Array.from(root.parentNode.children)\n          : []) {\n          if (sibling === root) continue\n          if (!sibling.hasAttribute('inert')) continue\n          sibling.removeAttribute('inert')\n        }\n      }\n\n      return {\n        close() {\n          fallback.close()\n          open = false\n\n          messenger.send('__internal', {\n            mode: 'iframe',\n            referrer: getReferrer(),\n            type: 'init',\n          })\n\n          hideDialog()\n          activatePage()\n        },\n        destroy() {\n          fallback.close()\n          open = false\n\n          activatePage()\n          hideDialog()\n\n          fallback.destroy()\n          messenger.destroy()\n          root.remove()\n          inertObserver.disconnect()\n\n          drawerModeQuery.removeEventListener('change', onDrawerModeChange)\n        },\n        open() {\n          if (open) return\n          open = true\n\n          showDialog()\n          activateDialog()\n\n          messenger.send('__internal', {\n            mode: 'iframe',\n            referrer: getReferrer(),\n            type: 'init',\n          })\n        },\n        async secure() {\n          const { trustedHosts } = await messenger.waitForReady()\n\n          const secureProtocol = (() => {\n            if (skipProtocolCheck) return true\n            const secure = window.location.protocol.startsWith('https')\n            if (!secure)\n              logger.warnOnce(\n                'Detected insecure protocol (HTTP).',\n                `\\n\\nThe Porto iframe is not supported on HTTP origins (${window.location.origin})`,\n                'due to lack of WebAuthn support.',\n                'See https://porto.sh/sdk#secure-origins-https for more information.',\n              )\n            return secure\n          })()\n          const intersectionObserverSupported = IO.supported()\n          const trustedHost = Boolean(\n            trustedHosts?.includes(window.location.hostname),\n          )\n\n          const secureFrame = Boolean(\n            intersectionObserverSupported || trustedHost,\n          )\n\n          if (!secureFrame)\n            logger.warnOnce(\n              [\n                `Warning: Browser does not support IntersectionObserver v2 or host \"${hostUrl.hostname}\" is not trusted by Porto.`,\n                'This may result in the dialog falling back to a popup.',\n                '',\n                `Add \"${hostUrl.hostname}\" to the trusted hosts list to enable iframe dialog: https://github.com/ithacaxyz/porto/edit/main/src/trusted-hosts.ts`,\n              ].join('\\n'),\n            )\n\n          return {\n            frame: secureFrame,\n            host: trustedHost,\n            protocol: secureProtocol,\n          }\n        },\n        async syncRequests(requests) {\n          const { methodPolicies } = await messenger.waitForReady()\n          const secure = await this.secure()\n\n          const headless = requests?.every(\n            (request) =>\n              methodPolicies?.find(\n                (policy) => policy.method === request.request.method,\n              )?.modes?.headless === true,\n          )\n\n          const unsupported = includesUnsupported(\n            requests.map((x) => x.request),\n          )\n\n          if (!headless && (unsupported || !secure.protocol || !secure.frame))\n            fallback.syncRequests(requests)\n          else {\n            const requiresConfirm = requests.some((x) =>\n              requiresConfirmation(x.request, {\n                methodPolicies,\n                targetOrigin: hostUrl.origin,\n              }),\n            )\n            if (!open && requiresConfirm) this.open()\n            messenger.send('rpc-requests', requests)\n          }\n        },\n      }\n    },\n    supportsHeadless: true,\n  })\n}\n\nexport declare namespace iframe {\n  export type Options = {\n    size?: { width: number; height?: number | undefined } | undefined\n    /**\n     * Skips check for insecure protocol (HTTP).\n     * @default false\n     */\n    skipProtocolCheck?: boolean | undefined\n    /**\n     * Skips check for unsupported iframe requests that result\n     * to a popup.\n     * @default false\n     */\n    skipUnsupported?: boolean | undefined\n  }\n}\n\n/**\n * Instantiates a popup dialog.\n *\n * @returns Popup dialog.\n */\nexport function popup(options: popup.Options = {}) {\n  if (typeof window === 'undefined') return noop()\n  const { type = 'auto', size = defaultSize } = options\n  return from({\n    name: 'popup',\n    setup(parameters) {\n      const { host, internal, themeController } = parameters\n      const { store } = internal\n\n      const hostUrl = new URL(host)\n\n      let popup: Window | null = null\n\n      const resolvedType =\n        type === 'page' || (type === 'auto' && UserAgent.isMobile())\n          ? 'page'\n          : 'popup'\n\n      function onBlur() {\n        if (popup) handleBlur(store)\n      }\n\n      const offDetectClosed = (() => {\n        const timer = setInterval(() => {\n          if (popup?.closed) handleBlur(store)\n        }, 100)\n        return () => clearInterval(timer)\n      })()\n\n      let messenger: Messenger.Bridge | undefined\n\n      themeController?._setup(null, true)\n\n      return {\n        close() {\n          if (!popup) return\n          popup.close()\n          popup = null\n        },\n        destroy() {\n          this.close()\n          window.removeEventListener('focus', onBlur)\n          messenger?.destroy()\n          offDetectClosed()\n        },\n        open() {\n          if (resolvedType === 'popup') {\n            const left = (window.innerWidth - size.width) / 2 + window.screenX\n            const top = window.screenY + 100\n\n            popup = window.open(\n              getDialogUrl(host),\n              '_blank',\n              `width=${size.width},height=${size.height},left=${left},top=${top}`,\n            )\n          } else {\n            popup = window.open(getDialogUrl(host), '_blank')\n          }\n\n          if (!popup) throw new Error('Failed to open popup')\n\n          messenger = Messenger.bridge({\n            from: Messenger.fromWindow(window, {\n              targetOrigin: hostUrl.origin,\n            }),\n            to: Messenger.fromWindow(popup, {\n              targetOrigin: hostUrl.origin,\n            }),\n            waitForReady: true,\n          })\n\n          themeController?._setup(messenger, false)\n\n          messenger.send('__internal', {\n            mode: resolvedType === 'page' ? 'page' : 'popup',\n            referrer: getReferrer(),\n            theme: themeController?.getTheme() ?? parameters.theme,\n            type: 'init',\n          })\n\n          messenger.on('rpc-response', (response) =>\n            handleResponse(store, response),\n          )\n\n          window.removeEventListener('focus', onBlur)\n          window.addEventListener('focus', onBlur)\n        },\n        async secure() {\n          return {\n            frame: true,\n            host: true,\n            protocol: true,\n          }\n        },\n        async syncRequests(requests) {\n          const requiresConfirm = requests.some((x) =>\n            requiresConfirmation(x.request),\n          )\n          if (requiresConfirm) {\n            if (!popup || popup.closed) this.open()\n            popup?.focus()\n          }\n          messenger?.send('rpc-requests', requests)\n        },\n      }\n    },\n    supportsHeadless: false,\n  })\n}\n\nexport declare namespace popup {\n  export type Options = {\n    /**\n     * The type of popup window to create.\n     * - 'auto': Automatically decide based on context (default)\n     * - 'popup': Popup window with controlled height\n     * - 'page': Full page/tab\n     * @default 'auto'\n     */\n    type?: 'auto' | 'popup' | 'page' | undefined\n    /**\n     * Initial size of the popup window when type is 'popup' or 'auto' resolves to popup.\n     * @default { width: 360, height: 282 }\n     */\n    size?: { width: number; height: number } | undefined\n  }\n}\n\n/**\n * Instantiates a authSession dialog for React Native.\n * @param options - Options.\n */\nexport function authSession(options: authSession.Options = {}) {\n  if (!isReactNative()) return noop()\n\n  const { requestOptions = { showTitle: true } } = options\n\n  return from({\n    name: 'authSession',\n    setup(parameters) {\n      const { host, internal } = parameters\n      const { store } = internal\n\n      const environment = ReactNativeEnvironment.reactNative.environment\n      environment.maybeCompleteAuthSession?.()\n\n      let processing = false\n      let inFlightId: number | null = null\n\n      async function handle(request: QueuedRequest) {\n        const { request: rpcRequest } = request\n        const reactNativePaths = {\n          account_verifyEmail: 'account_verifyEmail',\n          eth_requestAccounts: 'eth_requestAccounts',\n          eth_sendTransaction: 'eth_sendTransaction',\n          eth_signTypedData_v4: 'eth_signTypedData_v4',\n          personal_sign: 'personal_sign',\n          wallet_addFunds: 'wallet_addFunds',\n          wallet_connect: 'wallet_connect',\n          wallet_getAccountVersion: 'wallet_getAccountVersion',\n          wallet_getAssets: 'wallet_getAssets',\n          wallet_getCallsStatus: 'wallet_getCallsStatus',\n          wallet_getCapabilities: 'wallet_getCapabilities',\n          wallet_getKeys: 'wallet_getKeys',\n          wallet_getPermissions: 'wallet_getPermissions',\n          wallet_grantAdmin: 'wallet_grantAdmin',\n          wallet_grantPermissions: 'wallet_grantPermissions',\n          wallet_prepareCalls: 'wallet_prepareCalls',\n          wallet_prepareUpgradeAccount: 'wallet_prepareUpgradeAccount',\n          wallet_revokeAdmin: 'wallet_revokeAdmin',\n          wallet_revokePermissions: 'wallet_revokePermissions',\n          wallet_sendCalls: 'wallet_sendCalls',\n          wallet_sendPreparedCalls: 'wallet_sendPreparedCalls',\n          wallet_switchEthereumChain: 'wallet_switchEthereumChain',\n          wallet_verifySignature: 'wallet_verifySignature',\n        } as const satisfies Record<string, string>\n\n        const rpcMethod =\n          reactNativePaths[rpcRequest.method as keyof typeof reactNativePaths]\n        if (!rpcMethod)\n          throw new Provider.UnsupportedMethodError({\n            message: `Method not supported in Mode.reactNative(): ${rpcRequest.method}`,\n          })\n        const redirectUri = environment.makeRedirectUri({\n          ...(options.redirectUri\n            ? { scheme: options.redirectUri.scheme }\n            : {}),\n          path: options.redirectUri?.path ?? '/',\n          preferLocalhost: typeof __DEV__ === 'boolean' && __DEV__,\n        })\n\n        const url = new URL(host)\n        url.pathname = `${url.pathname.replace(/\\/$/, '')}/${rpcMethod}`\n\n        const searchParams = new URLSearchParams({\n          id: String(rpcRequest.id),\n          jsonrpc: '2.0',\n          method: rpcRequest.method,\n          redirectUri,\n        })\n\n        const params = (rpcRequest.params ?? []) as readonly unknown[]\n        if (params.length > 0)\n          searchParams.set('params', Json.stringify(params))\n\n        const decodedParams = (rpcRequest as any)._decoded?.params\n        if (decodedParams)\n          searchParams.set('_decoded', Json.stringify(decodedParams))\n\n        url.search = searchParams.toString()\n\n        const result = await environment.openAuthSessionAsync(\n          url.toString(),\n          redirectUri,\n          requestOptions,\n        )\n\n        const response = (() => {\n          if (result.type === 'success' && result.url) {\n            const resolved = new URL(result.url)\n            const status =\n              resolved.searchParams.get('status') ?? AuthSessionStatus.unknown\n            const message = resolved.searchParams.get('message') ?? undefined\n            const payload = resolved.searchParams.get('payload') ?? undefined\n            if (status === AuthSessionStatus.success)\n              try {\n                return {\n                  id: rpcRequest.id,\n                  jsonrpc: '2.0',\n                  result: payload ? Json.parse(payload) : undefined,\n                } satisfies RpcResponse.RpcResponse\n              } catch (error) {\n                return {\n                  error: {\n                    code: -32603,\n                    message:\n                      error instanceof Error\n                        ? error.message\n                        : 'Failed to parse redirect payload',\n                  },\n                  id: rpcRequest.id,\n                  jsonrpc: '2.0',\n                } satisfies RpcResponse.RpcResponse\n              }\n\n            const error =\n              status === AuthSessionStatus.cancel\n                ? new Provider.UserRejectedRequestError({\n                    message: message ?? 'User rejected request',\n                  })\n                : new Provider.ProviderRpcError(\n                    -32603,\n                    message ?? status ?? 'Request failed',\n                  )\n            return {\n              error: {\n                code: error.code,\n                message: error.message,\n              },\n              id: rpcRequest.id,\n              jsonrpc: '2.0',\n            } satisfies RpcResponse.RpcResponse\n          }\n          if (result.type === 'cancel' || result.type === 'dismiss')\n            return {\n              error: {\n                code: Provider.UserRejectedRequestError.code,\n                message: 'User rejected request',\n              },\n              id: rpcRequest.id,\n              jsonrpc: '2.0',\n            } satisfies RpcResponse.RpcResponse\n\n          return {\n            error: {\n              code: -32603,\n              message: (result as any).error ?? 'Request failed',\n            },\n            id: rpcRequest.id,\n            jsonrpc: '2.0',\n          } satisfies RpcResponse.RpcResponse\n        })()\n\n        handleResponse(store, response)\n        environment.dismissAuthSession?.()\n      }\n\n      return {\n        close() {\n          environment.dismissAuthSession?.()\n        },\n        destroy() {\n          environment.dismissAuthSession?.()\n        },\n        open() {\n          void 0\n        },\n        async secure() {\n          return {\n            frame: false,\n            host: true,\n            protocol: true,\n          }\n        },\n        async syncRequests(requests) {\n          if (processing) return\n          const [request] = requests\n          if (!request) return\n          if (inFlightId === request.request.id) return\n\n          inFlightId = request.request.id\n          processing = true\n          try {\n            await handle(request)\n          } catch (error) {\n            handleResponse(store, {\n              error: {\n                code: -32603,\n                message:\n                  error instanceof Error ? error.message : 'Request failed',\n              },\n              id: request.request.id,\n              jsonrpc: '2.0',\n            })\n            environment.dismissAuthSession?.()\n          } finally {\n            inFlightId = null\n            processing = false\n          }\n        },\n      }\n    },\n    supportsHeadless: false,\n  })\n}\n\nexport declare namespace authSession {\n  export type Options = {\n    /**\n     * where to redirect the user after operations are completed\n     */\n    redirectUri?:\n      | ReactNativeEnvironment.ReactNativeEnvironment['redirectUri']\n      | undefined\n    requestOptions?: ReactNativeEnvironment.AuthSessionOpenOptions | undefined\n  }\n}\n\n/**\n * Instantiates a noop dialog.\n *\n * @returns Noop dialog.\n */\nexport function noop() {\n  return from({\n    name: 'noop',\n    setup() {\n      return {\n        close() {},\n        destroy() {},\n        open() {},\n        async secure() {\n          return {\n            frame: true,\n            host: true,\n            protocol: true,\n          }\n        },\n        async syncRequests() {},\n      }\n    },\n    supportsHeadless: true,\n  })\n}\n\n/**\n * Instantiates an inline iframe dialog rendered on a provided `element`.\n *\n * @param options - Options.\n * @returns Inline iframe dialog.\n */\nexport function experimental_inline(options: inline.Options) {\n  const { element } = options\n  if (typeof window === 'undefined') return noop()\n  return from({\n    name: 'inline',\n    setup(parameters) {\n      const { host, internal, theme, themeController } = parameters\n      const { store } = internal\n\n      let open = false\n\n      const hostUrl = new URL(host)\n\n      const root = document.createElement('div')\n      root.dataset.porto = ''\n      root.style.height = '100%'\n      element().appendChild(root)\n\n      const iframe = document.createElement('iframe')\n      iframe.setAttribute(\n        'allow',\n        `payment; publickey-credentials-get ${hostUrl.origin}; publickey-credentials-create ${hostUrl.origin}`,\n      )\n      iframe.setAttribute('aria-label', 'Porto Wallet')\n      iframe.setAttribute('tabindex', '0')\n      iframe.setAttribute(\n        'sandbox',\n        'allow-forms allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox',\n      )\n\n      iframe.setAttribute('src', getDialogUrl(host))\n      iframe.setAttribute('title', 'Porto')\n      Object.assign(iframe.style, {\n        border: '0',\n        height: '100%',\n        width: '100%',\n      })\n\n      root.appendChild(iframe)\n\n      const messenger = Messenger.bridge({\n        from: Messenger.fromWindow(window, { targetOrigin: hostUrl.origin }),\n        to: Messenger.fromWindow(iframe.contentWindow!, {\n          targetOrigin: hostUrl.origin,\n        }),\n        waitForReady: true,\n      })\n\n      themeController?._setup(messenger, true)\n\n      messenger.on('ready', () => {\n        messenger.send('__internal', {\n          mode: 'inline-iframe',\n          referrer: getReferrer(),\n          theme,\n          type: 'init',\n        })\n      })\n\n      messenger.on('rpc-response', (response) =>\n        handleResponse(store, response),\n      )\n\n      return {\n        close() {},\n        destroy() {\n          messenger.destroy()\n          root.remove()\n        },\n        open() {\n          if (open) return\n          open = true\n\n          messenger.send('__internal', {\n            mode: 'iframe',\n            referrer: getReferrer(),\n            type: 'init',\n          })\n        },\n        async secure() {\n          return {\n            frame: true,\n            host: true,\n            protocol: true,\n          }\n        },\n        async syncRequests(requests) {\n          messenger.send('rpc-requests', requests)\n        },\n      }\n    },\n    supportsHeadless: true,\n  })\n}\n\nexport namespace inline {\n  export type Options = {\n    element: () => HTMLElement\n  }\n}\n\nexport type ThemeController = {\n  /**\n   * Used internally to setup the controller.\n   * @deprecated\n   */\n  _setup: (messenger: Messenger.Messenger | null, resetTheme?: boolean) => void\n  /**\n   * Update the dialog theme.\n   * @param theme - The theme to set.\n   */\n  setTheme: (theme: ThemeFragment) => void\n  /**\n   * Get the latest theme set since the controller was initialized.\n   * @returns The latest theme or `null` if no theme was set.\n   */\n  getTheme: () => ThemeFragment | null\n}\n\n/**\n * A controller to update the dialog theme.\n */\nexport function createThemeController(): ThemeController {\n  let lastTheme: ThemeFragment | null = null\n  let messenger: Messenger.Messenger | null = null\n  const controller: ThemeController = {\n    _setup(messenger_: Messenger.Messenger | null, resetTheme = false) {\n      if (resetTheme) lastTheme = null\n      messenger = messenger_\n    },\n    getTheme() {\n      return lastTheme\n    },\n    setTheme(theme) {\n      lastTheme = theme\n      messenger\n        ?.send('__internal', {\n          theme,\n          type: 'set-theme',\n        })\n        .catch(() => {})\n    },\n  }\n  return controller\n}\n\nexport const defaultSize = { height: 282, width: 360 }\n\nexport function requiresConfirmation(\n  request: RpcRequest.RpcRequest,\n  options: {\n    methodPolicies?: Messenger.ReadyOptions['methodPolicies'] | undefined\n    targetOrigin?: string | undefined\n  } = {},\n) {\n  const { methodPolicies, targetOrigin } = options\n  const policy = methodPolicies?.find((x) => x.method === request.method)\n  if (!policy) return true\n  if (policy.modes?.headless) {\n    if (\n      typeof policy.modes.headless === 'object' &&\n      policy.modes.headless.sameOrigin &&\n      targetOrigin !== window.location.origin\n    )\n      return true\n    return false\n  }\n  return true\n}\n\nexport function getReferrer() {\n  const icon = (() => {\n    const dark = document.querySelector(\n      'link[rel=\"icon\"][media=\"(prefers-color-scheme: dark)\"]',\n    )?.href\n    const light =\n      document.querySelector(\n        'link[rel=\"icon\"][media=\"(prefers-color-scheme: light)\"]',\n      )?.href ?? document.querySelector('link[rel=\"icon\"]')?.href\n    if (dark && light && dark !== light) return { dark, light }\n    const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches\n    if (isDark) return dark\n    return light\n  })()\n  return {\n    icon,\n    title: document.title,\n  }\n}\n\nexport function handleBlur(store: Store) {\n  store.setState((x) => ({\n    ...x,\n    requestQueue: x.requestQueue.map((x) => ({\n      account: x.account,\n      error: new Provider.UserRejectedRequestError(),\n      request: x.request,\n      status: 'error',\n    })),\n  }))\n}\n\nexport function handleResponse(\n  store: Store,\n  response: RpcResponse.RpcResponse,\n) {\n  store.setState((x) => ({\n    ...x,\n    requestQueue: x.requestQueue.map((queued) => {\n      if (queued.request.id !== response.id) return queued\n      if (response.error)\n        return {\n          account: queued.account,\n          error: response.error,\n          request: queued.request,\n          status: 'error',\n        } satisfies QueuedRequest\n      return {\n        account: queued.account,\n        request: queued.request,\n        result: response.result,\n        status: 'success',\n      } satisfies QueuedRequest\n    }),\n  }))\n}\n\nexport function getDialogUrl(host: string) {\n  const url = new URL(host)\n  const parentParams = new URLSearchParams(window.location.search)\n  const prefix = 'porto.'\n  for (const [key, value] of parentParams.entries()) {\n    if (key.startsWith(prefix))\n      url.searchParams.set(key.slice(prefix.length), value)\n  }\n  return url.toString()\n}\n","import type * as Mipd from 'mipd'\nimport type * as Address from 'ox/Address'\nimport type * as Hex from 'ox/Hex'\nimport type * as RpcRequest from 'ox/RpcRequest'\nimport type * as RpcResponse from 'ox/RpcResponse'\nimport { http, type Transport } from 'viem'\nimport { devtools, persist, subscribeWithSelector } from 'zustand/middleware'\nimport { createStore, type Mutate, type StoreApi } from 'zustand/vanilla'\nimport type * as Account from '../viem/Account.js'\nimport * as Chains from './Chains.js'\nimport { hostUrls } from './Dialog.js'\nimport type * as Mode from './internal/mode.js'\nimport { dialog } from './internal/modes/dialog.js'\nimport { relay } from './internal/modes/relay.js'\nimport type * as internal from './internal/porto.js'\nimport * as Provider from './internal/provider.js'\nimport type * as Token from './internal/schema/token.js'\nimport type * as Siwe from './internal/siwe.js'\nimport type { ExactPartial, OneOf } from './internal/types.js'\nimport * as Utils from './internal/utils.js'\nimport * as Storage from './Storage.js'\nimport { relayUrls } from './Transport.js'\n\nconst browser = typeof window !== 'undefined' && typeof document !== 'undefined'\n\nexport const defaultConfig = {\n  announceProvider: true,\n  chains: Chains.all,\n  mode: browser ? dialog({ host: hostUrls.prod }) : relay(),\n  relay: http(relayUrls.prod.http),\n  storage:\n    browser && typeof indexedDB !== 'undefined'\n      ? Storage.idb()\n      : Storage.memory(),\n  storageKey: 'porto.store',\n} as const satisfies ExactPartial<Config>\n\n/**\n * Instantiates an Porto instance.\n *\n * @example\n * ```ts twoslash\n * import { Porto } from 'porto'\n *\n * const porto = Porto.create()\n *\n * const blockNumber = await porto.provider.request({ method: 'eth_blockNumber' })\n * ```\n */\nexport function create<\n  const chains extends readonly [Chains.Chain, ...Chains.Chain[]],\n>(parameters?: ExactPartial<Config<chains>> | undefined): Porto<chains>\nexport function create(\n  parameters: ExactPartial<Config> | undefined = {},\n): Porto {\n  const chains = parameters.chains ?? defaultConfig.chains\n  const transports = Object.fromEntries(\n    chains!.map((chain) => [\n      chain.id,\n      parameters.transports?.[chain.id] ?? http(),\n    ]),\n  )\n\n  const config = {\n    announceProvider:\n      parameters.announceProvider ?? defaultConfig.announceProvider,\n    authUrl: parameters.authUrl,\n    chains,\n    feeToken: parameters.feeToken,\n    merchantUrl: parameters.merchantUrl,\n    mode: parameters.mode ?? defaultConfig.mode,\n    relay: parameters.relay ?? defaultConfig.relay,\n    storage: parameters.storage ?? defaultConfig.storage,\n    storageKey: parameters.storageKey ?? defaultConfig.storageKey,\n    transports,\n  } satisfies Config\n\n  const store = createStore(\n    devtools(\n      subscribeWithSelector(\n        persist<State>(\n          (_) => ({\n            accounts: [],\n            chainIds: config.chains.map((chain) => chain.id) as [\n              number,\n              ...number[],\n            ],\n            feeToken: config.feeToken,\n            requestQueue: [],\n          }),\n          {\n            merge(p, currentState) {\n              const persistedState = p as State\n              const currentChainId =\n                config.chains.find(\n                  (chain) => chain.id === persistedState.chainIds[0],\n                )?.id ?? config.chains[0].id\n              const chainIds = [\n                currentChainId,\n                ...config.chains\n                  .map((chain) => chain.id)\n                  .filter((id) => id !== currentChainId),\n              ] as const\n              return {\n                ...currentState,\n                ...persistedState,\n                chainIds,\n              }\n            },\n            name: config.storageKey,\n            partialize: (state) =>\n              ({\n                accounts: state.accounts.map((account) =>\n                  // omit non-serializable properties (e.g. functions).\n                  Utils.normalizeValue(account),\n                ),\n                chainIds: state.chainIds,\n              }) as unknown as State,\n            storage: config.storage,\n            version: 5,\n          },\n        ),\n      ),\n    ),\n  )\n\n  let mode = config.mode\n\n  const internal = {\n    config,\n    getMode() {\n      return mode\n    },\n    id: Utils.uuidv4(),\n    setMode(i) {\n      destroy?.()\n      mode = i\n      destroy = i.setup({\n        internal,\n      })\n      return destroy\n    },\n    store,\n  } satisfies internal.Internal\n\n  const provider = Provider.from(internal)\n\n  let destroy =\n    mode !== null\n      ? mode.setup({\n          internal,\n        })\n      : () => {}\n\n  return {\n    _internal: internal,\n    config,\n    destroy() {\n      destroy()\n      provider._internal.destroy()\n    },\n    provider,\n  }\n}\n\nexport type Config<\n  chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n    Chains.Chain,\n    ...Chains.Chain[],\n  ],\n> = {\n  /**\n   * Whether to announce the provider via EIP-6963.\n   * Also accepts EIP-6963 provider info.\n   * @default true\n   */\n  announceProvider: boolean | Partial<Mipd.EIP6963ProviderInfo>\n  /**\n   * API URL(s) to use for offchain SIWE authentication.\n   */\n  authUrl?: string | Siwe.AuthUrl | undefined\n  /**\n   * List of supported chains.\n   */\n  chains: chains\n  /**\n   * Token to use to pay for fees.\n   * @default 'native'\n   */\n  feeToken?: State['feeToken'] | undefined\n  /**\n   * Mode to use.\n   * @default Mode.dialog()\n   */\n  mode: Mode.Mode | null\n  /**\n   * URL to use for merchant server.\n   */\n  merchantUrl?: string | undefined\n  /**\n   * Relay RPC Transport override.\n   */\n  relay: Transport\n  /**\n   * Storage to use.\n   * @default Storage.idb()\n   */\n  storage: Storage.Storage\n  /**\n   * Key to use for store.\n   */\n  storageKey?: string | undefined\n  /**\n   * Public RPC Transport overrides to use for each chain.\n   */\n  transports: Record<chains[number]['id'], Transport>\n}\n\nexport type Porto<\n  chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n    Chains.Chain,\n    ...Chains.Chain[],\n  ],\n> = {\n  config: Config<chains>\n  destroy: () => void\n  provider: Provider.Provider\n  /**\n   * Not part of versioned API, proceed with caution.\n   * @deprecated\n   */\n  _internal: internal.Internal<chains>\n}\n\nexport type State<\n  chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n    Chains.Chain,\n    ...Chains.Chain[],\n  ],\n> = {\n  accounts: readonly Account.Account[]\n  chainIds: readonly [chains[number]['id'], ...chains[number]['id'][]]\n  feeToken: Token.Symbol | undefined\n  requestQueue: readonly QueuedRequest[]\n}\n\nexport type Store<\n  chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n    Chains.Chain,\n    ...Chains.Chain[],\n  ],\n> = Mutate<\n  StoreApi<State<chains>>,\n  [['zustand/subscribeWithSelector', never], ['zustand/persist', any]]\n>\n\nexport type QueuedRequest<result = unknown> = {\n  /** Account to assert the request for, and sync if neccessary. */\n  account:\n    | {\n        /** Address of the account. */\n        address: Address.Address\n        /** Active key of the account. */\n        key?:\n          | {\n              /** Credential ID. May be `undefined` when the key is not a WebAuthn credential. */\n              credentialId?: string | undefined\n              /** Public key */\n              publicKey: Hex.Hex\n            }\n          | undefined\n      }\n    | undefined\n  request: RpcRequest.RpcRequest & { _internal?: unknown }\n} & OneOf<\n  | {\n      status: 'pending'\n    }\n  | {\n      result: result\n      status: 'success'\n    }\n  | {\n      error: RpcResponse.ErrorObject\n      status: 'error'\n    }\n>\n","import type * as Address from 'ox/Address'\nimport type * as Errors from 'ox/Errors'\nimport type * as Hex from 'ox/Hex'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport {\n  type Calls,\n  type Client,\n  createClient,\n  http,\n  type Narrow,\n  type Transport,\n} from 'viem'\nimport type { Chain } from '../core/Chains.js'\nimport type * as Capabilities from '../core/internal/relay/schema/capabilities.js'\nimport type * as Quotes from '../core/internal/relay/schema/quotes.js'\nimport type { OneOf, PartialBy, RequiredBy } from '../core/internal/types.js'\nimport type { relay } from '../core/Mode.js'\nimport * as Account from './Account.js'\nimport * as RelayActions from './internal/relayActions.js'\nimport type {\n  GetAccountParameter,\n  GetChainParameter,\n} from './internal/utils.js'\nimport * as Key from './Key.js'\n\nexport {\n  addFaucetFunds,\n  getAssets,\n  getAuthorization,\n  getCallsStatus,\n  getCapabilities,\n  health,\n  verifySignature,\n} from './internal/relayActions.js'\n\n/**\n * Creates a new Porto Account using an ephemeral EOA.\n *\n * @example\n * TODO\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function createAccount<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: createAccount.Parameters<chain>,\n): Promise<createAccount.ReturnType> {\n  const account = Account.fromPrivateKey(Secp256k1.randomPrivateKey(), {\n    keys: parameters.authorizeKeys,\n  })\n  return await upgradeAccount(client, {\n    ...(parameters as any),\n    account,\n  })\n}\n\nexport declare namespace createAccount {\n  export type Parameters<chain extends Chain | undefined = Chain | undefined> =\n    Omit<upgradeAccount.UnpreparedParameters<chain>, 'account'>\n\n  export type ReturnType = RequiredBy<Account.Account, 'keys'>\n}\n\n/**\n * Gets the keys for an account.\n *\n * @example\n * TODO\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Account keys.\n */\nexport async function getKeys<\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: getKeys.Parameters<account>,\n): Promise<getKeys.ReturnType> {\n  const { account = client.account, chainIds } = parameters\n  const account_ = account ? Account.from(account) : undefined\n  if (!account_) throw new Error('account is required.')\n  const keys = await RelayActions.getKeys(client, {\n    address: account_.address,\n    chainIds,\n  })\n  return Object.entries(keys).flatMap(([chainId, keys]) =>\n    keys.map((key) => Key.fromRelay(key, { chainId: Number(chainId) })),\n  )\n}\n\nexport namespace getKeys {\n  export type Parameters<\n    account extends Account.Account | undefined = Account.Account | undefined,\n  > = GetAccountParameter<account> &\n    Pick<RelayActions.getKeys.Parameters, 'chainIds'>\n\n  export type ReturnType = readonly Key.Key[]\n\n  export type ErrorType = RelayActions.getKeys.ErrorType\n}\n\n/**\n * Gets onramp contact info for address.\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function getOnrampContactInfo<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: getOnrampContactInfo.Parameters,\n): Promise<getOnrampContactInfo.ReturnType>\nexport async function getOnrampContactInfo(\n  client: Client,\n  parameters: getOnrampContactInfo.Parameters,\n) {\n  const { address, secret } = parameters\n  return await RelayActions.getOnrampContactInfo(client, {\n    address,\n    secret,\n  })\n}\n\nexport declare namespace getOnrampContactInfo {\n  export type Parameters = RelayActions.getOnrampContactInfo.Parameters\n\n  export type ReturnType = RelayActions.getOnrampContactInfo.ReturnType\n\n  export type ErrorType =\n    | RelayActions.getOnrampContactInfo.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets onramp status for address.\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function onrampStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: onrampStatus.Parameters,\n): Promise<onrampStatus.ReturnType>\nexport async function onrampStatus(\n  client: Client,\n  parameters: onrampStatus.Parameters,\n) {\n  const { address } = parameters\n  return await RelayActions.onrampStatus(client, {\n    address,\n  })\n}\n\nexport declare namespace onrampStatus {\n  export type Parameters = RelayActions.onrampStatus.Parameters\n\n  export type ReturnType = RelayActions.onrampStatus.ReturnType\n\n  export type ErrorType =\n    | RelayActions.onrampStatus.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Prepares the digest to sign over and fills the request to send a call bundle.\n *\n * @example\n * TODO\n *\n * @param client - Client.\n * @param parameters - Prepare call bundle parameters.\n * @returns Prepared properties.\n */\nexport async function prepareCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: prepareCalls.Parameters<calls, chain, account>,\n): Promise<prepareCalls.ReturnType> {\n  const {\n    account = client.account,\n    calls,\n    chain = client.chain,\n    feePayer,\n    merchantUrl,\n    nonce,\n    preCalls,\n    requiredFunds,\n    revokeKeys,\n  } = parameters\n\n  const account_ = account ? Account.from(account) : undefined\n  const key =\n    parameters.key ??\n    (account_ ? Account.getKey(account_, { role: 'admin' }) : undefined)\n\n  const hasSessionKey = parameters.authorizeKeys?.some(\n    (x) => x.role === 'session',\n  )\n  const {\n    contracts,\n    fees: { tokens },\n  } = await RelayActions.getCapabilities(client, { chainId: chain?.id })\n  const orchestrator = hasSessionKey\n    ? contracts.orchestrator.address\n    : undefined\n\n  const authorizeKeys = (parameters.authorizeKeys ?? []).map((key) =>\n    Key.toRelay(key, { feeTokens: tokens, orchestrator }),\n  )\n\n  // If a fee token is provided, use it.\n  // Otherwise, if there are spend permissions set, we cannot predictably\n  // infer the fee token (not pass it) as the fee token needs to have\n  // an assigned spend permission set. It is assumed that the first spend\n  // permission is the one that is used for the fee token.\n  const feeToken = (() => {\n    if (parameters.feeToken) return parameters.feeToken\n    return key?.permissions?.spend?.[0]?.token\n  })()\n\n  const preCall = typeof preCalls === 'boolean' ? preCalls : false\n  const signedPreCalls =\n    typeof preCalls === 'object'\n      ? preCalls.map(({ context, signature }) => ({\n          ...(context.preCall as any),\n          signature,\n        }))\n      : undefined\n\n  const args = {\n    address: account_?.address,\n    calls: (calls ?? []) as never,\n    capabilities: {\n      authorizeKeys,\n      meta: {\n        feePayer,\n        feeToken,\n        nonce,\n      },\n      preCall,\n      preCalls: signedPreCalls,\n      requiredFunds,\n      revokeKeys: revokeKeys?.map((key) => ({\n        hash: key.hash,\n      })),\n    },\n    chain: chain as never,\n    key: key ? Key.toRelay(key, { feeTokens: tokens }) : undefined,\n  } as const\n\n  const result = await (async () => {\n    if (merchantUrl) {\n      const client_ = createClient({\n        chain: client.chain,\n        transport: http(merchantUrl),\n      })\n      // Prepare with Merchant RPC.\n      return await RelayActions.prepareCalls(client_, args).catch((e) => {\n        console.error(e)\n        // Fall back to default client.\n        return RelayActions.prepareCalls(client, args)\n      })\n    }\n    return await RelayActions.prepareCalls(client, args)\n  })()\n\n  const { capabilities, context, digest, signature, typedData } = result\n\n  if (merchantUrl) {\n    const isValid = await RelayActions.verifyPrepareCallsResponse(client, {\n      response: result._raw,\n      signature,\n    })\n    if (!isValid)\n      throw new Error(\n        `cannot verify integrity of \\`wallet_prepareCalls\\` response from ${merchantUrl}`,\n      )\n  }\n\n  return {\n    capabilities: { ...capabilities, quote: context.quote as any },\n    context,\n    digest,\n    key,\n    typedData,\n  } as const\n}\n\nexport namespace prepareCalls {\n  export type Parameters<\n    calls extends readonly unknown[] = readonly unknown[],\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account.Account | undefined = Account.Account | undefined,\n  > = GetChainParameter<chain> &\n    GetAccountParameter<account, false> & {\n      /** Additional keys to authorize on the account. */\n      authorizeKeys?: readonly Key.Key[] | undefined\n      /** Calls to prepare. */\n      calls?: Calls<Narrow<calls>> | undefined\n      /** Key that will be used to sign the calls. */\n      key?:\n        | Pick<Key.Key, 'permissions' | 'publicKey' | 'prehash' | 'type'>\n        | undefined\n      /**\n       * Indicates if the bundle is \"pre-calls\", and should be executed before\n       * the main bundle.\n       *\n       * Accepts:\n       * - `true`: Indicates this is pre-calls.\n       * - An array: Set of prepared pre-calls.\n       */\n      preCalls?:\n        | true\n        | readonly {\n            context: prepareCalls.ReturnType['context']\n            signature: Hex.Hex\n          }[]\n        | undefined\n      /** Required funds to execute the calls. */\n      requiredFunds?: Capabilities.requiredFunds.Request | undefined\n      /** Additional keys to revoke from the account. */\n      revokeKeys?: readonly Key.Key[] | undefined\n      /** Merchant RPC URL. */\n      merchantUrl?: string | undefined\n    } & Omit<Capabilities.meta.Request, 'keyHash'>\n\n  export type ReturnType = {\n    capabilities: RelayActions.prepareCalls.ReturnType['capabilities'] & {\n      quote: Quotes.Signed\n    }\n    context: RelayActions.prepareCalls.ReturnType['context']\n    digest: RelayActions.prepareCalls.ReturnType['digest']\n    key: Parameters['key']\n    typedData: RelayActions.prepareCalls.ReturnType['typedData']\n  }\n\n  export type ErrorType =\n    | RelayActions.prepareCalls.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Prepares an account upgrade.\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function prepareUpgradeAccount<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: prepareUpgradeAccount.Parameters<chain>,\n): Promise<prepareUpgradeAccount.ReturnType> {\n  const { address, authorizeKeys: keys, chain = client.chain } = parameters\n\n  if (!chain) throw new Error('chain is required.')\n\n  const {\n    contracts,\n    fees: { tokens },\n  } = await RelayActions.getCapabilities(client, { chainId: chain.id })\n\n  const delegation = parameters.delegation ?? contracts.accountProxy.address\n  const hasSessionKey = keys.some((x) => x.role === 'session')\n  const orchestrator = hasSessionKey\n    ? contracts.orchestrator.address\n    : undefined\n\n  const authorizeKeys = keys.map((key) => {\n    const permissions = key.role === 'session' ? key.permissions : {}\n    return Key.toRelay(\n      { ...key, permissions },\n      { feeTokens: tokens, orchestrator },\n    )\n  })\n\n  const { capabilities, chainId, context, digests, typedData } =\n    await RelayActions.prepareUpgradeAccount(client, {\n      address,\n      authorizeKeys,\n      chain,\n      delegation,\n    })\n\n  const account = Account.from({\n    address,\n    keys,\n  })\n\n  return {\n    capabilities,\n    chainId,\n    context: {\n      ...context,\n      account,\n    },\n    digests,\n    typedData,\n  }\n}\n\nexport declare namespace prepareUpgradeAccount {\n  export type Parameters<chain extends Chain | undefined = Chain | undefined> =\n    GetChainParameter<chain> & {\n      /** Address of the account to upgrade. */\n      address: Address.Address\n      /** Keys to authorize. */\n      authorizeKeys: readonly Key.Key[]\n      /** Contract address to delegate to. */\n      delegation?: Address.Address | undefined\n      /** Fee token. */\n      feeToken?: Address.Address | undefined\n    }\n\n  export type ReturnType = Omit<\n    RelayActions.prepareUpgradeAccount.ReturnType,\n    'context'\n  > & {\n    context: RelayActions.prepareUpgradeAccount.ReturnType['context'] & {\n      account: Account.Account\n    }\n  }\n\n  export type ErrorType =\n    | RelayActions.prepareUpgradeAccount.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Resends phone verification code for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function resendVerifyPhone<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: resendVerifyPhone.Parameters,\n): Promise<resendVerifyPhone.ReturnType>\nexport async function resendVerifyPhone(\n  client: Client,\n  parameters: resendVerifyPhone.Parameters,\n) {\n  const { phone, walletAddress } = parameters\n  return await RelayActions.resendVerifyPhone(client, {\n    phone,\n    walletAddress,\n  })\n}\n\nexport declare namespace resendVerifyPhone {\n  export type Parameters = RelayActions.resendVerifyPhone.Parameters\n\n  export type ReturnType = RelayActions.resendVerifyPhone.ReturnType\n\n  export type ErrorType =\n    | RelayActions.resendVerifyPhone.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Broadcasts a call bundle to the Relay.\n *\n * @example\n * TODO\n *\n * @param client - Client.\n * @param parameters - Parameters.\n * @returns Bundle identifier.\n */\nexport async function sendCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: sendCalls.Parameters<calls, chain, account>,\n): Promise<sendCalls.ReturnType> {\n  const {\n    account = client.account,\n    chain = client.chain,\n    webAuthn,\n  } = parameters\n\n  if (!chain) throw new Error('`chain` is required.')\n\n  // If no signature is provided, prepare the calls and sign them.\n  const account_ = account ? Account.from(account) : undefined\n  if (!account_) throw new Error('`account` is required.')\n\n  const key = parameters.key ?? Account.getKey(account_, parameters)\n  if (!key && !account_.sign)\n    throw new Error('`key` or `account` with `sign` is required')\n\n  // Prepare pre-calls.\n  const preCalls = await Promise.all(\n    (parameters.preCalls ?? []).map(async (pre) => {\n      if (pre.signature) return pre\n\n      const { authorizeKeys, key, calls, revokeKeys } = pre\n      const { context, digest } = await prepareCalls(client, {\n        account: account_,\n        authorizeKeys,\n        calls,\n        chain,\n        feeToken: parameters.feeToken,\n        key,\n        preCalls: true,\n        revokeKeys,\n      })\n      const signature = await Key.sign(key, {\n        address: null,\n        payload: digest,\n        webAuthn,\n      })\n      return { context, signature }\n    }),\n  )\n\n  // Prepare main bundle.\n  const { capabilities, context, digest } = await prepareCalls(client, {\n    ...parameters,\n    account: account_,\n    chain,\n    key,\n    preCalls,\n  } as never)\n\n  // Sign over the bundles.\n  const signature = await (async () => {\n    if (key)\n      return await Key.sign(key, {\n        address: null,\n        payload: digest,\n        webAuthn,\n        wrap: false,\n      })\n    return await account_.sign({\n      hash: digest,\n    })\n  })()\n\n  // Broadcast the bundle to the Relay.\n  return await sendPreparedCalls(client, {\n    capabilities: capabilities.feeSignature\n      ? {\n          feeSignature: capabilities.feeSignature,\n        }\n      : undefined,\n    context,\n    key,\n    signature,\n  })\n}\n\nexport declare namespace sendCalls {\n  export type Parameters<\n    calls extends readonly unknown[] = readonly unknown[],\n    chain extends Chain | undefined = Chain | undefined,\n    account extends Account.Account | undefined = Account.Account | undefined,\n  > = Omit<\n    prepareCalls.Parameters,\n    'account' | 'calls' | 'chain' | 'key' | 'preCalls'\n  > &\n    GetAccountParameter<account> &\n    GetChainParameter<chain> & {\n      /** Calls to execute. */\n      calls?: Calls<Narrow<calls>> | undefined\n      /** Key to sign the bundle with. */\n      key?: Key.Key | undefined\n      /** Calls to execute before the main bundle. */\n      preCalls?:\n        | readonly OneOf<\n            | {\n                context: prepareCalls.ReturnType['context']\n                signature: Hex.Hex\n              }\n            | (Pick<\n                prepareCalls.Parameters<calls>,\n                'authorizeKeys' | 'calls' | 'revokeKeys'\n              > & {\n                key: Key.Key\n              })\n          >[]\n        | undefined\n      /** Merchant RPC URL. */\n      merchantUrl?: string | undefined\n      webAuthn?: relay.Parameters['webAuthn']\n    }\n\n  export type ReturnType = RelayActions.sendPreparedCalls.ReturnType\n\n  export type ErrorType =\n    | RelayActions.sendPreparedCalls.ErrorType\n    | Errors.GlobalErrorType\n}\n\nexport async function signCalls(\n  request: prepareCalls.ReturnType,\n  options: signCalls.Options,\n) {\n  const isPrecall = Boolean(request.context.preCall)\n  const { account, key } = options\n\n  if (account) {\n    const keyIndex = account.keys?.findIndex(\n      (k) => k.publicKey === request.key?.publicKey,\n    )\n    if (keyIndex === -1) throw new Error('key not found')\n    return await Account.sign(account, {\n      key: keyIndex,\n      payload: request.digest,\n      replaySafe: false,\n      wrap: isPrecall,\n    })\n  }\n  if (key)\n    return await Key.sign(key, {\n      address: null,\n      payload: request.digest,\n      wrap: isPrecall,\n    })\n  throw new Error('no key or account provided')\n}\n\nexport declare namespace signCalls {\n  export type Options = OneOf<\n    | {\n        account: Account.Account\n      }\n    | {\n        key: Key.Key\n      }\n  >\n}\n\nexport async function sendPreparedCalls(\n  client: Client,\n  parameters: sendPreparedCalls.Parameters,\n): Promise<sendPreparedCalls.ReturnType> {\n  const { capabilities, context, key, signature } = parameters\n  return await RelayActions.sendPreparedCalls(client, {\n    capabilities,\n    context,\n    key: key ? Key.toRelay(key) : undefined,\n    signature,\n  })\n}\n\nexport declare namespace sendPreparedCalls {\n  export type Parameters = {\n    /** Capabilities. */\n    capabilities?:\n      | RelayActions.sendPreparedCalls.Parameters['capabilities']\n      | undefined\n    /** Context. */\n    context: prepareCalls.ReturnType['context']\n    /** Key. */\n    key?: Pick<Key.Key, 'publicKey' | 'prehash' | 'type'> | undefined\n    /** Signature. */\n    signature: Hex.Hex\n  }\n\n  export type ReturnType = RelayActions.sendPreparedCalls.ReturnType\n\n  export type ErrorType = RelayActions.sendPreparedCalls.ErrorType\n}\n\n/**\n * Sets email for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function setEmail<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: setEmail.Parameters,\n): Promise<setEmail.ReturnType>\nexport async function setEmail(\n  client: Client,\n  parameters: setEmail.Parameters,\n) {\n  const { email, walletAddress } = parameters\n  return await RelayActions.setEmail(client, {\n    email,\n    walletAddress,\n  })\n}\n\nexport declare namespace setEmail {\n  export type Parameters = RelayActions.setEmail.Parameters\n\n  export type ReturnType = RelayActions.setEmail.ReturnType\n\n  export type ErrorType =\n    | RelayActions.setEmail.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Sets phone for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function setPhone<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: setPhone.Parameters,\n): Promise<setPhone.ReturnType>\nexport async function setPhone(\n  client: Client,\n  parameters: setPhone.Parameters,\n) {\n  const { phone, walletAddress } = parameters\n  return await RelayActions.setPhone(client, {\n    phone,\n    walletAddress,\n  })\n}\n\nexport declare namespace setPhone {\n  export type Parameters = RelayActions.setPhone.Parameters\n\n  export type ReturnType = RelayActions.setPhone.ReturnType\n\n  export type ErrorType =\n    | RelayActions.setPhone.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Broadcasts an account upgrade.\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\n// @ts-expect-error\nexport async function upgradeAccount<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: upgradeAccount.Parameters<chain>,\n): Promise<upgradeAccount.ReturnType>\nexport async function upgradeAccount(\n  client: Client,\n  parameters: upgradeAccount.Parameters,\n) {\n  if (parameters.account) {\n    const { account } = parameters\n    const authorizeKeys = [\n      ...(account.keys ?? []),\n      ...(parameters.authorizeKeys ?? []),\n    ].filter(\n      (key, index, array) => array.findIndex((k) => k.id === key.id) === index,\n    )\n    const { digests, ...request } = await prepareUpgradeAccount(client, {\n      ...parameters,\n      address: account.address,\n      authorizeKeys,\n    })\n\n    const signatures = {\n      auth: await account.sign({ hash: digests.auth }),\n      exec: await account.sign({ hash: digests.exec }),\n    }\n\n    return await upgradeAccount(client, {\n      ...request,\n      signatures,\n    })\n  }\n\n  const { context, signatures } = parameters\n\n  const account = Account.from(context.account)\n\n  await RelayActions.upgradeAccount(client, {\n    context,\n    signatures,\n  })\n\n  return account\n}\n\nexport declare namespace upgradeAccount {\n  type Parameters<chain extends Chain | undefined = Chain | undefined> = OneOf<\n    PreparedParameters | UnpreparedParameters<chain>\n  >\n\n  type PreparedParameters = {\n    context: prepareUpgradeAccount.ReturnType['context']\n    signatures: RelayActions.upgradeAccount.Parameters['signatures']\n  }\n\n  type UnpreparedParameters<\n    chain extends Chain | undefined = Chain | undefined,\n  > = PartialBy<\n    Omit<prepareUpgradeAccount.Parameters<chain>, 'address'>,\n    'authorizeKeys'\n  > & {\n    account: Account.Account<'privateKey'>\n  }\n\n  type ReturnType = RequiredBy<Account.Account, 'keys'>\n\n  type ErrorType =\n    | RelayActions.upgradeAccount.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies email for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function verifyEmail<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: verifyEmail.Parameters,\n): Promise<verifyEmail.ReturnType>\nexport async function verifyEmail(\n  client: Client,\n  parameters: verifyEmail.Parameters,\n) {\n  const { chainId, email, signature, token, walletAddress } = parameters\n  return await RelayActions.verifyEmail(client, {\n    chainId,\n    email,\n    signature,\n    token,\n    walletAddress,\n  })\n}\n\nexport declare namespace verifyEmail {\n  export type Parameters = RelayActions.verifyEmail.Parameters\n\n  export type ReturnType = RelayActions.verifyEmail.ReturnType\n\n  export type ErrorType =\n    | RelayActions.verifyEmail.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies phone for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function verifyPhone<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: verifyPhone.Parameters,\n): Promise<verifyPhone.ReturnType>\nexport async function verifyPhone(\n  client: Client,\n  parameters: verifyPhone.Parameters,\n) {\n  const { code, phone, walletAddress } = parameters\n  return await RelayActions.verifyPhone(client, {\n    code,\n    phone,\n    walletAddress,\n  })\n}\n\nexport declare namespace verifyPhone {\n  export type Parameters = RelayActions.verifyPhone.Parameters\n\n  export type ReturnType = RelayActions.verifyPhone.ReturnType\n\n  export type ErrorType =\n    | RelayActions.verifyPhone.ErrorType\n    | Errors.GlobalErrorType\n}\n\nexport type Decorator<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account.Account | undefined = Account.Account | undefined,\n> = {\n  /**\n   * Creates a new Porto Account using an ephemeral EOA.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - Client.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  createAccount: (\n    parameters: createAccount.Parameters<chain>,\n  ) => Promise<createAccount.ReturnType>\n  /**\n   * Gets the status of a call bundle.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - The client to use.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  getCallsStatus: (\n    parameters: RelayActions.getCallsStatus.Parameters,\n  ) => Promise<RelayActions.getCallsStatus.ReturnType>\n  /**\n   * Gets the capabilities for a given chain ID.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - The client to use.\n   * @param options - Options.\n   * @returns Result.\n   */\n  getCapabilities: <\n    const chainIds extends readonly number[] | undefined = undefined,\n    const raw extends boolean = false,\n  >() => Promise<RelayActions.getCapabilities.ReturnType<chainIds, raw>>\n  /**\n   * Gets the keys for a given account.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - The client to use.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  getKeys: (\n    parameters: getKeys.Parameters<account>,\n  ) => Promise<getKeys.ReturnType>\n  /**\n   * Gets the health of the RPC.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - The client to use.\n   * @returns Result.\n   */\n  health: () => Promise<RelayActions.health.ReturnType>\n  /**\n   * Prepares a call bundle.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - The client to use.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  prepareCalls: <const calls extends readonly unknown[]>(\n    parameters: prepareCalls.Parameters<calls, chain, account>,\n  ) => Promise<prepareCalls.ReturnType>\n  /**\n   * Prepares an account upgrade.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - Client to use.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  prepareUpgradeAccount: (\n    parameters: prepareUpgradeAccount.Parameters<chain>,\n  ) => Promise<prepareUpgradeAccount.ReturnType>\n  /**\n   * Broadcasts a call bundle.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - Client to use.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  sendCalls: <const calls extends readonly unknown[]>(\n    parameters: sendCalls.Parameters<calls, chain, account>,\n  ) => Promise<sendCalls.ReturnType>\n  /**\n   * Broadcasts a signed call bundle.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - The client to use.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  sendPreparedCalls: (\n    parameters: sendPreparedCalls.Parameters,\n  ) => Promise<sendPreparedCalls.ReturnType>\n  /**\n   * Broadcasts an account upgrade.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - Client to use.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  upgradeAccount: (\n    parameters: upgradeAccount.Parameters<chain>,\n  ) => Promise<upgradeAccount.ReturnType>\n  /**\n   * Verifies a signature.\n   *\n   * @example\n   * TODO\n   *\n   * @param client - The client to use.\n   * @param parameters - Parameters.\n   * @returns Result.\n   */\n  verifySignature: (\n    parameters: RelayActions.verifySignature.Parameters<chain>,\n  ) => Promise<RelayActions.verifySignature.ReturnType>\n}\n\nexport function decorator<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  account extends Account.Account | undefined,\n>(client: Client<transport, chain, account>): Decorator<chain, account> {\n  return {\n    createAccount: (parameters) => createAccount(client, parameters),\n    getCallsStatus: (parameters) =>\n      RelayActions.getCallsStatus(client, parameters),\n    getCapabilities: () => RelayActions.getCapabilities(client),\n    getKeys: (parameters) => getKeys(client, parameters),\n    health: () => RelayActions.health(client),\n    prepareCalls: (parameters) => prepareCalls(client, parameters),\n    prepareUpgradeAccount: (parameters) =>\n      prepareUpgradeAccount(client, parameters),\n    sendCalls: (parameters) => sendCalls(client, parameters),\n    sendPreparedCalls: (parameters) => sendPreparedCalls(client, parameters),\n    upgradeAccount: (parameters) => upgradeAccount(client, parameters),\n    verifySignature: (parameters) =>\n      RelayActions.verifySignature(client, parameters),\n  }\n}\n","import { type Chain, defineChain } from 'viem'\nimport { anvil as viem_anvil } from 'viem/chains'\nimport * as chains from './internal/_generated/chains.js'\n\nexport type { Chain } from 'viem/chains'\nexport * from './internal/_generated/chains.js'\n\nexport const all = [\n  chains.base,\n  ...Object.values(chains).filter((c) => c && c.id !== chains.base.id),\n] as const satisfies [Chain, ...Chain[]]\n\nexport const anvil = viem_anvil\n\n/** Additional Anvil environment, purposed for interop. */\nexport const anvil2 = /*#__PURE__*/ defineChain({\n  ...anvil,\n  id: 31_338,\n})\n\n/** Additional Anvil environment, purposed for interop. */\nexport const anvil3 = /*#__PURE__*/ defineChain({\n  ...anvil,\n  id: 31_339,\n})\n","import type * as Address from 'ox/Address'\nimport type * as z from 'zod/mini'\n\nimport * as Key from '../../viem/Key.js'\nimport * as Permissions_ from './schema/permissions.js'\n\nexport const Schema = Permissions_.Permissions\n\nexport type Permissions = z.infer<typeof Schema>\n\nexport function fromKey(key: Key.Key, options: fromKey.Options): Permissions {\n  const { chainId, expiry, permissions, id, publicKey, type } = key\n  const { address } = options\n  return {\n    address,\n    chainId,\n    expiry,\n    id,\n    key: {\n      publicKey,\n      type,\n    },\n    permissions: (permissions ?? {}) as never,\n  }\n}\n\nexport declare namespace fromKey {\n  export type Options = {\n    address: Address.Address\n  }\n}\n\nexport function toKey(permissions: Permissions): Key.Key {\n  const { chainId, expiry, key } = permissions\n  return Key.from({\n    chainId,\n    expiry,\n    permissions: permissions.permissions ?? {},\n    publicKey: key.publicKey,\n    role: 'session',\n    type: key.type,\n  })\n}\n","// Generated by `pnpm gen:chains`\nexport {\n  arbitrum,\n  arbitrumSepolia,\n  base,\n  baseSepolia,\n  berachain,\n  berachainBepolia,\n  bsc,\n  celo,\n  gnosis,\n  hoodi,\n  katana,\n  mainnet,\n  optimism,\n  optimismSepolia,\n  polygon,\n  sepolia,\n} from 'viem/chains'","export const abi = [\n  {\n    type: 'fallback',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'receive',\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'execute',\n    inputs: [\n      {\n        name: 'mode',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n      {\n        name: 'executionData',\n        type: 'bytes',\n        internalType: 'bytes',\n      },\n    ],\n    outputs: [],\n    stateMutability: 'payable',\n  },\n  {\n    type: 'function',\n    name: 'supportsExecutionMode',\n    inputs: [\n      {\n        name: 'mode',\n        type: 'bytes32',\n        internalType: 'bytes32',\n      },\n    ],\n    outputs: [\n      {\n        name: 'result',\n        type: 'bool',\n        internalType: 'bool',\n      },\n    ],\n    stateMutability: 'view',\n  },\n  {\n    type: 'error',\n    name: 'FnSelectorNotRecognized',\n    inputs: [],\n  },\n  {\n    type: 'error',\n    name: 'UnsupportedExecutionMode',\n    inputs: [],\n  },\n] as const\n\nexport const executionMode = {\n  default: '0x0100000000000000000000000000000000000000000000000000000000000000',\n  opData: '0x0100000000007821000100000000000000000000000000000000000000000000',\n  batchOfBatches:\n    '0x0100000000007821000200000000000000000000000000000000000000000000',\n} as const\n","import * as Json from 'ox/Json'\nimport type * as RpcRequest from 'ox/RpcRequest'\nimport type * as RpcResponse from 'ox/RpcResponse'\nimport type * as MethodPolicies from '../remote/internal/methodPolicies.js'\nimport type * as Theme from '../theme/Theme.js'\nimport * as promise from './internal/promise.js'\nimport * as Utils from './internal/utils.js'\nimport type * as Porto from './Porto.js'\n\n/** Messenger interface. */\nexport type Messenger = {\n  destroy: () => void\n  on: <const topic extends Topic>(\n    topic: topic | Topic,\n    listener: (payload: Payload<topic>, event: MessageEvent) => void,\n    id?: string | undefined,\n  ) => () => void\n  send: <const topic extends Topic>(\n    topic: topic | Topic,\n    payload: Payload<topic>,\n    targetOrigin?: string | undefined,\n  ) => Promise<{ id: string; topic: topic; payload: Payload<topic> }>\n  sendAsync: <const topic extends Topic>(\n    topic: topic | Topic,\n    payload: Payload<topic>,\n    targetOrigin?: string | undefined,\n  ) => Promise<Response<topic>>\n}\n\nexport type WithReady = Messenger & {\n  ready: (options: ReadyOptions) => void\n}\n\nexport type ReadyOptions = {\n  chainIds: readonly [number, ...number[]]\n  methodPolicies?: MethodPolicies.MethodPolicies | undefined\n  trustedHosts?: string[] | undefined\n}\n\n/** Bridge messenger. */\nexport type Bridge = WithReady & {\n  waitForReady: () => Promise<ReadyOptions>\n}\n\n/** CLI relay messenger. */\nexport type CliRelay = WithReady\n\n/** Messenger schema. */\nexport type Schema = [\n  {\n    topic: 'close'\n    payload: undefined\n    response: undefined\n  },\n  {\n    topic: 'ready'\n    payload: ReadyOptions\n    response: undefined\n  },\n  {\n    topic: 'rpc-requests'\n    payload: readonly Porto.QueuedRequest[]\n    response: undefined\n  },\n  {\n    topic: 'rpc-response'\n    payload: RpcResponse.RpcResponse & {\n      _request: RpcRequest.RpcRequest\n    }\n    response: undefined\n  },\n  {\n    topic: 'success'\n    payload: {\n      title: string\n      content: string\n    }\n    response: undefined\n  },\n  {\n    topic: '__internal'\n    payload:\n      | {\n          type: 'init'\n          chainIds?: readonly number[] | undefined\n          mode:\n            | 'inline-iframe'\n            | 'iframe'\n            | 'popup'\n            | 'popup-standalone'\n            | 'page'\n          referrer: {\n            icon?: string | { light: string; dark: string } | undefined\n            title: string\n          }\n          theme?: Theme.ThemeFragment | undefined\n        }\n      | {\n          type: 'switch'\n          mode:\n            | 'inline-iframe'\n            | 'iframe'\n            | 'popup'\n            | 'popup-standalone'\n            | 'page'\n        }\n      | {\n          type: 'resize'\n          height?: number | undefined\n          width?: number | undefined\n        }\n      | {\n          type: 'set-theme'\n          theme: Theme.ThemeFragment\n        }\n      | {\n          // backward compatibility from 0.2.7 (to be removed in a future version)\n          type: 'dialog-lifecycle'\n          action: 'request:close' | 'done:close'\n        }\n    response: undefined\n  },\n]\n\nexport type Topic = Schema[number]['topic']\n\nexport type Payload<topic extends Topic> = Extract<\n  Schema[number],\n  { topic: topic }\n>['payload']\n\nexport type Response<topic extends Topic> = Extract<\n  Schema[number],\n  { topic: topic }\n>['response']\n\n/**\n * Instantiates a messenger.\n *\n * @param messenger - Messenger.\n * @returns Instantiated messenger.\n */\nexport function from(messenger: Messenger): Messenger {\n  return messenger\n}\n\n/**\n * Instantiates a messenger from a window instance.\n *\n * @param w - Window.\n * @param options - Options.\n * @returns Instantiated messenger.\n */\nexport function fromWindow(\n  w: Window,\n  options: fromWindow.Options = {},\n): Messenger {\n  const { targetOrigin } = options\n  const listeners = new Map<string, (event: any) => any>()\n  return from({\n    destroy() {\n      for (const listener of listeners.values()) {\n        w.removeEventListener('message', listener)\n      }\n    },\n    on(topic, listener, id) {\n      function handler(event: MessageEvent) {\n        if (event.data.topic !== topic) return\n        if (id && event.data.id !== id) return\n        if (targetOrigin && event.origin !== targetOrigin) return\n        listener(event.data.payload, event)\n      }\n      w.addEventListener('message', handler)\n      listeners.set(topic, handler)\n      return () => w.removeEventListener('message', handler)\n    },\n    async send(topic, payload, target) {\n      const id = Utils.uuidv4()\n      w.postMessage(\n        Utils.normalizeValue({ id, payload, topic }),\n        target ?? targetOrigin ?? '*',\n      )\n      return { id, payload, topic } as never\n    },\n    async sendAsync(topic, payload, target) {\n      const { id } = await this.send(topic, payload, target)\n      return new Promise<any>((resolve) => this.on(topic as Topic, resolve, id))\n    },\n  })\n}\n\nexport declare namespace fromWindow {\n  export type Options = {\n    /**\n     * Target origin.\n     */\n    targetOrigin?: string | undefined\n  }\n}\n\n/**\n * Bridges two messengers for cross-window (e.g. parent to iframe) communication.\n *\n * @param parameters - Parameters.\n * @returns Instantiated messenger.\n */\nexport function bridge(parameters: bridge.Parameters): Bridge {\n  const { from: from_, to, waitForReady = false } = parameters\n\n  let pending = false\n\n  const ready = promise.withResolvers<ReadyOptions>()\n  from_.on('ready', ready.resolve)\n\n  const messenger = from({\n    destroy() {\n      from_.destroy()\n      to.destroy()\n      if (pending) ready.reject()\n    },\n    on(topic, listener, id) {\n      return from_.on(topic, listener, id)\n    },\n    async send(topic, payload) {\n      pending = true\n      if (waitForReady) await ready.promise.finally(() => (pending = false))\n      return to.send(topic, payload)\n    },\n    async sendAsync(topic, payload) {\n      pending = true\n      if (waitForReady) await ready.promise.finally(() => (pending = false))\n      return to.sendAsync(topic, payload)\n    },\n  })\n\n  return {\n    ...messenger,\n    ready(options) {\n      void messenger.send('ready', options)\n    },\n    waitForReady() {\n      return ready.promise\n    },\n  }\n}\n\nexport declare namespace bridge {\n  export type Parameters = {\n    /**\n     * Source messenger.\n     */\n    from: Messenger\n    /**\n     * Target messenger.\n     */\n    to: Messenger\n    /**\n     * Whether to wait for the target messenger to indicate that it is ready via\n     * `messenger.ready()`.\n     */\n    waitForReady?: boolean | undefined\n  }\n}\n\nexport function noop(): Bridge {\n  return {\n    destroy() {},\n    on() {\n      return () => {}\n    },\n    ready() {},\n    send() {\n      return Promise.resolve(undefined as never)\n    },\n    sendAsync() {\n      return Promise.resolve(undefined as never)\n    },\n    waitForReady() {\n      return Promise.resolve(undefined as never)\n    },\n  }\n}\n\n/**\n * Creates a CLI relay messenger that sends messages via fetch to a relay URL\n * and receives events via server-sent events.\n *\n * @param options - Options.\n * @returns Local relay messenger.\n */\nexport function cliRelay(options: cliRelay.Options): CliRelay {\n  const { relayUrl } = options\n\n  let eventSource: EventSource | null = null\n  const listenerSets = new Map<\n    string,\n    Set<(payload: any, event: any) => void>\n  >()\n\n  function connect() {\n    if (!relayUrl || eventSource) return\n\n    eventSource = new EventSource(relayUrl)\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data)\n        if (!data.topic) return\n        if (!data.payload) return\n\n        const listeners = listenerSets.get(data.topic)\n        if (!listeners) return\n\n        for (const listener of listeners)\n          listener(data.payload, { data, origin: relayUrl })\n      } catch (error) {\n        console.error('Error parsing SSE message:', error)\n      }\n    }\n\n    eventSource.onerror = (error) => {\n      console.error('SSE connection error:', error)\n      eventSource?.close()\n      eventSource = null\n      // attempt to reconnect in 1s\n      setTimeout(connect, 1000)\n    }\n  }\n  connect()\n\n  async function request(topic: Topic, payload: any) {\n    const id = Utils.uuidv4()\n    const data = { id, payload, topic }\n\n    const response = await fetch(relayUrl, {\n      body: Json.stringify(data),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    })\n\n    return { id, payload, response, topic }\n  }\n\n  return {\n    destroy() {\n      eventSource?.close()\n      eventSource = null\n      listenerSets.clear()\n    },\n    on(topic, listener) {\n      if (!listenerSets.has(topic)) listenerSets.set(topic, new Set())\n      listenerSets.get(topic)!.add(listener)\n\n      return () => {\n        const listeners = listenerSets.get(topic)\n        if (!listeners) return\n\n        listeners.delete(listener)\n        if (listeners.size === 0) listenerSets.delete(topic)\n      }\n    },\n    async ready(options) {\n      await new Promise((resolve) => setTimeout(resolve, 32))\n      void this.send('ready', options)\n    },\n    async send(topic, payload) {\n      const { id } = await request(topic, payload)\n      return { id, payload, topic } as never\n    },\n    async sendAsync(topic, payload) {\n      const { response } = await request(topic, payload)\n\n      if (!response.ok)\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n\n      const contentType = response.headers.get('content-type')\n      if (contentType?.includes('application/json'))\n        return await response.json()\n\n      return undefined as never\n    },\n  }\n}\n\nexport declare namespace cliRelay {\n  export type Options = {\n    /**\n     * Relay URL for both sending messages (POST) and receiving events (GET).\n     */\n    relayUrl: string\n  }\n}\n","import { p256 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPair(\n  options: createKeyPair.Options = {},\n): Promise<createKeyPair.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['sign', 'verify'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates an ECDH P256 key pair for key agreement that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * - a `publicKey` of type {@link ox#PublicKey.PublicKey}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPairECDH()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPairECDH(\n  options: createKeyPairECDH.Options = {},\n): Promise<createKeyPairECDH.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['deriveKey', 'deriveBits'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPairECDH {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key using Web Crypto APIs.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = await WebCryptoP256.createKeyPairECDH()\n * const { publicKey: publicKeyB } = await WebCryptoP256.createKeyPairECDH()\n *\n * const sharedSecret = await WebCryptoP256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport async function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): Promise<getSharedSecret.ReturnType<as>> {\n  const { as = 'Hex', privateKey, publicKey } = options\n\n  if (privateKey.algorithm.name === 'ECDSA') {\n    throw new Error(\n      'privateKey is not compatible with ECDH. please use `createKeyPairECDH` to create an ECDH key.',\n    )\n  }\n\n  const publicKeyCrypto = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(publicKey),\n    { name: 'ECDH', namedCurve: 'P-256' },\n    false,\n    [],\n  )\n\n  const sharedSecretBuffer = await globalThis.crypto.subtle.deriveBits(\n    {\n      name: 'ECDH',\n      public: publicKeyCrypto,\n    },\n    privateKey,\n    256, // 32 bytes * 8 bits/byte\n  )\n\n  const sharedSecret = new Uint8Array(sharedSecretBuffer)\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation (must be a CryptoKey for ECDH).\n     */\n    privateKey: CryptoKey\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | PublicKey.toBytes.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nexport async function sign(\n  options: sign.Options,\n): Promise<Signature.Signature<false>> {\n  const { payload, privateKey } = options\n  const signature = await globalThis.crypto.subtle.sign(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    privateKey,\n    Bytes.from(payload),\n  )\n  const signature_bytes = Bytes.fromArray(new Uint8Array(signature))\n  const r = Bytes.toBigInt(Bytes.slice(signature_bytes, 0, 32))\n  let s = Bytes.toBigInt(Bytes.slice(signature_bytes, 32, 64))\n  if (s > p256.CURVE.n / 2n) s = p256.CURVE.n - s\n  return { r, s }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /** Payload to sign. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** ECDSA private key. */\n    privateKey: CryptoKey\n  }\n\n  type ErrorType = Bytes.fromArray.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport async function verify(options: verify.Options): Promise<boolean> {\n  const { payload, signature } = options\n\n  const publicKey = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(options.publicKey),\n    { name: 'ECDSA', namedCurve: 'P-256' },\n    true,\n    ['verify'],\n  )\n\n  return await globalThis.crypto.subtle.verify(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    publicKey,\n    Bytes.concat(Bytes.fromNumber(signature.r), Bytes.fromNumber(signature.s)),\n    Bytes.from(payload),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<false>\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","/** @internal */\nexport type PromiseWithResolvers<type> = {\n  promise: Promise<type>\n  resolve: (value: type | PromiseLike<type>) => void\n  reject: (reason?: unknown) => void\n}\n\n/** @internal */\nexport function withResolvers<type>(): PromiseWithResolvers<type> {\n  let resolve: PromiseWithResolvers<type>['resolve'] = () => undefined\n  let reject: PromiseWithResolvers<type>['reject'] = () => undefined\n\n  const promise = new Promise<type>((resolve_, reject_) => {\n    resolve = resolve_\n    reject = reject_\n  })\n\n  return { promise, reject, resolve }\n}\n","import type * as Address from 'ox/Address'\nimport type * as Hex from 'ox/Hex'\nimport type * as z from 'zod/mini'\nimport * as Key from '../../viem/Key.js'\nimport * as Permissions from './schema/permissions.js'\nimport type * as Tokens from './tokens.js'\n\nexport const Schema = Permissions.Request\n\nexport type PermissionsRequest = z.infer<typeof Schema>\n\nexport function fromKey(key: Key.Key): PermissionsRequest {\n  const { expiry, feeToken, permissions, publicKey, type } = key\n  return {\n    expiry,\n    feeToken: feeToken ?? null,\n    key: {\n      publicKey,\n      type,\n    },\n    permissions: (permissions ?? {}) as never,\n  }\n}\n\nexport declare namespace fromKey {\n  export type Options = {\n    address: Address.Address\n    chainId?: Hex.Hex | undefined\n  }\n}\n\nexport async function toKey(\n  request: PermissionsRequest | undefined,\n  options: toKey.Options = {},\n): Promise<Key.Key | undefined> {\n  if (!request) return undefined\n\n  const chainId = options.chainId ?? request.chainId\n  const expiry = request.expiry ?? 0\n  const feeToken = request.feeToken\n  const permissions = Key.resolvePermissions(request, {\n    feeTokens: options.feeTokens,\n  })\n  const baseParameters = {\n    chainId,\n    expiry,\n    feeToken,\n    permissions,\n    role: 'session' as const,\n  }\n\n  if (request?.key)\n    return Key.from({\n      ...baseParameters,\n      publicKey: request.key.publicKey,\n      type: request.key.type ?? 'secp256k1',\n    })\n\n  const hasWebCryptoSubtle =\n    typeof globalThis.crypto?.subtle?.generateKey === 'function'\n\n  if (hasWebCryptoSubtle)\n    try {\n      return await Key.createWebCryptoP256(baseParameters)\n    } catch (error) {\n      if (!isWebCryptoUnavailable(error)) throw error\n    }\n\n  return Key.createP256(baseParameters)\n}\n\nexport declare namespace toKey {\n  export type Options = {\n    chainId?: number | undefined\n    feeTokens?: Tokens.Tokens | undefined\n  }\n}\n\nfunction isWebCryptoUnavailable(error: unknown) {\n  if (!(error instanceof Error)) return false\n  const message = error.message?.toLowerCase() ?? ''\n  return (\n    error.name === 'TypeError' ||\n    error.name === 'ReferenceError' ||\n    message.includes('subtle') ||\n    message.includes('generatekey')\n  )\n}\n","import type * as Address from 'ox/Address'\nimport type * as Hex from 'ox/Hex'\nimport * as Siwe from 'ox/Siwe'\nimport type { Chain, Client, Transport } from 'viem'\nimport type * as Capabilities from './schema/capabilities.js'\n\n/** Set of authentication endpoints. */\nexport type AuthUrl = {\n  /** Endpoint to logout the user. (e.g. `/logout`) */\n  logout: string\n  /** Endpoint to generate a nonce. (e.g. `/nonce`) */\n  nonce: string\n  /** Endpoint to verify the signature, and authenticate the user. (e.g. `/verify`) */\n  verify: string\n}\n\nexport async function authenticate(\n  parameters: authenticate.Parameters,\n): Promise<authenticate.ReturnType> {\n  const { address, authUrl, message, signature, publicKey } = parameters\n\n  const { chainId } = Siwe.parseMessage(message)\n\n  return await fetch(authUrl.verify, {\n    body: JSON.stringify({\n      address,\n      chainId,\n      message,\n      signature,\n      walletAddress: address,\n      ...(publicKey && { publicKey }),\n    }),\n    credentials: 'include',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    method: 'POST',\n  }).then((res) => res.json())\n}\n\nexport declare namespace authenticate {\n  type Parameters = {\n    address: Address.Address\n    authUrl: AuthUrl\n    message: string\n    publicKey?: Hex.Hex | undefined\n    signature: Hex.Hex\n  }\n\n  type ReturnType = {\n    token?: string | undefined\n  }\n}\n\nexport async function buildMessage<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  siwe: Capabilities.signInWithEthereum.Request,\n  options: buildMessage.Options,\n) {\n  const {\n    chainId = client.chain?.id,\n    domain,\n    uri,\n    resources,\n    version = '1',\n  } = siwe\n  const { address } = options\n\n  const authUrl = siwe.authUrl ? resolveAuthUrl(siwe.authUrl) : undefined\n\n  if (!chainId) throw new Error('`chainId` is required.')\n  if (!domain) throw new Error('`domain` is required.')\n  if (!siwe.nonce && !authUrl?.nonce)\n    throw new Error('`nonce` or `authUrl.nonce` is required.')\n  if (!uri) throw new Error('`uri` is required.')\n\n  const nonce = await (async () => {\n    if (siwe.nonce) return siwe.nonce\n    if (!authUrl?.nonce)\n      throw new Error('`nonce` or `authUrl.nonce` is required.')\n    const response = await fetch(authUrl.nonce, {\n      body: JSON.stringify({\n        address,\n        chainId,\n        walletAddress: address,\n      }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      method: 'POST',\n    })\n    const res = await response.json().catch(() => undefined)\n    if (!res?.nonce) throw new Error('`nonce` or `authUrl.nonce` is required.')\n    return res.nonce\n  })()\n\n  const message = Siwe.createMessage({\n    ...siwe,\n    address: options.address,\n    chainId,\n    domain,\n    nonce,\n    resources: resources as string[] | undefined,\n    uri,\n    version,\n  })\n\n  return message\n}\n\nexport declare namespace buildMessage {\n  type Options = {\n    address: Address.Address\n  }\n}\n\nexport function resolveAuthUrl(\n  authUrl: string | AuthUrl,\n  origin = '',\n): AuthUrl | undefined {\n  if (!authUrl) return undefined\n\n  const urls = (() => {\n    if (typeof authUrl === 'string') {\n      const url = authUrl.replace(/\\/$/, '')\n      return {\n        logout: url + '/logout',\n        nonce: url + '/nonce',\n        verify: url + '/verify',\n      }\n    }\n    return authUrl\n  })()\n\n  return {\n    logout: resolveUrl(urls.logout, origin),\n    nonce: resolveUrl(urls.nonce, origin),\n    verify: resolveUrl(urls.verify, origin),\n  }\n}\n\nfunction resolveUrl(url: string, origin: string) {\n  if (!origin) return url\n  if (!url.startsWith('/')) return url\n  return origin + url\n}\n","import { p256 } from '@noble/curves/p256'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport * as PublicKey from '../PublicKey.js'\nimport { CredentialCreationFailedError } from '../WebAuthnP256.js'\n\n/** @internal */\nexport type AttestationConveyancePreference =\n  | 'direct'\n  | 'enterprise'\n  | 'indirect'\n  | 'none'\n\n/** @internal */\nexport type AuthenticatorAttachment = 'cross-platform' | 'platform'\n\n/** @internal */\nexport type AuthenticatorTransport =\n  | 'ble'\n  | 'hybrid'\n  | 'internal'\n  | 'nfc'\n  | 'usb'\n\n/** @internal */\nexport type COSEAlgorithmIdentifier = number\n\n/** @internal */\nexport type CredentialMediationRequirement =\n  | 'conditional'\n  | 'optional'\n  | 'required'\n  | 'silent'\n\n/** @internal */\nexport type PublicKeyCredentialType = 'public-key'\n\n/** @internal */\nexport type ResidentKeyRequirement = 'discouraged' | 'preferred' | 'required'\n\n/** @internal */\nexport type UserVerificationRequirement =\n  | 'discouraged'\n  | 'preferred'\n  | 'required'\n\n/** @internal */\nexport type LargeBlobSupport = {\n  support: 'required' | 'preferred'\n}\n\n/** @internal */\nexport type BufferSource = ArrayBufferView | ArrayBuffer\n\n/** @internal */\nexport type PrfExtension = Record<'eval', Record<'first', Uint8Array>>\n\n/** @internal */\nexport interface AuthenticationExtensionsClientInputs {\n  appid?: string\n  credProps?: boolean\n  hmacCreateSecret?: boolean\n  minPinLength?: boolean\n  prf?: PrfExtension\n  largeBlob?: LargeBlobSupport\n}\n\n/** @internal */\nexport interface AuthenticatorSelectionCriteria {\n  authenticatorAttachment?: AuthenticatorAttachment\n  requireResidentKey?: boolean\n  residentKey?: ResidentKeyRequirement\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface Credential {\n  readonly id: string\n  readonly type: string\n}\n\n/** @internal */\nexport interface CredentialCreationOptions {\n  publicKey?: PublicKeyCredentialCreationOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface CredentialRequestOptions {\n  mediation?: CredentialMediationRequirement\n  publicKey?: PublicKeyCredentialRequestOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface PublicKeyCredential extends Credential {\n  readonly authenticatorAttachment: string | null\n  readonly rawId: ArrayBuffer\n  readonly response: AuthenticatorResponse\n  getClientExtensionResults(): AuthenticationExtensionsClientOutputs\n}\n\n/** @internal */\nexport interface PublicKeyCredentialCreationOptions {\n  attestation?: AttestationConveyancePreference\n  authenticatorSelection?: AuthenticatorSelectionCriteria\n  challenge: BufferSource\n  excludeCredentials?: PublicKeyCredentialDescriptor[]\n  extensions?: AuthenticationExtensionsClientInputs\n  pubKeyCredParams: PublicKeyCredentialParameters[]\n  rp: PublicKeyCredentialRpEntity\n  timeout?: number\n  user: PublicKeyCredentialUserEntity\n}\n\n/** @internal */\nexport interface PublicKeyCredentialDescriptor {\n  id: BufferSource\n  transports?: AuthenticatorTransport[]\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialEntity {\n  name: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialParameters {\n  alg: COSEAlgorithmIdentifier\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRequestOptions {\n  allowCredentials?: PublicKeyCredentialDescriptor[]\n  challenge: BufferSource\n  extensions?: AuthenticationExtensionsClientInputs\n  rpId?: string\n  timeout?: number\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {\n  id?: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialUserEntity\n  extends PublicKeyCredentialEntity {\n  displayName: string\n  id: BufferSource\n}\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nexport function parseAsn1Signature(bytes: Uint8Array) {\n  const r_start = bytes[4] === 0 ? 5 : 4\n  const r_end = r_start + 32\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2\n\n  const r = BigInt(Hex.fromBytes(bytes.slice(r_start, r_end)))\n  const s = BigInt(Hex.fromBytes(bytes.slice(s_start)))\n\n  return {\n    r,\n    s: s > p256.CURVE.n / 2n ? p256.CURVE.n - s : s,\n  }\n}\n\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nexport async function parseCredentialPublicKey(\n  response: AuthenticatorAttestationResponse,\n): Promise<PublicKey.PublicKey> {\n  try {\n    const publicKeyBuffer = response.getPublicKey()\n    if (!publicKeyBuffer) throw new CredentialCreationFailedError()\n\n    // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n    const publicKeyBytes = new Uint8Array(publicKeyBuffer)\n    const cryptoKey = await crypto.subtle.importKey(\n      'spki',\n      new Uint8Array(publicKeyBytes),\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: 'SHA-256',\n      },\n      true,\n      ['verify'],\n    )\n    const publicKey = new Uint8Array(\n      await crypto.subtle.exportKey('raw', cryptoKey),\n    )\n    return PublicKey.from(publicKey)\n  } catch (error) {\n    // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n    // so we need to use `attestationObject` to extract the public key.\n    // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n    if ((error as Error).message !== 'Permission denied to access object')\n      throw error\n\n    const data = new Uint8Array(response.attestationObject)\n    const coordinateLength = 0x20\n    const cborPrefix = 0x58\n\n    const findStart = (key: number) => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength])\n      for (let i = 0; i < data.length - coordinate.length; i++)\n        if (coordinate.every((byte, j) => data[i + j] === byte))\n          return i + coordinate.length\n      throw new CredentialCreationFailedError()\n    }\n\n    const xStart = findStart(0x21)\n    const yStart = findStart(0x22)\n\n    return PublicKey.from(\n      new Uint8Array([\n        0x04,\n        ...data.slice(xStart, xStart + coordinateLength),\n        ...data.slice(yStart, yStart + coordinateLength),\n      ]),\n    )\n  }\n}\n\nexport declare namespace parseCredentialPublicKey {\n  type ErrorType = CredentialCreationFailedError | Errors.GlobalErrorType\n}\n","export { from, type Mode } from './internal/mode.js'\nexport { dialog } from './internal/modes/dialog.js'\nexport { reactNative } from './internal/modes/reactNative.js'\nexport { relay } from './internal/modes/relay.js'\n\n// Export types required for inference.\nexport * as _internal_types from './internal/types.js'\n","import * as Json from 'ox/Json'\nimport {\n  type ClientConfig,\n  createClient,\n  fallback,\n  http,\n  type Client as viem_Client,\n} from 'viem'\nimport type * as Chains from '../core/Chains.js'\nimport type { Internal } from '../core/internal/porto.js'\nimport * as Transport from '../core/Transport.js'\nimport type * as Account from './Account.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\nexport type RelayClient<\n  transport extends Transport.Transport = Transport.Transport,\n  chain extends Chains.Chain = Chains.Chain,\n  account extends Account.Account | undefined = Account.Account | undefined,\n> = viem_Client<transport, chain, account, RpcSchema.Relay>\n\nconst clientCache = new Map<string, any>()\n\n/**\n * Extracts a Viem Client from a Porto instance, and an optional chain ID.\n * By default, the Client for the current chain ID will be extracted.\n *\n * @param porto - Porto instance.\n * @param parameters - Parameters.\n * @returns Client.\n */\nexport function fromPorto<\n  chains extends readonly [Chains.Chain, ...Chains.Chain[]],\n  account extends Account.Account | undefined = undefined,\n>(\n  porto: { _internal: Internal<chains> },\n  config: fromPorto.Config<chains, account> = {},\n): RelayClient<Transport.Transport, chains[number], account> {\n  const { config: config_, id, store } = porto._internal\n  const { chains, relay } = config_\n\n  const state = store.getState()\n  const chainId = config.chainId ?? state.chainIds[0]\n  const chain = chains.find((chain) => chain.id === chainId)\n  if (!chain)\n    throw new Error(\n      [\n        'Could not find a compatible Porto chain on the given chain configuration.',\n        '',\n        `Provided chains: [${chains.map((chain) => `${chain.name} (id: ${chain.id})`).join(', ')}]`,\n        `Needed chain (id): ${chainId}`,\n        'Please add this chain (id) to your chain configuration.',\n      ].join('\\n'),\n    )\n\n  const transport = Transport.relayProxy({\n    public:\n      (config_.transports as Record<number, Transport.Transport>)[chain.id] ??\n      fallback(chain.rpcUrls.default.http.map((url) => http(url))),\n    relay,\n  })\n\n  const key = [id, Json.stringify(chain)].filter(Boolean).join(':')\n  if (clientCache.has(key)) return clientCache.get(key)!\n  const client = createClient({\n    ...config,\n    chain,\n    pollingInterval: 1_000,\n    transport,\n  })\n  clientCache.set(key, client)\n  return client as never\n}\n\nexport declare namespace fromPorto {\n  type Config<\n    chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n      Chains.Chain,\n      ...Chains.Chain[],\n    ],\n    account extends Account.Account | undefined = Account.Account | undefined,\n  > = Pick<\n    ClientConfig<Transport.Transport, Chains.Chain | undefined, account>,\n    'account' | 'cacheTime' | 'key' | 'name' | 'pollingInterval'\n  > & {\n    chainId?: chains[number]['id'] | undefined\n  }\n}\n","import * as Mipd from 'mipd'\nimport * as Address from 'ox/Address'\nimport * as Hex from 'ox/Hex'\nimport * as Json from 'ox/Json'\nimport * as ox_Provider from 'ox/Provider'\nimport * as RpcResponse from 'ox/RpcResponse'\nimport { getAddress, type ValueOf, withCache } from 'viem'\nimport * as z from 'zod/mini'\nimport * as Account from '../../viem/Account.js'\nimport * as Actions from '../../viem/internal/relayActions.js'\nimport type * as Key from '../../viem/Key.js'\nimport * as RelayClient from '../../viem/RelayClient.js'\nimport type * as Chains from '../Chains.js'\nimport type * as Porto from '../Porto.js'\nimport type * as RpcSchema from '../RpcSchema.js'\nimport * as Permissions from './permissions.js'\nimport type * as Porto_internal from './porto.js'\nimport * as RpcRequest from './schema/request.js'\nimport * as Rpc from './schema/rpc.js'\nimport * as Store from './store.js'\nimport * as UrlString from './urlString.js'\nimport { uuidv4, withDedupe } from './utils.js'\n\nexport type Provider = ox_Provider.Provider<{\n  includeEvents: true\n  schema: RpcSchema.Schema\n}> & {\n  /**\n   * Not part of versioned API, proceed with caution.\n   * @deprecated\n   */\n  _internal: {\n    destroy: () => void\n  }\n}\n\nexport function from<\n  chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n    Chains.Chain,\n    ...Chains.Chain[],\n  ],\n>(parameters: from.Parameters<chains>): Provider {\n  const { config, getMode, id, store } = parameters\n  const { announceProvider } = config\n\n  function getCapabilities(\n    parameters: {\n      chainIds?: readonly Hex.Hex[] | undefined\n      request?: RpcRequest.Request | undefined\n    } = {},\n  ) {\n    const client = getClient()\n    const request =\n      parameters.request ??\n      RpcRequest.validate(RpcRequest.Request, {\n        method: 'wallet_getCapabilities',\n        params: parameters.chainIds\n          ? [undefined, parameters.chainIds]\n          : undefined,\n      })\n    return withCache(\n      () =>\n        getMode().actions.getCapabilities({\n          chainIds: parameters.chainIds,\n          internal: {\n            client,\n            config,\n            request,\n            store,\n          },\n        }),\n      { cacheKey: `getCapabilities.${id}.${parameters.chainIds?.join(',')}` },\n    )\n  }\n\n  function getClient(chainId_?: Hex.Hex | number | undefined) {\n    const chainId =\n      typeof chainId_ === 'string' ? Hex.toNumber(chainId_) : chainId_\n    return RelayClient.fromPorto({ _internal: parameters }, { chainId })\n  }\n\n  const lock = new Map<string, boolean>()\n  const preparedAccounts_internal: Account.Account[] = []\n\n  const emitter = ox_Provider.createEmitter()\n  const provider = ox_Provider.from({\n    ...emitter,\n    async request(request_) {\n      await Store.waitForHydration(store)\n\n      // we should deduplicate all immutable public methods to avoid\n      // unnecessary perf overhead or dialog requests.\n      const shouldDedupe = [\n        'eth_accounts',\n        'eth_chainId',\n        'eth_requestAccounts',\n        'wallet_getAssets',\n        'wallet_getCapabilities',\n        'wallet_getKeys',\n        'wallet_getPermissions',\n        'wallet_getAccountVersion',\n        'wallet_connect',\n      ].includes(request_.method)\n\n      return withDedupe(\n        async () => {\n          let request: RpcRequest.Request\n          try {\n            request = RpcRequest.validate(RpcRequest.Request, request_)\n          } catch (e) {\n            const error = e as Error\n            if (!(error instanceof RpcResponse.MethodNotSupportedError))\n              throw error\n\n            // catch unsupported methods\n            if ((request_ as { method: string }).method.startsWith('wallet_'))\n              throw new ox_Provider.UnsupportedMethodError()\n            return getClient().request(request_ as any)\n          }\n\n          const state = store.getState()\n\n          switch (request.method) {\n            case 'account_verifyEmail': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [parameters] = request._decoded.params\n              const { chainId, email, token, walletAddress } = parameters\n\n              const client = getClient(chainId)\n\n              if (chainId && chainId !== client.chain.id)\n                throw new ox_Provider.ChainDisconnectedError()\n\n              const account = walletAddress\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, walletAddress),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              return await getMode().actions.verifyEmail({\n                account,\n                chainId,\n                email,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                token,\n                walletAddress,\n              })\n            }\n\n            case 'wallet_addFunds': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const { address, value, token } = request.params[0] ?? {}\n\n              const account = address\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, address),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient()\n\n              const result = await getMode().actions.addFunds({\n                address: account.address,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                token,\n                value,\n              })\n\n              emitter.emit('message', {\n                data: null,\n                type: 'assetsChanged',\n              })\n\n              return result\n            }\n\n            case 'eth_accounts': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n              return state.accounts.map(getAccountAddress) satisfies z.input<\n                typeof Rpc.eth_accounts.Response\n              >\n            }\n\n            case 'eth_chainId': {\n              return Hex.fromNumber(state.chainIds[0]) satisfies z.input<\n                typeof Rpc.eth_chainId.Response\n              >\n            }\n\n            case 'eth_requestAccounts': {\n              // Some apps will call `eth_requestAccounts` multiple times in a short period of time.\n              // Return the cached accounts if the request is locked.\n              if (state.accounts.length > 0 && lock.get('eth_requestAccounts'))\n                return state.accounts.map(getAccountAddress) satisfies z.input<\n                  typeof Rpc.eth_requestAccounts.Response\n                >\n\n              const client = getClient()\n\n              const { accounts } = await getMode().actions.loadAccounts({\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              store.setState((x) => ({ ...x, accounts }))\n\n              emitter.emit('connect', {\n                chainId: Hex.fromNumber(client.chain.id),\n              })\n\n              lock.set('eth_requestAccounts', true)\n              setTimeout(() => lock.delete('eth_requestAccounts'), 1_000)\n\n              return accounts.map(getAccountAddress) satisfies z.input<\n                typeof Rpc.eth_requestAccounts.Response\n              >\n            }\n\n            case 'eth_sendTransaction': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ capabilities, chainId, data = '0x', from, to, value }] =\n                request._decoded.params\n\n              const client = getClient(chainId)\n\n              if (chainId && chainId !== client.chain.id)\n                throw new ox_Provider.ChainDisconnectedError()\n\n              const account = from\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, from),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const { id } = await getMode().actions.sendCalls({\n                account,\n                asTxHash: true,\n                calls: [\n                  {\n                    data,\n                    to,\n                    value,\n                  },\n                ],\n                chainId: client.chain.id,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                merchantUrl: UrlString.toAbsolute(\n                  config.merchantUrl ?? capabilities?.merchantUrl,\n                ),\n              })\n\n              return id satisfies z.input<\n                typeof Rpc.eth_sendTransaction.Response\n              >\n            }\n\n            case 'eth_signTypedData_v4': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [address, data] = request._decoded.params\n\n              const account = state.accounts.find((account) =>\n                Address.isEqual(account.address, address),\n              )\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient()\n\n              const signature = await getMode().actions.signTypedData({\n                account,\n                data,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              return signature satisfies z.input<\n                typeof Rpc.eth_signTypedData_v4.Response\n              >\n            }\n\n            case 'wallet_grantAdmin': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ address, capabilities, chainId, key: keyToAuthorize }] =\n                request._decoded.params ?? [{}]\n\n              const account = address\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, address),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient(chainId)\n\n              const keyExists = getAdmins([...(account.keys ?? [])])?.some(\n                (key) =>\n                  key.publicKey?.toLowerCase() ===\n                  keyToAuthorize.publicKey.toLowerCase(),\n              )\n              if (keyExists)\n                throw new RpcResponse.InvalidParamsError({\n                  message: 'Key already granted as admin.',\n                })\n\n              const { key } = await getMode().actions.grantAdmin({\n                account,\n                feeToken: capabilities?.feeToken,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                key: keyToAuthorize,\n              })\n\n              store.setState((x) => {\n                const index = x.accounts.findIndex((x) =>\n                  account ? Address.isEqual(x.address, account.address) : true,\n                )\n                if (index === -1) return x\n                return {\n                  ...x,\n                  accounts: x.accounts.map((account, i) =>\n                    i === index\n                      ? { ...account, keys: [...(account.keys ?? []), key] }\n                      : account,\n                  ),\n                }\n              })\n\n              const admins = getAdmins([...(account.keys ?? []), key])\n\n              emitter.emit('message', {\n                data: null,\n                type: 'adminsChanged',\n              })\n\n              return z.encode(Rpc.wallet_grantAdmin.Response, {\n                address: account.address,\n                chainId: client.chain.id,\n                key: admins.at(-1)!,\n              })\n            }\n\n            case 'wallet_grantPermissions': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ address, chainId, ...permissions }] = request._decoded\n                .params ?? [{}]\n\n              const account = address\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, address),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient(chainId)\n\n              const { key } = await getMode().actions.grantPermissions({\n                account,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                permissions,\n              })\n\n              store.setState((x) => {\n                const index = x.accounts.findIndex((x) =>\n                  account ? Address.isEqual(x.address, account.address) : true,\n                )\n                if (index === -1) return x\n                return {\n                  ...x,\n                  accounts: x.accounts.map((account, i) =>\n                    i === index\n                      ? { ...account, keys: [...(account.keys ?? []), key] }\n                      : account,\n                  ),\n                }\n              })\n\n              emitter.emit('message', {\n                data: null,\n                type: 'permissionsChanged',\n              })\n\n              return z.encode(Rpc.wallet_grantPermissions.Response, {\n                ...Permissions.fromKey(key, {\n                  address: account.address,\n                }),\n              })\n            }\n\n            case 'wallet_getAdmins': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ address, chainId }] = request._decoded.params ?? [{}]\n\n              const account = address\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, address),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient(chainId)\n\n              const keys = await getMode().actions.getKeys({\n                account,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n              const admins = getAdmins(keys)\n\n              return z.encode(Rpc.wallet_getAdmins.Response, {\n                address: account.address,\n                chainId: client.chain.id,\n                keys: admins,\n              })\n            }\n\n            case 'wallet_prepareUpgradeAccount': {\n              const [{ address, capabilities, chainId }] = request._decoded\n                .params ?? [{}]\n\n              const {\n                email,\n                label,\n                grantPermissions: permissions,\n              } = capabilities ?? {}\n\n              const client = getClient(chainId)\n\n              const { context, digests } =\n                await getMode().actions.prepareUpgradeAccount({\n                  address,\n                  email,\n                  internal: {\n                    client,\n                    config,\n                    request,\n                    store,\n                  },\n                  label,\n                  permissions,\n                })\n\n              preparedAccounts_internal.push((context as any).account)\n\n              return {\n                context,\n                digests,\n              } satisfies z.input<\n                typeof Rpc.wallet_prepareUpgradeAccount.Response\n              >\n            }\n\n            case 'wallet_getAccountVersion': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ address }] = request._decoded.params ?? [{}]\n\n              const account = address\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, address),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient()\n\n              const { current, latest } =\n                await getMode().actions.getAccountVersion({\n                  address: account.address,\n                  internal: {\n                    client,\n                    config,\n                    request,\n                    store,\n                  },\n                })\n\n              return {\n                current,\n                latest,\n              } satisfies z.input<typeof Rpc.wallet_getAccountVersion.Response>\n            }\n\n            case 'wallet_getKeys': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ address, chainIds }] = request._decoded.params ?? [{}]\n\n              const account = state.accounts.find((account) =>\n                Address.isEqual(account.address, address),\n              )\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient()\n\n              const keys = await getMode().actions.getKeys({\n                account,\n                chainIds,\n                internal: { client, config, request, store },\n              })\n\n              return z.encode(Rpc.wallet_getKeys.Response, keys)\n            }\n\n            case 'wallet_getPermissions': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ address, chainIds }] = request._decoded.params ?? [{}]\n\n              const account = address\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, address),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient()\n\n              const keys = await getMode().actions.getKeys({\n                account,\n                chainIds,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n              const permissions = getActivePermissions(keys, {\n                address: account.address,\n              })\n\n              return permissions satisfies z.input<\n                typeof Rpc.wallet_getPermissions.Response\n              >\n            }\n\n            case 'wallet_revokeAdmin': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ address, capabilities, id }] = request._decoded.params\n\n              const account = address\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, address),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient()\n\n              await getMode().actions.revokeAdmin({\n                account,\n                feeToken: capabilities?.feeToken,\n                id,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              const keys = account.keys?.filter(\n                (key) => key.id.toLowerCase() !== id.toLowerCase(),\n              )\n\n              store.setState((x) => ({\n                ...x,\n                accounts: x.accounts.map((x) =>\n                  Address.isEqual(x.address, account.address)\n                    ? {\n                        ...x,\n                        keys,\n                      }\n                    : x,\n                ),\n              }))\n\n              emitter.emit('message', {\n                data: null,\n                type: 'adminsChanged',\n              })\n\n              return\n            }\n\n            case 'wallet_revokePermissions': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [{ address, capabilities, id }] = request._decoded.params\n\n              const account = address\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, address),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient()\n\n              await getMode().actions.revokePermissions({\n                account,\n                feeToken: capabilities?.feeToken,\n                id,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              const keys = account.keys?.filter(\n                (key) => key.id.toLowerCase() !== id.toLowerCase(),\n              )\n\n              store.setState((x) => ({\n                ...x,\n                accounts: x.accounts.map((x) =>\n                  Address.isEqual(x.address, account.address)\n                    ? {\n                        ...x,\n                        keys,\n                      }\n                    : x,\n                ),\n              }))\n\n              emitter.emit('message', {\n                data: null,\n                type: 'permissionsChanged',\n              })\n\n              return\n            }\n\n            case 'wallet_upgradeAccount': {\n              const [{ context, signatures }] = request._decoded.params ?? [{}]\n\n              const client = getClient()\n\n              const account_ = preparedAccounts_internal.find((account) =>\n                Address.isEqual(\n                  account.address,\n                  (context as any).account.address,\n                ),\n              )\n              if (!account_) throw new ox_Provider.UnauthorizedError()\n\n              const { account } = await getMode().actions.upgradeAccount({\n                account: account_,\n                context,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                signatures,\n              })\n\n              const admins = getAdmins(account.keys ?? [])\n              const permissions = getActivePermissions(account.keys ?? [], {\n                address: account.address,\n              })\n\n              store.setState((x) => ({ ...x, accounts: [account] }))\n\n              emitter.emit('connect', {\n                chainId: Hex.fromNumber(client.chain.id),\n              })\n              return {\n                address: account.address,\n                capabilities: {\n                  admins,\n                  ...(permissions.length > 0 ? { permissions } : {}),\n                },\n              } satisfies z.input<typeof Rpc.wallet_upgradeAccount.Response>\n            }\n\n            case 'porto_ping': {\n              return 'pong' satisfies z.input<typeof Rpc.porto_ping.Response>\n            }\n\n            case 'personal_sign': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [data, address] = request._decoded.params\n\n              const account = state.accounts.find((account) =>\n                Address.isEqual(account.address, address),\n              )\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const client = getClient()\n\n              const signature = await getMode().actions.signPersonalMessage({\n                account,\n                data,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              return signature satisfies z.input<\n                typeof Rpc.personal_sign.Response\n              >\n            }\n\n            case 'wallet_connect': {\n              const [{ capabilities, chainIds }] = request._decoded.params ?? [\n                {},\n              ]\n\n              const client = getClient(chainIds?.[0])\n              const chainId = client.chain.id\n\n              const {\n                createAccount,\n                email,\n                grantAdmins: admins,\n                grantPermissions: permissions,\n                selectAccount,\n                signInWithEthereum,\n              } = capabilities ?? {}\n\n              const internal = {\n                client,\n                config,\n                request,\n                store,\n              }\n\n              const { accounts } = await (async () => {\n                if (email || createAccount) {\n                  const { label = undefined } =\n                    typeof createAccount === 'object' ? createAccount : {}\n                  const { account } = await getMode().actions.createAccount({\n                    admins,\n                    email,\n                    internal,\n                    label,\n                    permissions,\n                    signInWithEthereum,\n                  })\n                  return { accounts: [account] }\n                }\n                const account = state.accounts[0]\n                const { address, key } = (() => {\n                  if (selectAccount) {\n                    if (typeof selectAccount === 'object') return selectAccount\n                    return {\n                      address: undefined,\n                      key: undefined,\n                    }\n                  }\n                  for (const key of account?.keys ?? []) {\n                    if (key.type === 'webauthn-p256' && key.role === 'admin')\n                      return {\n                        address: account?.address,\n                        key: {\n                          credentialId:\n                            (key as any).credentialId ??\n                            key.privateKey?.credential?.id,\n                          publicKey: key.publicKey,\n                        },\n                      }\n                  }\n                  return {\n                    address: undefined,\n                    key: undefined,\n                  }\n                })()\n                const loadAccountsParams = {\n                  internal,\n                  permissions,\n                  signInWithEthereum,\n                }\n                try {\n                  // try to restore from stored account (`address`/`key`) to avoid multiple prompts\n                  return await getMode().actions.loadAccounts({\n                    address,\n                    key,\n                    ...loadAccountsParams,\n                  })\n                } catch (error) {\n                  if (error instanceof ox_Provider.UserRejectedRequestError)\n                    throw error\n\n                  // error with `address`/`key` likely means one or both are stale, retry\n                  if (address && key)\n                    return await getMode().actions.loadAccounts(\n                      loadAccountsParams,\n                    )\n                  throw error\n                }\n              })()\n\n              store.setState((x) => ({ ...x, accounts }))\n\n              const chainIds_response = [\n                chainId,\n                ...store.getState().chainIds.filter((id) => id !== chainId),\n              ] as const\n\n              emitter.emit('connect', {\n                chainId: Hex.fromNumber(chainIds_response[0]),\n              })\n\n              return {\n                accounts: accounts.map((account) => ({\n                  address: getAccountAddress(account),\n                  capabilities: {\n                    admins: account.keys ? getAdmins(account.keys) : [],\n                    permissions: account.keys\n                      ? getActivePermissions(account.keys, {\n                          address: account.address,\n                        })\n                      : [],\n                    ...(account.signInWithEthereum && {\n                      signInWithEthereum: account.signInWithEthereum,\n                    }),\n                  },\n                })),\n                chainIds: chainIds_response.map((chainId) =>\n                  Hex.fromNumber(chainId),\n                ),\n              } satisfies z.input<typeof Rpc.wallet_connect.Response>\n            }\n\n            case 'wallet_disconnect': {\n              const client = getClient()\n\n              await getMode().actions.disconnect?.({\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              store.setState((x) => ({ ...x, accounts: [] }))\n              emitter.emit('disconnect', new ox_Provider.DisconnectedError())\n              return\n            }\n\n            case 'wallet_getAssets': {\n              const [parameters] = request._decoded.params ?? []\n              const { account, chainFilter, assetFilter, assetTypeFilter } =\n                parameters\n\n              const client = getClient()\n\n              const response = await getMode().actions.getAssets({\n                account,\n                assetFilter,\n                assetTypeFilter,\n                chainFilter,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              const value = Object.entries(response).reduce(\n                (acc, [key, value]) => {\n                  acc[Hex.fromNumber(Number(key))] = value\n                  return acc\n                },\n                {} as Record<string, ValueOf<typeof response>>,\n              )\n\n              return z.encode(Rpc.wallet_getAssets.Response, value)\n            }\n\n            case 'wallet_getCallsStatus': {\n              const [id] = request._decoded.params ?? []\n\n              const client = getClient()\n\n              const response = await getMode().actions.getCallsStatus({\n                id,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              return response satisfies z.input<\n                typeof Rpc.wallet_getCallsStatus.Response\n              >\n            }\n\n            case 'wallet_getCapabilities': {\n              const [_, chainIds] = request.params ?? []\n\n              const capabilities = await getCapabilities({\n                chainIds,\n                request,\n              })\n\n              return capabilities\n            }\n\n            case 'wallet_prepareCalls': {\n              const [parameters] = request._decoded.params\n              const { calls, capabilities, chainId, key, from } = parameters\n\n              const client = getClient(chainId)\n\n              const account = from ?? state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              if (chainId && chainId !== client.chain.id)\n                throw new ox_Provider.ChainDisconnectedError()\n\n              const { digest, ...rest } = await getMode().actions.prepareCalls({\n                account: Account.from(account),\n                calls,\n                feeToken: capabilities?.feeToken,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                key,\n                merchantUrl: UrlString.toAbsolute(\n                  config.merchantUrl ?? capabilities?.merchantUrl,\n                ),\n                requiredFunds: capabilities?.requiredFunds,\n              })\n\n              return z.encode(Rpc.wallet_prepareCalls.Response, {\n                capabilities: rest.capabilities,\n                chainId: Hex.fromNumber(rest.chainId ?? client.chain.id),\n                context: {\n                  ...rest.context,\n                  account: {\n                    address: rest.account.address,\n                  },\n                  calls: rest.context.calls ?? [],\n                  nonce: rest.context.nonce ?? 0n,\n                },\n                digest,\n                key: rest.key,\n                typedData: rest.typedData,\n              })\n            }\n\n            case 'wallet_sendPreparedCalls': {\n              const [parameters] = request._decoded.params\n              const { chainId, context, key, signature } = parameters\n              const { account } = parameters.context\n\n              const client = getClient(chainId)\n\n              if (chainId && Hex.toNumber(chainId) !== client.chain.id)\n                throw new ox_Provider.ChainDisconnectedError()\n\n              const hash = await getMode().actions.sendPreparedCalls({\n                account: Account.from(account),\n                context,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                key,\n                signature,\n              })\n\n              return [{ id: hash }] satisfies z.input<\n                typeof Rpc.wallet_sendPreparedCalls.Response\n              >\n            }\n\n            case 'wallet_sendCalls': {\n              if (state.accounts.length === 0)\n                throw new ox_Provider.DisconnectedError()\n\n              const [parameters] = request._decoded.params\n              const { calls, capabilities, chainId, from } = parameters\n\n              const client = getClient(chainId)\n\n              if (chainId && chainId !== client.chain.id)\n                throw new ox_Provider.ChainDisconnectedError()\n\n              const account = from\n                ? state.accounts.find((account) =>\n                    Address.isEqual(account.address, from),\n                  )\n                : state.accounts[0]\n              if (!account) throw new ox_Provider.UnauthorizedError()\n\n              const { id } = await getMode().actions.sendCalls({\n                account,\n                calls,\n                chainId: client.chain.id,\n                feeToken: capabilities?.feeToken,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n                merchantUrl: UrlString.toAbsolute(\n                  config.merchantUrl ?? capabilities?.merchantUrl,\n                ),\n                permissionsId: capabilities?.permissions?.id,\n                requiredFunds: capabilities?.requiredFunds,\n              })\n\n              return { id } satisfies z.input<\n                typeof Rpc.wallet_sendCalls.Response\n              >\n            }\n\n            case 'wallet_switchEthereumChain': {\n              const [parameters] = request._decoded.params\n              const { chainId } = parameters\n              const chainId_number = Hex.toNumber(chainId)\n\n              const chain = config.chains.find(\n                (chain) => chain.id === chainId_number,\n              )\n              if (!chain) throw new ox_Provider.UnsupportedChainIdError()\n\n              const client = getClient(chainId)\n              await getMode().actions.switchChain?.({\n                chainId: client.chain.id,\n                internal: {\n                  client,\n                  config,\n                  request,\n                  store,\n                },\n              })\n\n              store.setState((state) => ({\n                ...state,\n                chainIds: [\n                  chainId_number,\n                  ...state.chainIds.filter((id) => id !== chainId_number),\n                ],\n              }))\n\n              return undefined\n            }\n\n            case 'wallet_verifySignature': {\n              const [parameters] = request._decoded.params\n              const { address, chainId, digest, signature } = parameters\n\n              const client = getClient(chainId)\n\n              const result = await Actions.verifySignature(client, {\n                address,\n                digest,\n                signature,\n              })\n\n              return {\n                ...result,\n                address,\n                chainId: Hex.fromNumber(client.chain.id),\n              } satisfies z.input<typeof Rpc.wallet_verifySignature.Response>\n            }\n          }\n        },\n        {\n          enabled: shouldDedupe,\n          id: Json.stringify(request_),\n        },\n      )\n    },\n  })\n\n  function setup() {\n    let unsubscribe_accounts: () => void = () => {}\n    let unsubscribe_chain: () => void = () => {}\n\n    void Store.waitForHydration(store).then(() => {\n      // Pre-fetch the capabilities to hit cache.\n      getCapabilities().catch(() => {})\n\n      unsubscribe_accounts()\n      unsubscribe_accounts = store.subscribe(\n        (state) => state.accounts,\n        (accounts) => {\n          emitter.emit('accountsChanged', accounts.map(getAccountAddress))\n        },\n        {\n          equalityFn: (a, b) =>\n            a.every((a, index) => a.address === b[index]?.address),\n        },\n      )\n\n      unsubscribe_chain()\n      unsubscribe_chain = store.subscribe(\n        (state) => state.chainIds[0],\n        (chainId, previousChainId) => {\n          if (chainId === previousChainId) return\n          emitter.emit('chainChanged', Hex.fromNumber(chainId))\n        },\n      )\n    })\n\n    const unannounce = announce(provider as Provider, announceProvider)\n\n    return () => {\n      unsubscribe_accounts()\n      unsubscribe_chain()\n      unannounce()\n    }\n  }\n  const destroy = setup()\n\n  return Object.assign(provider, {\n    _internal: {\n      destroy,\n    },\n  })\n}\n\nexport declare namespace from {\n  export type Parameters<\n    chains extends readonly [Chains.Chain, ...Chains.Chain[]] = readonly [\n      Chains.Chain,\n      ...Chains.Chain[],\n    ],\n  > = Porto_internal.Internal<chains> & { store: Porto.Store }\n}\n\nfunction announce(\n  provider: Provider,\n  info: boolean | Partial<Mipd.EIP6963ProviderInfo>,\n) {\n  if (!info) return () => {}\n  if (typeof window === 'undefined' || !window.dispatchEvent) return () => {}\n  const {\n    icon = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K',\n    name = 'Porto',\n    rdns = 'xyz.ithaca.porto',\n  } = typeof info === 'object' ? info : {}\n  return Mipd.announceProvider({\n    info: {\n      icon,\n      name,\n      rdns,\n      uuid: uuidv4(),\n    },\n    provider: provider as any,\n  })\n}\n\nfunction getAdmins(\n  keys: readonly Key.Key[],\n): z.input<typeof Rpc.wallet_getAdmins.Response>['keys'] {\n  return keys\n    .map((key) => {\n      if (key.role !== 'admin') return undefined\n      try {\n        return z.encode(Rpc.wallet_getAdmins.Key, {\n          id: key.id ?? key.publicKey,\n          publicKey: key.publicKey,\n          type: key.type,\n          ...(key.type === 'webauthn-p256'\n            ? {\n                credentialId: key.privateKey?.credential?.id,\n                privateKey: {\n                  credential: {\n                    id: key.privateKey?.credential?.id,\n                  },\n                  rpId: key.privateKey?.rpId,\n                },\n              }\n            : {}),\n        })\n      } catch {\n        return undefined\n      }\n    })\n    .filter(Boolean) as never\n}\n\nfunction getActivePermissions(\n  keys: readonly Key.Key[],\n  { address }: { address: Address.Address },\n): z.input<typeof Rpc.wallet_getPermissions.Response> {\n  return keys\n    .map((key) => {\n      if (!key.chainId) return undefined\n      if (key.role !== 'session') return undefined\n      if (key.expiry > 0 && key.expiry < BigInt(Math.floor(Date.now() / 1000)))\n        return undefined\n      try {\n        return z.encode(\n          Permissions.Schema,\n          Permissions.fromKey(key, { address }),\n        )\n      } catch {\n        return undefined\n      }\n    })\n    .filter(Boolean) as never\n}\n\nfunction getAccountAddress(account: Account.Account): Address.Address {\n  return getAddress(account.address)\n}\n","const size = 256\nlet index = size\nlet buffer: string\n\n/** @internal */\nexport function uid(length = 11) {\n  if (!buffer || index + length > size * 2) {\n    buffer = ''\n    index = 0\n    for (let i = 0; i < size; i++) {\n      buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1)\n    }\n  }\n  return buffer.substring(index, index++ + length)\n}\n","/**\n * Normalizes a value into a structured-clone compatible format.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/structuredClone\n */\nexport function normalizeValue<type>(value: type): type {\n  if (Array.isArray(value)) return value.map(normalizeValue) as never\n  if (typeof value === 'function') return undefined as never\n  if (typeof value !== 'object' || value === null) return value\n  if (Object.getPrototypeOf(value) !== Object.prototype)\n    try {\n      return structuredClone(value)\n    } catch {\n      return undefined as never\n    }\n\n  const normalized: Record<string, unknown> = {}\n  for (const [k, v] of Object.entries(value)) normalized[k] = normalizeValue(v)\n  return normalized as never\n}\n\n/**\n * Returns a new array containing only one copy of each element in the original\n * list transformed by a function.\n *\n * @param data - Array.\n * @param fn - Extracts a value to be used to compare elements.\n */\nexport function uniqBy<data>(data: data[], fn: (item: data) => unknown) {\n  const result: data[] = []\n  const seen = new Set()\n  for (const item of data) {\n    const key = fn(item)\n    if (!seen.has(key)) {\n      seen.add(key)\n      result.push(item)\n    }\n  }\n  return result\n}\n\nexport function uuidv4() {\n  if (typeof globalThis !== 'undefined' && 'crypto' in globalThis)\n    return globalThis.crypto.randomUUID()\n  return crypto.randomUUID()\n}\n\n/** Deduplicates in-flight promises. */\nexport function withDedupe<data>(\n  fn: () => Promise<data>,\n  { enabled = true, id }: withDedupe.Options,\n): Promise<data> {\n  if (!enabled || !id) return fn()\n  if (withDedupe.cache.get(id)) return withDedupe.cache.get(id)!\n  const promise = fn().finally(() => withDedupe.cache.delete(id))\n  withDedupe.cache.set(id, promise)\n  return promise\n}\n\nexport namespace withDedupe {\n  export type Options = {\n    enabled?: boolean | undefined\n    id?: string | undefined\n  }\n\n  export const cache = new Map<string, Promise<any>>()\n}\n","export const abi = [\n  {\n    \"type\": \"constructor\",\n    \"inputs\": [\n      {\n        \"name\": \"orchestrator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"fallback\",\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"receive\",\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"ANY_FN_SEL\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes4\",\n        \"internalType\": \"bytes4\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"ANY_KEYHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"ANY_TARGET\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"CALL_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"DOMAIN_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"EMPTY_CALLDATA_FN_SEL\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes4\",\n        \"internalType\": \"bytes4\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"EXECUTE_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"MULTICHAIN_NONCE_PREFIX\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint16\",\n        \"internalType\": \"uint16\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"ORCHESTRATOR\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"SIGN_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"approvedSignatureCheckers\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"authorize\",\n    \"inputs\": [\n      {\n        \"name\": \"key\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IthacaAccount.Key\",\n        \"components\": [\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint40\",\n            \"internalType\": \"uint40\"\n          },\n          {\n            \"name\": \"keyType\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum IthacaAccount.KeyType\"\n          },\n          {\n            \"name\": \"isSuperAdmin\",\n            \"type\": \"bool\",\n            \"internalType\": \"bool\"\n          },\n          {\n            \"name\": \"publicKey\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"callCheckerInfos\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"results\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct GuardedExecutor.CallCheckerInfo[]\",\n        \"components\": [\n          {\n            \"name\": \"target\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"checker\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"canExecute\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"target\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"data\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"canExecutePackedInfos\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"checkAndIncrementNonce\",\n    \"inputs\": [\n      {\n        \"name\": \"nonce\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"computeDigest\",\n    \"inputs\": [\n      {\n        \"name\": \"calls\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct ERC7821.Call[]\",\n        \"components\": [\n          {\n            \"name\": \"to\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"value\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"data\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          }\n        ]\n      },\n      {\n        \"name\": \"nonce\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"result\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"eip712Domain\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"fields\",\n        \"type\": \"bytes1\",\n        \"internalType\": \"bytes1\"\n      },\n      {\n        \"name\": \"name\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      },\n      {\n        \"name\": \"version\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      },\n      {\n        \"name\": \"chainId\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"verifyingContract\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"salt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"extensions\",\n        \"type\": \"uint256[]\",\n        \"internalType\": \"uint256[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"execute\",\n    \"inputs\": [\n      {\n        \"name\": \"mode\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"executionData\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"payable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getContextKeyHash\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getKey\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"key\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IthacaAccount.Key\",\n        \"components\": [\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint40\",\n            \"internalType\": \"uint40\"\n          },\n          {\n            \"name\": \"keyType\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum IthacaAccount.KeyType\"\n          },\n          {\n            \"name\": \"isSuperAdmin\",\n            \"type\": \"bool\",\n            \"internalType\": \"bool\"\n          },\n          {\n            \"name\": \"publicKey\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getKeys\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"keys\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IthacaAccount.Key[]\",\n        \"components\": [\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint40\",\n            \"internalType\": \"uint40\"\n          },\n          {\n            \"name\": \"keyType\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum IthacaAccount.KeyType\"\n          },\n          {\n            \"name\": \"isSuperAdmin\",\n            \"type\": \"bool\",\n            \"internalType\": \"bool\"\n          },\n          {\n            \"name\": \"publicKey\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          }\n        ]\n      },\n      {\n        \"name\": \"keyHashes\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getNonce\",\n    \"inputs\": [\n      {\n        \"name\": \"seqKey\",\n        \"type\": \"uint192\",\n        \"internalType\": \"uint192\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"hash\",\n    \"inputs\": [\n      {\n        \"name\": \"key\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IthacaAccount.Key\",\n        \"components\": [\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint40\",\n            \"internalType\": \"uint40\"\n          },\n          {\n            \"name\": \"keyType\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum IthacaAccount.KeyType\"\n          },\n          {\n            \"name\": \"isSuperAdmin\",\n            \"type\": \"bool\",\n            \"internalType\": \"bool\"\n          },\n          {\n            \"name\": \"publicKey\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"pure\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"invalidateNonce\",\n    \"inputs\": [\n      {\n        \"name\": \"nonce\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"isValidSignature\",\n    \"inputs\": [\n      {\n        \"name\": \"digest\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"signature\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes4\",\n        \"internalType\": \"bytes4\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"keyAt\",\n    \"inputs\": [\n      {\n        \"name\": \"i\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IthacaAccount.Key\",\n        \"components\": [\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint40\",\n            \"internalType\": \"uint40\"\n          },\n          {\n            \"name\": \"keyType\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum IthacaAccount.KeyType\"\n          },\n          {\n            \"name\": \"isSuperAdmin\",\n            \"type\": \"bool\",\n            \"internalType\": \"bool\"\n          },\n          {\n            \"name\": \"publicKey\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"keyCount\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"label\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"pay\",\n    \"inputs\": [\n      {\n        \"name\": \"paymentAmount\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"intentDigest\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"encodedIntent\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"removeSpendLimit\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"token\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"period\",\n        \"type\": \"uint8\",\n        \"internalType\": \"enum GuardedExecutor.SpendPeriod\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"revoke\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setCallChecker\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"target\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"checker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setCanExecute\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"target\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"fnSel\",\n        \"type\": \"bytes4\",\n        \"internalType\": \"bytes4\"\n      },\n      {\n        \"name\": \"can\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setLabel\",\n    \"inputs\": [\n      {\n        \"name\": \"newLabel\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setSignatureCheckerApproval\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"checker\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"isApproved\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setSpendLimit\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"token\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"period\",\n        \"type\": \"uint8\",\n        \"internalType\": \"enum GuardedExecutor.SpendPeriod\"\n      },\n      {\n        \"name\": \"limit\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"spendAndExecuteInfos\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHashes\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"spends\",\n        \"type\": \"tuple[][]\",\n        \"internalType\": \"struct GuardedExecutor.SpendInfo[][]\",\n        \"components\": [\n          {\n            \"name\": \"token\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"period\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum GuardedExecutor.SpendPeriod\"\n          },\n          {\n            \"name\": \"limit\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"spent\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"lastUpdated\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"currentSpent\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"current\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"executes\",\n        \"type\": \"bytes32[][]\",\n        \"internalType\": \"bytes32[][]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"spendInfos\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"results\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct GuardedExecutor.SpendInfo[]\",\n        \"components\": [\n          {\n            \"name\": \"token\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"period\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum GuardedExecutor.SpendPeriod\"\n          },\n          {\n            \"name\": \"limit\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"spent\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"lastUpdated\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"currentSpent\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"current\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"startOfSpendPeriod\",\n    \"inputs\": [\n      {\n        \"name\": \"unixTimestamp\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"period\",\n        \"type\": \"uint8\",\n        \"internalType\": \"enum GuardedExecutor.SpendPeriod\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"pure\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"supportsExecutionMode\",\n    \"inputs\": [\n      {\n        \"name\": \"mode\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"result\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"unwrapAndValidateSignature\",\n    \"inputs\": [\n      {\n        \"name\": \"digest\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"signature\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"isValid\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      },\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"upgradeHook\",\n    \"inputs\": [\n      {\n        \"name\": \"previousVersion\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"upgradeProxyAccount\",\n    \"inputs\": [\n      {\n        \"name\": \"newImplementation\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Authorized\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"indexed\": true,\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"key\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IthacaAccount.Key\",\n        \"components\": [\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint40\",\n            \"internalType\": \"uint40\"\n          },\n          {\n            \"name\": \"keyType\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum IthacaAccount.KeyType\"\n          },\n          {\n            \"name\": \"isSuperAdmin\",\n            \"type\": \"bool\",\n            \"internalType\": \"bool\"\n          },\n          {\n            \"name\": \"publicKey\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          }\n        ]\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"CallCheckerSet\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"indexed\": false,\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"target\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"checker\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"CanExecuteSet\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"indexed\": false,\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"target\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"fnSel\",\n        \"type\": \"bytes4\",\n        \"indexed\": false,\n        \"internalType\": \"bytes4\"\n      },\n      {\n        \"name\": \"can\",\n        \"type\": \"bool\",\n        \"indexed\": false,\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"ImplementationApprovalSet\",\n    \"inputs\": [\n      {\n        \"name\": \"implementation\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"isApproved\",\n        \"type\": \"bool\",\n        \"indexed\": false,\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"ImplementationCallerApprovalSet\",\n    \"inputs\": [\n      {\n        \"name\": \"implementation\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"caller\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"isApproved\",\n        \"type\": \"bool\",\n        \"indexed\": false,\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"LabelSet\",\n    \"inputs\": [\n      {\n        \"name\": \"newLabel\",\n        \"type\": \"string\",\n        \"indexed\": false,\n        \"internalType\": \"string\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"NonceInvalidated\",\n    \"inputs\": [\n      {\n        \"name\": \"nonce\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Revoked\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"indexed\": true,\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"SignatureCheckerApprovalSet\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"indexed\": true,\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"checker\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"isApproved\",\n        \"type\": \"bool\",\n        \"indexed\": false,\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"SpendLimitRemoved\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"indexed\": false,\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"token\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"period\",\n        \"type\": \"uint8\",\n        \"indexed\": false,\n        \"internalType\": \"enum GuardedExecutor.SpendPeriod\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"SpendLimitSet\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"indexed\": false,\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"token\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"period\",\n        \"type\": \"uint8\",\n        \"indexed\": false,\n        \"internalType\": \"enum GuardedExecutor.SpendPeriod\"\n      },\n      {\n        \"name\": \"limit\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"BatchOfBatchesDecodingError\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"CannotSelfExecute\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"ExceededSpendLimit\",\n    \"inputs\": [\n      {\n        \"name\": \"token\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ]\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"ExceedsCapacity\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"FnSelectorNotRecognized\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"IndexOutOfBounds\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidNonce\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidPublicKey\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"KeyDoesNotExist\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"KeyHashIsZero\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"KeyTypeCannotBeSuperAdmin\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"NewImplementationIsZero\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"NewSequenceMustBeLarger\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"NoSpendPermissions\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OpDataError\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"PaymasterNonceError\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"SuperAdminCanExecuteEverything\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"SuperAdminCanSpendAnything\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"Unauthorized\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"UnauthorizedCall\",\n    \"inputs\": [\n      {\n        \"name\": \"keyHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"target\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"data\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ]\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"UnsupportedExecutionMode\",\n    \"inputs\": []\n  }\n] as const;\n\nexport const code = \"0x610140604052604051615ccb380380615ccb833981016040819052610023916100ea565b306080524660a052606080610075604080518082018252600d81526c125d1a1858d85058d8dbdd5b9d609a1b602080830191909152825180840190935260068352650302e352e31360d41b9083015291565b815160209283012081519183019190912060c082905260e0819052604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f8152938401929092529082015246606082015230608082015260a090206101005250506001600160a01b031661012052610117565b5f602082840312156100fa575f5ffd5b81516001600160a01b0381168114610110575f5ffd5b9392505050565b60805160a05160c05160e0516101005161012051615b586101735f395f81816107800152818161194901528181611fed015261378001525f612f3001525f612fea01525f612fc401525f612f7401525f612f510152615b585ff3fe60806040526004361061026a575f3560e01c80638e87cf4711610143578063cb4774c4116100b5578063e9ae5c5311610079578063e9ae5c5314610859578063f81d87a71461086c578063faba56d81461088b578063fac750e0146108aa578063fcd4e707146108be578063ff619c6b146108e657610271565b8063cb4774c4146107a2578063cebfe336146107c3578063d03c7914146107e2578063dcc09ebf14610801578063e5adda711461082d57610271565b8063b70e36f011610107578063b70e36f0146106d1578063b75c7dc6146106f0578063bc2c554a1461070f578063be766d151461073c578063bf53096914610750578063c885f95a1461076f57610271565b80638e87cf4714610628578063912aa1b8146106545780639e49fbf114610673578063a840fe4914610686578063ad077083146106a557610271565b80632f3f30c7116101dc57806357022451116101a05780635702245114610552578063598daac41461057157806360d2f33d146105905780636fd91454146105c35780637656d304146105e257806384b0196e1461060157610271565b80632f3f30c7146104c057806335058501146104da5780633e1b0812146104f45780634223b5c214610513578063515c9d6d1461053257610271565b806317e69ab81161022e57806317e69ab8146103a95780631a912f3e146103d857806320606b70146104195780632081a2781461044c5780632150c5181461046b5780632f1d14cb1461048d57610271565b80630cef73b4146102aa57806311a86fd6146102e557806312aaac7014610324578063136a12f7146103505780631626ba7e1461037157610271565b3661027157005b5f3560e01c63bc197c81811463f23a6e6182141763150b7a028214171561029c57806020526020603cf35b50633c10b94e5f526004601cfd5b3480156102b5575f5ffd5b506102c96102c4366004614f5c565b610905565b6040805192151583526020830191909152015b60405180910390f35b3480156102f0575f5ffd5b5061030c73323232323232323232323232323232323232323281565b6040516001600160a01b0390911681526020016102dc565b34801561032f575f5ffd5b5061034361033e366004614fa3565b610bb4565b6040516102dc9190615049565b34801561035b575f5ffd5b5061036f61036a366004615087565b610ca3565b005b34801561037c575f5ffd5b5061039061038b366004614f5c565b610dcd565b6040516001600160e01b031990911681526020016102dc565b3480156103b4575f5ffd5b506103c86103c3366004614fa3565b610eb2565b60405190151581526020016102dc565b3480156103e3575f5ffd5b5061040b7f9085b19ea56248c94d86174b3784cfaaa8673d1041d6441f61ff52752dac848381565b6040519081526020016102dc565b348015610424575f5ffd5b5061040b7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81565b348015610457575f5ffd5b5061036f6104663660046150f1565b610f79565b348015610476575f5ffd5b5061047f6110c8565b6040516102dc929190615166565b348015610498575f5ffd5b5061040b7feff7fda3af271797e53f62724a17c2e5c118cf95ac65e8274759fcfff97bf1fe81565b3480156104cb575f5ffd5b50610390630707070760e51b81565b3480156104e5575f5ffd5b50610390631919191960e11b81565b3480156104ff575f5ffd5b5061040b61050e3660046151d3565b611232565b34801561051e575f5ffd5b5061034361052d366004614fa3565b61126a565b34801561053d575f5ffd5b5061040b5f516020615b185f395f51905f5281565b34801561055d575f5ffd5b5061036f61056c3660046151f9565b6112a2565b34801561057c575f5ffd5b5061036f61058b366004615238565b61138f565b34801561059b575f5ffd5b5061040b7f9a5906d05ceef8b2885ad4b95ec46e2570079e7f040193be5767e1329736de5781565b3480156105ce575f5ffd5b5061040b6105dd3660046152bb565b6114e1565b3480156105ed575f5ffd5b5061036f6105fc366004615302565b611620565b34801561060c575f5ffd5b506106156116da565b6040516102dc9796959493929190615336565b348015610633575f5ffd5b50610647610642366004614fa3565b611700565b6040516102dc91906153cc565b34801561065f575f5ffd5b5061036f61066e366004615426565b6117e8565b61036f610681366004614fa3565b61193e565b348015610691575f5ffd5b5061040b6106a0366004615506565b6119a0565b3480156106b0575f5ffd5b506106c46106bf366004614fa3565b6119d9565b6040516102dc91906155b3565b3480156106dc575f5ffd5b5061036f6106eb366004614fa3565b6119ec565b3480156106fb575f5ffd5b5061036f61070a366004614fa3565b611a54565b34801561071a575f5ffd5b5061072e6107293660046155f3565b611aa9565b6040516102dc9291906156cb565b348015610747575f5ffd5b5061040b611be0565b34801561075b575f5ffd5b5061036f61076a366004615789565b611c35565b34801561077a575f5ffd5b5061030c7f000000000000000000000000000000000000000000000000000000000000000081565b3480156107ad575f5ffd5b506107b6611cd9565b6040516102dc91906157bb565b3480156107ce575f5ffd5b5061040b6107dd366004615506565b611cf2565b3480156107ed575f5ffd5b506103c86107fc366004614fa3565b611d5a565b34801561080c575f5ffd5b5061082061081b366004614fa3565b611d6c565b6040516102dc91906157cd565b348015610838575f5ffd5b5061084c610847366004614fa3565b611f30565b6040516102dc91906157df565b61036f610867366004614f5c565b611f43565b348015610877575f5ffd5b5061036f6108863660046157f1565b611fc5565b348015610896575f5ffd5b5061040b6108a536600461584c565b6121d3565b3480156108b5575f5ffd5b5061040b61230b565b3480156108c9575f5ffd5b506108d361c1d081565b60405161ffff90911681526020016102dc565b3480156108f1575f5ffd5b506103c8610900366004615876565b61231e565b5f80602183101561091a57505f905080610bac565b6041831460408414171561094857306109348686866125f2565b6001600160a01b03161491505f9050610bac565b506020198281018381118185180281189385019182013591601f19013560ff1615610979576109768661267a565b95505b505f61098482610bb4565b805190915064ffffffffff1642811090151516156109a5575f925050610bac565b5f816020015160038111156109bc576109bc614fba565b03610a17575f80603f86118735810290602089013502915091505f5f6109fb856060015180516020820151604090920151603f90911191820292910290565b91509150610a0c8a85858585612693565b965050505050610baa565b600181602001516003811115610a2f57610a2f614fba565b03610ab457606081810151805160208083015160409384015184518084018d9052855180820385018152601f8c018590049094028101870186529485018a8152603f9490941091820295910293610aab935f92610aa4928d918d918291018382808284375f9201919091525061272c92505050565b8585612814565b94505050610baa565b600281602001516003811115610acc57610acc614fba565b03610afb57610af48160600151806020019051810190610aec91906158cd565b878787612933565b9250610baa565b600381602001516003811115610b1357610b13614fba565b03610baa57806060015151602014610b3e5760405163145a1fdd60e31b815260040160405180910390fd5b5f8160600151610b4d906158e8565b60601c9050604051638afc93b48152876020820152836040820152606080820152856080820152858760a08301375f5f526084860160205f82601c8501865afa915050638afc93b45f5160e01c14811615610ba757600194505b50505b505b935093915050565b604080516080810182525f80825260208201819052918101919091526060808201525f82815268448e3efef2f6a7f2f960205260408120610bf490612a13565b8051909150610c165760405163395ed8c160e21b815260040160405180910390fd5b8051600619015f610c2a8383016020015190565b60d881901c855260c881901c915060d01c60ff166003811115610c4f57610c4f614fba565b84602001906003811115610c6557610c65614fba565b90816003811115610c7857610c78614fba565b90525060ff811615156040850152610c9583838151811082025290565b606085015250919392505050565b333014610cc2576040516282b42960e81b815260040160405180910390fd5b8380610ce157604051638707510560e01b815260040160405180910390fd5b5f516020615b185f395f51905f528514610d1c57610cfe85612a79565b15610d1c57604051630442081560e01b815260040160405180910390fd5b610d268484612add565b15610d44576040516303a6f8c760e21b815260040160405180910390fd5b610d6760e084901c606086901b1783610800610d5f89612b05565b929190612b54565b50604080518681526001600160a01b03861660208201526001600160e01b031985169181019190915282151560608201527f7eb91b8ac56c0864a4e4f5598082d140d04bed1a4dd62a41d605be2430c494e1906080015b60405180910390a15050505050565b5f5f610e027feff7fda3af271797e53f62724a17c2e5c118cf95ac65e8274759fcfff97bf1fe865f9182526020526040902090565b604080517f035aff83d86937d35b32e04f0ddc6ff469290eef2f1b692d8a815c89404d47495f908152306020908152838220905261190190528282526042601e20915290915094505f5f610e57878787610905565b90925090508115158115151615610e8d57610e7181612a79565b80610e8a5750610e8a33610e8483612b7d565b90612bac565b91505b81610e9c5763ffffffff610ea2565b631626ba7e5b60e01b93505050505b9392505050565b5f333014610ed2576040516282b42960e81b815260040160405180910390fd5b5f610f0b610f07610f0460017fa7d540c151934097be66b966a69e67d3055ab4350de7ff57a5f5cb2284ad4a5a615940565b90565b5c90565b90507f0a9f35b227e9f474cb86caa2e9b62847626fede22333cf52c7abea325d2eaa358114610f38575f5ffd5b610f6e610f69610f0460017fa7d540c151934097be66b966a69e67d3055ab4350de7ff57a5f5cb2284ad4a5a615940565b612c56565b60019150505b919050565b333014610f98576040516282b42960e81b815260040160405180910390fd5b8280610fb757604051638707510560e01b815260040160405180910390fd5b610fc084612a79565b15610fde5760405163f2fee1e160e01b815260040160405180910390fd5b5f610fe885612b05565b6001600160a01b0385165f90815260028201602052604090206001909101915061103684600681111561101d5761101d614fba565b8254600160ff9092169190911b80198216845516151590565b15611056575f61104582612c5c565b03611056576110548286612c77565b505b611085816001015f86600681111561107057611070614fba565b60ff1681526020019081526020015f205f9055565b7fa17fd662986af6bbcda33ce6b68c967b609aebe07da86cd25ee7bfbd01a65a278686866040516110b893929190615953565b60405180910390a1505050505050565b6060805f6110d461230b565b9050806001600160401b038111156110ee576110ee615441565b60405190808252806020026020018201604052801561113d57816020015b604080516080810182525f80825260208083018290529282015260608082015282525f1990920191018161110c5790505b509250806001600160401b0381111561115857611158615441565b604051908082528060200260200182016040528015611181578160200160208202803683370190505b5091505f805b82811015611227575f6111a88268448e3efef2f6a7f2f65b60020190612dac565b90505f6111b482610bb4565b805190915064ffffffffff1642811090151516156111d357505061121f565b808785815181106111e6576111e6615976565b60200260200101819052508186858151811061120457611204615976565b6020908102919091010152836112198161598a565b94505050505b600101611187565b508084528252509091565b6001600160c01b0381165f90815268448e3efef2f6a7f2f76020526040808220549083901b67ffffffffffffffff1916175b92915050565b604080516080810182525f808252602082018190529181019190915260608082015261126461033e8368448e3efef2f6a7f2f661119f565b3330146112c1576040516282b42960e81b815260040160405180910390fd5b82806112e057604051638707510560e01b815260040160405180910390fd5b5f516020615b185f395f51905f52841461131b576112fd84612a79565b1561131b5760405163f2fee1e160e01b815260040160405180910390fd5b5f61132585612b05565b60030190506113448185856001600160a01b0381161515610800612df5565b50604080518681526001600160a01b0380871660208301528516918101919091527f7e2baa9c3a554d7c6587682e28fe9607c29d1d8c8a46968368d5614607c6079990606001610dbe565b3330146113ae576040516282b42960e81b815260040160405180910390fd5b83806113cd57604051638707510560e01b815260040160405180910390fd5b6113d685612a79565b156113f45760405163f2fee1e160e01b815260040160405180910390fd5b5f6113fe86612b05565b600101905061140f81866040612e20565b506001600160a01b0385165f908152600182016020526040902061145585600681111561143e5761143e614fba565b8254600160ff9092169190911b8082178455161590565b505f816001015f87600681111561146e5761146e614fba565b60ff1681526020019081526020015f2090505f61148a82612e5c565b86815290506114998282612ea6565b7f68c781b0acb659616fc73da877ee77ae95c51ce973b6c7a762c8692058351b4a898989896040516114ce94939291906159a2565b60405180910390a1505050505050505050565b5f806114fd8460408051828152600190920160051b8201905290565b90505f5b8481101561159d575f5f365f6115188a8a87612eeb565b9296509094509250905061158d8561157e7f9085b19ea56248c94d86174b3784cfaaa8673d1041d6441f61ff52752dac84836001600160a01b0388168761155f8888612f1d565b6040805194855260208501939093529183015260608201526080902090565b600190910160051b8801528690565b5050505050806001019050611501565b5061c1d060f084901c145f6115f77f9a5906d05ceef8b2885ad4b95ec46e2570079e7f040193be5767e1329736de5783855160051b6020870120886040805194855260208501939093529183015260608201526080902090565b90508161160c5761160781612f2e565b611615565b61161581613044565b979650505050505050565b33301461163f576040516282b42960e81b815260040160405180910390fd5b5f83815268448e3efef2f6a7f2f9602052604090205460ff166116755760405163395ed8c160e21b815260040160405180910390fd5b61168e828261020061168687612b7d565b9291906130b8565b50816001600160a01b0316837f30653b7562c17b712ebc81c7a2373ea1c255cf2a055380385273b5bf7192cc99836040516116cd911515815260200190565b60405180910390a3505050565b600f60f81b6060805f8080836116ee6130d3565b97989097965046955030945091925090565b60605f61170c83612b05565b600301905061171a81613117565b6001600160401b0381111561173157611731615441565b60405190808252806020026020018201604052801561177557816020015b604080518082019091525f808252602082015281526020019060019003908161174f5790505b5091505f5b82518110156117e15761178d8282613121565b84838151811061179f5761179f615976565b60200260200101515f018584815181106117bb576117bb615976565b6020908102919091018101516001600160a01b039384169101529116905260010161177a565b5050919050565b333014611807576040516282b42960e81b815260040160405180910390fd5b6001600160a01b03811661182e57604051634adebaa360e11b815260040160405180910390fd5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80545f908152606083901b600c525190555f6118696130d3565b91506118c590507f0a9f35b227e9f474cb86caa2e9b62847626fede22333cf52c7abea325d2eaa356118bf610f0460017fa7d540c151934097be66b966a69e67d3055ab4350de7ff57a5f5cb2284ad4a5a615940565b9061315b565b306317e69ab86118d483613162565b6040518263ffffffff1660e01b81526004016118f291815260200190565b6020604051808303815f875af115801561190e573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061193291906159d4565b61193a575f5ffd5b5050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614611986576040516282b42960e81b815260040160405180910390fd5b61199d68448e3efef2f6a7f2f65b6001018261318a565b50565b5f611264826020015160038111156119ba576119ba614fba565b60ff168360600151805190602001205f1c5f9182526020526040902090565b60606112646119e783612b7d565b6131a1565b333014611a0b576040516282b42960e81b815260040160405180910390fd5b611a1e68448e3efef2f6a7f2f782613275565b6040518181527f4d9dbebf1d909894d9c26fe228c27cec643b2cb490124e5b658f4edd203c20c19060200160405180910390a150565b333014611a73576040516282b42960e81b815260040160405180910390fd5b611a7c816132df565b60405181907fe5af7daed5ab2a2dc5f98d53619f05089c0c14d11a6621f6b906a2366c9a7ab3905f90a250565b60608082806001600160401b03811115611ac557611ac5615441565b604051908082528060200260200182016040528015611af857816020015b6060815260200190600190039081611ae35790505b509250806001600160401b03811115611b1357611b13615441565b604051908082528060200260200182016040528015611b4657816020015b6060815260200190600190039081611b315790505b5091505f5b81811015611bd757611b74868683818110611b6857611b68615976565b90506020020135611d6c565b848281518110611b8657611b86615976565b6020026020010181905250611bb2868683818110611ba657611ba6615976565b90506020020135611f30565b838281518110611bc457611bc4615976565b6020908102919091010152600101611b4b565b50509250929050565b5f80611c0e611bfd60015f516020615b385f395f51905f52615940565b604080516020810190915290815290565b9050611c1981515c90565b5f03611c2657505f919050565b611c2f8161334a565b91505090565b333014611c54576040516282b42960e81b815260040160405180910390fd5b611c9c82828080601f0160208091040260200160405190810160405280939291908181526020018383808284375f92019190915250611c969250612a06915050565b9061336a565b7faec6ef4baadc9acbdf52442522dfffda03abe29adba8d4af611bcef4cbe0c9ad8282604051611ccd929190615a17565b60405180910390a15050565b6060611ced68448e3efef2f6a7f2f6612a13565b905090565b5f333014611d12576040516282b42960e81b815260040160405180910390fd5b611d1b826133c2565b9050807f3d3a48be5a98628ecf98a6201185102da78bbab8f63a4b2d6b9eef354f5131f583604051611d4d9190615049565b60405180910390a2919050565b5f611d6482613430565b151592915050565b60605f611d7883612b05565b6001019050611d936040518060200160405280606081525090565b5f611d9d83613479565b90505f5b81811015611f26575f611db485836134ca565b6001600160a01b0381165f9081526001870160205260408120919250611dd982613523565b90505f5b8151811015611f17575f828281518110611df957611df9615976565b602002602001015190505f611e22856001015f8460ff1681526020019081526020015f20612e5c565b9050611e5f6040805160e081019091525f808252602082019081526020015f81526020015f81526020015f81526020015f81526020015f81525090565b8260ff166006811115611e7457611e74614fba565b81602001906006811115611e8a57611e8a614fba565b90816006811115611e9d57611e9d614fba565b9052506001600160a01b03871681528151604080830191909152820151608082015260208201516060820152611ee24260ff851660068111156108a5576108a5614fba565b60c08201819052608082015160608301519111150260a082015280611f078b8261357c565b5050505050806001019050611ddd565b50505050806001019050611da1565b5050519392505050565b6060611264611f3e83612b05565b613625565b5f611f4d84613430565b905080600303611f6857611f628484846136de565b50505050565b365f365f84611f7e57637f1812755f526004601cfd5b5085358087016020810194503592505f90604011600286141115611fac575050602080860135860190810190355b611fbb88888887878787613776565b5050505050505050565b813580830190604081901c602084101715611fde575f5ffd5b50612053336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461204a3061201f6020860186615426565b6001600160a01b0316143061203a6080870160608801615426565b6001600160a01b03161417151590565b15159015151690565b61206f576040516282b42960e81b815260040160405180910390fd5b306120806080830160608401615426565b6001600160a01b031603612133575f84815268448e3efef2f6a7f2fb602052604090205460ff16156120c557604051638f56f14960e01b815260040160405180910390fd5b5f84815268448e3efef2f6a7f2fb60205260408120805460ff19166001179055806120f8866102c4610240860186615a2a565b975091508690506001600160c01b0332311061211357600191505b81612130576040516282b42960e81b815260040160405180910390fd5b50505b61215e61214660a0830160808401615426565b61215861022084016102008501615426565b8861398e565b84158061216f575061216f85612a79565b6121cb575f61217d86612b05565b6001810191506121c9906002015f61219b60a0860160808701615426565b6001600160a01b0316815260208101919091526040015f206121c360a0850160808601615426565b896139b6565b505b505050505050565b5f808260068111156121e7576121e7614fba565b036121fa57603c808404025b9050611264565b600182600681111561220e5761220e614fba565b0361221f57610e10808404026121f3565b600282600681111561223357612233614fba565b036122455762015180808404026121f3565b600382600681111561225957612259614fba565b0361227f576007600362015180808604918201929092069003620545ff851102026121f3565b5f5f61228a85613adb565b50909250905060048460068111156122a4576122a4614fba565b036122be576122b582826001613b85565b92505050611264565b60058460068111156122d2576122d2614fba565b036122e3576122b582600180613b85565b60068460068111156122f7576122f7614fba565b0361230757600192505050611264565b5f5ffd5b5f611ced68448e3efef2f6a7f2f8613bdc565b5f8461232c575060016125ea565b61233585612a79565b15612342575060016125ea565b631919191960e11b60048310612356575082355b826123655750630707070760e51b5b61236f8582612add565b1561237d575f9150506125ea565b5f61238787612b05565b905061239281613bdc565b1561244f576123ad60e083901c606088901b175b8290613c28565b156123bd576001925050506125ea565b6123d06332323232606088901b176123a6565b156123e0576001925050506125ea565b61240660e083901c73191919191919191919191919191919191919191960611b176123a6565b15612416576001925050506125ea565b61243f7f32323232323232323232323232323232323232320000000000000000323232326123a6565b1561244f576001925050506125ea565b6124655f516020615b185f395f51905f52612b05565b905061247081613bdc565b1561252a5761248860e083901c606088901b176123a6565b15612498576001925050506125ea565b6124ab6332323232606088901b176123a6565b156124bb576001925050506125ea565b6124e160e083901c73191919191919191919191919191919191919191960611b176123a6565b156124f1576001925050506125ea565b61251a7f32323232323232323232323232323232323232320000000000000000323232326123a6565b1561252a576001925050506125ea565b612538878888898989613cac565b15612548576001925050506125ea565b61256a8788733232323232323232323232323232323232323232898989613cac565b1561257a576001925050506125ea565b6125955f516020615b185f395f51905f528888808989613cac565b156125a5576001925050506125ea565b6125d45f516020615b185f395f51905f5288733232323232323232323232323232323232323232898989613cac565b156125e4576001925050506125ea565b5f925050505b949350505050565b5f604051826040811461260d57604181146126345750612665565b60208581013560ff81901c601b0190915285356040526001600160ff1b0316606052612645565b60408501355f1a6020526040856040375b50845f526020600160805f60015afa5191505f606052806040523d612672575b638baa579f5f526004601cfd5b509392505050565b5f815f526020600160205f60025afa5190503d610f7457fe5b5f6040518681528560208201528460408201528360608201528260808201525f5f5260205f60a0836101005afa503d6126f7576d1ab2e8006fd8b71907bf06a5bdee3b6126f75760205f60a0836dd01ea45f9efd5c54f037fa57ea1a5afa6126f757fe5b505f516001147f7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5617e3192a8851110905095945050505050565b6127616040518060c0016040528060608152602001606081526020015f81526020015f81526020015f81526020015f81525090565b815160c0811061280e5760208301818101818251018281108260c0830111171561278d5750505061280e565b80815101925080602082015101818110838211178285108486111717156127b7575050505061280e565b82815160208301011183855160208701011117156127d8575050505061280e565b8386528060208701525060408101516040860152606081015160608601526080810151608086015260a081015160a08601525050505b50919050565b5f5f5f61282388600180613d5a565b905060208601518051602082019150604088015160608901518451600d81016c1131b430b63632b733b2911d1160991b60981c8752848482011060228286890101515f1a14168160138901208286890120141685846014011085851760801c1074113a3cb832911d113bb2b130baba34371733b2ba1160591b60581c8589015160581c14161698505080865250505087515189151560021b600117808160218c510151161460208311881616965050851561290757602089510181810180516020600160208601856020868a8c60025afa60011b5afa51915295503d905061290757fe5b5050508215612928576129258287608001518860a001518888612693565b92505b505095945050505050565b5f6001600160a01b038516156125ea57604051853b6129c3578260408114612963576041811461298a57506129fd565b60208581013560ff81901c601b0190915285356040526001600160ff1b031660605261299b565b60408501355f1a6020526040856040375b50845f526020600160805f60015afa5180871860601b3d119250505f606052806040526129fd565b631626ba7e60e01b80825285600483015260248201604081528460448401528486606485013760208160648701858b5afa90519091141691505b50949350505050565b68448e3efef2f6a7f2f690565b60405181546020820190600881901c5f8260ff841714612a4157505080825260ff8116601f80821115612a63575b855f5260205f205b8160051c81015482860152602082019150828210612a4957505b508084525f920191825250602001604052919050565b5f81815268448e3efef2f6a7f2f960205260408120805460ff808216908114801590910260089290921c021780612ac35760405163395ed8c160e21b815260040160405180910390fd5b612ad0825f198301613e4b565b60ff161515949350505050565b6001600160a01b039190911630146001600160e01b03199190911663e9ae5c5360e01b141690565b5f805f516020615b185f395f51905f528314612b2957612b2483613eb8565b612b38565b5f516020615b185f395f51905f525b68b11ddb8fabd886bebb6009525f908152602990209392505050565b5f82612b6957612b648585613ee5565b612b74565b612b74858584613fe3565b95945050505050565b5f81815268448e3efef2f6a7f2fa602052604081208054601f5263d4203f8b6004528152603f81208190610eab565b63978aab926004525f828152602481206001600160a01b03929092169168fbb67fda52d4bfb8be198301612be75763f5a267f15f526004601cfd5b82612bf95768fbb67fda52d4bfb8bf92505b80546001600160601b038116612c3d5760019250838160601c0315612c4e57600182015460601c8414612c4e57600282015460601c8414612c4e575b5f9250612c4e565b81602052835f5260405f2054151592505b505092915050565b5f815d50565b5f81545b801561280e57600191820191811901811618612c60565b63978aab926004525f828152602481206001600160a01b03929092169168fbb67fda52d4bfb8be198301612cb25763f5a267f15f526004601cfd5b82612cc45768fbb67fda52d4bfb8bf92505b80546001600160601b03811680612d3e5760019350848260601c03612cfc5760018301805484556002840180549091555f9055612da3565b84600184015460601c03612d1d5760028301805460018501555f9055612da3565b84600284015460601c03612d36575f6002840155612da3565b5f9350612da3565b82602052845f5260405f20805480612d57575050612da3565b60018360011c039250826001820314612d87578285015460601c8060601b60018303870155805f52508060405f20555b5060018260011b17845460601c60601b1784555f815550600193505b50505092915050565b6318fb58646004525f8281526024902081015468fbb67fda52d4bfb8bf81141502612dd683613bdc565b821061126457604051634e23d03560e01b815260040160405180910390fd5b5f82612e0a57612e058686614000565b612e16565b612e1686868685614031565b9695505050505050565b5f612e2b848461406c565b90508015610eab5781612e3d85613479565b1115610eab5760405163155176b960e11b815260040160405180910390fd5b612e7d60405180606001604052805f81526020015f81526020015f81525090565b5f612e8783612a13565b905080515f1461280e575f612e9b826141c7565b602001949350505050565b6040805182516020808301919091528301518183015290820151606082015261193a908390612ee690608001604051602081830303815290604052614313565b61336a565b60051b82013590910180356001600160a01b031680153002179260208083013593506040830135909201918201913590565b5f8183604051375060405120919050565b7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000030147f00000000000000000000000000000000000000000000000000000000000000004614166130215750604080517f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f81527f000000000000000000000000000000000000000000000000000000000000000060208201527f00000000000000000000000000000000000000000000000000000000000000009181019190915246606082015230608082015260a090205b6719010000000000005f5280601a5281603a52604260182090505f603a52919050565b5f5f5f61304f6130d3565b915091506040517f91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a27665f5282516020840120602052815160208301206040523060605260805f206020526119015f52846040526042601e20935080604052505f6060525050919050565b5f826130c857612b648585612c77565b612b74858584612e20565b604080518082018252600d81526c125d1a1858d85058d8dbdd5b9d609a1b602080830191909152825180840190935260068352650302e352e31360d41b9083015291565b5f61126482613479565b5f80600184018161313286866134ca565b6001600160a01b038082168352602083019390935260409091015f205490969116945092505050565b80825d5050565b8051602181106131795763ec92f9a35f526004601cfd5b9081015160209190910360031b1b90565b5f5f6131968484614540565b600101905550505050565b63978aab926004525f818152602481206060915068fbb67fda52d4bfb8bf81548060a01b60a01c6040519450846020018260601c925083831415830281528161322f57821561322a57600191508185015460601c9250821561322a578284141590920260208301525060028381015460601c91821561322a576003915083831415830260408201525b61325f565b600191821c915b8281101561325d578581015460601c858114158102600583901b8401529350600101613236565b505b8186528160051b81016040525050505050919050565b604081811c5f90815260208490522080546001600160401b03831610156132af576040516312ee5c9360e01b815260040160405180910390fd5b6132d96132d3836001600160401b031667fffffffffffffffe808218908211021890565b60010190565b90555050565b5f81815268448e3efef2f6a7f2f96020908152604080832083905568448e3efef2f6a7f2fa90915290208054600101905568448e3efef2f6a7f2f661332d68448e3efef2f6a7f2f883613ee5565b61193a5760405163395ed8c160e21b815260040160405180910390fd5b80515f90805c806133625763bc7ec7795f526004601cfd5b015c92915050565b80518060081b60ff175f60fe8311613393575050601f8281015160081b821790808311156133ba575b60208401855f5260205f205b828201518360051c82015560208301925084831061339f5750505b509092555050565b5f6133cc826119a0565b90505f68448e3efef2f6a7f2f66060840151845160208087015160408089015190519596506134239561340195949301615a6c565b60408051601f198184030181529181525f85815260038501602052209061336a565b6117e16002820183614586565b6003690100000000007821000260b09290921c69ffff00000000ffffffff16918214026901000000000078210001821460011b6901000000000000000000909214919091171790565b63978aab926004525f8181526024812080548060a01b60a01c8060011c9350808260601c15176134c2576001935083830154156134c2576002935083830154156134c257600393505b505050919050565b63978aab926004525f828152602481208281015460601c915068fbb67fda52d4bfb8bf821415820291506134fd84613479565b831061351c57604051634e23d03560e01b815260040160405180910390fd5b5092915050565b604051815460208201905f905b80156135665761ffff811661354b576010918201911c613530565b8183526020600582901b16909201916001918201911c613530565b5050601f198282030160051c8252604052919050565b604080516060815290819052829050825160018151018060051b661d174b32e2c553602084035181810615828204029050808310613614578281178101811582602001870160405118176135e057828102601f198701528501602001604052613614565b602060405101816020018101604052808a52601f19855b88810151838201528101806135f757509184029181019190915294505b505082019390935291909152919050565b6318fb58646004525f81815260249020801954604051919068fbb67fda52d4bfb8bf90602084018161369e57835480156136985780841415028152600184810154909250801561369857808414150260208201526002848101549092508015613698576003925083811415810260408301525b506136c9565b8160011c91505f5b828110156136c757848101548481141502600582901b8301526001016136a6565b505b8185528160051b810160405250505050919050565b600360b01b929092189181358083018035916020808301928686019291600586901b9091018101831090861017604082901c171561372357633995943b5f526004601cfd5b505f5b8381146121c957365f8260051b850135808601602081019350803592505084828401118160401c171561376057633995943b5f526004601cfd5b5061376c898383611f43565b5050600101613726565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016330361383c57602081146137c75760405163438e981560e11b815260040160405180910390fd5b60408051602081019091528235906137fc908290806137f460015f516020615b385f395f51905f52615940565b905290614698565b6138078585836146b2565b6040805160208101909152613836908061382f60015f516020615b385f395f51905f52615940565b9052614b7b565b506121c9565b8061387057333014613860576040516282b42960e81b815260040160405180910390fd5b61386b84845f6146b2565b6121c9565b60208110156138925760405163438e981560e11b815260040160405180910390fd5b81356138a668448e3efef2f6a7f2f6611994565b6040518181527f4d9dbebf1d909894d9c26fe228c27cec643b2cb490124e5b658f4edd203c20c19060200160405180910390a15f5f6139036138e98888866114e1565b602080871081881802188088019080880390881102610905565b9150915081613924576040516282b42960e81b815260040160405180910390fd5b61394f81604051806020016040528060015f516020615b385f395f51905f525f1c6137f49190615940565b61395a8787836146b2565b6040805160208101909152613982908061382f60015f516020615b385f395f51905f52615940565b50505050505050505050565b6001600160a01b0383166139ab576139a68282614b9c565b505050565b6139a6838383614bb5565b806139c057505050565b5f6139ca84613523565b905080515f036139ed57604051635ee7e5b160e01b815260040160405180910390fd5b5f5b8151811015613ad4575f828281518110613a0b57613a0b615976565b602002602001015190505f866001015f8360ff1681526020019081526020015f2090505f613a3882612e5c565b90505f613a54428560ff1660068111156108a5576108a5614fba565b90508082604001511015613a7057604082018190525f60208301525b815f01518783602001818151613a869190615abb565b9150818152501115613abb5760405163482a648960e11b81526001600160a01b03891660048201526024015b60405180910390fd5b613ac58383612ea6565b505050508060010190506139ef565b5050505050565b5f8080613b78613aee6201518086615ace565b5f5f5f620afa6c8401935062023ab1840661016d62023ab082146105b48304618eac84048401030304606481048160021c8261016d0201038203915060996002836005020104600161030161f4ff830201600b1c84030193506b030405060708090a0b0c010260a01b811a9450506003841061019062023ab1880402820101945050509193909250565b9196909550909350915050565b5f620afa6c1961019060038510860381810462023ab10260649290910691820461016d830260029390931c9290920161f4ff600c60098901060261030101600b1c8601019190910301016201518002949350505050565b6318fb58646004525f818152602481208019548060011c9250806117e15781545f9350156117e1576001925082820154156117e1576002925082820154156117e1575060039392505050565b6318fb58646004525f8281526024812068fbb67fda52d4bfb8bf8303613c555763f5a267f15f526004601cfd5b82613c675768fbb67fda52d4bfb8bf92505b801954613c9857805460019250831461351c576001810154831461351c576002810154831461351c575f915061351c565b602052505f90815260409020541515919050565b5f5f5f613cc587613cbc8b612b05565b60030190614bff565b915091508115613d4c576040516001629e639560e01b031981526001600160a01b0382169063ff619c6b90613d04908b908a908a908a90600401615aed565b602060405180830381865afa158015613d1f573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613d4391906159d4565b92505050612e16565b505f98975050505050505050565b606083518015612672576003600282010460021b60405192507f4142434445464748494a4b4c4d4e4f505152535455565758595a616263646566601f526106708515027f6768696a6b6c6d6e6f707172737475767778797a303132333435363738392d5f18603f526020830181810183886020010180515f82525b60038a0199508951603f8160121c16515f53603f81600c1c1651600153603f8160061c1651600253603f811651600353505f518452600484019350828410613dd5579052602001604052613d3d60f01b60038406600204808303919091525f861515909102918290035290038252509392505050565b5f82548060ff821714613e9357601e8311613e6a5780831a915061351c565b8060ff168311613e8e57835f52601f83038060051c60205f200154601f82161a9250505b61351c565b8060081c831161351c57835f528260051c60205f200154601f84161a91505092915050565b5f81815268448e3efef2f6a7f2fa602052604081208054601f5263d4203f8b6004528152603f8120611264565b6318fb58646004525f8281526024812068fbb67fda52d4bfb8bf8303613f125763f5a267f15f526004601cfd5b82613f245768fbb67fda52d4bfb8bf92505b80195480613f85576001925083825403613f515760018201805483556002830180549091555f9055612c4e565b83600183015403613f6f5760028201805460018401555f9055612c4e565b83600283015403612c35575f6002830155612c4e565b81602052835f5260405f20805480613f9e575050612c4e565b60018360011c039250826001820314613fc857828401548060018303860155805f52508060405f20555b5060018260011b178319555f81555060019250505092915050565b5f613fee8484614586565b90508015610eab5781612e3d85613bdc565b6001600160a01b0381165f908152600183016020526040812080546001600160a01b0319169055610eab8383612c77565b6001600160a01b038381165f908152600186016020526040812080546001600160a01b03191692851692909217909155612b74858584612e20565b63978aab926004525f828152602481206001600160a01b03929092169168fbb67fda52d4bfb8be1983016140a75763f5a267f15f526004601cfd5b826140b95768fbb67fda52d4bfb8bf92505b80546001600160601b038116826020528061417b578160601c806140e7578560601b84556001945050612da3565b8581036140f45750612da3565b600184015460601c80614115578660601b6001860155600195505050612da3565b868103614123575050612da3565b600285015460601c80614145578760601b600287015560019650505050612da3565b87810361415457505050612da3565b5f928352604080842060019055918352818320600290558252902060039055506007908117905b845f5260405f2080546141bd57600191821c8083018255919450816141a9578560601b600317845550612da3565b8560601b8285015582600201845550612da3565b5050505092915050565b6060815115610f74576040519050600482018051835184602001017f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f6020850183198552866020015b8051805f1a61426857600190811a016080811161424857600282019150803684379182019184821061424257506142f5565b50614210565b5f198352918201607f1901916002919091019084821061424257506142f5565b80835283811684011783171980157fc0c8c8d0c8e8d0d8c8e8e0e8d0d8e0f0c8d0e8d0e0e0d8f0d0d0e0d8f8f8f8f8601f6f8421084210842108cc6318c6db6d54be660204081020408185821060071b86811c6001600160401b031060061b1795861c0260181a1c161a90911860031c01918201910183811061421057838111156142f557838103820391505b509290935250601f198382030183525f815260200160405250919050565b606061436b565b6fffffffffffffffffffffffffffffffff811160071b81811c6001600160401b031060061b1781811c63ffffffff1060051b1781811c61ffff1060041b1790811c60ff1060039190911c17601f1890565b50604051815182017f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f60208301845b83811461451c57600101805160ff1680614424575b6020820151806143f35782860360208181189082110218607f839003818111818318021893840193928301929050601f81116143ec575050614414565b50506143af565b6143fc8161431a565b90508286038181118183180218928301929190910190505b60f01b825260029091019061439a565b60ff810361447757602080830151198015614445576144428161431a565b91505b508286038181118282180218601f81811890821102186080811760f01b855260029094019392909201915061439a9050565b80835350602081015160018381018290528482168501821791198581168601179190911684171980157fc0c8c8d0c8e8d0d8c8e8e0e8d0d8e0f0c8d0e8d0e0e0d8f0d0d0e0d8f8f8f8f86f8421084210842108cc6318c6db6d54be660204081020408184821060071b85811c6001600160401b031060061b1794851c0260181a1c601f161a90911860031c01828603818111918118919091021892830101910161439a565b50600484018051199052601f198482030184525f8152602001604052509092915050565b604081811c5f90815260208490522080546001600160401b0380841682149082101661457f57604051633ab3447f60e11b815260040160405180910390fd5b9250929050565b6318fb58646004525f8281526024812068fbb67fda52d4bfb8bf83036145b35763f5a267f15f526004601cfd5b826145c55768fbb67fda52d4bfb8bf92505b8019548160205280614669578154806145e5578483556001935050612c4e565b8481036145f25750612c4e565b60018301548061460d57856001850155600194505050612c4e565b85810361461b575050612c4e565b6002840154806146375786600286015560019550505050612c4e565b86810361464657505050612c4e565b5f9283526040808420600190559183528183206002905582529020600390555060075b835f5260405f208054612da357600191821c8381018690558083019182905590821b8217831955909250612c4e565b5f825f015190506001815c01828183015d80825d50505050565b8015806146c357506146c381612a79565b156146d3576139a6838383614c39565b5f6146dd82612b05565b600101905061474b6040805160e081018252606060c0820181815282528251602080820185528282528084019190915283518082018552828152838501528351808201855282815282840152835180820185528281526080840152835190810190935282529060a082015290565b5f61475583613479565b90505f5b818110156147a7575f61476c85836134ca565b90506001600160a01b0381161561479e57604084015161478c9082614c83565b50606084015161479c905f61357c565b505b50600101614759565b505f5f5b86811015614998575f5f365f6147c28c8c87612eeb565b9350935093509350825f146147de576147db8387615abb565b95505b60048110156147f05750505050614990565b813560e01c63a9059cbb8190036148275760408901516148109086614c83565b5061482560248401355b60608b015190614ca2565b505b8063ffffffff166323b872dd0361488a573060248401356001600160a01b031603614856575050505050614990565b60448301355f0361486b575050505050614990565b604089015161487a9086614c83565b50614888604484013561481a565b505b8063ffffffff1663095ea7b3036148f05760248301355f036148b0575050505050614990565b88516148bc9086614c83565b506148d0600484013560208b015190614c83565b5060408901516148e09086614c83565b506148ee602484013561481a565b505b8063ffffffff166387517c450361498a576001600160a01b0385166e22d473030f116ddee9f6b43ac78ba31461492a575050505050614990565b60448301355f0361493f575050505050614990565b614952600484013560808b015190614c83565b50614966602484013560a08b015190614c83565b5061497a600484013560408b015190614c83565b50614988604484013561481a565b505b50505050505b6001016147ab565b506040830151516060840151516149af9190614cb8565b5f6149e26149c08560400151515190565b60606040518260201c5f031790508181528160051b6020820101604052919050565b90505f5b60408501515151811015614a2e57604085015151600582901b0160200151614a2482614a128330614dfb565b85919060059190911b82016020015290565b50506001016149e6565b50614a3a888888614c39565b5f8080526001860160205260408120614a5391846139b6565b5f5b84515151811015614a9757845151600582901b0160200151614a8e81614a88848960200151614deb90919063ffffffff16565b5f614e25565b50600101614a55565b505f5b60808501515151811015614ae157608085015151600582901b0160200151614ad881614ad3848960a00151614deb90919063ffffffff16565b614e65565b50600101614a9a565b505f5b60408501515151811015614b7057604085810151516020600584901b9182018101516001600160a01b0381165f90815260018b018352939093206060890151518301820151928601909101519091614b669183918591614b619190614b5690614b4d8930614dfb565b80821191030290565b808218908210021890565b6139b6565b5050600101614ae4565b505050505050505050565b8051805c80614b915763bc7ec7795f526004601cfd5b60018103825d505050565b5f385f3884865af161193a5763b12d13eb5f526004601cfd5b816014528060345263a9059cbb60601b5f5260205f604460105f875af18060015f511416614bf557803d853b151710614bf5576390b8ec185f526004601cfd5b505f603452505050565b6001600160a01b038181165f90815260018401602052604081205490911680151580614c305750614c308484614ec0565b91509250929050565b5f82614c455750505050565b5f5f365f614c54888887612eeb565b9350935093509350614c69848484848a614ecb565b50505050838390508160010191508103614c455750505050565b604080516060815290819052610eab83836001600160a01b031661357c565b604080516060815290819052610eab838361357c565b614d45565b805181602083015b8281511015614cf157805160209290920180518252918252614cf1868301878301805182519091529052565b602001848110614cc557508251815184528152614d18858201868501805182519091529052565b808360400111614d2d57614d2d858285614cbd565b838160600111613ad457613ad4858560208401614cbd565b805180835114614d6157634e487b715f5260326020526024601cfd5b600281106139a657828203602084018260051b8101614d81838284614cbd565b82820151604087015b8051845114614da65781858501525f9150602084019350805184525b8085015191820191821015614dc757634e487b715f5260116020526024601cfd5b602081019050828103614d8a57509282019290925284900360051c93849052505052565b905160059190911b016020015190565b5f816014526370a0823160601b5f5260208060246010865afa601f3d111660205102905092915050565b816014528060345263095ea7b360601b5f5260205f604460105f875af18060015f511416614bf557803d853b151710614bf557633e3f8f735f526004601cfd5b60405163cc53287f8152602080820152600160408201528260601b60601c60608201528160601b60601c60808201525f3860a0601c84015f6e22d473030f116ddee9f6b43ac78ba35af16139a6576396b3de235f526004601cfd5b5f610eab8383612bac565b614ed78186858561231e565b614efc578085848460405163f78c1b5360e01b8152600401613ab29493929190615aed565b613ad48585858585604051828482375f388483888a5af16121cb573d5f823e3d81fd5b5f5f83601f840112614f2f575f5ffd5b5081356001600160401b03811115614f45575f5ffd5b60208301915083602082850101111561457f575f5ffd5b5f5f5f60408486031215614f6e575f5ffd5b8335925060208401356001600160401b03811115614f8a575f5ffd5b614f9686828701614f1f565b9497909650939450505050565b5f60208284031215614fb3575f5ffd5b5035919050565b634e487b7160e01b5f52602160045260245ffd5b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b64ffffffffff81511682525f60208201516004811061501d5761501d614fba565b806020850152506040820151151560408401526060820151608060608501526125ea6080850182614fce565b602081525f610eab6020830184614ffc565b6001600160a01b038116811461199d575f5ffd5b801515811461199d575f5ffd5b8035610f748161506f565b5f5f5f5f6080858703121561509a575f5ffd5b8435935060208501356150ac8161505b565b925060408501356001600160e01b0319811681146150c8575f5ffd5b915060608501356150d88161506f565b939692955090935050565b803560078110610f74575f5ffd5b5f5f5f60608486031215615103575f5ffd5b8335925060208401356151158161505b565b9150615123604085016150e3565b90509250925092565b5f8151808452602084019350602083015f5b8281101561515c57815186526020958601959091019060010161513e565b5093949350505050565b5f604082016040835280855180835260608501915060608160051b8601019250602087015f5b828110156151bd57605f198786030184526151a8858351614ffc565b9450602093840193919091019060010161518c565b505050508281036020840152612b74818561512c565b5f602082840312156151e3575f5ffd5b81356001600160c01b0381168114610eab575f5ffd5b5f5f5f6060848603121561520b575f5ffd5b83359250602084013561521d8161505b565b9150604084013561522d8161505b565b809150509250925092565b5f5f5f5f6080858703121561524b575f5ffd5b84359350602085013561525d8161505b565b925061526b604086016150e3565b9396929550929360600135925050565b5f5f83601f84011261528b575f5ffd5b5081356001600160401b038111156152a1575f5ffd5b6020830191508360208260051b850101111561457f575f5ffd5b5f5f5f604084860312156152cd575f5ffd5b83356001600160401b038111156152e2575f5ffd5b6152ee8682870161527b565b909790965060209590950135949350505050565b5f5f5f60608486031215615314575f5ffd5b8335925060208401356153268161505b565b9150604084013561522d8161506f565b60ff60f81b8816815260e060208201525f61535460e0830189614fce565b82810360408401526153668189614fce565b606084018890526001600160a01b038716608085015260a0840186905283810360c0850152845180825260208087019350909101905f5b818110156153bb57835183526020938401939092019160010161539d565b50909b9a5050505050505050505050565b602080825282518282018190525f918401906040840190835b8181101561541b57835180516001600160a01b0390811685526020918201511681850152909301926040909201916001016153e5565b509095945050505050565b5f60208284031215615436575f5ffd5b8135610eab8161505b565b634e487b7160e01b5f52604160045260245ffd5b604051608081016001600160401b038111828210171561547757615477615441565b60405290565b5f82601f83011261548c575f5ffd5b81356001600160401b038111156154a5576154a5615441565b604051601f8201601f19908116603f011681016001600160401b03811182821017156154d3576154d3615441565b6040528181528382016020018510156154ea575f5ffd5b816020850160208301375f918101602001919091529392505050565b5f60208284031215615516575f5ffd5b81356001600160401b0381111561552b575f5ffd5b82016080818503121561553c575f5ffd5b615544615455565b813564ffffffffff81168114615558575f5ffd5b815260208201356004811061556b575f5ffd5b602082015261557c6040830161507c565b604082015260608201356001600160401b03811115615599575f5ffd5b6155a58682850161547d565b606083015250949350505050565b602080825282518282018190525f918401906040840190835b8181101561541b5783516001600160a01b03168352602093840193909201916001016155cc565b5f5f60208385031215615604575f5ffd5b82356001600160401b03811115615619575f5ffd5b6156258582860161527b565b90969095509350505050565b6007811061564157615641614fba565b9052565b5f8151808452602084019350602083015f5b8281101561515c57815180516001600160a01b031687526020808201515f91615682908a0182615631565b505060408181015190880152606080820151908801526080808201519088015260a0808201519088015260c0908101519087015260e09095019460209190910190600101615657565b5f604082016040835280855180835260608501915060608160051b8601019250602087015f5b8281101561572257605f1987860301845261570d858351615645565b945060209384019391909101906001016156f1565b50505050828103602084015280845180835260208301915060208160051b840101602087015f5b8381101561577b57601f1986840301855261576583835161512c565b6020958601959093509190910190600101615749565b509098975050505050505050565b5f5f6020838503121561579a575f5ffd5b82356001600160401b038111156157af575f5ffd5b61562585828601614f1f565b602081525f610eab6020830184614fce565b602081525f610eab6020830184615645565b602081525f610eab602083018461512c565b5f5f5f5f5f60808688031215615805575f5ffd5b85359450602086013593506040860135925060608601356001600160401b0381111561582f575f5ffd5b61583b88828901614f1f565b969995985093965092949392505050565b5f5f6040838503121561585d575f5ffd5b8235915061586d602084016150e3565b90509250929050565b5f5f5f5f60608587031215615889575f5ffd5b84359350602085013561589b8161505b565b925060408501356001600160401b038111156158b5575f5ffd5b6158c187828801614f1f565b95989497509550505050565b5f602082840312156158dd575f5ffd5b8151610eab8161505b565b805160208201516bffffffffffffffffffffffff198116919060148210156117e1576bffffffffffffffffffffffff1960149290920360031b82901b161692915050565b634e487b7160e01b5f52601160045260245ffd5b818103818111156112645761126461592c565b8381526001600160a01b0383166020820152606081016125ea6040830184615631565b634e487b7160e01b5f52603260045260245ffd5b5f6001820161599b5761599b61592c565b5060010190565b8481526001600160a01b0384166020820152608081016159c56040830185615631565b82606083015295945050505050565b5f602082840312156159e4575f5ffd5b8151610eab8161506f565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b602081525f6125ea6020830184866159ef565b5f5f8335601e19843603018112615a3f575f5ffd5b8301803591506001600160401b03821115615a58575f5ffd5b60200191503681900382131561457f575f5ffd5b5f85518060208801845e60d886901b6001600160d81b03191690830190815260048510615a9b57615a9b614fba565b60f894851b600582015292151590931b6006830152506007019392505050565b808201808211156112645761126461592c565b5f82615ae857634e487b7160e01b5f52601260045260245ffd5b500490565b8481526001600160a01b03841660208201526060604082018190525f90612e1690830184866159ef56fe3232323232323232323232323232323232323232323232323232323232323232def24cb3236edf62937b12ea8dc676927599974e90729c6e9eafa9f05b03eab8\" as const;\n\n","/**\n * Actions for Porto Relay.\n *\n * @see https://porto.sh/relay\n */\n\nimport * as AbiError from 'ox/AbiError'\nimport * as AbiFunction from 'ox/AbiFunction'\nimport type * as Address from 'ox/Address'\nimport * as Errors from 'ox/Errors'\nimport * as Hash from 'ox/Hash'\nimport * as Hex from 'ox/Hex'\nimport * as Secp256k1 from 'ox/Secp256k1'\nimport * as Signature from 'ox/Signature'\nimport {\n  BaseError,\n  type Calls,\n  type Chain,\n  type Client,\n  type Narrow,\n  type Transport,\n  type ValueOf,\n  withCache,\n} from 'viem'\nimport { verifyHash } from 'viem/actions'\nimport {\n  type GetExecuteErrorReturnType,\n  getExecuteError,\n} from 'viem/experimental/erc7821'\nimport * as z from 'zod/mini'\nimport * as RpcSchema from '../../core/internal/relay/rpcSchema.js'\nimport * as u from '../../core/internal/schema/utils.js'\nimport type { IsUndefined, OneOf } from '../../core/internal/types.js'\nimport * as U from '../../core/internal/utils.js'\nimport type { sendCalls } from '../RelayActions.js'\nimport type { GetChainParameter } from './utils.js'\n\n/**\n * Gets the authorization for a given address.\n *\n * @example\n * TODO\n *\n * @param client - The client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function getAuthorization(\n  client: Client,\n  parameters: getAuthorization.Parameters,\n): Promise<getAuthorization.ReturnType> {\n  try {\n    const method = 'wallet_getAuthorization' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await withCache(\n      () =>\n        client.request<Schema>({\n          method,\n          params: [\n            z.encode(RpcSchema.wallet_getAuthorization.Parameters, parameters),\n          ],\n        }),\n      { cacheKey: `${client.uid}.${method}.${parameters.address}` },\n    )\n    return z.decode(RpcSchema.wallet_getAuthorization.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    throw error\n  }\n}\n\nexport namespace getAuthorization {\n  export type Parameters = RpcSchema.wallet_getAuthorization.Parameters\n  export type ReturnType = RpcSchema.wallet_getAuthorization.Response\n}\n\n/**\n * Gets the capabilities for a given chain ID.\n *\n * @example\n * TODO\n *\n * @param client - The client to use.\n * @param options - Options.\n * @returns Result.\n */\nexport async function getCapabilities<\n  const chainIds extends 'all' | readonly number[] | undefined = undefined,\n  const raw extends boolean = false,\n>(\n  client: Client<Transport>,\n  options: getCapabilities.Options<chainIds, raw> = {},\n): Promise<getCapabilities.ReturnType<chainIds, raw>> {\n  const chainIds = (() => {\n    if (options.chainId) return [options.chainId]\n    if (options.chainIds === 'all') return undefined\n    if (options.chainIds) return options.chainIds as readonly number[]\n    return [client.chain!.id]\n  })()\n\n  try {\n    const method = 'wallet_getCapabilities' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await withCache(\n      () =>\n        client.request<Schema>(\n          {\n            method,\n            params: chainIds ? [chainIds] : undefined,\n          },\n          {\n            retryCount: 0,\n          },\n        ),\n      {\n        cacheKey: `${client.uid}.${method}.${chainIds?.join(',')}`,\n      },\n    )\n    const parsed = (() => {\n      if (options.raw) return result as never\n      return z.decode(RpcSchema.wallet_getCapabilities.Response, result)\n    })()\n    if (options.chainIds) return parsed as never\n    return Object.values(parsed)[0]! as never\n  } catch (error) {\n    parseSchemaError(error)\n    throw error\n  }\n}\n\nexport namespace getCapabilities {\n  export type Options<\n    chainIds extends 'all' | readonly number[] | undefined = undefined,\n    raw extends boolean = false,\n  > = {\n    /**\n     * Whether to return the raw, non-decoded response.\n     * @default false\n     */\n    raw?: raw | boolean | undefined\n  } & OneOf<\n    | {\n        /**\n         * Chain IDs to get the capabilities for.\n         * `\"all\"` will return the capabilities for all supported chains.\n         */\n        chainIds?: chainIds | 'all' | readonly number[] | undefined\n      }\n    | {\n        /**\n         * Chain ID to get the capabilities for.\n         */\n        chainId?: number | undefined\n      }\n  >\n\n  export type ReturnType<\n    chainIds extends 'all' | readonly number[] | undefined = undefined,\n    raw extends boolean = false,\n    //\n    value = raw extends true\n      ? z.input<typeof RpcSchema.wallet_getCapabilities.Response>\n      : RpcSchema.wallet_getCapabilities.Response,\n  > = IsUndefined<chainIds> extends true ? ValueOf<value> : value\n\n  export type ErrorType = parseSchemaError.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Get assets owned by user in given chain IDs.\n */\nexport async function getAssets(\n  client: Client,\n  parameters: getAssets.Parameters,\n): Promise<getAssets.ReturnType> {\n  const { account, assetFilter, assetTypeFilter, chainFilter } = parameters\n\n  try {\n    const method = 'wallet_getAssets' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>({\n      method,\n      params: [\n        z.encode(RpcSchema.wallet_getAssets.Parameters, {\n          account,\n          assetFilter,\n          assetTypeFilter,\n          chainFilter,\n        }),\n      ],\n    })\n\n    const value = z.decode(RpcSchema.wallet_getAssets.Response, result)\n    const decoded = Object.entries(value).reduce(\n      (acc, [key, value]) => {\n        acc[Hex.toNumber(key as `0x${string}`)] = value\n        return acc\n      },\n      {} as Record<number, ValueOf<typeof value>>,\n    )\n\n    const aggregated = {} as Record<string, ValueOf<typeof decoded>[number]>\n    for (const value of Object.values(decoded)) {\n      for (const item of value) {\n        const key = JSON.stringify(item.metadata)\n        aggregated[key] = {\n          ...item,\n          balance: item.balance + (aggregated[key]?.balance ?? 0n),\n        }\n      }\n    }\n\n    return {\n      ...decoded,\n      '0': Object.values(aggregated),\n    }\n  } catch (error) {\n    parseSchemaError(error)\n    throw error\n  }\n}\n\nexport namespace getAssets {\n  export type Parameters = RpcSchema.wallet_getAssets.Parameters\n  export type ReturnType = RpcSchema.wallet_getAssets.Response\n}\n\n/**\n * Requests faucet funds to be sent to an address on the Relay.\n */\nexport async function addFaucetFunds<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: addFaucetFunds.Parameters<chain>,\n): Promise<RpcSchema.wallet_addFaucetFunds.Response> {\n  const { address, chain = client.chain, tokenAddress, value } = parameters\n  try {\n    const method = 'wallet_addFaucetFunds' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.wallet_addFaucetFunds.Parameters, {\n            address,\n            chainId: chain?.id!,\n            tokenAddress,\n            value,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    // relay state can be behind node state. wait to ensure sync.\n    // TODO: figure out how to resolve.\n    await new Promise((resolve) => setTimeout(resolve, 2_000))\n    return result\n  } catch (error) {\n    parseSchemaError(error)\n    throw error\n  }\n}\n\nexport namespace addFaucetFunds {\n  export type Parameters<chain extends Chain | undefined = Chain | undefined> =\n    Omit<RpcSchema.wallet_addFaucetFunds.Parameters, 'chainId'> &\n      GetChainParameter<chain>\n}\n\n/**\n * Gets the status of a call bundle.\n *\n * @example\n * TODO\n *\n * @param client - The client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function getCallsStatus(\n  client: Client,\n  parameters: getCallsStatus.Parameters,\n): Promise<getCallsStatus.ReturnType> {\n  const { id } = parameters\n\n  try {\n    const method = 'wallet_getCallsStatus' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>({\n      method,\n      params: [id],\n    })\n    return z.decode(RpcSchema.wallet_getCallsStatus.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    throw error\n  }\n}\n\nexport namespace getCallsStatus {\n  export type Parameters = {\n    id: Hex.Hex\n  }\n\n  export type ReturnType = RpcSchema.wallet_getCallsStatus.Response\n\n  export type ErrorType = parseSchemaError.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Gets the keys for a given account.\n *\n * @example\n * TODO\n *\n * @param client - The client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function getKeys(\n  client: Client,\n  parameters: getKeys.Parameters,\n): Promise<getKeys.ReturnType> {\n  const { address, chainIds } = parameters\n\n  try {\n    const method = 'wallet_getKeys' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>({\n      method,\n      params: [\n        z.encode(RpcSchema.wallet_getKeys.Parameters, {\n          address,\n          chainIds,\n        }),\n      ],\n    })\n    return z.decode(RpcSchema.wallet_getKeys.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    throw error\n  }\n}\n\nexport namespace getKeys {\n  export type Parameters = RpcSchema.wallet_getKeys.Parameters\n\n  export type ReturnType = RpcSchema.wallet_getKeys.Response\n\n  export type ErrorType = parseSchemaError.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Gets the health of the RPC.\n *\n * @example\n * TODO\n *\n * @param client - The client to use.\n * @returns Result.\n */\nexport async function health(client: Client): Promise<health.ReturnType> {\n  const method = 'health' as const\n  type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n  const result = await withCache(\n    () =>\n      client.request<Schema>({\n        method,\n      }),\n    { cacheKey: `${client.uid}.${method}` },\n  )\n  return z.decode(RpcSchema.health.Response, result)\n}\n\nexport namespace health {\n  export type ReturnType = RpcSchema.health.Response\n\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Prepares a call bundle.\n *\n * @example\n * TODO\n *\n * @param client - The client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function prepareCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: prepareCalls.Parameters<calls, chain>,\n): Promise<prepareCalls.ReturnType> {\n  const { address, capabilities, chain = client.chain, key } = parameters\n\n  const calls = parameters.calls.map((call: any) => {\n    return {\n      data: call.abi\n        ? AbiFunction.encodeData(\n            AbiFunction.fromAbi(call.abi, call.functionName),\n            call.args,\n          )\n        : (call.data ?? '0x'),\n      to: call.to,\n      value: call.value ?? 0n,\n    }\n  })\n\n  try {\n    const method = 'wallet_prepareCalls' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.wallet_prepareCalls.Parameters, {\n            calls,\n            capabilities: {\n              ...capabilities,\n              meta: {\n                ...capabilities?.meta,\n              },\n            },\n            chainId: chain?.id!,\n            from: address,\n            key: key\n              ? {\n                  prehash: key.prehash,\n                  publicKey: key.publicKey,\n                  type: key.type,\n                }\n              : undefined,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return Object.assign(\n      z.decode(RpcSchema.wallet_prepareCalls.Response, result),\n      { _raw: result },\n    )\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error, { calls: parameters.calls })\n    throw error\n  }\n}\n\nexport namespace prepareCalls {\n  export type Parameters<\n    calls extends readonly unknown[] = readonly unknown[],\n    chain extends Chain | undefined = Chain | undefined,\n  > = {\n    address?: Address.Address | undefined\n    calls: Calls<Narrow<calls>>\n    capabilities?: RpcSchema.wallet_prepareCalls.Capabilities | undefined\n    key: RpcSchema.wallet_prepareCalls.Parameters['key']\n  } & GetChainParameter<chain>\n\n  export type ReturnType = RpcSchema.wallet_prepareCalls.Response & {\n    _raw: z.input<typeof RpcSchema.wallet_prepareCalls.Response>\n  }\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Prepares an account upgrade.\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function prepareUpgradeAccount<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: prepareUpgradeAccount.Parameters<chain>,\n): Promise<prepareUpgradeAccount.ReturnType> {\n  const {\n    address,\n    chain = client.chain,\n    delegation,\n    ...capabilities\n  } = parameters\n\n  try {\n    const method = 'wallet_prepareUpgradeAccount' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(\n            RpcSchema.wallet_prepareUpgradeAccount.Parameters,\n            U.normalizeValue({\n              address,\n              capabilities,\n              chainId: chain?.id,\n              delegation,\n            }),\n          ),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.wallet_prepareUpgradeAccount.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\nexport namespace prepareUpgradeAccount {\n  export type Parameters<chain extends Chain | undefined = Chain | undefined> =\n    RpcSchema.wallet_prepareUpgradeAccount.Parameters['capabilities'] &\n      Omit<\n        RpcSchema.wallet_prepareUpgradeAccount.Parameters,\n        'capabilities' | 'chainId'\n      > &\n      GetChainParameter<chain>\n\n  export type ReturnType = RpcSchema.wallet_prepareUpgradeAccount.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Broadcasts a signed call bundle.\n *\n * @example\n * TODO\n *\n * @param client - The client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function sendPreparedCalls(\n  client: Client,\n  parameters: sendPreparedCalls.Parameters,\n): Promise<sendPreparedCalls.ReturnType> {\n  const { capabilities, context, key, signature } = parameters\n  try {\n    const method = 'wallet_sendPreparedCalls' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.wallet_sendPreparedCalls.Parameters, {\n            capabilities,\n            context: {\n              preCall: context.preCall,\n              quote: context.quote,\n            },\n            key: key\n              ? {\n                  prehash: key.prehash,\n                  publicKey: key.publicKey,\n                  type: key.type,\n                }\n              : undefined,\n            signature,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.wallet_sendPreparedCalls.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace sendPreparedCalls {\n  export type Parameters = RpcSchema.wallet_sendPreparedCalls.Parameters\n\n  export type ReturnType = RpcSchema.wallet_sendPreparedCalls.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * NOTE: SHOULD ONLY BE USED ON SERVER.\n *\n * Gets onramp contact info for address.\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function getOnrampContactInfo(\n  client: Client,\n  parameters: getOnrampContactInfo.Parameters,\n): Promise<getOnrampContactInfo.ReturnType> {\n  const { address, secret } = parameters\n\n  try {\n    const method = 'account_getOnrampContactInfo' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.account_getOnrampContactInfo.Parameters, {\n            address,\n            secret,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.account_getOnrampContactInfo.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace getOnrampContactInfo {\n  export type Parameters = RpcSchema.account_getOnrampContactInfo.Parameters\n\n  export type ReturnType = RpcSchema.account_getOnrampContactInfo.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets onramp status for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function onrampStatus(\n  client: Client,\n  parameters: onrampStatus.Parameters,\n): Promise<onrampStatus.ReturnType> {\n  const { address } = parameters\n\n  try {\n    const method = 'account_onrampStatus' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.account_onrampStatus.Parameters, {\n            address,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.account_onrampStatus.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace onrampStatus {\n  export type Parameters = RpcSchema.account_onrampStatus.Parameters\n\n  export type ReturnType = RpcSchema.account_onrampStatus.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Resends phone verification for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function resendVerifyPhone(\n  client: Client,\n  parameters: resendVerifyPhone.Parameters,\n): Promise<resendVerifyPhone.ReturnType> {\n  const { phone, walletAddress } = parameters\n\n  try {\n    const method = 'account_resendVerifyPhone' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.account_resendVerifyPhone.Parameters, {\n            phone,\n            walletAddress,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.account_resendVerifyPhone.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace resendVerifyPhone {\n  export type Parameters = RpcSchema.account_resendVerifyPhone.Parameters\n\n  export type ReturnType = RpcSchema.account_resendVerifyPhone.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Sets email for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function setEmail(\n  client: Client,\n  parameters: setEmail.Parameters,\n): Promise<setEmail.ReturnType> {\n  const { email, walletAddress } = parameters\n\n  try {\n    const method = 'account_setEmail' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.account_setEmail.Parameters, {\n            email,\n            walletAddress,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.account_setEmail.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace setEmail {\n  export type Parameters = RpcSchema.account_setEmail.Parameters\n\n  export type ReturnType = RpcSchema.account_setEmail.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Sets phone for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function setPhone(\n  client: Client,\n  parameters: setPhone.Parameters,\n): Promise<setPhone.ReturnType> {\n  const { phone, walletAddress } = parameters\n\n  try {\n    const method = 'account_setPhone' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.account_setPhone.Parameters, {\n            phone,\n            walletAddress,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.account_setPhone.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace setPhone {\n  export type Parameters = RpcSchema.account_setPhone.Parameters\n\n  export type ReturnType = RpcSchema.account_setPhone.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Submits an account upgrade to the Relay.\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function upgradeAccount(\n  client: Client,\n  parameters: upgradeAccount.Parameters,\n): Promise<upgradeAccount.ReturnType> {\n  const { context, signatures } = parameters\n\n  try {\n    const method = 'wallet_upgradeAccount' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.wallet_upgradeAccount.Parameters, {\n            context,\n            signatures,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace upgradeAccount {\n  export type Parameters = RpcSchema.wallet_upgradeAccount.Parameters\n\n  export type ReturnType = RpcSchema.wallet_upgradeAccount.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies email for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function verifyEmail(\n  client: Client,\n  parameters: verifyEmail.Parameters,\n): Promise<verifyEmail.ReturnType> {\n  const { chainId, email, signature, token, walletAddress } = parameters\n\n  try {\n    const method = 'account_verifyEmail' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.account_verifyEmail.Parameters, {\n            chainId,\n            email,\n            signature,\n            token,\n            walletAddress,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.account_verifyEmail.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace verifyEmail {\n  export type Parameters = RpcSchema.account_verifyEmail.Parameters\n\n  export type ReturnType = RpcSchema.account_verifyEmail.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies email for address\n *\n * @example\n * TODO\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function verifyPhone(\n  client: Client,\n  parameters: verifyPhone.Parameters,\n): Promise<verifyPhone.ReturnType> {\n  const { code, phone, walletAddress } = parameters\n\n  try {\n    const method = 'account_verifyPhone' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await client.request<Schema>(\n      {\n        method,\n        params: [\n          z.encode(RpcSchema.account_verifyPhone.Parameters, {\n            code,\n            phone,\n            walletAddress,\n          }),\n        ],\n      },\n      {\n        retryCount: 0,\n      },\n    )\n    return z.decode(RpcSchema.account_verifyPhone.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    parseExecutionError(error)\n    throw error\n  }\n}\n\nexport namespace verifyPhone {\n  export type Parameters = RpcSchema.account_verifyPhone.Parameters\n\n  export type ReturnType = RpcSchema.account_verifyPhone.Response\n\n  export type ErrorType =\n    | parseSchemaError.ErrorType\n    | parseExecutionError.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a prepare calls response.\n *\n * @param client - Client to use.\n * @param parameters - Parameters.\n * @returns Whether or not the response is valid.\n */\nexport async function verifyPrepareCallsResponse(\n  client: Client,\n  parameters: verifyPrepareCallsResponse.Parameters,\n) {\n  const { signature } = parameters\n  const {\n    signature: _,\n    capabilities: { feeSignature: __, ...capabilities },\n    ...response\n  } = parameters.response\n\n  const sorted = sortKeys({ capabilities, ...response })\n\n  const payload = Hash.keccak256(Hex.fromString(JSON.stringify(sorted)))\n  const address = Secp256k1.recoverAddress({\n    payload,\n    signature: Signature.fromHex(signature),\n  })\n  const { quoteSigner } = await health(client)\n  return address === quoteSigner\n}\n\nexport namespace verifyPrepareCallsResponse {\n  export type Parameters = {\n    response: z.input<typeof RpcSchema.wallet_prepareCalls.Response>\n    signature: Hex.Hex\n  }\n}\n\n/**\n * Verifies a signature.\n *\n * @example\n * TODO\n *\n * @param client - The client to use.\n * @param parameters - Parameters.\n * @returns Result.\n */\nexport async function verifySignature<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: verifySignature.Parameters<chain>,\n): Promise<verifySignature.ReturnType> {\n  const { address, chain = client.chain, digest, signature } = parameters\n\n  try {\n    async function fallback() {\n      const valid = await verifyHash(client, {\n        address,\n        hash: digest,\n        signature,\n      })\n      return {\n        proof: null,\n        valid,\n      }\n    }\n\n    const method = 'wallet_verifySignature' as const\n    type Schema = Extract<RpcSchema.Viem[number], { Method: typeof method }>\n    const result = await (async () => {\n      const result = await client\n        .request<Schema>(\n          {\n            method,\n            params: [\n              z.encode(RpcSchema.wallet_verifySignature.Parameters, {\n                address,\n                chainId: chain?.id!,\n                digest,\n                signature,\n              }),\n            ],\n          },\n          {\n            retryCount: 0,\n          },\n        )\n        .catch(fallback)\n      if (result.valid) return result\n      return fallback()\n    })()\n    return z.decode(RpcSchema.wallet_verifySignature.Response, result)\n  } catch (error) {\n    parseSchemaError(error)\n    throw error\n  }\n}\n\nexport namespace verifySignature {\n  export type Parameters<chain extends Chain | undefined = Chain | undefined> =\n    Omit<\n      RpcSchema.wallet_verifySignature.Parameters,\n      'chainId' | 'keyIdOrAddress'\n    > & {\n      address: Address.Address\n    } & GetChainParameter<chain>\n\n  export type ReturnType = RpcSchema.wallet_verifySignature.Response\n\n  export type ErrorType = parseSchemaError.ErrorType | Errors.GlobalErrorType\n}\n\nexport function parseExecutionError<const calls extends readonly unknown[]>(\n  e: unknown,\n  { calls }: { calls?: sendCalls.Parameters<calls>['calls'] | undefined } = {},\n) {\n  if (!(e instanceof BaseError)) return\n\n  const getAbiError = (error: GetExecuteErrorReturnType) => {\n    try {\n      if (error.name === 'ContractFunctionExecutionError') {\n        const data =\n          error.cause.name === 'ContractFunctionRevertedError'\n            ? error.cause.data\n            : undefined\n        if (data)\n          return AbiError.fromAbi(\n            [data.abiItem],\n            data.errorName,\n          ) as AbiError.AbiError\n      }\n\n      const cause = error.walk(\n        (e) =>\n          !(e instanceof Error) &&\n          (e as { code?: number | undefined }).code === 3,\n      ) as (BaseError & { code: number; data: Hex.Hex }) | undefined\n      if (!cause) return undefined\n\n      const { data, message } = cause\n      if (data === '0xd0d5039b') return AbiError.from('error Unauthorized()')\n      return {\n        inputs: [],\n        name: (message ?? data).split('(')[0]!,\n        type: 'error',\n      } satisfies AbiError.AbiError\n    } catch {\n      return undefined\n    }\n  }\n  const error = getExecuteError(e as BaseError, {\n    calls: (calls ?? []) as any,\n  })\n  const abiError = getAbiError(error)\n  if (error === e && !abiError) return\n  throw new ExecutionError(Object.assign(error, { abiError }))\n}\n\nexport function sortKeys<value>(value: value): value {\n  if (typeof value === 'object' && value !== null) {\n    if (Array.isArray(value)) return value.map(sortKeys) as value\n    const result = {} as Record<string, unknown>\n    for (const key of Object.keys(value).sort())\n      result[key] = sortKeys(value[key as keyof typeof value])\n    return result as value\n  }\n  return value\n}\n\nexport declare namespace parseExecutionError {\n  export type ErrorType = ExecutionError | Errors.GlobalErrorType\n}\n\n/** Thrown when schema validation fails. */\nexport function parseSchemaError(e: unknown) {\n  if ((e as any).name === '$ZodError') throw u.toValidationError(e)\n}\n\nexport declare namespace parseSchemaError {\n  type ErrorType = u.ValidationError | Errors.GlobalErrorType\n}\n\n/** Thrown when the execution fails. */\nexport class ExecutionError extends Errors.BaseError<BaseError> {\n  override readonly name = 'Rpc.ExecutionError'\n\n  abiError?: AbiError.AbiError | undefined\n\n  constructor(cause: BaseError & { abiError?: AbiError.AbiError | undefined }) {\n    super('An error occurred while executing calls.', {\n      cause,\n      metaMessages: [cause.abiError && 'Reason: ' + cause.abiError.name].filter(\n        Boolean,\n      ),\n    })\n\n    this.abiError = cause.abiError\n  }\n}\n","import type * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Encodes a personal sign message in [ERC-191 format](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e): `0x19  \"Ethereum Signed Message:\\n\" + message.length  message`.\n *\n * @example\n * ```ts twoslash\n * import { Hex, PersonalMessage } from 'ox'\n *\n * const data = PersonalMessage.encode(Hex.fromString('hello world'))\n * // @log: '0x19457468657265756d205369676e6564204d6573736167653a0a313168656c6c6f20776f726c64'\n * // @log: (0x19  'Ethereum Signed Message:\\n11'  'hello world')\n * ```\n *\n * @param data - The data to encode.\n * @returns The encoded personal sign message.\n */\nexport function encode(data: Hex.Hex | Bytes.Bytes): Hex.Hex {\n  const message = Hex.from(data)\n  return Hex.concat(\n    // Personal Sign Format: `0x19  \"Ethereum Signed Message:\\n\"  message.length  message`\n    '0x19',\n    Hex.fromString('Ethereum Signed Message:\\n' + Hex.size(message)),\n    message,\n  )\n}\n\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.from.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing an [ERC-191 formatted](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e) personal message.\n *\n * @example\n * ```ts twoslash\n * import { Hex, PersonalMessage, Secp256k1 } from 'ox'\n *\n * const payload = PersonalMessage.getSignPayload(Hex.fromString('hello world')) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param data - The data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload(data: Hex.Hex | Bytes.Bytes): Hex.Hex {\n  return Hash.keccak256(encode(data))\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n","import type { ResolvedRegister } from './internal/register.js'\nimport type { Compute, IsNarrowable } from './internal/types.js'\n\nexport type { Eth } from './internal/rpcSchemas/eth.js'\nexport type { Wallet } from './internal/rpcSchemas/wallet.js'\n\n/**\n * Instantiates a statically typed Schema. This is a runtime-noop function, and is purposed\n * to be used as a type-level tag to be used with {@link ox#Provider.(from:function)} or\n * {@link ox#RpcTransport.(fromHttp:function)}.\n *\n * @example\n * ### Using with `Provider.from`\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Provider, RpcSchema } from 'ox'\n *\n * const schema = RpcSchema.from<\n *   | RpcSchema.Default\n *   | {\n *       Request: {\n *         method: 'abe_foo',\n *         params: [id: number],\n *       }\n *       ReturnType: string\n *     }\n *   | {\n *       Request: {\n *         method: 'abe_bar',\n *         params: [id: string],\n *       }\n *       ReturnType: string\n *     }\n * >()\n *\n * const provider = Provider.from(window.ethereum, { schema })\n *\n * const blockNumber = await provider.request({ method: 'e' })\n * //                                                    ^|\n *\n *\n *\n *\n *\n * ```\n */\nexport function from<schema extends Generic>(): schema {\n  return null as never\n}\n\n/**\n * Extracts a schema item from a {@link ox#RpcSchema.Generic} or {@link ox#RpcSchema.MethodNameGeneric}.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Item = RpcSchema.ExtractItem<RpcSchema.Eth, 'eth_getBlockByNumber'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractItem<\n  schema extends Generic,\n  methodName extends MethodNameGeneric<schema> = MethodNameGeneric<schema>,\n> = Compute<{\n  Request: ExtractRequest<schema, methodName>\n  ReturnType: ExtractReturnType<schema, methodName>\n}>\n\n/**\n * Extracts request from a {@link ox#RpcSchema.Generic} or {@link ox#RpcSchema.MethodNameGeneric}.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Request = RpcSchema.ExtractRequest<RpcSchema.Eth, 'eth_getBlockByNumber'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractRequest<\n  schema extends Generic,\n  methodName extends MethodNameGeneric<schema> = MethodNameGeneric<schema>,\n> = Extract<schema['Request'], { method: methodName }>\n\n/**\n * Type-safe union of all JSON-RPC Method Names.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type MethodName = RpcSchema.ExtractMethodName<RpcSchema.Default>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractMethodName<schema extends Generic> =\n  schema['Request']['method']\n\n/**\n * Extracts parameters from a {@link ox#RpcSchema.Generic} or {@link ox#RpcSchema.MethodNameGeneric}.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Eth_GetBlockByNumber = RpcSchema.ExtractParams<RpcSchema.Eth, 'eth_getBlockByNumber'>\n * //   ^?\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractParams<\n  schema extends Generic,\n  methodName extends MethodNameGeneric<schema> = MethodNameGeneric<schema>,\n> = ExtractRequest<schema, methodName>['params']\n\n/**\n * Extracts return type from a {@link ox#RpcSchema.Generic} or {@link ox#RpcSchema.MethodNameGeneric}.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type ReturnType = RpcSchema.ExtractReturnType<RpcSchema.Eth, 'eth_getBlockByNumber'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type ExtractReturnType<\n  schema extends Generic,\n  methodName extends MethodNameGeneric<schema> = MethodNameGeneric<schema>,\n> = methodName extends schema['Request']['method']\n  ? IsNarrowable<schema, Generic> extends true\n    ? Extract<schema, { Request: { method: methodName } }>['ReturnType']\n    : unknown\n  : unknown\n\n/**\n * Type to define a custom type-safe JSON-RPC Schema.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema, RpcRequest } from 'ox'\n *\n * type Schema = RpcSchema.From<{\n *   Request: {\n *     method: 'eth_foobar',\n *     params: [id: number],\n *   }\n *   ReturnType: string\n * }>\n * ```\n */\nexport type From<schema extends Generic> = schema\n\n/**\n * Generic type to define a JSON-RPC Method.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Schema = RpcSchema.Generic\n * //   ^?\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type Generic<name extends string = string, params = unknown> = {\n  Request: {\n    method: name\n    params?: params | undefined\n  }\n  ReturnType?: unknown\n}\n\n/**\n * Type-safe union of all JSON-RPC Methods.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Schema = RpcSchema.Default\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type Default = ResolvedRegister['RpcSchema']\n\n/**\n * Generic type to define a JSON-RPC Method Name.\n *\n * @example\n * ```ts twoslash\n * import { RpcSchema } from 'ox'\n *\n * type Name = RpcSchema.MethodNameGeneric\n * //   ^?\n *\n *\n *\n *\n *\n * ```\n */\nexport type MethodNameGeneric<schema extends Generic = Generic> =\n  | schema['Request']['method']\n  | (string & {})\n","import type { Errors } from '../index.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport type { Compute } from './internal/types.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** A JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object). */\nexport type RpcRequest<schema extends RpcSchema.Generic = RpcSchema.Generic> =\n  Compute<\n    schema extends any\n      ? schema['Request'] & {\n          id: number\n          jsonrpc: '2.0'\n          /** @deprecated internal */\n          _returnType: schema['ReturnType']\n        }\n      : never\n  >\n\n/** JSON-RPC request store type. */\nexport type Store<schema extends RpcSchema.Generic = RpcSchema.Default> =\n  Compute<{\n    prepare: <methodName extends RpcSchema.MethodNameGeneric>(\n      parameters: Compute<\n        RpcSchema_internal.ExtractRequestOpaque<schema, methodName>\n      >,\n    ) => Compute<RpcRequest<RpcSchema.ExtractItem<schema, methodName>>>\n    readonly id: number\n  }>\n\n/**\n * Creates a JSON-RPC request store to build requests with an incrementing `id`.\n *\n * Returns a type-safe `prepare` function to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest } from 'ox'\n *\n * const store = RpcRequest.createStore()\n *\n * const request_1 = store.prepare({\n *   method: 'eth_blockNumber',\n * })\n * // @log: { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber' }\n *\n * const request_2 = store.prepare({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       to: '0x0000000000000000000000000000000000000000',\n *       data: '0xdeadbeef',\n *     },\n *   ],\n * })\n * // @log: { id: 1, jsonrpc: '2.0', method: 'eth_call', params: [{ to: '0x0000000000000000000000000000000000000000', data: '0xdeadbeef' }] }\n * ```\n *\n * @example\n * ### Type-safe Custom Schemas\n *\n * It is possible to define your own type-safe schema by using the {@link ox#RpcSchema.From} type.\n *\n * ```ts twoslash\n * import { RpcSchema, RpcRequest } from 'ox'\n *\n * type Schema = RpcSchema.From<{ // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobar' // [!code focus]\n *     params: [number] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * } | { // [!code focus]\n *   Request: { // [!code focus]\n *     method: 'eth_foobaz' // [!code focus]\n *     params: [string] // [!code focus]\n *   } // [!code focus]\n *   ReturnType: string // [!code focus]\n * }> // [!code focus]\n *\n * const store = RpcRequest.createStore<Schema>() // [!code focus]\n *\n * const request = store.prepare({\n *   method: 'eth_foobar', // [!code focus]\n *   // ^?\n *   params: [42],\n * })\n * ```\n *\n * @param options - Request store options.\n * @returns The request store\n */\nexport function createStore<\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n>(options: createStore.Options = {}): createStore.ReturnType<schema> {\n  let id = options.id ?? 0\n  return {\n    prepare(options) {\n      return from({\n        id: id++,\n        ...options,\n      } as never) as never\n    },\n    get id() {\n      return id\n    },\n  }\n}\n\nexport declare namespace createStore {\n  type Options = {\n    /** The initial request ID. */\n    id?: number\n  }\n\n  type ReturnType<schema extends RpcSchema.Generic = RpcSchema.Default> =\n    Store<schema>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * A type-safe interface to build a JSON-RPC request object as per the [JSON-RPC 2.0 specification](https://www.jsonrpc.org/specification#request_object).\n *\n * :::warning\n *\n * You will likely want to use {@link ox#RpcRequest.(createStore:function)} instead as it will also manage `id`s and uses this function internally.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, RpcResponse } from 'ox'\n *\n * // 1. Build a request object.\n * const request = RpcRequest.from({ // [!code focus]\n *   id: 0, // [!code focus]\n *   method: 'eth_estimateGas', // [!code focus]\n *   params: [ // [!code focus]\n *     { // [!code focus]\n *       from: '0xd2135CfB216b74109775236E36d4b433F1DF507B', // [!code focus]\n *       to: '0x0D44f617435088c947F00B31160f64b074e412B4', // [!code focus]\n *       value: '0x69420', // [!code focus]\n *     }, // [!code focus]\n *   ], // [!code focus]\n * }) // [!code focus]\n *\n * // 2. Send the JSON-RPC request via HTTP.\n * const gas = await fetch('https://1.rpc.thirdweb.com', {\n *   body: JSON.stringify(request),\n *   headers: {\n *     'Content-Type': 'application/json',\n *   },\n *   method: 'POST',\n * })\n *  .then((response) => response.json())\n *  // 3. Parse the JSON-RPC response into a type-safe result.\n *  .then((response) => RpcResponse.parse(response, { request }))\n * ```\n *\n * @param options - JSON-RPC request options.\n * @returns The fully-formed JSON-RPC request object.\n */\nexport function from<methodName extends RpcSchema.MethodNameGeneric>(\n  options: from.Options<methodName>,\n): from.ReturnType<methodName> {\n  return {\n    ...options,\n    jsonrpc: '2.0',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<methodName extends RpcSchema.MethodNameGeneric> = Compute<\n    RpcSchema_internal.ExtractRequestOpaque<RpcSchema.Default, methodName> & {\n      id: number\n    }\n  >\n\n  type ReturnType<methodName extends RpcSchema.MethodNameGeneric> = Compute<\n    RpcRequest<RpcSchema.ExtractItem<RpcSchema.Default, methodName>>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"names":[],"mappings":"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AkB7IN,CAAC,CoB0FG,ADhOO,CAAA,KAAA,CnBuIV,EGqUmB,Aa7TV,ChBPT,GAA2B,GAAG,CAAC,AAChC,CAAA,IAAA,CADmB,CAAC,OAAO,IAKhB,CAAE,CgBKC,AhBLE,GJ6Ba,GI7BP,EAAS,MAAD,CAAQ,CAAC,kCAItC,GAAA,EAAW,MAAM,C7B1DS,C6B0DP,CAAC,CAAC,CAAC,CACtB,aAAc,CACZ,CG8W4B,EH9W5B,EAAW,MAAM,EAAA,CAAA,EAAA,EAAO,KJiCiB,GtBJO,I0B7BZ,CACpC,I7B3D6B,CAAA,W6B2Db,CAAE,EAClB,CdIoB,GiC9IN,YnByIsB,GAElC,GAAW,EAAA,IAEF,CAAkB,CgBSV,AhBRX,CgBQY,A9BDQ,A8BCS,C9BDT,C8BCW,CAAA,IhBRtB,YAKtB,GAGH,CGyYO,MHzYA,QAAQ,CCjBD,A9BvCE,CAAC,C6BwDC,CAAA,EACP,GAAG,CAAA,MAAQ,MgBaH,ChBbU,CgBaR,AhBZX,C7BzDD,C8BwCC,ADiBY,CCjBD,Ce8BG,Af7BpB,ADgB0B,YAAY,EAAE,MAAM,EAC1C,C7BzDC,C8B0CL,EDeS,AAAD,CgBaI,Ef5BH,GDeW,AAAM,CCfb,ADeQ,CCfP,ADeW,CAAI,CAAC,ACfX,ADgBhB,CAD4B,MACrB,EChBoB,Ae6BlB,If7BsB,CkB7Hb,AnB6IJ,AChBkB,CDgBiB,CAAA,AAC9C,EAAc,ECjBqB,ADiBb,ICdE,CAAC,IAHmB,AAGf,CAAC,EAAA,CAHkB,CDiBZ,MCdI,CAAC,AAHe,CAGf,EAHkB,CDiBZ,CCjBc,CACpE,ADiBK,CCjBL,GDiBS,AAAC,CG0iBS,EAAE,CHziBhB,ECbE,CAAA,CDcA,ECdY,EDcN,CCdW,CAAC,ADcK,GACrB,CG0iBiC,AH1iBhC,CAAC,C7BzD6C,GAAA,G6ByDvC,CAAC,GAAoB,C7BzDyB,G6B2DxD,GAAI,EAAe,CAFsB,CAAC,AG2iB1B,AHziBK,CADpB,CAAA,CACyB,CGyiBS,CAAC,CHziBP,AAAE,EAAE,CAC/B,C7B1DG,K6B0DI,IACF,CGwiBiB,AACE,CHxiBtB,AGuiBqB,CFxjBP,CAAC,AE0jBD,ChCrmBE,A6B4Db,CChB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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]}