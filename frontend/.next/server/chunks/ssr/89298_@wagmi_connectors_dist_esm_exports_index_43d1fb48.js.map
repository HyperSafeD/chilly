{"version":3,"sources":["turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/pony-cause/index.mjs","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/version.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/utils/src/json.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/superstruct/src/structs/refinements.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/core/src/connectors/mock.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/superstruct/src/structs/coercions.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/utils/src/assert.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/superstruct/src/structs/utilities.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/core/src/utils/extractRpcUrls.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/superstruct/src/struct.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/rpc-errors/src/utils.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/rpc-errors/src/errors.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/rpc-errors/src/error-constants.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/superstruct/src/structs/types.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/gemini.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/utils/src/errors.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/safe.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/metaMask.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/porto.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/coinbaseWallet.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/baseAccount.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/walletConnect.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@wagmi/connectors/src/exports/index.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@gemini-wallet/core/src/communicator.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/utils/src/misc.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/superstruct/src/error.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@gemini-wallet/core/dist/index.js","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/pony-cause/lib/error-with-cause.mjs","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/superstruct/src/utils.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@gemini-wallet/core/src/constants.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@metamask/rpc-errors/src/classes.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/pony-cause/lib/helpers.mjs","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@gemini-wallet/core/src/types.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@gemini-wallet/core/src/utils/base64.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@gemini-wallet/core/src/utils/calculateWalletAddress.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@gemini-wallet/core/src/utils/ens.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/@gemini-wallet/core/src/utils/popup.ts"],"sourcesContent":["'use strict';\n\nexport { ErrorWithCause } from './lib/error-with-cause.mjs';\n\nexport {\n  findCauseByReference,\n  getErrorCause,\n  messageWithCauses,\n  stackWithCauses,\n} from './lib/helpers.mjs';\n","export const version = '6.1.3'\n","import {\n  any,\n  array,\n  coerce,\n  create,\n  define,\n  integer,\n  is,\n  literal,\n  nullable,\n  number,\n  object as superstructObject,\n  optional,\n  record,\n  string,\n  union,\n  unknown,\n  Struct,\n  refine,\n} from '@metamask/superstruct';\nimport type {\n  Context,\n  Infer,\n  ObjectSchema,\n  Simplify,\n  Optionalize,\n} from '@metamask/superstruct';\n\nimport type { AssertionErrorConstructor } from './assert';\nimport { assertStruct } from './assert';\nimport { hasProperty } from './misc';\n\n/**\n * Any JSON-compatible value.\n */\nexport type Json =\n  | null\n  | boolean\n  | number\n  | string\n  | Json[]\n  | { [prop: string]: Json };\n\n/**\n * A helper type to make properties with `undefined` in their type optional, but\n * not `undefined` itself.\n *\n * @deprecated Use `ObjectType` and/or `ExactOptionalize` from `@metamask/superstruct@>=3.2.0` instead.\n * @example\n * ```ts\n * type Foo = ObjectOptional<{ foo: string | undefined }>;\n * // Foo is equivalent to { foo?: string }\n * ```\n */\nexport type ObjectOptional<Schema extends Record<string, unknown>> = {\n  [Key in keyof Schema as Schema[Key] extends ExactOptionalGuard\n    ? Key\n    : never]?: Schema[Key] extends ExactOptionalGuard & infer Original\n    ? Original\n    : never;\n} & {\n  [Key in keyof Schema as Schema[Key] extends ExactOptionalGuard\n    ? never\n    : Key]: Schema[Key];\n};\n\n/**\n * An object type with support for exact optionals. This is used by the `object`\n * struct. This uses the {@link ObjectOptional} helper to make properties with\n * `undefined` in their type optional, but not `undefined` itself.\n *\n * @deprecated Use `ObjectType` from `@metamask/superstruct@>=3.2.0` instead.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  ObjectOptional<\n    Optionalize<{\n      [Key in keyof Schema]: Infer<Schema[Key]>;\n    }>\n  >\n>;\n\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nexport const object = <Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>> =>\n  // The type is slightly different from a regular object struct, because we\n  // want to make properties with `undefined` in their type optional, but not\n  // `undefined` itself. This means that we need a type cast.\n  superstructObject(schema) as unknown as Struct<ObjectType<Schema>>;\n\ndeclare const exactOptionalSymbol: unique symbol;\ntype ExactOptionalGuard = {\n  _exactOptionalGuard?: typeof exactOptionalSymbol;\n};\n\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }: Context): boolean {\n  const field = path[path.length - 1];\n  return hasProperty(branch[branch.length - 2], field);\n}\n\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nexport function exactOptional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type & ExactOptionalGuard, Schema> {\n  return new Struct<Type & ExactOptionalGuard, Schema>({\n    ...struct,\n\n    type: `optional ${struct.type}`,\n    validator: (value, context) =>\n      !hasOptional(context) || struct.validator(value, context),\n\n    refiner: (value, context) =>\n      !hasOptional(context) || struct.refiner(value as Type, context),\n  });\n}\n\n/**\n * Validate an unknown input to be valid JSON.\n *\n * Useful for constructing JSON structs.\n *\n * @param json - An unknown value.\n * @returns True if the value is valid JSON, otherwise false.\n */\nfunction validateJson(json: unknown): boolean {\n  if (json === null || typeof json === 'boolean' || typeof json === 'string') {\n    return true;\n  }\n\n  if (typeof json === 'number' && Number.isFinite(json)) {\n    return true;\n  }\n\n  if (typeof json === 'object') {\n    let every = true;\n    if (Array.isArray(json)) {\n      // Ignoring linting error since for-of is significantly slower than a normal for-loop\n      // and performance is important in this specific function.\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < json.length; i++) {\n        if (!validateJson(json[i])) {\n          every = false;\n          break;\n        }\n      }\n      return every;\n    }\n\n    const entries = Object.entries(json);\n    // Ignoring linting errors since for-of is significantly slower than a normal for-loop\n    // and performance is important in this specific function.\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < entries.length; i++) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      if (typeof entries[i]![0] !== 'string' || !validateJson(entries[i]![1])) {\n        every = false;\n        break;\n      }\n    }\n    return every;\n  }\n\n  return false;\n}\n\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\nexport const UnsafeJsonStruct: Struct<Json> = define('JSON', (json) =>\n  validateJson(json),\n);\n\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexport const JsonStruct = coerce(\n  UnsafeJsonStruct,\n  refine(any(), 'JSON', (value) => is(value, UnsafeJsonStruct)),\n  (value) =>\n    JSON.parse(\n      JSON.stringify(value, (propKey, propValue) => {\n        // Strip __proto__ and constructor properties to prevent prototype pollution.\n        if (propKey === '__proto__' || propKey === 'constructor') {\n          return undefined;\n        }\n        return propValue;\n      }),\n    ),\n);\n\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nexport function isValidJson(value: unknown): value is Json {\n  try {\n    getSafeJson(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nexport function getSafeJson<Type extends Json = Json>(value: unknown): Type {\n  return create(value, JsonStruct) as Type;\n}\n\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nexport function getJsonSize(value: unknown): number {\n  assertStruct(value, JsonStruct, 'Invalid JSON value');\n\n  const json = JSON.stringify(value);\n  return new TextEncoder().encode(json).byteLength;\n}\n\n/**\n * The string '2.0'.\n */\nexport const jsonrpc2 = '2.0' as const;\nexport const JsonRpcVersionStruct = literal(jsonrpc2);\n\n/**\n * A String specifying the version of the JSON-RPC protocol.\n * MUST be exactly \"2.0\".\n */\nexport type JsonRpcVersion2 = typeof jsonrpc2;\n\nexport const JsonRpcIdStruct = nullable(union([number(), string()]));\n\n/**\n * An identifier established by the Client that MUST contain a String, Number,\n * or NULL value if included. If it is not included it is assumed to be a\n * notification. The value SHOULD normally not be Null and Numbers SHOULD\n * NOT contain fractional parts.\n */\nexport type JsonRpcId = Infer<typeof JsonRpcIdStruct>;\n\nexport const JsonRpcErrorStruct = object({\n  code: integer(),\n  message: string(),\n  data: exactOptional(JsonStruct),\n  stack: exactOptional(string()),\n});\n\n/**\n * Mark a certain key of a type as optional.\n */\nexport type OptionalField<\n  Type extends Record<string, unknown>,\n  Key extends keyof Type,\n> = Omit<Type, Key> & Partial<Pick<Type, Key>>;\n\n/**\n * A JSON-RPC error object.\n *\n * Note that TypeScript infers `unknown | undefined` as `unknown`, meaning that\n * the `data` field is not optional. To make it optional, we use the\n * `OptionalField` helper, to explicitly make it optional.\n */\nexport type JsonRpcError = OptionalField<\n  Infer<typeof JsonRpcErrorStruct>,\n  'data'\n>;\n\nexport const JsonRpcParamsStruct: Struct<Json[] | Record<string, Json>, null> =\n  union([record(string(), JsonStruct), array(JsonStruct)]);\n\nexport type JsonRpcParams = Json[] | Record<string, Json>;\n\nexport const JsonRpcRequestStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct),\n});\n\nexport type InferWithParams<\n  Type extends Struct<any>,\n  Params extends JsonRpcParams,\n> = Infer<Type> & {\n  params?: Params;\n};\n\n/**\n * A JSON-RPC request object.\n */\nexport type JsonRpcRequest<Params extends JsonRpcParams = JsonRpcParams> =\n  InferWithParams<typeof JsonRpcRequestStruct, Params>;\n\nexport const JsonRpcNotificationStruct = object({\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct),\n});\n\n/**\n * A JSON-RPC notification object.\n */\nexport type JsonRpcNotification<Params extends JsonRpcParams = JsonRpcParams> =\n  InferWithParams<typeof JsonRpcNotificationStruct, Params>;\n\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nexport function isJsonRpcNotification(\n  value: unknown,\n): value is JsonRpcNotification {\n  return is(value, JsonRpcNotificationStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nexport function assertIsJsonRpcNotification(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcNotification {\n  assertStruct(\n    value,\n    JsonRpcNotificationStruct,\n    'Invalid JSON-RPC notification',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nexport function isJsonRpcRequest(value: unknown): value is JsonRpcRequest {\n  return is(value, JsonRpcRequestStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nexport function assertIsJsonRpcRequest(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcRequest {\n  assertStruct(\n    value,\n    JsonRpcRequestStruct,\n    'Invalid JSON-RPC request',\n    ErrorWrapper,\n  );\n}\n\nexport const PendingJsonRpcResponseStruct = superstructObject({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: optional(unknown()),\n  error: optional(JsonRpcErrorStruct),\n});\n\n/**\n * A JSON-RPC response object that has not yet been resolved.\n */\nexport type PendingJsonRpcResponse<Result extends Json = Json> = Omit<\n  Infer<typeof PendingJsonRpcResponseStruct>,\n  'result'\n> & {\n  result?: Result;\n};\n\nexport const JsonRpcSuccessStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: JsonStruct,\n});\n\n/**\n * A successful JSON-RPC response object.\n */\nexport type JsonRpcSuccess<Result extends Json = Json> = Omit<\n  Infer<typeof JsonRpcSuccessStruct>,\n  'result'\n> & {\n  result: Result;\n};\n\nexport const JsonRpcFailureStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  error: JsonRpcErrorStruct as Struct<JsonRpcError>,\n});\n\n/**\n * A failed JSON-RPC response object.\n */\nexport type JsonRpcFailure = Infer<typeof JsonRpcFailureStruct>;\n\nexport const JsonRpcResponseStruct = union([\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct,\n]);\n\n/**\n * A JSON-RPC response object. Must be checked to determine whether it's a\n * success or failure.\n *\n * @template Result - The type of the result.\n */\nexport type JsonRpcResponse<Result extends Json = Json> =\n  | JsonRpcSuccess<Result>\n  | JsonRpcFailure;\n\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nexport function isPendingJsonRpcResponse(\n  response: unknown,\n): response is PendingJsonRpcResponse {\n  return is(response, PendingJsonRpcResponseStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nexport function assertIsPendingJsonRpcResponse(\n  response: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts response is PendingJsonRpcResponse {\n  assertStruct(\n    response,\n    PendingJsonRpcResponseStruct,\n    'Invalid pending JSON-RPC response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nexport function isJsonRpcResponse(\n  response: unknown,\n): response is JsonRpcResponse {\n  return is(response, JsonRpcResponseStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nexport function assertIsJsonRpcResponse(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcResponse {\n  assertStruct(\n    value,\n    JsonRpcResponseStruct,\n    'Invalid JSON-RPC response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nexport function isJsonRpcSuccess(value: unknown): value is JsonRpcSuccess {\n  return is(value, JsonRpcSuccessStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nexport function assertIsJsonRpcSuccess(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcSuccess {\n  assertStruct(\n    value,\n    JsonRpcSuccessStruct,\n    'Invalid JSON-RPC success response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nexport function isJsonRpcFailure(value: unknown): value is JsonRpcFailure {\n  return is(value, JsonRpcFailureStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nexport function assertIsJsonRpcFailure(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcFailure {\n  assertStruct(\n    value,\n    JsonRpcFailureStruct,\n    'Invalid JSON-RPC failure response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nexport function isJsonRpcError(value: unknown): value is JsonRpcError {\n  return is(value, JsonRpcErrorStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nexport function assertIsJsonRpcError(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcError {\n  assertStruct(\n    value,\n    JsonRpcErrorStruct,\n    'Invalid JSON-RPC error',\n    ErrorWrapper,\n  );\n}\n\ntype JsonRpcValidatorOptions = {\n  permitEmptyString?: boolean;\n  permitFractions?: boolean;\n  permitNull?: boolean;\n};\n\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nexport function getJsonRpcIdValidator(options?: JsonRpcValidatorOptions) {\n  const { permitEmptyString, permitFractions, permitNull } = {\n    permitEmptyString: true,\n    permitFractions: false,\n    permitNull: true,\n    ...options,\n  };\n\n  /**\n   * Type guard for {@link JsonRpcId}.\n   *\n   * @param id - The JSON-RPC ID value to check.\n   * @returns Whether the given ID is valid per the options given to the\n   * factory.\n   */\n  const isValidJsonRpcId = (id: unknown): id is JsonRpcId => {\n    return Boolean(\n      (typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n        (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n        (permitNull && id === null),\n    );\n  };\n\n  return isValidJsonRpcId;\n}\n","import type { Refiner } from '../struct.js';\nimport { Struct } from '../struct.js';\nimport { toFailures } from '../utils.js';\n\n/**\n * Ensure that a string, array, map, or set is empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept empty values.\n */\nexport function empty<\n  Type extends string | any[] | Map<any, any> | Set<any>,\n  Schema,\n>(struct: Struct<Type, Schema>): Struct<Type, Schema> {\n  return refine(struct, 'empty', (value) => {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const size = getSize(value);\n    return (\n      size === 0 ||\n      `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``\n    );\n  });\n}\n\n/**\n * Get the size of a string, array, map, or set.\n *\n * @param value - The value to measure.\n * @returns The size of the value.\n */\nfunction getSize(value: string | any[] | Map<any, any> | Set<any>): number {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size;\n  }\n\n  return value.length;\n}\n\n/**\n * Ensure that a number or date is below a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The maximum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly less than\n * the threshold. When `false`, the input must be less than or equal to the\n * threshold.\n * @returns A new struct that will only accept values below the threshold.\n */\nexport function max<Type extends number | Date, Schema>(\n  struct: Struct<Type, Schema>,\n  threshold: Type,\n  options: {\n    exclusive?: boolean | undefined;\n  } = {},\n): Struct<Type, Schema> {\n  const { exclusive } = options;\n  return refine(struct, 'max', (value) => {\n    return exclusive\n      ? value < threshold\n      : value <= threshold ||\n          `Expected a ${struct.type} less than ${\n            exclusive ? '' : 'or equal to '\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n          }${threshold} but received \\`${value}\\``;\n  });\n}\n\n/**\n * Ensure that a number or date is above a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The minimum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly greater\n * than the threshold. When `false`, the input must be greater than or equal to\n * the threshold.\n * @returns A new struct that will only accept values above the threshold.\n */\nexport function min<Type extends number | Date, Schema>(\n  struct: Struct<Type, Schema>,\n  threshold: Type,\n  options: {\n    exclusive?: boolean | undefined;\n  } = {},\n): Struct<Type, Schema> {\n  const { exclusive } = options;\n  return refine(struct, 'min', (value) => {\n    return exclusive\n      ? value > threshold\n      : value >= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n          }${threshold} but received \\`${value}\\``;\n  });\n}\n\n/**\n * Ensure that a string, array, map or set is not empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept non-empty values.\n */\nexport function nonempty<\n  Type extends string | any[] | Map<any, any> | Set<any>,\n  Schema,\n>(struct: Struct<Type, Schema>): Struct<Type, Schema> {\n  return refine(struct, 'nonempty', (value) => {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const size = getSize(value);\n    return (\n      size > 0 || `Expected a nonempty ${struct.type} but received an empty one`\n    );\n  });\n}\n\n/**\n * Ensure that a string matches a regular expression.\n *\n * @param struct - The struct to augment.\n * @param regexp - The regular expression to match against.\n * @returns A new struct that will only accept strings matching the regular\n * expression.\n */\nexport function pattern<Type extends string, Schema>(\n  struct: Struct<Type, Schema>,\n  regexp: RegExp,\n): Struct<Type, Schema> {\n  return refine(struct, 'pattern', (value) => {\n    return (\n      regexp.test(value) ||\n      `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`\n    );\n  });\n}\n\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length,\n * or time) between `min` and `max`.\n *\n * @param struct - The struct to augment.\n * @param minimum - The minimum size that the input can be.\n * @param maximum - The maximum size that the input can be.\n * @returns A new struct that will only accept values within the given size\n * range.\n */\nexport function size<\n  Type extends string | number | Date | any[] | Map<any, any> | Set<any>,\n  Schema,\n>(\n  struct: Struct<Type, Schema>,\n  minimum: number,\n  maximum: number = minimum,\n): Struct<Type, Schema> {\n  const expected = `Expected a ${struct.type}`;\n  const of =\n    minimum === maximum\n      ? `of \\`${minimum}\\``\n      : `between \\`${minimum}\\` and \\`${maximum}\\``;\n\n  return refine(struct, 'size', (value) => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return (\n        (minimum <= value && value <= maximum) ||\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `${expected} ${of} but received \\`${value}\\``\n      );\n    } else if (value instanceof Map || value instanceof Set) {\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      const { size } = value;\n      return (\n        (minimum <= size && size <= maximum) ||\n        `${expected} with a size ${of} but received one with a size of \\`${size}\\``\n      );\n    }\n\n    const { length } = value;\n    return (\n      (minimum <= length && length <= maximum) ||\n      `${expected} with a length ${of} but received one with a length of \\`${length}\\``\n    );\n  });\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n *\n * @param struct - The struct to augment.\n * @param name - The name of the refinement.\n * @param refiner - The refiner function.\n * @returns A new struct that will run the refiner function after the existing\n * validation.\n */\nexport function refine<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  name: string,\n  refiner: Refiner<Type>,\n): Struct<Type, Schema> {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n\n      for (const failure of failures) {\n        yield { ...failure, refinement: name };\n      }\n    },\n  });\n}\n","import {\n  type Address,\n  custom,\n  type EIP1193RequestFn,\n  fromHex,\n  getAddress,\n  type Hex,\n  keccak256,\n  numberToHex,\n  RpcRequestError,\n  SwitchChainError,\n  stringToHex,\n  type Transport,\n  UserRejectedRequestError,\n  type WalletCallReceipt,\n  type WalletGetCallsStatusReturnType,\n  type WalletRpcSchema,\n} from 'viem'\nimport { rpc } from 'viem/utils'\n\nimport {\n  ChainNotConfiguredError,\n  ConnectorNotConnectedError,\n} from '../errors/config.js'\nimport { createConnector } from './createConnector.js'\n\nexport type MockParameters = {\n  accounts: readonly [Address, ...Address[]]\n  features?:\n    | {\n        defaultConnected?: boolean | undefined\n        connectError?: boolean | Error | undefined\n        switchChainError?: boolean | Error | undefined\n        signMessageError?: boolean | Error | undefined\n        signTypedDataError?: boolean | Error | undefined\n        reconnect?: boolean | undefined\n        watchAssetError?: boolean | Error | undefined\n      }\n    | undefined\n}\n\nmock.type = 'mock' as const\nexport function mock(parameters: MockParameters) {\n  const transactionCache = new Map<Hex, Hex[]>()\n  const features =\n    parameters.features ??\n    ({ defaultConnected: false } satisfies MockParameters['features'])\n\n  type Provider = ReturnType<\n    Transport<'custom', unknown, EIP1193RequestFn<WalletRpcSchema>>\n  >\n  type Properties = {\n    // TODO(v3): Make `withCapabilities: true` default behavior\n    connect<withCapabilities extends boolean = false>(parameters?: {\n      chainId?: number | undefined\n      isReconnecting?: boolean | undefined\n      foo?: string | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{\n      accounts: withCapabilities extends true\n        ? readonly {\n            address: Address\n            capabilities: {\n              foo: {\n                bar: Hex\n              }\n            }\n          }[]\n        : readonly Address[]\n      chainId: number\n    }>\n  }\n  let connected = features.defaultConnected\n  let connectedChainId: number\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'mock',\n    name: 'Mock Connector',\n    type: mock.type,\n    async setup() {\n      connectedChainId = config.chains[0].id\n    },\n    async connect({ chainId, withCapabilities } = {}) {\n      if (features.connectError) {\n        if (typeof features.connectError === 'boolean')\n          throw new UserRejectedRequestError(new Error('Failed to connect.'))\n        throw features.connectError\n      }\n\n      const provider = await this.getProvider()\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts',\n      })\n\n      let currentChainId = await this.getChainId()\n      if (chainId && currentChainId !== chainId) {\n        const chain = await this.switchChain!({ chainId })\n        currentChainId = chain.id\n      }\n\n      connected = true\n\n      return {\n        accounts: (withCapabilities\n          ? accounts.map((x) => ({\n              address: getAddress(x),\n              capabilities: { foo: { bar: x } },\n            }))\n          : accounts.map((x) => getAddress(x))) as never,\n        chainId: currentChainId,\n      }\n    },\n    async disconnect() {\n      connected = false\n    },\n    async getAccounts() {\n      if (!connected) throw new ConnectorNotConnectedError()\n      const provider = await this.getProvider()\n      const accounts = await provider.request({ method: 'eth_accounts' })\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const hexChainId = await provider.request({ method: 'eth_chainId' })\n      return fromHex(hexChainId, 'number')\n    },\n    async isAuthorized() {\n      if (!features.reconnect) return false\n      if (!connected) return false\n      const accounts = await this.getAccounts()\n      return !!accounts.length\n    },\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider()\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: numberToHex(chainId) }],\n      })\n      return chain\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n      connected = false\n    },\n    async getProvider({ chainId } = {}) {\n      const chain =\n        config.chains.find((x) => x.id === chainId) ?? config.chains[0]\n      const url = chain.rpcUrls.default.http[0]!\n\n      const request: EIP1193RequestFn = async ({ method, params }) => {\n        // eth methods\n        if (method === 'eth_chainId') return numberToHex(connectedChainId)\n        if (method === 'eth_requestAccounts') return parameters.accounts\n        if (method === 'eth_signTypedData_v4')\n          if (features.signTypedDataError) {\n            if (typeof features.signTypedDataError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to sign typed data.'),\n              )\n            throw features.signTypedDataError\n          }\n\n        // wallet methods\n        if (method === 'wallet_switchEthereumChain') {\n          if (features.switchChainError) {\n            if (typeof features.switchChainError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to switch chain.'),\n              )\n            throw features.switchChainError\n          }\n          type Params = [{ chainId: Hex }]\n          connectedChainId = fromHex((params as Params)[0].chainId, 'number')\n          this.onChainChanged(connectedChainId.toString())\n          return\n        }\n\n        if (method === 'wallet_watchAsset') {\n          if (features.watchAssetError) {\n            if (typeof features.watchAssetError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to switch chain.'),\n              )\n            throw features.watchAssetError\n          }\n          return connected\n        }\n\n        if (method === 'wallet_getCapabilities')\n          return {\n            '0x2105': {\n              paymasterService: {\n                supported:\n                  (params as [Hex])[0] ===\n                  '0x95132632579b073D12a6673e18Ab05777a6B86f8',\n              },\n              sessionKeys: {\n                supported: true,\n              },\n            },\n            '0x14A34': {\n              paymasterService: {\n                supported:\n                  (params as [Hex])[0] ===\n                  '0x95132632579b073D12a6673e18Ab05777a6B86f8',\n              },\n            },\n          }\n\n        if (method === 'wallet_sendCalls') {\n          const hashes = []\n          const calls = (params as any)[0].calls\n          const from = (params as any)[0].from\n          for (const call of calls) {\n            const { result, error } = await rpc.http(url, {\n              body: {\n                method: 'eth_sendTransaction',\n                params: [\n                  {\n                    ...call,\n                    ...(typeof from !== 'undefined' ? { from } : {}),\n                  },\n                ],\n              },\n            })\n            if (error)\n              throw new RpcRequestError({\n                body: { method, params },\n                error,\n                url,\n              })\n            hashes.push(result)\n          }\n          const id = keccak256(stringToHex(JSON.stringify(calls)))\n          transactionCache.set(id, hashes)\n          return { id }\n        }\n\n        if (method === 'wallet_getCallsStatus') {\n          const hashes = transactionCache.get((params as any)[0])\n          if (!hashes)\n            return {\n              atomic: false,\n              chainId: '0x1',\n              id: (params as any)[0],\n              status: 100,\n              receipts: [],\n              version: '2.0.0',\n            } satisfies WalletGetCallsStatusReturnType\n\n          const receipts = await Promise.all(\n            hashes.map(async (hash) => {\n              const { result, error } = await rpc.http(url, {\n                body: {\n                  method: 'eth_getTransactionReceipt',\n                  params: [hash],\n                  id: 0,\n                },\n              })\n              if (error)\n                throw new RpcRequestError({\n                  body: { method, params },\n                  error,\n                  url,\n                })\n              if (!result) return null\n              return {\n                blockHash: result.blockHash,\n                blockNumber: result.blockNumber,\n                gasUsed: result.gasUsed,\n                logs: result.logs,\n                status: result.status,\n                transactionHash: result.transactionHash,\n              } satisfies WalletCallReceipt\n            }),\n          )\n          const receipts_ = receipts.filter((x) => x !== null)\n          if (receipts_.length === 0)\n            return {\n              atomic: false,\n              chainId: '0x1',\n              id: (params as any)[0],\n              status: 100,\n              receipts: [],\n              version: '2.0.0',\n            } satisfies WalletGetCallsStatusReturnType\n          return {\n            atomic: false,\n            chainId: '0x1',\n            id: (params as any)[0],\n            status: 200,\n            receipts: receipts_,\n            version: '2.0.0',\n          } satisfies WalletGetCallsStatusReturnType\n        }\n\n        if (method === 'wallet_showCallsStatus') return\n\n        // other methods\n        if (method === 'personal_sign') {\n          if (features.signMessageError) {\n            if (typeof features.signMessageError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to sign message.'),\n              )\n            throw features.signMessageError\n          }\n          // Change `personal_sign` to `eth_sign` and swap params\n          method = 'eth_sign'\n          type Params = [data: Hex, address: Address]\n          params = [(params as Params)[1], (params as Params)[0]]\n        }\n\n        const body = { method, params }\n        const { error, result } = await rpc.http(url, { body })\n        if (error) throw new RpcRequestError({ body, error, url })\n\n        return result\n      }\n      return custom({ request })({ retryCount: 0 })\n    },\n  }))\n}\n","import type { Coercer } from '../struct.js';\nimport { Struct, is } from '../struct.js';\nimport { isPlainObject } from '../utils.js';\nimport { string, unknown } from './types.js';\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param condition - A struct that the input must pass to be coerced.\n * @param coercer - A function that takes the input and returns the coerced\n * value.\n * @returns A new struct that will coerce its input before validating it.\n */\nexport function coerce<Type, Schema, CoercionType>(\n  struct: Struct<Type, Schema>,\n  condition: Struct<CoercionType, any>,\n  coercer: Coercer<CoercionType>,\n): Struct<Type, Schema> {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition)\n        ? struct.coercer(coercer(value, ctx), ctx)\n        : struct.coercer(value, ctx);\n    },\n  });\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param fallback - The value to use when the input is `undefined`.\n * @param options - An optional options object.\n * @param options.strict - When `true`, the fallback will only be used when the\n * input is `undefined`. When `false`, the fallback will be used when the input\n * is `undefined` or when the input is a plain object and the fallback is a\n * plain object, and any keys in the fallback are missing from the input.\n * @returns A new struct that will replace `undefined` inputs with a default.\n */\nexport function defaulted<Type, Schema>(\n  struct: Struct<Type, Schema>,\n  fallback: any,\n  options: {\n    strict?: boolean | undefined;\n  } = {},\n): Struct<Type, Schema> {\n  return coerce(struct, unknown(), (value) => {\n    const result = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (value === undefined) {\n      return result;\n    }\n\n    if (!options.strict && isPlainObject(value) && isPlainObject(result)) {\n      const ret = { ...value };\n      let changed = false;\n\n      for (const key in result) {\n        if (ret[key] === undefined) {\n          ret[key] = result[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return value;\n  });\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will trim string inputs before validating them.\n */\nexport function trimmed<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type, Schema> {\n  return coerce(struct, string(), (value) => value.trim());\n}\n","import type { Struct } from '@metamask/superstruct';\nimport { assert as assertSuperstruct } from '@metamask/superstruct';\n\nimport { getErrorMessage } from './errors';\n\nexport type AssertionErrorConstructor =\n  | (new (args: { message: string }) => Error)\n  | ((args: { message: string }) => Error);\n\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(\n  fn: AssertionErrorConstructor,\n): fn is new (args: { message: string }) => Error {\n  /* istanbul ignore next */\n  return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error: unknown): string {\n  // We'll add our own period.\n  return getErrorMessage(error).replace(/\\.$/u, '');\n}\n\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper: AssertionErrorConstructor, message: string) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message,\n    });\n  }\n  return ErrorWrapper({\n    message,\n  });\n}\n\n/**\n * The default error class that is thrown if an assertion fails.\n */\nexport class AssertionError extends Error {\n  readonly code = 'ERR_ASSERTION';\n\n  constructor(options: { message: string }) {\n    super(options.message);\n  }\n}\n\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nexport function assert(\n  value: any,\n  message: string | Error = 'Assertion failed.',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value {\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n\n    throw getError(ErrorWrapper, message);\n  }\n}\n\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nexport function assertStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  errorPrefix = 'Assertion failed',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value is Type {\n  try {\n    assertSuperstruct(value, struct);\n  } catch (error) {\n    throw getError(\n      ErrorWrapper,\n      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`,\n    );\n  }\n}\n\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nexport function assertExhaustive(_object: never): never {\n  throw new Error(\n    'Invalid branch reached. Should be detected during compilation.',\n  );\n}\n","import type { Context, Validator } from '../struct.js';\nimport { Struct } from '../struct.js';\nimport type {\n  Assign,\n  ObjectSchema,\n  ObjectType,\n  PartialObjectSchema,\n} from '../utils.js';\nimport { object, optional, type } from './types.js';\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * Like JavaScript's `Object.assign` utility.\n *\n * @param First - The first struct to combine.\n * @param Second - The second struct to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign<First extends ObjectSchema, Second extends ObjectSchema>(\n  First: Struct<ObjectType<First>, First>,\n  Second: Struct<ObjectType<Second>, Second>,\n): Struct<ObjectType<Assign<First, Second>>, Assign<First, Second>>;\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param First - The first struct to combine.\n * @param Second - The second struct to combine.\n * @param Third - The third struct to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign<\n  First extends ObjectSchema,\n  Second extends ObjectSchema,\n  Third extends ObjectSchema,\n>(\n  First: Struct<ObjectType<First>, First>,\n  Second: Struct<ObjectType<Second>, Second>,\n  Third: Struct<ObjectType<Third>, Third>,\n): Struct<\n  ObjectType<Assign<Assign<First, Second>, Third>>,\n  Assign<Assign<First, Second>, Third>\n>;\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param First - The first struct to combine.\n * @param Second - The second struct to combine.\n * @param Third - The third struct to combine.\n * @param Fourth - The fourth struct to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign<\n  First extends ObjectSchema,\n  Second extends ObjectSchema,\n  Third extends ObjectSchema,\n  Fourth extends ObjectSchema,\n>(\n  First: Struct<ObjectType<First>, First>,\n  Second: Struct<ObjectType<Second>, Second>,\n  Third: Struct<ObjectType<Third>, Third>,\n  Fourth: Struct<ObjectType<Fourth>, Fourth>,\n): Struct<\n  ObjectType<Assign<Assign<Assign<First, Second>, Third>, Fourth>>,\n  Assign<Assign<Assign<First, Second>, Third>, Fourth>\n>;\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param First - The first struct to combine.\n * @param Second - The second struct to combine.\n * @param Third - The third struct to combine.\n * @param Fourth - The fourth struct to combine.\n * @param Fifth - The fifth struct to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign<\n  First extends ObjectSchema,\n  Second extends ObjectSchema,\n  Third extends ObjectSchema,\n  Fourth extends ObjectSchema,\n  Fifth extends ObjectSchema,\n>(\n  First: Struct<ObjectType<First>, First>,\n  Second: Struct<ObjectType<Second>, Second>,\n  Third: Struct<ObjectType<Third>, Third>,\n  Fourth: Struct<ObjectType<Fourth>, Fourth>,\n  Fifth: Struct<ObjectType<Fifth>, Fifth>,\n): Struct<\n  ObjectType<\n    Assign<Assign<Assign<Assign<First, Second>, Third>, Fourth>, Fifth>\n  >,\n  Assign<Assign<Assign<Assign<First, Second>, Third>, Fourth>, Fifth>\n>;\n\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param Structs - The structs to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign(...Structs: Struct<any>[]): any {\n  const isType = Structs[0]?.type === 'type';\n  const schemas = Structs.map(({ schema }) => schema);\n  const schema = Object.assign({}, ...schemas);\n  return isType ? type(schema) : object(schema);\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @param name - The name of the struct type.\n * @param validator - The validation function.\n * @returns A new struct type.\n */\nexport function define<Type>(\n  name: string,\n  validator: Validator,\n): Struct<Type, null> {\n  return new Struct({ type: name, schema: null, validator });\n}\n\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n *\n * @param struct - The struct to augment.\n * @param log - The function to call when the value is not `undefined`.\n * @returns A new struct that will only accept `undefined` or values that pass\n * the input struct.\n */\nexport function deprecated<Type>(\n  struct: Struct<Type>,\n  log: (value: unknown, ctx: Context) => void,\n): Struct<Type> {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      }\n      log(value, ctx);\n      return struct.validator(value, ctx);\n    },\n  });\n}\n\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with dynamic validation logic.\n */\nexport function dynamic<Type>(\n  fn: (value: unknown, ctx: Context) => Struct<Type, any>,\n): Struct<Type, null> {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.refiner(value, ctx);\n    },\n  });\n}\n\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with lazily evaluated validation logic.\n */\nexport function lazy<Type>(fn: () => Struct<Type, any>): Struct<Type, null> {\n  let struct: Struct<Type, any> | undefined;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ??= fn();\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      struct ??= fn();\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      struct ??= fn();\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      struct ??= fn();\n      return struct.refiner(value, ctx);\n    },\n  });\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to omit.\n * @returns A new struct that will not accept the input keys.\n */\nexport function omit<Schema extends ObjectSchema, Key extends keyof Schema>(\n  struct: Struct<ObjectType<Schema>, Schema>,\n  keys: Key[],\n): Struct<ObjectType<Omit<Schema, Key>>, Omit<Schema, Key>> {\n  const { schema } = struct;\n  const subschema: any = { ...schema };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  switch (struct.type) {\n    case 'type':\n      return type(subschema as Omit<Schema, Key>);\n    default:\n      return object(subschema as Omit<Schema, Key>);\n  }\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept the input keys as `undefined`.\n */\nexport function partial<Schema extends ObjectSchema>(\n  struct: Struct<ObjectType<Schema>, Schema> | Schema,\n): Struct<\n  ObjectType<PartialObjectSchema<Schema>>,\n  PartialObjectSchema<Schema>\n> {\n  const isStruct = struct instanceof Struct;\n  const schema: any = isStruct ? { ...struct.schema } : { ...struct };\n\n  // eslint-disable-next-line guard-for-in\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  if (isStruct && struct.type === 'type') {\n    return type(schema) as any;\n  }\n\n  return object(schema) as any;\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to pick.\n * @returns A new struct that will only accept the input keys.\n */\nexport function pick<Schema extends ObjectSchema, Key extends keyof Schema>(\n  struct: Struct<ObjectType<Schema>, Schema>,\n  keys: Key[],\n): Struct<ObjectType<Pick<Schema, Key>>, Pick<Schema, Key>> {\n  const { schema } = struct;\n  const subschema: any = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  switch (struct.type) {\n    case 'type':\n      return type(subschema) as any;\n\n    default:\n      return object(subschema) as any;\n  }\n}\n","import type { Chain, Transport } from 'viem'\n\ntype ExtractRpcUrlsParameters = {\n  transports?: Record<string, Transport> | undefined\n  chain: Chain\n}\n\nexport function extractRpcUrls(parameters: ExtractRpcUrlsParameters) {\n  const { chain } = parameters\n  const fallbackUrl = chain.rpcUrls.default.http[0]\n\n  if (!parameters.transports) return [fallbackUrl]\n\n  const transport = parameters.transports?.[chain.id]?.({ chain })\n  const transports = (transport?.value?.transports as NonNullable<\n    typeof transport\n  >[]) || [transport]\n  return transports.map(({ value }) => value?.url || fallbackUrl)\n}\n","import type { Failure } from './error.js';\nimport { StructError } from './error.js';\nimport type { StructSchema } from './utils.js';\nimport { isObject, toFailures, shiftIterator, run } from './utils.js';\n\ntype StructParams<Type, Schema> = {\n  type: string;\n  schema: Schema;\n  coercer?: Coercer | undefined;\n  validator?: Validator | undefined;\n  refiner?: Refiner<Type> | undefined;\n  entries?: Struct<Type, Schema>['entries'] | undefined;\n};\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nexport class Struct<Type = unknown, Schema = unknown> {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  readonly TYPE!: Type;\n\n  type: string;\n\n  schema: Schema;\n\n  coercer: (value: unknown, context: Context) => unknown;\n\n  validator: (value: unknown, context: Context) => Iterable<Failure>;\n\n  refiner: (value: Type, context: Context) => Iterable<Failure>;\n\n  entries: (\n    value: unknown,\n    context: Context,\n  ) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>;\n\n  constructor(props: StructParams<Type, Schema>) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = (value: unknown) => value,\n      entries = function* () {\n        /* noop */\n      },\n    } = props;\n\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown, message?: string): asserts value is Type {\n    return assert(value, this, message);\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown, message?: string): Type {\n    return create(value, this, message);\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is Type {\n    return is(value, this);\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown, message?: string): Type {\n    return mask(value, this, message);\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean;\n      message?: string;\n    } = {},\n  ): [StructError, undefined] | [undefined, Type] {\n    return validate(value, this, options);\n  }\n}\n\n// String instead of a Symbol in case of multiple different versions of this library.\nconst ExactOptionalBrand = 'EXACT_OPTIONAL';\n\n/**\n * An `ExactOptionalStruct` is a `Struct` that is used to create exactly optional\n * properties of `object()` structs.\n */\nexport class ExactOptionalStruct<\n  Type = unknown,\n  Schema = unknown,\n> extends Struct<Type, Schema> {\n  // ESLint wants us to make this #-private, but we need it to be accessible by\n  // other versions of this library at runtime. If it were #-private, the\n  // implementation would break if multiple instances of this library were\n  // loaded at runtime.\n  // eslint-disable-next-line no-restricted-syntax\n  readonly brand: typeof ExactOptionalBrand;\n\n  constructor(props: StructParams<Type, Schema>) {\n    super({\n      ...props,\n      type: `exact optional ${props.type}`,\n    });\n    this.brand = ExactOptionalBrand;\n  }\n\n  static isExactOptional(value: unknown): value is ExactOptionalStruct {\n    return (\n      isObject(value) && 'brand' in value && value.brand === ExactOptionalBrand\n    );\n  }\n}\n\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n */\nexport function assert<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  message?: string,\n): asserts value is Type {\n  const result = validate(value, struct, { message });\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n\n/**\n * Create a value with the coercion logic of struct and validate it.\n *\n * @param value - The value to coerce and validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n * @returns The coerced and validated value.\n */\nexport function create<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  message?: string,\n): Type {\n  const result = validate(value, struct, { coerce: true, message });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n *\n * @param value - The value to mask.\n * @param struct - The struct to mask against.\n * @param message - An optional message to include in the error.\n * @returns The masked value.\n */\nexport function mask<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  message?: string,\n): Type {\n  const result = validate(value, struct, { coerce: true, mask: true, message });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n\n/**\n * Check if a value passes a struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @returns `true` if the value passes the struct, `false` otherwise.\n */\nexport function is<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n): value is Type {\n  const result = validate(value, struct);\n  return !result[0];\n}\n\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param options - Optional settings.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @returns A tuple containing the error (if invalid) and the validated value.\n */\nexport function validate<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  options: {\n    coerce?: boolean | undefined;\n    mask?: boolean | undefined;\n    message?: string | undefined;\n  } = {},\n): [StructError, undefined] | [undefined, Type] {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples) as [\n    Failure | undefined,\n    Type | undefined,\n  ];\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const innerTuple of tuples) {\n        if (innerTuple[0]) {\n          yield innerTuple[0];\n        }\n      }\n    });\n\n    return [error, undefined];\n  }\n\n  const validatedValue = tuple[1] as Type;\n  return [undefined, validatedValue];\n}\n\n/**\n * A `Context` contains information about the current location of the\n * validation inside the initial input value.\n */\n\nexport type Context = {\n  branch: any[];\n  path: any[];\n};\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<StructType extends Struct<any, any>> = StructType['TYPE'];\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result =\n  | boolean\n  | string\n  | Partial<Failure>\n  | Iterable<boolean | string | Partial<Failure>>;\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer<Type = unknown> = (\n  value: Type,\n  context: Context,\n) => unknown;\n\n/**\n * A `Validator` takes an unknown value and validates it.\n */\n\nexport type Validator = (value: unknown, context: Context) => Result;\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<Type> = (value: Type, context: Context) => Result;\n","import type {\n  Json,\n  JsonRpcError as SerializedJsonRpcError,\n  RuntimeObject,\n} from '@metamask/utils';\nimport {\n  hasProperty,\n  isValidJson,\n  isObject,\n  isJsonRpcError,\n} from '@metamask/utils';\n\nimport { errorCodes, errorValues } from './error-constants';\n\n/**\n * A data object, that must be either:\n *\n * - A JSON-serializable object.\n * - An object with a `cause` property that is an error-like value, and any\n * other properties that are JSON-serializable.\n */\nexport type DataWithOptionalCause =\n  | Json\n  | {\n      // Unfortunately we can't use just `Json` here, because all properties of\n      // an object with an index signature must be assignable to the index\n      // signature's type. So we have to use `Json | unknown` instead.\n      [key: string]: Json | unknown;\n      cause?: unknown;\n    };\n\n/**\n * A data object, that must be either:\n *\n * - A valid DataWithOptionalCause value.\n * - undefined.\n */\nexport type OptionalDataWithOptionalCause = undefined | DataWithOptionalCause;\n\nconst FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nconst FALLBACK_MESSAGE =\n  'Unspecified error message. This is a bug, please report it.';\nconst FALLBACK_ERROR: SerializedJsonRpcError = {\n  code: FALLBACK_ERROR_CODE,\n  message: getMessageFromCode(FALLBACK_ERROR_CODE),\n};\n\nexport const JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';\n\ntype ErrorValueKey = keyof typeof errorValues;\n\n/**\n * Gets the message for a given code, or a fallback message if the code has\n * no corresponding message.\n *\n * @param code - The error code.\n * @param fallbackMessage - The fallback message to use if the code has no\n * corresponding message.\n * @returns The message for the given code, or the fallback message if the code\n * has no corresponding message.\n */\nexport function getMessageFromCode(\n  code: unknown,\n  fallbackMessage: string = FALLBACK_MESSAGE,\n): string {\n  if (isValidCode(code)) {\n    const codeString = code.toString();\n\n    if (hasProperty(errorValues, codeString)) {\n      return errorValues[codeString as ErrorValueKey].message;\n    }\n\n    if (isJsonRpcServerError(code)) {\n      return JSON_RPC_SERVER_ERROR_MESSAGE;\n    }\n  }\n  return fallbackMessage;\n}\n\n/**\n * Returns whether the given code is valid.\n * A code is valid if it is an integer.\n *\n * @param code - The error code.\n * @returns Whether the given code is valid.\n */\nexport function isValidCode(code: unknown): code is number {\n  return Number.isInteger(code);\n}\n\n/**\n * Serializes the given error to an Ethereum JSON RPC-compatible error object.\n * If the given error is not fully compatible, it will be preserved on the\n * returned object's data.cause property.\n *\n * @param error - The error to serialize.\n * @param options - Options bag.\n * @param options.fallbackError - The error to return if the given error is\n * not compatible. Should be a JSON-serializable value.\n * @param options.shouldIncludeStack - Whether to include the error's stack\n * on the returned object.\n * @param options.shouldPreserveMessage - Whether to preserve the error's\n * message if the fallback error is used.\n * @returns The serialized error.\n */\nexport function serializeError(\n  error: unknown,\n  {\n    fallbackError = FALLBACK_ERROR,\n    shouldIncludeStack = true,\n    shouldPreserveMessage = true,\n  } = {},\n): SerializedJsonRpcError {\n  if (!isJsonRpcError(fallbackError)) {\n    throw new Error(\n      'Must provide fallback error with integer number code and string message.',\n    );\n  }\n\n  const serialized = buildError(error, fallbackError, shouldPreserveMessage);\n\n  if (!shouldIncludeStack) {\n    delete serialized.stack;\n  }\n\n  return serialized;\n}\n\n/**\n * Construct a JSON-serializable object given an error and a JSON-serializable `fallbackError`\n *\n * @param error - The error in question.\n * @param fallbackError - A JSON-serializable fallback error.\n * @param shouldPreserveMessage - Whether to preserve the error's message if the fallback\n * error is used.\n * @returns A JSON-serializable error object.\n */\nfunction buildError(\n  error: unknown,\n  fallbackError: SerializedJsonRpcError,\n  shouldPreserveMessage: boolean,\n): SerializedJsonRpcError {\n  // If an error specifies a `serialize` function, we call it and return the result.\n  if (\n    error &&\n    typeof error === 'object' &&\n    'serialize' in error &&\n    typeof error.serialize === 'function'\n  ) {\n    return error.serialize();\n  }\n\n  if (isJsonRpcError(error)) {\n    return error;\n  }\n\n  const originalMessage = getOriginalMessage(error);\n\n  // If the error does not match the JsonRpcError type, use the fallback error, but try to include the original error as `cause`.\n  const cause = serializeCause(error);\n  const fallbackWithCause = {\n    ...fallbackError,\n    ...(shouldPreserveMessage &&\n      originalMessage && { message: originalMessage }),\n    data: { cause },\n  };\n\n  return fallbackWithCause;\n}\n\n/**\n * Attempts to extract the original `message` property from an error value of uncertain shape.\n *\n * @param error - The error in question.\n * @returns The original message, if it exists and is a non-empty string.\n */\nfunction getOriginalMessage(error: unknown): string | undefined {\n  if (\n    isObject(error) &&\n    hasProperty(error, 'message') &&\n    typeof error.message === 'string' &&\n    error.message.length > 0\n  ) {\n    return error.message;\n  }\n  return undefined;\n}\n\n/**\n * Check if the given code is a valid JSON-RPC server error code.\n *\n * @param code - The error code.\n * @returns Whether the given code is a valid JSON-RPC server error code.\n */\nfunction isJsonRpcServerError(code: number): boolean {\n  return code >= -32099 && code <= -32000;\n}\n\n/**\n * Serializes an unknown error to be used as the `cause` in a fallback error.\n *\n * @param error - The unknown error.\n * @returns A JSON-serializable object containing as much information about the original error as possible.\n */\nexport function serializeCause(error: unknown): Json {\n  if (Array.isArray(error)) {\n    return error.map((entry) => {\n      if (isValidJson(entry)) {\n        return entry;\n      } else if (isObject(entry)) {\n        return serializeObject(entry);\n      }\n      return null;\n    });\n  } else if (isObject(error)) {\n    return serializeObject(error);\n  }\n\n  if (isValidJson(error)) {\n    return error;\n  }\n\n  return null;\n}\n\n/**\n * Extracts all JSON-serializable properties from an object.\n *\n * @param object - The object in question.\n * @returns An object containing all the JSON-serializable properties.\n */\nfunction serializeObject(object: RuntimeObject): Json {\n  return Object.getOwnPropertyNames(object).reduce<Record<string, Json>>(\n    (acc, key) => {\n      const value = object[key];\n      if (isValidJson(value)) {\n        acc[key] = value;\n      }\n\n      return acc;\n    },\n    {},\n  );\n}\n\n/**\n * Returns true if supplied error data has a usable `cause` property; false otherwise.\n *\n * @param data - Optional data to validate.\n * @returns Whether cause property is present and an object.\n */\nexport function dataHasCause(data: unknown): data is {\n  [key: string]: Json | unknown;\n  cause: object;\n} {\n  return isObject(data) && hasProperty(data, 'cause') && isObject(data.cause);\n}\n","import { JsonRpcError, EthereumProviderError } from './classes';\nimport { errorCodes } from './error-constants';\nimport type { OptionalDataWithOptionalCause } from './utils';\nimport { getMessageFromCode } from './utils';\n\ntype EthereumErrorOptions<Data extends OptionalDataWithOptionalCause> = {\n  message?: string;\n  data?: Data;\n};\n\ntype ServerErrorOptions<Data extends OptionalDataWithOptionalCause> = {\n  code: number;\n} & EthereumErrorOptions<Data>;\n\ntype CustomErrorArg<Data extends OptionalDataWithOptionalCause> =\n  ServerErrorOptions<Data>;\n\ntype JsonRpcErrorsArg<Data extends OptionalDataWithOptionalCause> =\n  | EthereumErrorOptions<Data>\n  | string;\n\nexport const rpcErrors = {\n  /**\n   * Get a JSON RPC 2.0 Parse (-32700) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  parse: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.parse, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidRequest: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidParams: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotFound: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Internal (-32603) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  internal: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.internal, arg),\n\n  /**\n   * Get a JSON RPC 2.0 Server error.\n   * Permits integer error codes in the [ -32099 <= -32005 ] range.\n   * Codes -32000 through -32004 are reserved by EIP-1474.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  server: <Data extends OptionalDataWithOptionalCause>(\n    opts: ServerErrorOptions<Data>,\n  ) => {\n    if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n      throw new Error(\n        'Ethereum RPC Server errors must provide single object argument.',\n      );\n    }\n    const { code } = opts;\n    if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n      throw new Error(\n        '\"code\" must be an integer such that: -32099 <= code <= -32005',\n      );\n    }\n    return getJsonRpcError(code, opts);\n  },\n\n  /**\n   * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidInput: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceNotFound: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceUnavailable: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  transactionRejected: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotSupported: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n\n  /**\n   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  limitExceeded: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => getJsonRpcError(errorCodes.rpc.limitExceeded, arg),\n};\n\nexport const providerErrors = {\n  /**\n   * Get an Ethereum Provider User Rejected Request (4001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  userRejectedRequest: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n  },\n\n  /**\n   * Get an Ethereum Provider Unauthorized (4100) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unauthorized: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.unauthorized, arg);\n  },\n\n  /**\n   * Get an Ethereum Provider Unsupported Method (4200) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unsupportedMethod: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n  },\n\n  /**\n   * Get an Ethereum Provider Not Connected (4900) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  disconnected: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.disconnected, arg);\n  },\n\n  /**\n   * Get an Ethereum Provider Chain Not Connected (4901) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  chainDisconnected: <Data extends OptionalDataWithOptionalCause>(\n    arg?: JsonRpcErrorsArg<Data>,\n  ) => {\n    return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n  },\n\n  /**\n   * Get a custom Ethereum Provider error.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  custom: <Data extends OptionalDataWithOptionalCause>(\n    opts: CustomErrorArg<Data>,\n  ) => {\n    if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {\n      throw new Error(\n        'Ethereum Provider custom errors must provide single object argument.',\n      );\n    }\n\n    const { code, message, data } = opts;\n\n    if (!message || typeof message !== 'string') {\n      throw new Error('\"message\" must be a nonempty string');\n    }\n    return new EthereumProviderError(code, message, data);\n  },\n};\n\n/**\n * Get a generic JSON-RPC error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link JsonRpcError} class.\n */\nfunction getJsonRpcError<Data extends OptionalDataWithOptionalCause>(\n  code: number,\n  arg?: JsonRpcErrorsArg<Data>,\n): JsonRpcError<Data> {\n  const [message, data] = parseOpts(arg);\n  return new JsonRpcError(code, message ?? getMessageFromCode(code), data);\n}\n\n/**\n * Get an Ethereum Provider error class instance.\n *\n * @param code - The error code.\n * @param arg - The error message or options bag.\n * @returns An instance of the {@link EthereumProviderError} class.\n */\nfunction getEthProviderError<Data extends OptionalDataWithOptionalCause>(\n  code: number,\n  arg?: JsonRpcErrorsArg<Data>,\n): EthereumProviderError<Data> {\n  const [message, data] = parseOpts(arg);\n  return new EthereumProviderError(\n    code,\n    message ?? getMessageFromCode(code),\n    data,\n  );\n}\n\n/**\n * Get an error message and optional data from an options bag.\n *\n * @param arg - The error message or options bag.\n * @returns A tuple containing the error message and optional data.\n */\nfunction parseOpts<Data extends OptionalDataWithOptionalCause>(\n  arg?: JsonRpcErrorsArg<Data>,\n): [message?: string | undefined, data?: Data | undefined] {\n  if (arg) {\n    if (typeof arg === 'string') {\n      return [arg];\n    } else if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const { message, data } = arg;\n\n      if (message && typeof message !== 'string') {\n        throw new Error('Must specify string message.');\n      }\n      return [message ?? undefined, data];\n    }\n  }\n\n  return [];\n}\n","export const errorCodes = {\n  rpc: {\n    invalidInput: -32000,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603,\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901,\n  },\n};\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport const errorValues = {\n  '-32700': {\n    standard: 'JSON RPC 2.0',\n    message:\n      'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n  },\n  '-32600': {\n    standard: 'JSON RPC 2.0',\n    message: 'The JSON sent is not a valid Request object.',\n  },\n  '-32601': {\n    standard: 'JSON RPC 2.0',\n    message: 'The method does not exist / is not available.',\n  },\n  '-32602': {\n    standard: 'JSON RPC 2.0',\n    message: 'Invalid method parameter(s).',\n  },\n  '-32603': {\n    standard: 'JSON RPC 2.0',\n    message: 'Internal JSON-RPC error.',\n  },\n  '-32000': {\n    standard: 'EIP-1474',\n    message: 'Invalid input.',\n  },\n  '-32001': {\n    standard: 'EIP-1474',\n    message: 'Resource not found.',\n  },\n  '-32002': {\n    standard: 'EIP-1474',\n    message: 'Resource unavailable.',\n  },\n  '-32003': {\n    standard: 'EIP-1474',\n    message: 'Transaction rejected.',\n  },\n  '-32004': {\n    standard: 'EIP-1474',\n    message: 'Method not supported.',\n  },\n  '-32005': {\n    standard: 'EIP-1474',\n    message: 'Request limit exceeded.',\n  },\n  '4001': {\n    standard: 'EIP-1193',\n    message: 'User rejected the request.',\n  },\n  '4100': {\n    standard: 'EIP-1193',\n    message:\n      'The requested account and/or method has not been authorized by the user.',\n  },\n  '4200': {\n    standard: 'EIP-1193',\n    message: 'The requested method is not supported by this Ethereum provider.',\n  },\n  '4900': {\n    standard: 'EIP-1193',\n    message: 'The provider is disconnected from all chains.',\n  },\n  '4901': {\n    standard: 'EIP-1193',\n    message: 'The provider is disconnected from the specified chain.',\n  },\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n","import type { Infer } from '../struct.js';\nimport { ExactOptionalStruct, Struct } from '../struct.js';\nimport type {\n  ObjectSchema,\n  ObjectType,\n  AnyStruct,\n  InferStructTuple,\n  UnionToIntersection,\n} from '../utils.js';\nimport { print, run, isObject } from '../utils.js';\nimport { define } from './utilities.js';\n\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nexport function any(): Struct<any, null> {\n  return define('any', () => true);\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array<Type extends Struct<any>>(\n  Element: Type,\n): Struct<Infer<Type>[], Type>;\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @returns A new struct that will accept any array.\n */\nexport function array(): Struct<unknown[], undefined>;\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array<Type extends Struct<any>>(Element?: Type): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [index, arrayValue] of value.entries()) {\n          yield [index, arrayValue, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nexport function bigint(): Struct<bigint, null> {\n  return define('bigint', (value) => {\n    return typeof value === 'bigint';\n  });\n}\n\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean';\n  });\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<Type extends number, Values extends readonly Type[]>(\n  values: Values,\n): Struct<Values[number], { [Key in Values[number]]: Key }>;\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<Type extends string, Values extends readonly Type[]>(\n  values: Values,\n): Struct<Values[number], { [Key in Values[number]]: Key }>;\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<\n  Type extends string | number,\n  Values extends readonly Type[],\n>(values: Values): any {\n  const schema: any = {};\n  const description = values.map((value) => print(value)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nexport function instance<Type extends new (...args: any) => any>(\n  Class: Type,\n): Struct<InstanceType<Type>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nexport function intersection<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<\n  Infer<First> & UnionToIntersection<InferStructTuple<Rest>[number]>,\n  null\n> {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, context) {\n      for (const { entries } of Structs) {\n        yield* entries(value, context);\n      }\n    },\n    *validator(value, context) {\n      for (const { validator } of Structs) {\n        yield* validator(value, context);\n      }\n    },\n    *refiner(value, context) {\n      for (const { refiner } of Structs) {\n        yield* refiner(value, context);\n      }\n    },\n  });\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends boolean>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends number>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends string>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type>(constant: Type): Struct<Type, null>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type>(constant: Type): any {\n  const description = print(constant);\n  const valueType = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema:\n      valueType === 'string' ||\n      valueType === 'number' ||\n      valueType === 'boolean'\n        ? constant\n        : null,\n\n    validator(value) {\n      return (\n        value === constant ||\n        `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map(): Struct<Map<unknown, unknown>, null>;\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map<Key, Value>(\n  Key: Struct<Key>,\n  Value: Struct<Value>,\n): Struct<Map<Key, Value>, null>;\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map<Key, Value>(Key?: Struct<Key>, Value?: Struct<Value>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [mapKey, mapValue] of value.entries()) {\n          yield [mapKey as string, mapKey, Key];\n          yield [mapKey as string, mapValue, Value];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nexport function never(): Struct<never, null> {\n  return define('never', () => false);\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nexport function nullable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | null, Schema> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  });\n}\n\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @returns A new struct that will only accept objects.\n */\nexport function object(): Struct<Record<string, unknown>, null>;\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema>;\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema?: Schema | undefined,\n): any {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ?? null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          const propertySchema = schema[key];\n          if (\n            ExactOptionalStruct.isExactOptional(propertySchema) &&\n            !Object.prototype.hasOwnProperty.call(value, key)\n          ) {\n            continue;\n          }\n\n          yield [key, value[key], schema[key] as Struct<any>];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value;\n    },\n  });\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nexport function optional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | undefined, Schema> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  });\n}\n\n/**\n * Augment a struct such that, if it is the property of an object, it is exactly optional.\n * In other words, it is either present with the correct type, or not present at all.\n *\n * NOTE: Only intended for use with `object()` structs.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that can be used to create exactly optional properties of `object()`\n * structs.\n */\nexport function exactOptional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): ExactOptionalStruct<Type, Schema> {\n  return new ExactOptionalStruct(struct);\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nexport function record<Key extends string, Value>(\n  Key: Struct<Key>,\n  Value: Struct<Value>,\n): Struct<Record<Key, Value>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        // eslint-disable-next-line guard-for-in\n        for (const objectKey in value) {\n          const objectValue = value[objectKey];\n          yield [objectKey, objectKey, Key];\n          yield [objectKey, objectValue, Value];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp;\n  });\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set(): Struct<Set<unknown>, null>;\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set<Type>(Element: Struct<Type>): Struct<Set<Type>, null>;\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set<Type>(Element?: Struct<Type>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const setValue of value) {\n          yield [setValue as string, setValue, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nexport function tuple<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<[Infer<First>, ...InferStructTuple<Rest>], null> {\n  const Never = never();\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function type<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema> {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k] as Struct<any>];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value;\n    },\n  });\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nexport function union<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<Infer<First> | InferStructTuple<Rest>[number], null> {\n  const description = Structs.map((struct) => struct.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer(value) {\n      for (const InnerStruct of Structs) {\n        const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n        if (!error) {\n          return coerced;\n        }\n      }\n\n      return value;\n    },\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const InnerStruct of Structs) {\n        const [...tuples] = run(value, InnerStruct, ctx);\n        const [first] = tuples;\n\n        if (!first?.[0]) {\n          return [];\n        }\n\n        for (const [failure] of tuples) {\n          if (failure) {\n            failures.push(failure);\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value,\n        )}`,\n        ...failures,\n      ];\n    },\n  });\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true);\n}\n","import type { AppMetadata, ProviderInterface } from '@gemini-wallet/core'\nimport { GeminiWalletProvider } from '@gemini-wallet/core'\nimport {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n} from '@wagmi/core'\nimport {\n  getAddress,\n  numberToHex,\n  SwitchChainError,\n  UserRejectedRequestError,\n} from 'viem'\n\nexport type GeminiParameters = {\n  appMetadata?: AppMetadata\n}\n\ngemini.type = 'gemini' as const\nexport function gemini(parameters: GeminiParameters = {}) {\n  type Provider = ProviderInterface\n\n  let walletProvider: Provider | undefined\n  let onAccountsChanged: Connector['onAccountsChanged'] | undefined\n  let onChainChanged: Connector['onChainChanged'] | undefined\n  let onDisconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider>((config) => ({\n    id: 'gemini',\n    name: 'Gemini Wallet',\n    type: gemini.type,\n    icon: 'https://keys.gemini.com/images/gemini-wallet-logo.svg',\n    async connect({ chainId, withCapabilities } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (await provider.request({\n          method: 'eth_requestAccounts',\n        })) as string[]\n\n        if (!onAccountsChanged) {\n          onAccountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', onAccountsChanged)\n        }\n        if (!onChainChanged) {\n          onChainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', onChainChanged)\n        }\n        if (!onDisconnect) {\n          onDisconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', onDisconnect)\n        }\n\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return {\n          // TODO(v3): Make `withCapabilities: true` default behavior\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (onAccountsChanged) {\n        provider.removeListener('accountsChanged', onAccountsChanged)\n        onAccountsChanged = undefined\n      }\n      if (onChainChanged) {\n        provider.removeListener('chainChanged', onChainChanged)\n        onChainChanged = undefined\n      }\n      if (onDisconnect) {\n        provider.removeListener('disconnect', onDisconnect)\n        onDisconnect = undefined\n      }\n\n      await provider.disconnect()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[]\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = (await provider.request({\n        method: 'eth_chainId',\n      })) as string\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        walletProvider = new GeminiWalletProvider({\n          appMetadata: parameters.appMetadata ?? {},\n          chain: {\n            id: config.chains[0]?.id ?? 1,\n            rpcUrl: config.chains[0]?.rpcUrls?.default?.http[0],\n          },\n        })\n      }\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return Boolean(accounts.length)\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chainId) }],\n        })\n        return chain\n      } catch (error) {\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x: string) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect() {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (onAccountsChanged) {\n        provider.removeListener('accountsChanged', onAccountsChanged)\n        onAccountsChanged = undefined\n      }\n      if (onChainChanged) {\n        provider.removeListener('chainChanged', onChainChanged)\n        onChainChanged = undefined\n      }\n      if (onDisconnect) {\n        provider.removeListener('disconnect', onDisconnect)\n        onDisconnect = undefined\n      }\n    },\n  }))\n}\n","import { ErrorWithCause } from 'pony-cause';\n\nimport { isNullOrUndefined, isObject } from './misc';\n\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error: unknown): error is Error {\n  return (\n    error instanceof Error ||\n    (isObject(error) && error.constructor.name === 'Error')\n  );\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithCode(error: unknown): error is { code: string } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithMessage(\n  error: unknown,\n): error is { message: string } {\n  return typeof error === 'object' && error !== null && 'message' in error;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithStack(error: unknown): error is { stack: string } {\n  return typeof error === 'object' && error !== null && 'stack' in error;\n}\n\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nexport function getErrorMessage(error: unknown): string {\n  if (isErrorWithMessage(error) && typeof error.message === 'string') {\n    return error.message;\n  }\n\n  if (isNullOrUndefined(error)) {\n    return '';\n  }\n\n  return String(error);\n}\n\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nexport function wrapError<Throwable>(\n  originalError: Throwable,\n  message: string,\n): Error & { code?: string } {\n  if (isError(originalError)) {\n    let error: Error & { code?: string };\n    if (Error.length === 2) {\n      // for some reason `tsserver` is not complaining that the\n      // Error constructor doesn't support a second argument in the editor,\n      // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      error = new Error(message, { cause: originalError });\n    } else {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      error = new ErrorWithCause(message, { cause: originalError });\n    }\n\n    if (isErrorWithCode(originalError)) {\n      error.code = originalError.code;\n    }\n\n    return error;\n  }\n\n  if (message.length > 0) {\n    return new Error(`${String(originalError)}: ${message}`);\n  }\n\n  return new Error(String(originalError));\n}\n","import type { SafeAppProvider } from '@safe-global/safe-apps-provider'\nimport type { Opts } from '@safe-global/safe-apps-sdk'\nimport {\n  type Connector,\n  createConnector,\n  ProviderNotFoundError,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport { getAddress, withTimeout } from 'viem'\n\nexport type SafeParameters = Compute<\n  Opts & {\n    /**\n     * Connector automatically connects when used as Safe App.\n     *\n     * This flag simulates the disconnect behavior by keeping track of connection status in storage\n     * and only autoconnecting when previously connected by user action (e.g. explicitly choosing to connect).\n     *\n     * @default false\n     */\n    shimDisconnect?: boolean | undefined\n    /**\n     * Timeout in milliseconds for `getInfo` (from the Safe SDK) to resolve.\n     *\n     * `getInfo` does not resolve when not used in Safe App iFrame. This allows the connector to force a timeout.\n     * @default 10\n     */\n    unstable_getInfoTimeout?: number | undefined\n  }\n>\n\nsafe.type = 'safe' as const\nexport function safe(parameters: SafeParameters = {}) {\n  const { shimDisconnect = false } = parameters\n\n  type Provider = SafeAppProvider | undefined\n  type Properties = Record<string, unknown>\n  type StorageItem = { 'safe.disconnected': true }\n\n  let provider_: Provider | undefined\n\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'safe',\n    name: 'Safe',\n    type: safe.type,\n    async connect({ withCapabilities } = {}) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const accounts = await this.getAccounts()\n      const chainId = await this.getChainId()\n\n      if (!disconnect) {\n        disconnect = this.onDisconnect.bind(this)\n        provider.on('disconnect', disconnect)\n      }\n\n      // Remove disconnected shim if it exists\n      if (shimDisconnect) await config.storage?.removeItem('safe.disconnected')\n\n      return {\n        // TODO(v3): Make `withCapabilities: true` default behavior\n        accounts: (withCapabilities\n          ? accounts.map((address) => ({ address, capabilities: {} }))\n          : accounts) as never,\n        chainId,\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect)\n        await config.storage?.setItem('safe.disconnected', true)\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      return (await provider.request({ method: 'eth_accounts' })).map(\n        getAddress,\n      )\n    },\n    async getProvider() {\n      // Only allowed in iframe context\n      const isIframe =\n        typeof window !== 'undefined' && window?.parent !== window\n      if (!isIframe) return\n\n      if (!provider_) {\n        const { default: SDK } = await import('@safe-global/safe-apps-sdk')\n        const sdk = new SDK(parameters)\n\n        // `getInfo` hangs when not used in Safe App iFrame\n        // https://github.com/safe-global/safe-apps-sdk/issues/263#issuecomment-1029835840\n        const safe = await withTimeout(() => sdk.safe.getInfo(), {\n          timeout: parameters.unstable_getInfoTimeout ?? 10,\n        })\n        if (!safe) throw new Error('Could not load Safe information')\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const SafeAppProvider = await (async () => {\n          const Provider = await import('@safe-global/safe-apps-provider')\n          if (\n            typeof Provider.SafeAppProvider !== 'function' &&\n            typeof Provider.default.SafeAppProvider === 'function'\n          )\n            return Provider.default.SafeAppProvider\n          return Provider.SafeAppProvider\n        })()\n        provider_ = new SafeAppProvider(safe, sdk)\n      }\n      return provider_\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      return Number(provider.chainId)\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          shimDisconnect &&\n          // If shim exists in storage, connector is disconnected\n          (await config.storage?.getItem('safe.disconnected'))\n        if (isDisconnected) return false\n\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    onAccountsChanged() {\n      // Not relevant for Safe because changing account requires app reload.\n    },\n    onChainChanged() {\n      // Not relevant for Safe because Safe smart contract wallets only exist on single chain.\n    },\n    onDisconnect() {\n      config.emitter.emit('disconnect')\n    },\n  }))\n}\n","import type {\n  MetaMaskSDK,\n  MetaMaskSDKOptions,\n  RPC_URLS_MAP,\n  SDKProvider,\n} from '@metamask/sdk'\nimport {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n  extractRpcUrls,\n  ProviderNotFoundError,\n} from '@wagmi/core'\nimport type {\n  Compute,\n  ExactPartial,\n  OneOf,\n  RemoveUndefined,\n  UnionCompute,\n} from '@wagmi/core/internal'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  getAddress,\n  type Hex,\n  hexToNumber,\n  numberToHex,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  ResourceUnavailableRpcError,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  withRetry,\n  withTimeout,\n} from 'viem'\n\nexport type MetaMaskParameters = UnionCompute<\n  WagmiMetaMaskSDKOptions &\n    OneOf<\n      | {\n          /* Shortcut to connect and sign a message */\n          connectAndSign?: string | undefined\n        }\n      | {\n          // TODO: Strongly type `method` and `params`\n          /* Allow `connectWith` any rpc method */\n          connectWith?: { method: string; params: unknown[] } | undefined\n        }\n    >\n>\n\ntype WagmiMetaMaskSDKOptions = Compute<\n  ExactPartial<\n    Omit<\n      MetaMaskSDKOptions,\n      | '_source'\n      | 'forceDeleteProvider'\n      | 'forceInjectProvider'\n      | 'injectProvider'\n      | 'useDeeplink'\n      | 'readonlyRPCMap'\n    >\n  > & {\n    /** @deprecated */\n    forceDeleteProvider?: MetaMaskSDKOptions['forceDeleteProvider']\n    /** @deprecated */\n    forceInjectProvider?: MetaMaskSDKOptions['forceInjectProvider']\n    /** @deprecated */\n    injectProvider?: MetaMaskSDKOptions['injectProvider']\n    /** @deprecated */\n    useDeeplink?: MetaMaskSDKOptions['useDeeplink']\n  }\n>\n\nmetaMask.type = 'metaMask' as const\nexport function metaMask(parameters: MetaMaskParameters = {}) {\n  type Provider = SDKProvider\n  type Properties = {\n    onConnect(connectInfo: ProviderConnectInfo): void\n    onDisplayUri(uri: string): void\n  }\n  type Listener = Parameters<Provider['on']>[1]\n\n  let sdk: MetaMaskSDK\n  let provider: Provider | undefined\n  let providerPromise: Promise<typeof provider>\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let connect: Connector['onConnect'] | undefined\n  let displayUri: ((uri: string) => void) | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'metaMaskSDK',\n    name: 'MetaMask',\n    rdns: ['io.metamask', 'io.metamask.mobile'],\n    type: metaMask.type,\n    async setup() {\n      const provider = await this.getProvider()\n      if (provider?.on) {\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect as Listener)\n        }\n\n        // We shouldn't need to listen for `'accountsChanged'` here since the `'connect'` event should suffice (and wallet shouldn't be connected yet).\n        // Some wallets, like MetaMask, do not implement the `'connect'` event and overload `'accountsChanged'` instead.\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged as Listener)\n        }\n      }\n    },\n    async connect({ chainId, isReconnecting, withCapabilities } = {}) {\n      const provider = await this.getProvider()\n      if (!displayUri) {\n        displayUri = this.onDisplayUri\n        provider.on('display_uri', displayUri as Listener)\n      }\n\n      let accounts: readonly Address[] = []\n      if (isReconnecting) accounts = await this.getAccounts().catch(() => [])\n\n      try {\n        let signResponse: string | undefined\n        let connectWithResponse: unknown | undefined\n        if (!accounts?.length) {\n          if (parameters.connectAndSign || parameters.connectWith) {\n            if (parameters.connectAndSign)\n              signResponse = await sdk.connectAndSign({\n                msg: parameters.connectAndSign,\n              })\n            else if (parameters.connectWith)\n              connectWithResponse = await sdk.connectWith({\n                method: parameters.connectWith.method,\n                params: parameters.connectWith.params,\n              })\n\n            accounts = await this.getAccounts()\n          } else {\n            const requestedAccounts = (await sdk.connect()) as string[]\n            accounts = requestedAccounts.map((x) => getAddress(x))\n          }\n        }\n        // Switch to chain if provided\n        let currentChainId = (await this.getChainId()) as number\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        if (displayUri) {\n          provider.removeListener('display_uri', displayUri)\n          displayUri = undefined\n        }\n\n        if (signResponse)\n          provider.emit('connectAndSign', {\n            accounts,\n            chainId: currentChainId,\n            signResponse,\n          })\n        else if (connectWithResponse)\n          provider.emit('connectWith', {\n            accounts,\n            chainId: currentChainId,\n            connectWithResponse,\n          })\n\n        // Manage EIP-1193 event listeners\n        // https://eips.ethereum.org/EIPS/eip-1193#events\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged as Listener)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged as Listener)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect as Listener)\n        }\n\n        return {\n          // TODO(v3): Make `withCapabilities: true` default behavior\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (err) {\n        const error = err as RpcError\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        if (error.code === ResourceUnavailableRpcError.code)\n          throw new ResourceUnavailableRpcError(error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect as Listener)\n      }\n\n      await sdk.terminate()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[]\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId =\n        provider.getChainId() ||\n        (await provider?.request({ method: 'eth_chainId' }))\n      return Number(chainId)\n    },\n    async getProvider() {\n      async function initProvider() {\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const MetaMaskSDK = await (async () => {\n          const { default: SDK } = await import('@metamask/sdk')\n          if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n            return SDK.default\n          return SDK as unknown as typeof SDK.default\n        })()\n\n        const readonlyRPCMap: RPC_URLS_MAP = {}\n        for (const chain of config.chains)\n          readonlyRPCMap[numberToHex(chain.id)] = extractRpcUrls({\n            chain,\n            transports: config.transports,\n          })?.[0]\n\n        sdk = new MetaMaskSDK({\n          _source: 'wagmi',\n          forceDeleteProvider: false,\n          forceInjectProvider: false,\n          injectProvider: false,\n          // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`\n          ...(parameters as RemoveUndefined<typeof parameters>),\n          readonlyRPCMap,\n          dappMetadata: {\n            ...parameters.dappMetadata,\n            // Test if name and url are set AND not empty\n            name: parameters.dappMetadata?.name\n              ? parameters.dappMetadata?.name\n              : 'wagmi',\n            url: parameters.dappMetadata?.url\n              ? parameters.dappMetadata?.url\n              : typeof window !== 'undefined'\n                ? window.location.origin\n                : 'https://wagmi.sh',\n          },\n          useDeeplink: parameters.useDeeplink ?? true,\n        })\n        const result = await sdk.init()\n        // On initial load, sometimes `sdk.getProvider` does not return provider.\n        // https://github.com/wevm/wagmi/issues/4367\n        // Use result of `init` call if available.\n        const provider = (() => {\n          if (result?.activeProvider) return result.activeProvider\n          return sdk.getProvider()\n        })()\n        if (!provider) throw new ProviderNotFoundError()\n        return provider\n      }\n\n      if (!provider) {\n        if (!providerPromise) providerPromise = initProvider()\n        provider = await providerPromise\n      }\n      return provider!\n    },\n    async isAuthorized() {\n      try {\n        // MetaMask mobile provider sometimes fails to immediately resolve\n        // JSON-RPC requests on page load\n        const timeout = 200\n        const accounts = await withRetry(\n          () => withTimeout(() => this.getAccounts(), { timeout }),\n          {\n            delay: timeout + 1,\n            retryCount: 3,\n          },\n        )\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chainId) }],\n        })\n\n        // During `'wallet_switchEthereumChain'`, MetaMask makes a `'net_version'` RPC call to the target chain.\n        // If this request fails, MetaMask does not emit the `'chainChanged'` event, but will still switch the chain.\n        // To counter this behavior, we request and emit the current chain ID to confirm the chain switch either via\n        // this callback or an externally emitted `'chainChanged'` event.\n        // https://github.com/MetaMask/metamask-extension/issues/24247\n        await waitForChainIdToSync()\n        await sendAndWaitForChangeEvent(chainId)\n\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n\n        // Indicates chain is not added to provider\n        if (\n          error.code === 4902 ||\n          // Unwrapping for MetaMask Mobile\n          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n          (error as ProviderRpcError<{ originalError?: { code: number } }>)\n            ?.data?.originalError?.code === 4902\n        ) {\n          try {\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [\n                {\n                  blockExplorerUrls: (() => {\n                    const { default: blockExplorer, ...blockExplorers } =\n                      chain.blockExplorers ?? {}\n                    if (addEthereumChainParameter?.blockExplorerUrls)\n                      return addEthereumChainParameter.blockExplorerUrls\n                    if (blockExplorer)\n                      return [\n                        blockExplorer.url,\n                        ...Object.values(blockExplorers).map((x) => x.url),\n                      ]\n                    return\n                  })(),\n                  chainId: numberToHex(chainId),\n                  chainName: addEthereumChainParameter?.chainName ?? chain.name,\n                  iconUrls: addEthereumChainParameter?.iconUrls,\n                  nativeCurrency:\n                    addEthereumChainParameter?.nativeCurrency ??\n                    chain.nativeCurrency,\n                  rpcUrls: (() => {\n                    if (addEthereumChainParameter?.rpcUrls?.length)\n                      return addEthereumChainParameter.rpcUrls\n                    return [chain.rpcUrls.default?.http[0] ?? '']\n                  })(),\n                } satisfies AddEthereumChainParameter,\n              ],\n            })\n\n            await waitForChainIdToSync()\n            await sendAndWaitForChangeEvent(chainId)\n\n            return chain\n          } catch (err) {\n            const error = err as RpcError\n            if (error.code === UserRejectedRequestError.code)\n              throw new UserRejectedRequestError(error)\n            throw new SwitchChainError(error)\n          }\n        }\n\n        throw new SwitchChainError(error)\n      }\n\n      async function waitForChainIdToSync() {\n        // On mobile, there is a race condition between the result of `'wallet_addEthereumChain'` and `'eth_chainId'`.\n        // To avoid this, we wait for `'eth_chainId'` to return the expected chain ID with a retry loop.\n        await withRetry(\n          async () => {\n            const value = hexToNumber(\n              // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks\n              (await provider.request({ method: 'eth_chainId' })) as Hex,\n            )\n            // `value` doesn't match expected `chainId`, throw to trigger retry\n            if (value !== chainId)\n              throw new Error('User rejected switch after adding network.')\n            return value\n          },\n          {\n            delay: 50,\n            retryCount: 20, // android device encryption is slower\n          },\n        )\n      }\n\n      async function sendAndWaitForChangeEvent(chainId: number) {\n        await new Promise<void>((resolve) => {\n          const listener = ((data) => {\n            if ('chainId' in data && data.chainId === chainId) {\n              config.emitter.off('change', listener)\n              resolve()\n            }\n          }) satisfies Parameters<typeof config.emitter.on>[1]\n          config.emitter.on('change', listener)\n          config.emitter.emit('change', { chainId })\n        })\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) {\n        // ... and using browser extension\n        if (sdk.isExtensionActive()) this.onDisconnect()\n        // FIXME(upstream): Mobile app sometimes emits invalid `accountsChanged` event with empty accounts array\n        else return\n      }\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString()\n        this.onConnect({ chainId })\n      }\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts()\n      if (accounts.length === 0) return\n\n      const chainId = Number(connectInfo.chainId)\n      config.emitter.emit('connect', { accounts, chainId })\n\n      const provider = await this.getProvider()\n      if (connect) {\n        provider.removeListener('connect', connect)\n        connect = undefined\n      }\n      if (!accountsChanged) {\n        accountsChanged = this.onAccountsChanged.bind(this)\n        provider.on('accountsChanged', accountsChanged as Listener)\n      }\n      if (!chainChanged) {\n        chainChanged = this.onChainChanged.bind(this)\n        provider.on('chainChanged', chainChanged as Listener)\n      }\n      if (!disconnect) {\n        disconnect = this.onDisconnect.bind(this)\n        provider.on('disconnect', disconnect as Listener)\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider()\n\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && (error as RpcError<1013>).code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return\n      }\n\n      config.emitter.emit('disconnect')\n\n      // Manage EIP-1193 event listeners\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect as Listener)\n      }\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', { type: 'display_uri', data: uri })\n    },\n  }))\n}\n","import {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n} from '@wagmi/core'\nimport type { ExactPartial } from '@wagmi/core/internal'\nimport { type Porto, RpcSchema } from 'porto'\nimport { z } from 'porto/internal'\nimport {\n  type Address,\n  getAddress,\n  numberToHex,\n  type ProviderConnectInfo,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  withRetry,\n} from 'viem'\n\nexport type PortoParameters = ExactPartial<Porto.Config>\n\nexport function porto(parameters: PortoParameters = {}) {\n  type Provider = ReturnType<typeof Porto.create>['provider']\n  type Properties = {\n    connect<withCapabilities extends boolean = false>(parameters?: {\n      chainId?: number | undefined\n      capabilities?:\n        | (RpcSchema.wallet_connect.Capabilities & {\n            force?: boolean | undefined\n          })\n        | undefined\n      isReconnecting?: boolean | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{\n      accounts: withCapabilities extends true\n        ? readonly {\n            address: Address\n            capabilities: RpcSchema.wallet_connect.ResponseCapabilities\n          }[]\n        : readonly Address[]\n      chainId: number\n    }>\n    getPortoInstance(): Promise<Porto.Porto>\n    onConnect(connectInfo: ProviderConnectInfo): void\n  }\n\n  return createConnector<Provider, Properties>((wagmiConfig) => {\n    const chains = wagmiConfig.chains ?? parameters.chains ?? []\n\n    const transports = (() => {\n      if (wagmiConfig.transports) return wagmiConfig.transports\n      return parameters.transports\n    })()\n\n    let porto_promise: Promise<any> | undefined\n\n    let accountsChanged: Connector['onAccountsChanged'] | undefined\n    let chainChanged: Connector['onChainChanged'] | undefined\n    let connect: Connector['onConnect'] | undefined\n    let disconnect: Connector['onDisconnect'] | undefined\n\n    return {\n      async connect({ chainId = chains[0].id, ...rest } = {}) {\n        const isReconnecting =\n          ('isReconnecting' in rest && rest.isReconnecting) || false\n        const withCapabilities =\n          ('withCapabilities' in rest && rest.withCapabilities) || false\n\n        let accounts: readonly (Address | { address: Address })[] = []\n        let currentChainId: number | undefined\n\n        if (isReconnecting) {\n          ;[accounts, currentChainId] = await Promise.all([\n            this.getAccounts().catch(() => []),\n            this.getChainId().catch(() => undefined),\n          ])\n          if (chainId && currentChainId !== chainId) {\n            const chain = await this.switchChain!({ chainId }).catch(\n              (error) => {\n                if (error.code === UserRejectedRequestError.code) throw error\n                return { id: currentChainId }\n              },\n            )\n            currentChainId = chain?.id ?? currentChainId\n          }\n        }\n\n        const provider = (await this.getProvider()) as Provider\n\n        try {\n          if (!accounts?.length && !isReconnecting) {\n            const res = await provider.request({\n              method: 'wallet_connect',\n              params: [\n                {\n                  ...('capabilities' in rest\n                    ? {\n                        capabilities: z.encode(\n                          RpcSchema.wallet_connect.Capabilities,\n                          rest.capabilities ?? {},\n                        ),\n                      }\n                    : {}),\n                  chainIds: [\n                    numberToHex(chainId),\n                    ...chains\n                      .filter((x) => x.id !== chainId)\n                      .map((x) => numberToHex(x.id)),\n                  ],\n                },\n              ],\n            })\n            accounts = res.accounts\n            currentChainId = Number(res.chainIds[0])\n          }\n\n          if (!currentChainId) throw new ChainNotConfiguredError()\n\n          // Manage EIP-1193 event listeners\n          // https://eips.ethereum.org/EIPS/eip-1193#events\n          if (connect) {\n            provider.removeListener('connect', connect)\n            connect = undefined\n          }\n          if (!accountsChanged) {\n            accountsChanged = this.onAccountsChanged.bind(this)\n            // Porto Provider uses Ox, which uses `readonly Address.Address[]` for `accountsChanged`,\n            // while Connector `accountsChanged` is `string[]`\n            provider.on('accountsChanged', accountsChanged as never)\n          }\n          if (!chainChanged) {\n            chainChanged = this.onChainChanged.bind(this)\n            provider.on('chainChanged', chainChanged)\n          }\n          if (!disconnect) {\n            disconnect = this.onDisconnect.bind(this)\n            provider.on('disconnect', disconnect)\n          }\n\n          return {\n            accounts: accounts.map((account) => {\n              if (typeof account === 'object')\n                return withCapabilities ? account : account.address\n              return withCapabilities\n                ? { address: account, capabilities: {} }\n                : account\n            }) as never,\n            chainId: currentChainId,\n          }\n        } catch (err) {\n          const error = err as RpcError\n          if (error.code === UserRejectedRequestError.code)\n            throw new UserRejectedRequestError(error)\n          throw error\n        }\n      },\n      async disconnect() {\n        const provider = await this.getProvider()\n\n        if (chainChanged) {\n          provider.removeListener('chainChanged', chainChanged)\n          chainChanged = undefined\n        }\n        if (disconnect) {\n          provider.removeListener('disconnect', disconnect)\n          disconnect = undefined\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n\n        await provider.request({ method: 'wallet_disconnect' })\n      },\n      async getAccounts() {\n        const provider = await this.getProvider()\n        const accounts = await provider.request({\n          method: 'eth_accounts',\n        })\n        return accounts.map((x) => getAddress(x))\n      },\n      async getChainId() {\n        const provider = await this.getProvider()\n        const hexChainId = await provider.request({\n          method: 'eth_chainId',\n        })\n        return Number(hexChainId)\n      },\n      async getPortoInstance() {\n        porto_promise ??= (async () => {\n          const { Porto } = await import('porto')\n          return Porto.create({\n            ...parameters,\n            announceProvider: false,\n            chains: chains as never,\n            transports: transports as never,\n          })\n        })()\n        return await porto_promise\n      },\n      async getProvider() {\n        return (await this.getPortoInstance()).provider\n      },\n      icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K',\n      id: 'xyz.ithaca.porto',\n      async isAuthorized() {\n        try {\n          // Use retry strategy as some injected wallets (e.g. MetaMask) fail to\n          // immediately resolve JSON-RPC requests on page load.\n          const accounts = await withRetry(() => this.getAccounts())\n          return !!accounts.length\n        } catch {\n          return false\n        }\n      },\n      name: 'Porto',\n      async onAccountsChanged(accounts) {\n        wagmiConfig.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n      },\n      onChainChanged(chain) {\n        const chainId = Number(chain)\n        wagmiConfig.emitter.emit('change', { chainId })\n      },\n      async onConnect(connectInfo) {\n        const accounts = await this.getAccounts()\n        if (accounts.length === 0) return\n\n        const chainId = Number(connectInfo.chainId)\n        wagmiConfig.emitter.emit('connect', { accounts, chainId })\n\n        // Manage EIP-1193 event listeners\n        const provider = await this.getProvider()\n        if (provider) {\n          if (connect) {\n            provider.removeListener('connect', connect)\n            connect = undefined\n          }\n          if (!accountsChanged) {\n            accountsChanged = this.onAccountsChanged.bind(this)\n            // Porto Provider uses Ox, which uses `readonly Address.Address[]` for `accountsChanged`,\n            // while Connector `accountsChanged` is `string[]`\n            provider.on('accountsChanged', accountsChanged as never)\n          }\n          if (!chainChanged) {\n            chainChanged = this.onChainChanged.bind(this)\n            provider.on('chainChanged', chainChanged)\n          }\n          if (!disconnect) {\n            disconnect = this.onDisconnect.bind(this)\n            provider.on('disconnect', disconnect)\n          }\n        }\n      },\n      async onDisconnect(_error) {\n        const provider = await this.getProvider()\n\n        wagmiConfig.emitter.emit('disconnect')\n\n        // Manage EIP-1193 event listeners\n        if (provider) {\n          if (chainChanged) {\n            provider.removeListener('chainChanged', chainChanged)\n            chainChanged = undefined\n          }\n          if (disconnect) {\n            provider.removeListener('disconnect', disconnect)\n            disconnect = undefined\n          }\n          if (!connect) {\n            connect = this.onConnect.bind(this)\n            provider.on('connect', connect)\n          }\n        }\n      },\n      async setup() {\n        if (!connect) {\n          const provider = await this.getProvider()\n          connect = this.onConnect.bind(this)\n          provider.on('connect', connect)\n        }\n      },\n      async switchChain({ chainId }) {\n        const chain = chains.find((x) => x.id === chainId)\n        if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n        const provider = await this.getProvider()\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chainId) }],\n        })\n\n        return chain\n      },\n      type: 'injected',\n    }\n  })\n}\n","import type {\n  createCoinbaseWalletSDK,\n  Preference,\n  ProviderInterface,\n} from '@coinbase/wallet-sdk'\nimport {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n} from '@wagmi/core'\nimport type { Compute, Mutable, Omit } from '@wagmi/core/internal'\nimport type {\n  CoinbaseWalletProvider as CBW_Provider,\n  CoinbaseWalletSDK as CBW_SDK,\n} from 'cbw-sdk'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  getAddress,\n  type Hex,\n  numberToHex,\n  type ProviderRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n} from 'viem'\n\ntype Version = '3' | '4'\n\nexport type CoinbaseWalletParameters<version extends Version = '3'> =\n  version extends '4'\n    ? Compute<\n        {\n          headlessMode?: false | undefined\n          /** Coinbase Wallet SDK version */\n          version?: version | '3' | undefined\n        } & Version4Parameters\n      >\n    : Compute<\n        {\n          /**\n           * @deprecated `headlessMode` will be removed in the next major version. Upgrade to `version: '4'`.\n           */\n          headlessMode?: true | undefined\n          /**\n           * Coinbase Wallet SDK version\n           * @deprecated Version 3 will be removed in the next major version. Upgrade to `version: '4'`.\n           * @default '4'\n           */\n          version?: version | '4' | undefined\n        } & Version3Parameters\n      >\n\ncoinbaseWallet.type = 'coinbaseWallet' as const\nexport function coinbaseWallet<version extends Version>(\n  parameters: CoinbaseWalletParameters<version> = {} as any,\n): version extends '4'\n  ? ReturnType<typeof version4>\n  : ReturnType<typeof version3> {\n  if (parameters.version === '3' || parameters.headlessMode)\n    return version3(parameters as Version3Parameters) as any\n  return version4(parameters as Version4Parameters) as any\n}\n\ntype Version4Parameters = Mutable<\n  Omit<\n    Parameters<typeof createCoinbaseWalletSDK>[0],\n    | 'appChainIds' // set via wagmi config\n    | 'preference'\n  > & {\n    // TODO(v3): Remove `Preference['options']`\n    /**\n     * Preference for the type of wallet to display.\n     * @default 'all'\n     */\n    preference?: Preference['options'] | Compute<Preference> | undefined\n  }\n>\n\nfunction version4(parameters: Version4Parameters) {\n  type Provider = ProviderInterface & {\n    // for backwards compatibility\n    close?(): void\n  }\n  type Properties = {\n    // TODO(v3): Make `withCapabilities: true` default behavior\n    connect<withCapabilities extends boolean = false>(parameters?: {\n      chainId?: number | undefined\n      instantOnboarding?: boolean | undefined\n      isReconnecting?: boolean | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{\n      accounts: withCapabilities extends true\n        ? readonly { address: Address }[]\n        : readonly Address[]\n      chainId: number\n    }>\n  }\n\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    rdns: 'com.coinbase.wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId, withCapabilities, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n            params:\n              'instantOnboarding' in rest && rest.instantOnboarding\n                ? [{ onboarding: 'instant' }]\n                : [],\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return {\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n      provider.close?.()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        (await provider.request({\n          method: 'eth_accounts',\n        })) as string[]\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = (await provider.request({\n        method: 'eth_chainId',\n      })) as Hex\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        const preference = (() => {\n          if (typeof parameters.preference === 'string')\n            return { options: parameters.preference }\n          return {\n            ...parameters.preference,\n            options: parameters.preference?.options ?? 'all',\n          }\n        })()\n\n        const { createCoinbaseWalletSDK } = await import('@coinbase/wallet-sdk')\n        const sdk = createCoinbaseWalletSDK({\n          ...parameters,\n          appChainIds: config.chains.map((x) => x.id),\n          preference,\n        })\n\n        walletProvider = sdk.getProvider()\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n\ntype Version3Parameters = Mutable<\n  Omit<\n    ConstructorParameters<typeof CBW_SDK>[0],\n    'reloadOnDisconnect' // remove property since TSDoc says default is `true`\n  >\n> & {\n  /**\n   * Fallback Ethereum JSON RPC URL\n   * @default \"\"\n   */\n  jsonRpcUrl?: string | undefined\n  /**\n   * Fallback Ethereum Chain ID\n   * @default 1\n   */\n  chainId?: number | undefined\n  /**\n   * Whether or not to reload dapp automatically after disconnect.\n   * @default false\n   */\n  reloadOnDisconnect?: boolean | undefined\n}\n\nfunction version3(parameters: Version3Parameters) {\n  const reloadOnDisconnect = false\n\n  type Provider = CBW_Provider\n\n  let sdk: CBW_SDK | undefined\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    rdns: 'com.coinbase.wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId, withCapabilities } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return {\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n      provider.close()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        await provider.request<string[]>({\n          method: 'eth_accounts',\n        })\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = await provider.request<Hex>({\n        method: 'eth_chainId',\n      })\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const CoinbaseWalletSDK = await (async () => {\n          const { default: SDK } = await import('cbw-sdk')\n          if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n            return SDK.default\n          return SDK as unknown as typeof SDK.default\n        })()\n\n        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect })\n\n        // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.\n        const walletExtensionChainId = (\n          sdk as unknown as {\n            get walletExtension(): { getChainId(): number } | undefined\n          }\n        ).walletExtension?.getChainId()\n\n        const chain =\n          config.chains.find((chain) =>\n            parameters.chainId\n              ? chain.id === parameters.chainId\n              : chain.id === walletExtensionChainId,\n          ) || config.chains[0]\n        const chainId = parameters.chainId || chain?.id\n        const jsonRpcUrl =\n          parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0]\n\n        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId)\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n","import type { createBaseAccountSDK, ProviderInterface } from '@base-org/account'\nimport {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n} from '@wagmi/core'\nimport type { Mutable, Omit } from '@wagmi/core/internal'\nimport {\n  type AddEthereumChainParameter,\n  getAddress,\n  type Hex,\n  numberToHex,\n  type ProviderRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n} from 'viem'\n\nexport type BaseAccountParameters = Mutable<\n  Omit<\n    Parameters<typeof createBaseAccountSDK>[0],\n    'appChainIds' // set via wagmi config\n  >\n>\n\nexport function baseAccount(parameters: BaseAccountParameters = {}) {\n  type Provider = ProviderInterface\n\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider>((config) => ({\n    id: 'baseAccount',\n    name: 'Base Account',\n    rdns: 'app.base.account',\n    type: 'baseAccount',\n    async connect({ chainId, withCapabilities } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n            params: [],\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return {\n          // TODO(v3): Make `withCapabilities: true` default behavior\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        (await provider.request({\n          method: 'eth_accounts',\n        })) as string[]\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = (await provider.request({\n        method: 'eth_chainId',\n      })) as Hex\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        const preference = (() => {\n          if (typeof parameters.preference === 'string')\n            return { options: parameters.preference }\n          return {\n            ...parameters.preference,\n            options: parameters.preference?.options ?? 'all',\n          }\n        })()\n\n        const { createBaseAccountSDK } = await import('@base-org/account')\n        const sdk = createBaseAccountSDK({\n          ...parameters,\n          appChainIds: config.chains.map((x) => x.id),\n          preference,\n        })\n\n        walletProvider = sdk.getProvider()\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n","import {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n  extractRpcUrls,\n  ProviderNotFoundError,\n} from '@wagmi/core'\nimport type { Compute, ExactPartial, Omit } from '@wagmi/core/internal'\nimport type { EthereumProvider } from '@walletconnect/ethereum-provider'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  getAddress,\n  numberToHex,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  type RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n} from 'viem'\n\ntype WalletConnectConnector = Connector & {\n  onDisplayUri(uri: string): void\n  onSessionDelete(data: { topic: string }): void\n}\n\ntype EthereumProviderOptions = Parameters<(typeof EthereumProvider)['init']>[0]\n\nexport type WalletConnectParameters = Compute<\n  {\n    /**\n     * If a new chain is added to a previously existing configured connector `chains`, this flag\n     * will determine if that chain should be considered as stale. A stale chain is a chain that\n     * WalletConnect has yet to establish a relationship with (e.g. the user has not approved or\n     * rejected the chain).\n     *\n     * This flag mainly affects the behavior when a wallet does not support dynamic chain authorization\n     * with WalletConnect v2.\n     *\n     * If `true` (default), the new chain will be treated as a stale chain. If the user\n     * has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect\n     * session, the connector will disconnect upon the dapp auto-connecting, and the user will have to\n     * reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.\n     * This is the default behavior to avoid an unexpected error upon switching chains which may\n     * be a confusing user experience (e.g. the user will not know they have to reconnect\n     * unless the dapp handles these types of errors).\n     *\n     * If `false`, the new chain will be treated as a potentially valid chain. This means that if the user\n     * has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully\n     * auto-connect the user. This comes with the trade-off that the connector will throw an error\n     * when attempting to switch to the unapproved chain if the wallet does not support dynamic session updates.\n     * This may be useful in cases where a dapp constantly\n     * modifies their configured chains, and they do not want to disconnect the user upon\n     * auto-connecting. If the user decides to switch to the unapproved chain, it is important that the\n     * dapp handles this error and prompts the user to reconnect to the dapp in order to approve\n     * the newly added chain.\n     *\n     * @default true\n     */\n    isNewChainsStale?: boolean\n  } & Omit<\n    EthereumProviderOptions,\n    | 'chains'\n    | 'events'\n    | 'optionalChains'\n    | 'optionalEvents'\n    | 'optionalMethods'\n    | 'methods'\n    | 'rpcMap'\n    | 'showQrModal'\n  > &\n    ExactPartial<Pick<EthereumProviderOptions, 'showQrModal'>>\n>\n\nwalletConnect.type = 'walletConnect' as const\n/**\n * @deprecated **NOTE: This connector uses a vulnerable dependency downstream** (`@walletconnect/ethereum-provider@2.21.1` > `@reown/appkit@1.8.9` > `@reown/appkit-utils@1.8.9` > `@walletconnect/logger@2.1.2` > `pino@7.11.0`). You should override `pino` to a secure version via your package manager:\n *\n * ### npm\n * ```json\n * {\n *   \"overrides\": {\n *     \"@walletconnect/logger\": {\n *       \"pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * ### pnpm\n * ```json\n * {\n *   \"pnpm\": {\n *     \"overrides\": {\n *       \"@walletconnect/logger>pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * ### yarn\n * ```json\n * {\n *   \"resolutions\": {\n *     \"@walletconnect/logger/pino\": \"10.0.0\"\n *   }\n * }\n * ```\n *\n * ### bun\n * ```json\n * {\n *   \"overrides\": {\n *     \"@walletconnect/logger\": {\n *       \"pino\": \"10.0.0\"\n *     }\n *   }\n * }\n * ```\n *\n * Normally the Wagmi team would upgrade `@walletconnect/ethereum-provider` to a fixed version for you, but `@walletconnect/ethereum-provider` was relicensed recently from Apache to a [non-permissive license](https://github.com/reown-com/appkit/blob/main/LICENSE.md). We are trying to get the WalletConnect team to release a version that closes the vulnerability under the old Apache license.\n */\nexport function walletConnect(parameters: WalletConnectParameters) {\n  const isNewChainsStale = parameters.isNewChainsStale ?? true\n\n  type Provider = Awaited<ReturnType<(typeof EthereumProvider)['init']>>\n  type Properties = {\n    // TODO(v3): Make `withCapabilities: true` default behavior\n    connect<withCapabilities extends boolean = false>(parameters?: {\n      chainId?: number | undefined\n      isReconnecting?: boolean | undefined\n      pairingTopic?: string | undefined\n      withCapabilities?: withCapabilities | boolean | undefined\n    }): Promise<{\n      accounts: withCapabilities extends true\n        ? readonly { address: Address }[]\n        : readonly Address[]\n      chainId: number\n    }>\n    getNamespaceChainsIds(): number[]\n    getRequestedChainsIds(): Promise<number[]>\n    isChainsStale(): Promise<boolean>\n    onConnect(connectInfo: ProviderConnectInfo): void\n    onDisplayUri(uri: string): void\n    onSessionDelete(data: { topic: string }): void\n    setRequestedChainsIds(chains: number[]): void\n    requestedChainsStorageKey: `${string}.requestedChains`\n  }\n  type StorageItem = {\n    [_ in Properties['requestedChainsStorageKey']]: number[]\n  }\n\n  let provider_: Provider | undefined\n  let providerPromise: Promise<typeof provider_>\n  const NAMESPACE = 'eip155'\n\n  let accountsChanged: WalletConnectConnector['onAccountsChanged'] | undefined\n  let chainChanged: WalletConnectConnector['onChainChanged'] | undefined\n  let connect: WalletConnectConnector['onConnect'] | undefined\n  let displayUri: WalletConnectConnector['onDisplayUri'] | undefined\n  let sessionDelete: WalletConnectConnector['onSessionDelete'] | undefined\n  let disconnect: WalletConnectConnector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'walletConnect',\n    name: 'WalletConnect',\n    type: walletConnect.type,\n    async setup() {\n      const provider = await this.getProvider().catch(() => null)\n      if (!provider) return\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n      if (!sessionDelete) {\n        sessionDelete = this.onSessionDelete.bind(this)\n        provider.on('session_delete', sessionDelete)\n      }\n    },\n    async connect({ chainId, withCapabilities, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        if (!provider) throw new ProviderNotFoundError()\n        if (!displayUri) {\n          displayUri = this.onDisplayUri\n          provider.on('display_uri', displayUri)\n        }\n\n        let targetChainId = chainId\n        if (!targetChainId) {\n          const state = (await config.storage?.getItem('state')) ?? {}\n          const isChainSupported = config.chains.some(\n            (x) => x.id === state.chainId,\n          )\n          if (isChainSupported) targetChainId = state.chainId\n          else targetChainId = config.chains[0]?.id\n        }\n        if (!targetChainId) throw new Error('No chains found on connector.')\n\n        const isChainsStale = await this.isChainsStale()\n        // If there is an active session with stale chains, disconnect current session.\n        if (provider.session && isChainsStale) await provider.disconnect()\n\n        // If there isn't an active session or chains are stale, connect.\n        if (!provider.session || isChainsStale) {\n          const optionalChains = config.chains\n            .filter((chain) => chain.id !== targetChainId)\n            .map((optionalChain) => optionalChain.id)\n          await provider.connect({\n            optionalChains: [targetChainId, ...optionalChains],\n            ...('pairingTopic' in rest\n              ? { pairingTopic: rest.pairingTopic }\n              : {}),\n          })\n\n          this.setRequestedChainsIds(config.chains.map((x) => x.id))\n        }\n\n        // If session exists and chains are authorized, enable provider for required chain\n        const accounts = (await provider.enable()).map((x) => getAddress(x))\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch(\n            (error: RpcError) => {\n              if (\n                error.code === UserRejectedRequestError.code &&\n                (error.cause as RpcError | undefined)?.message !==\n                  'Missing or invalid. request() method: wallet_addEthereumChain'\n              )\n                throw error\n              return { id: currentChainId }\n            },\n          )\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        if (displayUri) {\n          provider.removeListener('display_uri', displayUri)\n          displayUri = undefined\n        }\n        if (connect) {\n          provider.removeListener('connect', connect)\n          connect = undefined\n        }\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n        if (!sessionDelete) {\n          sessionDelete = this.onSessionDelete.bind(this)\n          provider.on('session_delete', sessionDelete)\n        }\n\n        return {\n          accounts: (withCapabilities\n            ? accounts.map((address) => ({ address, capabilities: {} }))\n            : accounts) as never,\n          chainId: currentChainId,\n        }\n      } catch (error) {\n        if (\n          /(user rejected|connection request reset)/i.test(\n            (error as ProviderRpcError)?.message,\n          )\n        ) {\n          throw new UserRejectedRequestError(error as Error)\n        }\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      try {\n        await provider?.disconnect()\n      } catch (error) {\n        if (!/No matching key/i.test((error as Error).message)) throw error\n      } finally {\n        if (chainChanged) {\n          provider?.removeListener('chainChanged', chainChanged)\n          chainChanged = undefined\n        }\n        if (disconnect) {\n          provider?.removeListener('disconnect', disconnect)\n          disconnect = undefined\n        }\n        if (!connect) {\n          connect = this.onConnect.bind(this)\n          provider?.on('connect', connect)\n        }\n        if (accountsChanged) {\n          provider?.removeListener('accountsChanged', accountsChanged)\n          accountsChanged = undefined\n        }\n        if (sessionDelete) {\n          provider?.removeListener('session_delete', sessionDelete)\n          sessionDelete = undefined\n        }\n\n        this.setRequestedChainsIds([])\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return provider.accounts.map((x) => getAddress(x))\n    },\n    async getProvider({ chainId } = {}) {\n      async function initProvider() {\n        const optionalChains = config.chains.map((x) => x.id) as [number]\n        if (!optionalChains.length) return\n        const { EthereumProvider } = await import(\n          '@walletconnect/ethereum-provider'\n        )\n        return await EthereumProvider.init({\n          ...parameters,\n          disableProviderPing: true,\n          optionalChains,\n          projectId: parameters.projectId,\n          rpcMap: Object.fromEntries(\n            config.chains.map((chain) => {\n              const [url] = extractRpcUrls({\n                chain,\n                transports: config.transports,\n              })\n              return [chain.id, url]\n            }),\n          ),\n          showQrModal: parameters.showQrModal ?? true,\n        })\n      }\n\n      if (!provider_) {\n        if (!providerPromise) providerPromise = initProvider()\n        provider_ = await providerPromise\n        provider_?.events.setMaxListeners(Number.POSITIVE_INFINITY)\n      }\n      if (chainId) await this.switchChain?.({ chainId })\n      return provider_!\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      return provider.chainId\n    },\n    async isAuthorized() {\n      try {\n        const [accounts, provider] = await Promise.all([\n          this.getAccounts(),\n          this.getProvider(),\n        ])\n\n        // If an account does not exist on the session, then the connector is unauthorized.\n        if (!accounts.length) return false\n\n        // If the chains are stale on the session, then the connector is unauthorized.\n        const isChainsStale = await this.isChainsStale()\n        if (isChainsStale && provider.session) {\n          await provider.disconnect().catch(() => {})\n          return false\n        }\n        return true\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        await Promise.all([\n          new Promise<void>((resolve) => {\n            const listener = ({\n              chainId: currentChainId,\n            }: {\n              chainId?: number | undefined\n            }) => {\n              if (currentChainId === chainId) {\n                config.emitter.off('change', listener)\n                resolve()\n              }\n            }\n            config.emitter.on('change', listener)\n          }),\n          provider.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: numberToHex(chainId) }],\n          }),\n        ])\n\n        const requestedChains = await this.getRequestedChainsIds()\n        this.setRequestedChainsIds([...requestedChains, chainId])\n\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        if (/(user rejected)/i.test(error.message))\n          throw new UserRejectedRequestError(error)\n\n        // Indicates chain is not added to provider\n        try {\n          let blockExplorerUrls: string[] | undefined\n          if (addEthereumChainParameter?.blockExplorerUrls)\n            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n          else\n            blockExplorerUrls = chain.blockExplorers?.default.url\n              ? [chain.blockExplorers?.default.url]\n              : []\n\n          let rpcUrls: readonly string[]\n          if (addEthereumChainParameter?.rpcUrls?.length)\n            rpcUrls = addEthereumChainParameter.rpcUrls\n          else rpcUrls = [...chain.rpcUrls.default.http]\n\n          const addEthereumChain = {\n            blockExplorerUrls,\n            chainId: numberToHex(chainId),\n            chainName: addEthereumChainParameter?.chainName ?? chain.name,\n            iconUrls: addEthereumChainParameter?.iconUrls,\n            nativeCurrency:\n              addEthereumChainParameter?.nativeCurrency ?? chain.nativeCurrency,\n            rpcUrls,\n          } satisfies AddEthereumChainParameter\n\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [addEthereumChain],\n          })\n\n          const requestedChains = await this.getRequestedChainsIds()\n          this.setRequestedChainsIds([...requestedChains, chainId])\n          return chain\n        } catch (error) {\n          throw new UserRejectedRequestError(error as Error)\n        }\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const chainId = Number(connectInfo.chainId)\n      const accounts = await this.getAccounts()\n      config.emitter.emit('connect', { accounts, chainId })\n    },\n    async onDisconnect(_error) {\n      this.setRequestedChainsIds([])\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n      if (sessionDelete) {\n        provider.removeListener('session_delete', sessionDelete)\n        sessionDelete = undefined\n      }\n      if (!connect) {\n        connect = this.onConnect.bind(this)\n        provider.on('connect', connect)\n      }\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', { type: 'display_uri', data: uri })\n    },\n    onSessionDelete() {\n      this.onDisconnect()\n    },\n    getNamespaceChainsIds() {\n      if (!provider_) return []\n      const chainIds = provider_.session?.namespaces[NAMESPACE]?.accounts?.map(\n        (account) => Number.parseInt(account.split(':')[1] || '', 10),\n      )\n      return chainIds ?? []\n    },\n    async getRequestedChainsIds() {\n      return (\n        (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? []\n      )\n    },\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     */\n    async isChainsStale() {\n      if (!isNewChainsStale) return false\n\n      const connectorChains = config.chains.map((x) => x.id)\n      const namespaceChains = this.getNamespaceChainsIds()\n      if (\n        namespaceChains.length &&\n        !namespaceChains.some((id) => connectorChains.includes(id))\n      )\n        return false\n\n      const requestedChains = await this.getRequestedChainsIds()\n      return !connectorChains.every((id) => requestedChains.includes(id))\n    },\n    async setRequestedChainsIds(chains) {\n      await config.storage?.setItem(this.requestedChainsStorageKey, chains)\n    },\n    get requestedChainsStorageKey() {\n      return `${this.id}.requestedChains` as Properties['requestedChainsStorageKey']\n    },\n  }))\n}\n","// biome-ignore lint/performance/noBarrelFile: entrypoint module\nexport {\n  type InjectedParameters,\n  injected,\n  type MockParameters,\n  mock,\n} from '@wagmi/core'\nexport { type BaseAccountParameters, baseAccount } from '../baseAccount.js'\nexport {\n  type CoinbaseWalletParameters,\n  coinbaseWallet,\n} from '../coinbaseWallet.js'\nexport { type GeminiParameters, gemini } from '../gemini.js'\nexport { type MetaMaskParameters, metaMask } from '../metaMask.js'\nexport { type PortoParameters, porto } from '../porto.js'\nexport { type SafeParameters, safe } from '../safe.js'\nexport { version } from '../version.js'\nexport {\n  type WalletConnectParameters,\n  walletConnect,\n} from '../walletConnect.js'\n","import { providerErrors, rpcErrors } from \"@metamask/rpc-errors\";\n\nimport { DEFAULT_CHAIN_ID } from \"./constants\";\nimport {\n  AppContext,\n  type AppMetadata,\n  GeminiSdkEvent,\n  type GeminiSdkMessage,\n  type GeminiSdkMessageResponse,\n} from \"./types\";\nimport { closePopup, openPopup, SDK_BACKEND_URL, SDK_VERSION } from \"./utils\";\n\ntype CommunicatorConfigParams = {\n  appMetadata: AppMetadata;\n  onDisconnectCallback?: () => void;\n};\n\n// creates and communicates with a popup window to send and receive messages\nexport class Communicator {\n  private readonly appMetadata: AppMetadata;\n  private readonly url: URL;\n  private popup: Window | null = null;\n  private listeners = new Map<\n    (_: MessageEvent) => void,\n    { reject: (_: Error) => void }\n  >();\n  private onDisconnectCallback?: () => void;\n\n  constructor({ appMetadata, onDisconnectCallback }: CommunicatorConfigParams) {\n    this.url = new URL(SDK_BACKEND_URL);\n    this.appMetadata = appMetadata;\n    this.onDisconnectCallback = onDisconnectCallback;\n  }\n\n  // posts a message to the popup window\n  postMessage = async (message: GeminiSdkMessage) => {\n    const popup = await this.waitForPopupLoaded();\n    popup.postMessage(message, this.url.origin);\n  };\n\n  // posts a request to the popup window and waits for a response\n  postRequestAndWaitForResponse = async <\n    M extends GeminiSdkMessage,\n    R extends GeminiSdkMessageResponse,\n  >(\n    request: GeminiSdkMessage,\n  ): Promise<R> => {\n    const responsePromise = this.onMessage<M, R>(\n      ({ requestId }) => requestId === request.requestId,\n    );\n    this.postMessage(request);\n    return await responsePromise;\n  };\n\n  // listens for messages from the popup window that match a given predicate\n  onMessage = <M extends GeminiSdkMessage, R extends GeminiSdkMessageResponse>(\n    predicate: (_: Partial<M>) => boolean,\n  ): Promise<R> => {\n    return new Promise((resolve, reject) => {\n      const listener = (event: MessageEvent<M>) => {\n        // ensure origin of message\n        if (event.origin !== this.url.origin) return;\n\n        const message = event.data;\n        if (predicate(message)) {\n          resolve(message as unknown as R);\n          window.removeEventListener(\"message\", listener);\n          this.listeners.delete(listener);\n        }\n      };\n\n      window.addEventListener(\"message\", listener);\n      this.listeners.set(listener, { reject });\n    });\n  };\n\n  // closes the popup, rejects all requests and clears event listeners\n  private onRequestCancelled = () => {\n    closePopup(this.popup);\n    this.popup = null;\n\n    this.listeners.forEach(({ reject }, listener) => {\n      reject(providerErrors.userRejectedRequest());\n      window.removeEventListener(\"message\", listener);\n    });\n    this.listeners.clear();\n  };\n\n  // waits for the popup window to fully load and then sends a version message\n  waitForPopupLoaded = (): Promise<Window> => {\n    if (this.popup && !this.popup.closed) {\n      // in case the user un-focused the popup between requests, focus it again\n      this.popup.focus();\n      return Promise.resolve(this.popup);\n    }\n\n    this.popup = openPopup(this.url);\n\n    // setup popup closed listener in case user closes window without explicit response\n    this.onMessage<GeminiSdkMessage, GeminiSdkMessageResponse>(\n      ({ event }) => event === GeminiSdkEvent.POPUP_UNLOADED,\n    )\n      .then(this.onRequestCancelled)\n      .catch(() => {});\n\n    // setup account disconnect listener in case user requests disconnect from within popup\n    this.onMessage<GeminiSdkMessage, GeminiSdkMessageResponse>(\n      ({ event }) => event === GeminiSdkEvent.SDK_DISCONNECT,\n    )\n      .then(() => {\n        // invoke disconnect callback passed in from wallet\n        this.onDisconnectCallback?.();\n        // cleanup remaining event listeners\n        this.onRequestCancelled();\n      })\n      .catch(() => {});\n\n    return this.onMessage<GeminiSdkMessage, GeminiSdkMessageResponse>(\n      ({ event }) => event === GeminiSdkEvent.POPUP_LOADED,\n    )\n      .then((message) => {\n        // report app metadata to backend upon load complete\n        this.postMessage({\n          chainId: DEFAULT_CHAIN_ID,\n          data: {\n            appMetadata: this.appMetadata,\n            origin: window.location.origin,\n            sdkVersion: SDK_VERSION,\n          } as AppContext,\n          event: GeminiSdkEvent.POPUP_APP_CONTEXT,\n          origin: window.location.origin,\n          requestId: message.requestId,\n        });\n      })\n      .then(() => {\n        if (!this.popup) throw rpcErrors.internal();\n        return this.popup;\n      });\n  };\n}\n","//\n// Types\n//\n\n/**\n * Makes every specified property of the specified object type mutable.\n *\n * @template ObjectValue - The object whose readonly properties to make mutable.\n * @template TargetKey - The property key(s) to make mutable.\n */\nexport type Mutable<\n  ObjectValue extends Record<string, unknown>,\n  TargetKey extends keyof ObjectValue,\n> = {\n  -readonly [Key in keyof Pick<ObjectValue, TargetKey>]: ObjectValue[Key];\n} & {\n  [Key in keyof Omit<ObjectValue, TargetKey>]: ObjectValue[Key];\n};\n\n/**\n * Get a type representing the public interface of the given type. The\n * returned type will have all public properties, but will omit private\n * properties.\n *\n * @template Interface - The interface to return a public representation of.\n */\nexport type PublicInterface<Interface> = Pick<Interface, keyof Interface>;\n\n/**\n * Useful for representing some value that _might_ be present and / or complete.\n *\n * @template Value - The value that might be present or complete.\n */\nexport type PartialOrAbsent<Value> = Partial<Value> | null | undefined;\n\n/**\n * Like {@link Array}, but always non-empty.\n *\n * @template Element - The non-empty array member type.\n */\nexport type NonEmptyArray<Element> = [Element, ...Element[]];\n\n/**\n * A JavaScript object that is not `null`, a function, or an array.\n */\nexport type RuntimeObject = Record<PropertyKey, unknown>;\n\n//\n// Type Guards\n//\n\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray<Element>(\n  value: Element[],\n): value is NonEmptyArray<Element> {\n  return Array.isArray(value) && value.length > 0;\n}\n\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nexport function isNullOrUndefined(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nexport function isObject(value: unknown): value is RuntimeObject {\n  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n\n//\n// Other utility functions\n//\n\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nexport const hasProperty = <\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ObjectToCheck extends Object,\n  Property extends PropertyKey,\n>(\n  objectToCheck: ObjectToCheck,\n  name: Property,\n): objectToCheck is ObjectToCheck &\n  Record<\n    Property,\n    Property extends keyof ObjectToCheck ? ObjectToCheck[Property] : unknown\n  > => Object.hasOwnProperty.call(objectToCheck, name);\n\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nexport function getKnownPropertyNames<Key extends PropertyKey>(\n  object: Partial<Record<Key, any>>,\n): Key[] {\n  return Object.getOwnPropertyNames(object) as Key[];\n}\n\nexport type PlainObject = Record<number | string | symbol, unknown>;\n\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nexport enum JsonSize {\n  Null = 4,\n  Comma = 1,\n  Wrapper = 1,\n  True = 4,\n  False = 5,\n  Quote = 1,\n  Colon = 1,\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Date = 24,\n}\n\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexport const ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nexport function isPlainObject(value: unknown): value is PlainObject {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nexport function isASCII(character: string) {\n  return character.charCodeAt(0) <= 127;\n}\n\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nexport function calculateStringSize(value: string): number {\n  const size = value.split('').reduce((total, character) => {\n    if (isASCII(character)) {\n      return total + 1;\n    }\n    return total + 2;\n  }, 0);\n\n  // Also detect characters that need backslash escape\n  return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nexport function calculateNumberSize(value: number): number {\n  return value.toString().length;\n}\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any;\n  key: any;\n  type: string;\n  refinement: string | undefined;\n  message: string;\n  explanation?: string | undefined;\n  branch: any[];\n  path: any[];\n};\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any;\n\n  key!: any;\n\n  type!: string;\n\n  refinement!: string | undefined;\n\n  path!: any[];\n\n  branch!: any[];\n\n  failures: () => Failure[];\n\n  [x: string]: any;\n\n  constructor(failure: Failure, failures: () => Generator<Failure>) {\n    let cached: Failure[] | undefined;\n    const { message, explanation, ...rest } = failure;\n    const { path } = failure;\n    const cause =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n    super(explanation ?? cause);\n\n    if (explanation !== null && explanation !== undefined) {\n      this.cause = cause;\n    }\n\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n    this.failures = () => {\n      return (cached ??= [failure, ...failures()]);\n    };\n  }\n}\n","// src/communicator.ts\nimport { providerErrors, rpcErrors as rpcErrors2 } from \"@metamask/rpc-errors\";\n\n// src/constants.ts\nimport {\n  arbitrum,\n  arbitrumSepolia,\n  base,\n  baseSepolia,\n  mainnet,\n  optimism,\n  optimismSepolia,\n  polygon,\n  polygonAmoy,\n  sepolia\n} from \"viem/chains\";\n\n// package.json\nvar package_default = {\n  name: \"@gemini-wallet/core\",\n  version: \"0.3.1\",\n  description: \"Core SDK for Gemini Wallet integration with popup communication\",\n  main: \"./dist/index.cjs\",\n  types: \"./dist/index.d.ts\",\n  type: \"module\",\n  repository: {\n    type: \"git\",\n    url: \"git+https://github.com/gemini/gemini-wallet-core.git\"\n  },\n  homepage: \"https://keys.gemini.com\",\n  bugs: {\n    url: \"https://github.com/gemini/gemini-wallet-core/issues\"\n  },\n  license: \"MIT\",\n  author: \"Gemini\",\n  files: [\n    \"dist\",\n    \"src\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  exports: {\n    \".\": {\n      types: \"./dist/index.d.ts\",\n      import: \"./dist/index.js\",\n      require: \"./dist/index.cjs\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  scripts: {\n    build: \"dotenv -e .env.production -- tsup\",\n    dev: \"dotenv -e .env.local -- tsup --watch\",\n    typecheck: \"tsc --noEmit\",\n    lint: \"eslint ./src\",\n    \"lint:ci\": \"eslint --max-warnings 0 ./src\",\n    \"lint:fix\": \"eslint ./src --fix\",\n    test: \"bun test\"\n  },\n  dependencies: {\n    \"@metamask/rpc-errors\": \"7.0.2\",\n    eventemitter3: \"5.0.1\"\n  },\n  devDependencies: {\n    \"@eslint/eslintrc\": \"3.3.1\",\n    \"@eslint/js\": \"9.33.0\",\n    \"@next/eslint-plugin-next\": \"15.4.7\",\n    \"@types/node\": \"22.13.0\",\n    \"dotenv-cli\": \"10.0.0\",\n    \"esbuild-plugin-replace\": \"1.4.0\",\n    eslint: \"9.33.0\",\n    \"eslint-config-prettier\": \"10.1.8\",\n    \"eslint-config-turbo\": \"2.5.6\",\n    \"eslint-plugin-import\": \"2.32.0\",\n    \"eslint-plugin-jsx-a11y\": \"6.10.2\",\n    \"eslint-plugin-only-warn\": \"1.1.0\",\n    \"eslint-plugin-prettier\": \"5.5.4\",\n    \"eslint-plugin-react\": \"7.37.5\",\n    \"eslint-plugin-react-hooks\": \"5.2.0\",\n    \"eslint-plugin-simple-import-sort\": \"12.1.1\",\n    \"eslint-plugin-sort-keys-fix\": \"1.1.2\",\n    globals: \"16.3.0\",\n    prettier: \"3.6.2\",\n    tsup: \"8.4.0\",\n    typescript: \"5.5.3\",\n    \"typescript-eslint\": \"8.40.0\",\n    vitest: \"3.2.4\"\n  },\n  peerDependencies: {\n    viem: \">=2.0.0\"\n  },\n  keywords: [\n    \"gemini\",\n    \"wallet\",\n    \"sdk\",\n    \"ethereum\",\n    \"web3\",\n    \"crypto\"\n  ],\n  module: \"./dist/index.js\"\n};\n\n// src/constants.ts\nvar DEFAULT_BACKEND_URL = \"https://keys.gemini.com\";\nvar SDK_BACKEND_URL = typeof process !== \"undefined\" && \"undefined\" || DEFAULT_BACKEND_URL;\nvar ENS_API_URL = \"https://horizon-api.gemini.com/api/ens\";\nvar SDK_VERSION = package_default.version;\nvar DEFAULT_CHAIN_ID = 42161;\nvar MAINNET_CHAIN_IDS = {\n  ARBITRUM_ONE: 42161,\n  BASE: 8453,\n  ETHEREUM: 1,\n  OP_MAINNET: 10,\n  POLYGON: 137\n};\nvar TESTNET_CHAIN_IDS = {\n  ARBITRUM_SEPOLIA: 421614,\n  BASE_SEPOLIA: 84532,\n  OP_SEPOLIA: 11155420,\n  POLYGON_AMOY: 80002,\n  SEPOLIA: 11155111\n};\nvar SUPPORTED_CHAIN_IDS = [\n  ...Object.values(MAINNET_CHAIN_IDS),\n  ...Object.values(TESTNET_CHAIN_IDS)\n];\nfunction getDefaultRpcUrl(chainId) {\n  const chainMap = {\n    [mainnet.id]: mainnet.rpcUrls.default.http[0],\n    [arbitrum.id]: arbitrum.rpcUrls.default.http[0],\n    [optimism.id]: optimism.rpcUrls.default.http[0],\n    [base.id]: base.rpcUrls.default.http[0],\n    [polygon.id]: polygon.rpcUrls.default.http[0],\n    [sepolia.id]: sepolia.rpcUrls.default.http[0],\n    [arbitrumSepolia.id]: arbitrumSepolia.rpcUrls.default.http[0],\n    [optimismSepolia.id]: optimismSepolia.rpcUrls.default.http[0],\n    [baseSepolia.id]: baseSepolia.rpcUrls.default.http[0],\n    [polygonAmoy.id]: polygonAmoy.rpcUrls.default.http[0]\n  };\n  return chainMap[chainId];\n}\nvar POPUP_WIDTH = 420;\nvar POPUP_HEIGHT = 650;\n\n// src/types.ts\nimport { EventEmitter } from \"eventemitter3\";\nvar GeminiSdkEvent = /* @__PURE__ */ ((GeminiSdkEvent2) => {\n  GeminiSdkEvent2[\"POPUP_LOADED\"] = \"POPUP_LOADED\";\n  GeminiSdkEvent2[\"POPUP_UNLOADED\"] = \"POPUP_UNLOADED\";\n  GeminiSdkEvent2[\"POPUP_APP_CONTEXT\"] = \"POPUP_APP_CONTEXT\";\n  GeminiSdkEvent2[\"SDK_CONNECT\"] = \"SDK_CONNECT\";\n  GeminiSdkEvent2[\"SDK_DISCONNECT\"] = \"SDK_DISCONNECT\";\n  GeminiSdkEvent2[\"SDK_SEND_TRANSACTION\"] = \"SDK_SEND_TRANSACTION\";\n  GeminiSdkEvent2[\"SDK_SIGN_DATA\"] = \"SDK_SIGN_DATA\";\n  GeminiSdkEvent2[\"SDK_SIGN_TYPED_DATA\"] = \"SDK_SIGN_TYPED_DATA\";\n  GeminiSdkEvent2[\"SDK_SWITCH_CHAIN\"] = \"SDK_SWITCH_CHAIN\";\n  GeminiSdkEvent2[\"SDK_OPEN_SETTINGS\"] = \"SDK_OPEN_SETTINGS\";\n  GeminiSdkEvent2[\"SDK_CURRENT_ACCOUNT\"] = \"SDK_CURRENT_ACCOUNT\";\n  return GeminiSdkEvent2;\n})(GeminiSdkEvent || {});\nvar PlatformType = {\n  REACT_NATIVE: \"REACT_NATIVE\",\n  WEB: \"WEB\"\n};\nvar ProviderEventEmitter = class extends EventEmitter {\n};\n\n// src/utils/base64.ts\nfunction encodeBase64(array) {\n  let base64;\n  if (typeof Buffer !== \"undefined\") {\n    base64 = Buffer.from(array).toString(\"base64\");\n  } else {\n    base64 = btoa(\n      Array.from(array).map((b) => String.fromCharCode(b)).join(\"\")\n    );\n  }\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeBase64(base64url) {\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n  if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  } else {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\nfunction bufferToBase64URLString(buffer) {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return encodeBase64(bytes);\n}\nfunction utf8StringToBuffer(value) {\n  if (typeof TextEncoder !== \"undefined\") {\n    return new TextEncoder().encode(value);\n  } else if (typeof Buffer !== \"undefined\") {\n    return new Uint8Array(Buffer.from(value, \"utf8\"));\n  } else {\n    const bytes = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i++) {\n      bytes[i] = value.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\nfunction base64ToHex(base64) {\n  const bytes = decodeBase64(base64);\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n// src/utils/calculateWalletAddress.ts\nimport {\n  encodeAbiParameters,\n  encodeFunctionData,\n  encodePacked,\n  getCreate2Address,\n  keccak256\n} from \"viem\";\nvar SHARED_CONTRACT_ADDRESSES = {\n  ATTESTER: \"0x000474392a9cd86a4687354f1Ce2964B52e97484\",\n  BOOTSTRAPPER: \"0x00000000D3254452a909E4eeD47455Af7E27C289\",\n  REGISTRY: \"0x000000000069E2a187AEFFb852bF3cCdC95151B2\"\n};\nvar V2_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x00000000029d9c8b864DD51d6bb0d99FB72D650b\",\n  FACTORY: \"0x000000000452377e1Bd9e72E939855ECb9363Cab\",\n  WEBAUTHN_VALIDATOR: \"0x7ab16Ff354AcB328452F1D445b3Ddee9a91e9e69\"\n};\nvar V1_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x0006050168DE255a8672ACaD4821e721CBA44337\",\n  FACTORY: \"0x00E58DF70FaB983a324c4C068c82d20407579FaC\",\n  WEBAUTHN_VALIDATOR: \"0xbA45a2BFb8De3D24cA9D7F1B551E14dFF5d690Fd\"\n};\nfunction processWalletAddressParams(params, contractAddresses) {\n  const { publicKey, credentialId, index = 0n } = params;\n  if (!publicKey.startsWith(\"0x\") || publicKey.length !== 130) {\n    throw new Error(\n      \"Invalid public key: must be 64-byte hex string (0x + 128 chars)\"\n    );\n  }\n  const pubKeyX = `0x${publicKey.slice(2, 66)}`;\n  const pubKeyY = `0x${publicKey.slice(66, 130)}`;\n  const webAuthnData = {\n    pubKeyX: BigInt(pubKeyX),\n    pubKeyY: BigInt(pubKeyY)\n  };\n  if (!validateWebAuthnKey(webAuthnData)) {\n    throw new Error(\n      \"Invalid WebAuthn key: coordinates are not on secp256r1 curve\"\n    );\n  }\n  const authenticatorIdHash = generateAuthenticatorIdHash(credentialId);\n  return calculateAddressInternal({\n    authenticatorIdHash,\n    contractAddresses,\n    index,\n    webAuthnData\n  });\n}\nfunction calculateWalletAddress(params) {\n  return processWalletAddressParams(params, V2_CONTRACT_ADDRESSES);\n}\nfunction calculateV1Address(params) {\n  return processWalletAddressParams(params, V1_CONTRACT_ADDRESSES);\n}\nfunction generateAuthenticatorIdHash(credentialId) {\n  const padding = \"=\".repeat((4 - credentialId.length % 4) % 4);\n  const base64 = credentialId.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return keccak256(bytes);\n}\nfunction validateWebAuthnKey(webAuthnData) {\n  const SECP256R1_P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn;\n  const SECP256R1_B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn;\n  const { pubKeyX, pubKeyY } = webAuthnData;\n  if (pubKeyX === 0n || pubKeyY === 0n || pubKeyX >= SECP256R1_P || pubKeyY >= SECP256R1_P) {\n    return false;\n  }\n  const ySquared = pubKeyY * pubKeyY % SECP256R1_P;\n  const xCubed = pubKeyX * pubKeyX * pubKeyX % SECP256R1_P;\n  const threeX = 3n * pubKeyX % SECP256R1_P;\n  const rightSide = (xCubed + SECP256R1_P - threeX + SECP256R1_B) % SECP256R1_P;\n  return ySquared === rightSide;\n}\nfunction calculateAddressInternal(params) {\n  const { webAuthnData, authenticatorIdHash, index, contractAddresses } = params;\n  const factoryAddress = contractAddresses.FACTORY;\n  const accountImplementation = contractAddresses.ACCOUNT_IMPLEMENTATION;\n  const webAuthnValidator = contractAddresses.WEBAUTHN_VALIDATOR;\n  const attester = contractAddresses.ATTESTER;\n  const bootstrapper = contractAddresses.BOOTSTRAPPER;\n  const registry = contractAddresses.REGISTRY;\n  const salt = keccak256(\n    encodePacked(\n      [\"uint256\", \"uint256\", \"bytes32\", \"uint256\"],\n      [webAuthnData.pubKeyX, webAuthnData.pubKeyY, authenticatorIdHash, index]\n    )\n  );\n  const validatorInitData = encodeAbiParameters(\n    [\n      {\n        components: [\n          { name: \"pubKeyX\", type: \"uint256\" },\n          { name: \"pubKeyY\", type: \"uint256\" }\n        ],\n        type: \"tuple\"\n      },\n      { type: \"bytes32\" }\n    ],\n    [webAuthnData, authenticatorIdHash]\n  );\n  const registryConfig = {\n    attesters: [attester],\n    registry,\n    threshold: 1n\n  };\n  const bootstrapCall = encodeFunctionData({\n    abi: [\n      {\n        inputs: [\n          { name: \"validator\", type: \"address\" },\n          { name: \"validatorInitData\", type: \"bytes\" },\n          {\n            components: [\n              { name: \"registry\", type: \"address\" },\n              { name: \"attesters\", type: \"address[]\" },\n              { name: \"threshold\", type: \"uint8\" }\n            ],\n            name: \"registryConfig\",\n            type: \"tuple\"\n          }\n        ],\n        name: \"initNexusWithSingleValidator\",\n        type: \"function\"\n      }\n    ],\n    args: [webAuthnValidator, validatorInitData, registryConfig],\n    functionName: \"initNexusWithSingleValidator\"\n  });\n  const initData = encodeAbiParameters(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [bootstrapper, bootstrapCall]\n  );\n  return predictProxyAddress(\n    accountImplementation,\n    salt,\n    initData,\n    factoryAddress\n  );\n}\nfunction predictProxyAddress(implementation, salt, initData, deployer) {\n  const initializeCall = encodeFunctionData({\n    abi: [\n      {\n        inputs: [{ name: \"data\", type: \"bytes\" }],\n        name: \"initializeAccount\",\n        type: \"function\"\n      }\n    ],\n    args: [initData],\n    functionName: \"initializeAccount\"\n  });\n  const constructorArgs = encodeAbiParameters(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [implementation, initializeCall]\n  );\n  const nexusProxyCreationCode = \"0x60806040526102c8803803806100148161018c565b92833981016040828203126101885781516001600160a01b03811692909190838303610188576020810151906001600160401b03821161018857019281601f8501121561018857835161006e610069826101c5565b61018c565b9481865260208601936020838301011161018857815f926020809301865e8601015260017f90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef8293005d823b15610176577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561015e575f8091610146945190845af43d15610156573d91610137610069846101c5565b9283523d5f602085013e6101e0565b505b6040516089908161023f8239f35b6060916101e0565b50505034156101485763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176101b157604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b0381116101b157601f01601f191660200190565b9061020457508051156101f557805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610235575b610215575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561020d56fe608060405236156051577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545f9081906001600160a01b0316368280378136915af43d5f803e15604d573d5ff35b3d5ffd5b00fea264697066735822122041b5f70a351952142223f22504ca7b4e6d975f3a302d114ff820442fcf815ac264736f6c634300081b0033\";\n  const initCodeHash = keccak256(\n    encodePacked([\"bytes\", \"bytes\"], [nexusProxyCreationCode, constructorArgs])\n  );\n  return getCreate2Address({\n    bytecodeHash: initCodeHash,\n    from: deployer,\n    salt\n  });\n}\n\n// src/utils/ens.ts\nasync function reverseResolveEns(address) {\n  try {\n    const response = await fetch(`${ENS_API_URL}/reverse/${address}`);\n    if (!response.ok) {\n      throw new Error(\n        `ENS API request failed: ${response.status} ${response.statusText}`\n      );\n    }\n    const data = await response.json();\n    return {\n      address: data.address,\n      name: data.name || null\n    };\n  } catch (error) {\n    console.error(\"Failed to resolve ENS name:\", error);\n    return {\n      address,\n      name: null\n    };\n  }\n}\n\n// src/utils/popup.ts\nimport { rpcErrors } from \"@metamask/rpc-errors\";\nvar POPUP_WIDTH2 = 420;\nvar POPUP_HEIGHT2 = 650;\nvar openPopup = (url) => {\n  const left = (window.innerWidth - POPUP_WIDTH2) / 2 + window.screenX;\n  const top = (window.innerHeight - POPUP_HEIGHT2) / 2 + window.screenY;\n  const popupId = `wallet_${window?.crypto?.randomUUID()}`;\n  const popup = window.open(\n    url,\n    popupId,\n    `width=${POPUP_WIDTH2}, height=${POPUP_HEIGHT2}, left=${left}, top=${top}`\n  );\n  popup?.focus();\n  if (!popup) {\n    throw rpcErrors.internal(\"Pop up window failed to open\");\n  }\n  return popup;\n};\nvar closePopup = (popup) => {\n  if (popup && !popup.closed) {\n    popup.opener?.focus();\n    popup.close();\n  }\n};\n\n// src/utils/strings.ts\nvar hexStringFromNumber = (num) => {\n  return `0x${BigInt(num).toString(16)}`;\n};\nvar safeJsonStringify = (obj) => JSON.stringify(\n  obj,\n  (_, value) => typeof value === \"bigint\" ? value.toString() + \"n\" : value,\n  2\n);\n\n// src/communicator.ts\nvar Communicator = class {\n  constructor({ appMetadata, onDisconnectCallback }) {\n    this.popup = null;\n    this.listeners = /* @__PURE__ */ new Map();\n    // posts a message to the popup window\n    this.postMessage = async (message) => {\n      const popup = await this.waitForPopupLoaded();\n      popup.postMessage(message, this.url.origin);\n    };\n    // posts a request to the popup window and waits for a response\n    this.postRequestAndWaitForResponse = async (request) => {\n      const responsePromise = this.onMessage(\n        ({ requestId }) => requestId === request.requestId\n      );\n      this.postMessage(request);\n      return await responsePromise;\n    };\n    // listens for messages from the popup window that match a given predicate\n    this.onMessage = (predicate) => {\n      return new Promise((resolve, reject) => {\n        const listener = (event) => {\n          if (event.origin !== this.url.origin) return;\n          const message = event.data;\n          if (predicate(message)) {\n            resolve(message);\n            window.removeEventListener(\"message\", listener);\n            this.listeners.delete(listener);\n          }\n        };\n        window.addEventListener(\"message\", listener);\n        this.listeners.set(listener, { reject });\n      });\n    };\n    // closes the popup, rejects all requests and clears event listeners\n    this.onRequestCancelled = () => {\n      closePopup(this.popup);\n      this.popup = null;\n      this.listeners.forEach(({ reject }, listener) => {\n        reject(providerErrors.userRejectedRequest());\n        window.removeEventListener(\"message\", listener);\n      });\n      this.listeners.clear();\n    };\n    // waits for the popup window to fully load and then sends a version message\n    this.waitForPopupLoaded = () => {\n      if (this.popup && !this.popup.closed) {\n        this.popup.focus();\n        return Promise.resolve(this.popup);\n      }\n      this.popup = openPopup(this.url);\n      this.onMessage(\n        ({ event }) => event === \"POPUP_UNLOADED\" /* POPUP_UNLOADED */\n      ).then(this.onRequestCancelled).catch(() => {\n      });\n      this.onMessage(\n        ({ event }) => event === \"SDK_DISCONNECT\" /* SDK_DISCONNECT */\n      ).then(() => {\n        this.onDisconnectCallback?.();\n        this.onRequestCancelled();\n      }).catch(() => {\n      });\n      return this.onMessage(\n        ({ event }) => event === \"POPUP_LOADED\" /* POPUP_LOADED */\n      ).then((message) => {\n        this.postMessage({\n          chainId: DEFAULT_CHAIN_ID,\n          data: {\n            appMetadata: this.appMetadata,\n            origin: window.location.origin,\n            sdkVersion: SDK_VERSION\n          },\n          event: \"POPUP_APP_CONTEXT\" /* POPUP_APP_CONTEXT */,\n          origin: window.location.origin,\n          requestId: message.requestId\n        });\n      }).then(() => {\n        if (!this.popup) throw rpcErrors2.internal();\n        return this.popup;\n      });\n    };\n    this.url = new URL(SDK_BACKEND_URL);\n    this.appMetadata = appMetadata;\n    this.onDisconnectCallback = onDisconnectCallback;\n  }\n};\n\n// src/provider/provider.ts\nimport {\n  errorCodes,\n  providerErrors as providerErrors2,\n  rpcErrors as rpcErrors4,\n  serializeError\n} from \"@metamask/rpc-errors\";\n\n// src/storage/storage.ts\nvar memoryStorage = {};\nvar GeminiStorage = class {\n  constructor({\n    scope = \"@gemini\",\n    module = \"wallet\"\n  } = {}) {\n    this.scope = scope;\n    this.module = module;\n  }\n  scopedKey(key) {\n    return `${this.scope}.${this.module}.${key}`;\n  }\n  async storeObject(key, item) {\n    const json = safeJsonStringify(item);\n    await this.setItem(key, json);\n  }\n  async loadObject(key, fallback) {\n    const item = await this.getItem(key);\n    if (!item) {\n      await this.storeObject(key, fallback);\n      return fallback;\n    }\n    try {\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Error parsing JSON for key ${key}:`, error);\n      return fallback;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async setItem(key, value) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.setItem(scoped, value);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      memoryStorage[scoped] = value;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async getItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      return localStorage.getItem(scoped);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      return memoryStorage[scoped] || null;\n    }\n  }\n  // eslint-disable-next-line require-await\n  async removeItem(key) {\n    const scoped = this.scopedKey(key);\n    try {\n      localStorage.removeItem(scoped);\n    } catch (e) {\n      console.warn(\"localStorage not available, using memory storage\", e);\n      delete memoryStorage[scoped];\n    }\n  }\n  async removeItems(keys) {\n    await Promise.all(keys.map((key) => this.removeItem(key)));\n  }\n};\n\n// src/storage/storageInterface.ts\nvar STORAGE_ETH_ACCOUNTS_KEY = \"eth-accounts\";\nvar STORAGE_ETH_ACTIVE_CHAIN_KEY = \"eth-active-chain\";\nvar STORAGE_PASSKEY_CREDENTIAL_KEY = \"passkey-credential\";\nvar STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY = \"preserved-passkey-credentials\";\nvar STORAGE_SMART_ACCOUNT_KEY = \"smart-account\";\nvar STORAGE_SETTINGS_KEY = \"settings\";\nvar STORAGE_WC_REQUESTS_KEY = \"wc-requests\";\n\n// src/wallets/wallet.ts\nfunction isChainSupportedByGeminiSw(chainId) {\n  return SUPPORTED_CHAIN_IDS.includes(\n    chainId\n  );\n}\nvar GeminiWallet = class {\n  constructor({\n    appMetadata,\n    chain,\n    onDisconnectCallback,\n    storage\n  }) {\n    this.accounts = [];\n    this.chain = { id: DEFAULT_CHAIN_ID };\n    this.communicator = new Communicator({\n      appMetadata,\n      onDisconnectCallback\n    });\n    this.storage = storage || new GeminiStorage();\n    const fallbackChainId = chain?.id ?? DEFAULT_CHAIN_ID;\n    const fallbackRpcUrl = chain?.rpcUrl ?? getDefaultRpcUrl(fallbackChainId);\n    const defaultChain = {\n      id: fallbackChainId,\n      rpcUrl: fallbackRpcUrl\n    };\n    this.initPromise = this.initializeFromStorage(defaultChain);\n  }\n  async initializeFromStorage(defaultChain) {\n    const fallbackChain = {\n      ...defaultChain,\n      rpcUrl: defaultChain.rpcUrl || getDefaultRpcUrl(defaultChain.id)\n    };\n    const [storedChain, storedAccounts] = await Promise.all([\n      this.storage.loadObject(\n        STORAGE_ETH_ACTIVE_CHAIN_KEY,\n        fallbackChain\n      ),\n      this.storage.loadObject(\n        STORAGE_ETH_ACCOUNTS_KEY,\n        this.accounts\n      )\n    ]);\n    this.chain = {\n      ...storedChain,\n      rpcUrl: storedChain.rpcUrl || getDefaultRpcUrl(storedChain.id)\n    };\n    this.accounts = storedAccounts;\n  }\n  async ensureInitialized() {\n    await this.initPromise;\n  }\n  async connect() {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      event: \"SDK_CONNECT\" /* SDK_CONNECT */,\n      origin: window.location.origin\n    });\n    this.accounts = response.data.address ? [response.data.address] : [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n    return this.accounts;\n  }\n  async disconnect() {\n    await this.ensureInitialized();\n    this.accounts = [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n  }\n  async switchChain({ id }) {\n    await this.ensureInitialized();\n    if (isChainSupportedByGeminiSw(id)) {\n      this.chain = {\n        id,\n        rpcUrl: getDefaultRpcUrl(id)\n      };\n      await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, this.chain);\n      return null;\n    }\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: id,\n      event: \"SDK_SWITCH_CHAIN\" /* SDK_SWITCH_CHAIN */,\n      origin: window.location.origin\n    });\n    return response.data.error ?? \"Unsupported chain.\";\n  }\n  async sendTransaction(txData) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: txData,\n      event: \"SDK_SEND_TRANSACTION\" /* SDK_SEND_TRANSACTION */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signData({\n    message\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: { message },\n      event: \"SDK_SIGN_DATA\" /* SDK_SIGN_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async signTypedData({\n    message,\n    types,\n    primaryType,\n    domain\n  }) {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {\n        domain,\n        message,\n        primaryType,\n        types\n      },\n      event: \"SDK_SIGN_TYPED_DATA\" /* SDK_SIGN_TYPED_DATA */,\n      origin: window.location.origin\n    });\n    return response.data;\n  }\n  async openSettings() {\n    await this.ensureInitialized();\n    await this.sendMessageToPopup({\n      chainId: this.chain.id,\n      data: {},\n      event: \"SDK_OPEN_SETTINGS\" /* SDK_OPEN_SETTINGS */,\n      origin: window.location.origin\n    });\n  }\n  sendMessageToPopup(request) {\n    return this.communicator.postRequestAndWaitForResponse({\n      ...request,\n      requestId: window?.crypto?.randomUUID()\n    });\n  }\n};\n\n// src/provider/provider.utils.ts\nimport { rpcErrors as rpcErrors3 } from \"@metamask/rpc-errors\";\nimport { isHex } from \"viem\";\nvar fetchRpcRequest = async (request, rpcUrl) => {\n  const requestBody = {\n    ...request,\n    id: window?.crypto?.randomUUID(),\n    jsonrpc: \"2.0\"\n  };\n  const res = await window.fetch(rpcUrl, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    mode: \"cors\"\n  });\n  const { result, error } = await res.json();\n  if (error) throw error;\n  return result;\n};\nfunction validateRpcRequestArgs(args) {\n  if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n    throw rpcErrors3.invalidParams({\n      message: \"Expected a single, non-array, object argument.\"\n    });\n  }\n  const { method, params } = args;\n  if (typeof method !== \"string\" || method.length === 0) {\n    throw rpcErrors3.invalidParams({\n      message: \"'args.method' must be a non-empty string.\"\n    });\n  }\n  if (params !== void 0 && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n    throw rpcErrors3.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\"\n    });\n  }\n}\nfunction convertSendValuesToBigInt(tx) {\n  const FIELDS_TO_NORMALIZE = [\"value\", \"gas\", \"gasPrice\", \"maxPriorityFeePerGas\", \"maxFeePerGas\"];\n  const normalized = { ...tx };\n  for (const field of FIELDS_TO_NORMALIZE) {\n    if (!(field in tx)) continue;\n    const value = tx[field];\n    if (typeof value === \"bigint\") continue;\n    if (isHex(value)) {\n      normalized[field] = BigInt(value);\n    }\n  }\n  return normalized;\n}\n\n// src/provider/provider.ts\nvar GeminiWalletProvider = class extends ProviderEventEmitter {\n  constructor(providerConfig) {\n    super();\n    this.wallet = null;\n    this.config = providerConfig;\n    const userDisconnectCallback = providerConfig.onDisconnectCallback;\n    this.wallet = new GeminiWallet({\n      ...providerConfig,\n      onDisconnectCallback: () => {\n        userDisconnectCallback?.();\n        this.disconnect();\n      }\n    });\n  }\n  async request(args) {\n    try {\n      validateRpcRequestArgs(args);\n      if (!this.wallet?.accounts?.length) {\n        switch (args.method) {\n          case \"eth_requestAccounts\": {\n            if (!this.wallet) {\n              const userDisconnectCallback = this.config.onDisconnectCallback;\n              this.wallet = new GeminiWallet({\n                ...this.config,\n                onDisconnectCallback: () => {\n                  userDisconnectCallback?.();\n                  this.disconnect();\n                }\n              });\n            }\n            await this.wallet.connect();\n            this.emit(\"accountsChanged\", this.wallet.accounts);\n            break;\n          }\n          case \"net_version\":\n            return DEFAULT_CHAIN_ID;\n          case \"eth_chainId\":\n            return hexStringFromNumber(DEFAULT_CHAIN_ID);\n          default: {\n            throw providerErrors2.unauthorized();\n          }\n        }\n      }\n      let response;\n      let requestParams;\n      switch (args.method) {\n        case \"eth_requestAccounts\":\n        case \"eth_accounts\":\n          response = this.wallet.accounts;\n          break;\n        case \"net_version\":\n          response = this.wallet.chain.id;\n          break;\n        case \"eth_chainId\":\n          response = hexStringFromNumber(this.wallet.chain.id);\n          break;\n        case \"personal_sign\":\n        case \"wallet_sign\":\n          requestParams = args.params;\n          response = await this.wallet.signData({\n            account: requestParams[1],\n            message: requestParams[0]\n          });\n          if (response.error) {\n            throw rpcErrors4.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"eth_sendTransaction\":\n        case \"wallet_sendTransaction\":\n          requestParams = args.params;\n          requestParams = convertSendValuesToBigInt(requestParams[0]);\n          response = await this.wallet.sendTransaction(requestParams);\n          if (response.error) {\n            throw rpcErrors4.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"wallet_switchEthereumChain\": {\n          const rawParams = args.params;\n          let chainId;\n          if (Array.isArray(rawParams) && rawParams[0]?.chainId) {\n            chainId = parseInt(rawParams[0].chainId, 16);\n          } else if (rawParams && typeof rawParams === \"object\" && \"id\" in rawParams && Number.isInteger(rawParams.id)) {\n            chainId = rawParams.id;\n          } else {\n            throw rpcErrors4.invalidParams(\n              \"Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.\"\n            );\n          }\n          response = await this.wallet.switchChain({ id: chainId });\n          if (response) {\n            throw providerErrors2.custom({ code: 4902, message: response });\n          }\n          await this.emit(\"chainChanged\", hexStringFromNumber(chainId));\n          break;\n        }\n        case \"eth_signTypedData_v1\":\n        case \"eth_signTypedData_v2\":\n        case \"eth_signTypedData_v3\":\n        case \"eth_signTypedData_v4\":\n        case \"eth_signTypedData\": {\n          requestParams = args.params;\n          const signedTypedDataParams = JSON.parse(\n            requestParams[1]\n          );\n          response = await this.wallet.signTypedData({\n            account: requestParams[0],\n            domain: signedTypedDataParams.domain,\n            message: signedTypedDataParams.message,\n            primaryType: signedTypedDataParams.primaryType,\n            types: signedTypedDataParams.types\n          });\n          if (response.error) {\n            throw rpcErrors4.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        }\n        // TODO: not yet implemented or unclear if we support\n        case \"eth_ecRecover\":\n        case \"eth_subscribe\":\n        case \"eth_unsubscribe\":\n        case \"personal_ecRecover\":\n        case \"eth_signTransaction\":\n        case \"wallet_watchAsset\":\n        case \"wallet_sendCalls\":\n        case \"wallet_getCallsStatus\":\n        case \"wallet_getCapabilities\":\n        case \"wallet_showCallsStatus\":\n        case \"wallet_grantPermissions\":\n          throw rpcErrors4.methodNotSupported(\"Not yet implemented.\");\n        // not supported\n        case \"eth_sign\":\n        case \"eth_coinbase\":\n        case \"wallet_addEthereumChain\":\n          throw rpcErrors4.methodNotSupported();\n        // call rpc directly for everything else\n        default:\n          if (!this.wallet.chain.rpcUrl)\n            throw rpcErrors4.internal(\n              `RPC URL missing for current chain (${this.wallet.chain.id})`\n            );\n          return fetchRpcRequest(args, this.wallet.chain.rpcUrl);\n      }\n      return response;\n    } catch (error) {\n      const { code } = error;\n      if (code === errorCodes.provider.unauthorized) this.disconnect();\n      return Promise.reject(serializeError(error));\n    }\n  }\n  // custom wallet function to open settings page\n  async openSettings() {\n    await this.wallet?.openSettings();\n  }\n  async disconnect() {\n    if (this.wallet) {\n      const storage = this.config.storage || new GeminiStorage();\n      await storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);\n      await storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);\n    }\n    this.wallet = null;\n    this.config.onDisconnectCallback?.();\n    await this.emit(\"disconnect\", \"User initiated disconnection\");\n    await this.emit(\"accountsChanged\", []);\n  }\n};\nexport {\n  Communicator,\n  DEFAULT_CHAIN_ID,\n  GeminiSdkEvent,\n  GeminiStorage,\n  GeminiWallet,\n  GeminiWalletProvider,\n  POPUP_HEIGHT,\n  POPUP_WIDTH,\n  PlatformType,\n  ProviderEventEmitter,\n  SDK_BACKEND_URL,\n  SDK_VERSION,\n  STORAGE_ETH_ACCOUNTS_KEY,\n  STORAGE_ETH_ACTIVE_CHAIN_KEY,\n  STORAGE_PASSKEY_CREDENTIAL_KEY,\n  STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY,\n  STORAGE_SETTINGS_KEY,\n  STORAGE_SMART_ACCOUNT_KEY,\n  STORAGE_WC_REQUESTS_KEY,\n  base64ToHex,\n  bufferToBase64URLString,\n  calculateV1Address,\n  calculateWalletAddress,\n  closePopup,\n  convertSendValuesToBigInt,\n  decodeBase64,\n  encodeBase64,\n  fetchRpcRequest,\n  generateAuthenticatorIdHash,\n  hexStringFromNumber,\n  isChainSupportedByGeminiSw,\n  openPopup,\n  reverseResolveEns,\n  safeJsonStringify,\n  utf8StringToBuffer,\n  validateRpcRequestArgs,\n  validateWebAuthnKey\n};\n//# sourceMappingURL=index.js.map","'use strict';\n\n/** @template [T=undefined] */\nexport class ErrorWithCause extends Error {\n  /**\n   * @param {string} message\n   * @param {{ cause?: T }} options\n   */\n  constructor (message, { cause } = {}) {\n    super(message);\n\n    /** @type {string} */\n    this.name = ErrorWithCause.name;\n    if (cause) {\n      /** @type {T} */\n      this.cause = cause;\n    }\n    /** @type {string} */\n    this.message = message;\n  }\n}\n","import type { Failure } from './error.js';\nimport type {\n  Struct,\n  Infer,\n  Result,\n  Context,\n  Describe,\n  ExactOptionalStruct,\n} from './struct.js';\n\n/**\n * Check if a value is an iterator.\n *\n * @param value - The value to check.\n * @returns Whether the value is an iterator.\n */\nfunction isIterable<Type>(value: unknown): value is Iterable<Type> {\n  return isObject(value) && typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isObject(\n  value: unknown,\n): value is Record<PropertyKey, unknown> {\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isPlainObject(value: unknown): value is { [key: string]: any } {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Return a value as a printable string.\n *\n * @param value - The value to print.\n * @returns The value as a string.\n */\nexport function print(value: any): string {\n  if (typeof value === 'symbol') {\n    return value.toString();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n\n/**\n * Shift (remove and return) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n *\n * @param input - The iterator to shift.\n * @returns The first value of the iterator, or `undefined` if the iterator is\n * empty.\n */\nexport function shiftIterator<Type>(input: Iterator<Type>): Type | undefined {\n  const { done, value } = input.next();\n  return done ? undefined : value;\n}\n\n/**\n * Convert a single validation result to a failure.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @returns A failure if the result is a failure, or `undefined` if the result\n * is a success.\n */\nexport function toFailure<Type, Schema>(\n  result: string | boolean | Partial<Failure>,\n  context: Context,\n  struct: Struct<Type, Schema>,\n  value: any,\n): Failure | undefined {\n  if (result === true) {\n    return undefined;\n  } else if (result === false) {\n    // eslint-disable-next-line no-param-reassign\n    result = {};\n  } else if (typeof result === 'string') {\n    // eslint-disable-next-line no-param-reassign\n    result = { message: result };\n  }\n\n  const { path, branch } = context;\n  const { type } = struct;\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${\n      refinement ? ` with refinement \\`${refinement}\\`` : ''\n    }, but received: \\`${print(value)}\\``,\n  } = result;\n\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message,\n  };\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @yields The failures.\n * @returns An iterable of failures.\n */\nexport function* toFailures<Type, Schema>(\n  result: Result,\n  context: Context,\n  struct: Struct<Type, Schema>,\n  value: any,\n): IterableIterator<Failure> {\n  if (!isIterable(result)) {\n    // eslint-disable-next-line no-param-reassign\n    result = [result];\n  }\n\n  for (const validationResult of result) {\n    const failure = toFailure(validationResult, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n *\n * @param value - The value to check.\n * @param struct - The struct to check against.\n * @param options - Optional settings.\n * @param options.path - The path to the value in the input data.\n * @param options.branch - The branch of the value in the input data.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @yields An iterator of failures or success.\n * @returns An iterator of failures or success.\n */\nexport function* run<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  options: {\n    path?: any[] | undefined;\n    branch?: any[] | undefined;\n    coerce?: boolean | undefined;\n    mask?: boolean | undefined;\n    message?: string | undefined;\n  } = {},\n): IterableIterator<[Failure, undefined] | [undefined, Type]> {\n  const { path = [], branch = [value], coerce = false, mask = false } = options;\n  const context: Context = { path, branch };\n\n  if (coerce) {\n    // eslint-disable-next-line no-param-reassign\n    value = struct.coercer(value, context);\n\n    if (\n      mask &&\n      struct.type !== 'type' &&\n      isObject(struct.schema) &&\n      isObject(value) &&\n      !Array.isArray(value)\n    ) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n\n  let status: 'valid' | 'not_refined' | 'not_valid' = 'valid';\n\n  for (const failure of struct.validator(value, context)) {\n    failure.explanation = options.message;\n    status = 'not_valid';\n    yield [failure, undefined];\n  }\n\n  // eslint-disable-next-line prefer-const\n  for (let [innerKey, innerValue, innerStruct] of struct.entries(\n    value,\n    context,\n  )) {\n    const iterable = run(innerValue, innerStruct as Struct, {\n      path: innerKey === undefined ? path : [...path, innerKey],\n      branch: innerKey === undefined ? branch : [...branch, innerValue],\n      coerce,\n      mask,\n      message: options.message,\n    });\n\n    for (const result of iterable) {\n      if (result[0]) {\n        status =\n          result[0].refinement === null || result[0].refinement === undefined\n            ? 'not_valid'\n            : 'not_refined';\n\n        yield [result[0], undefined];\n      } else if (coerce) {\n        innerValue = result[1];\n\n        if (innerKey === undefined) {\n          // eslint-disable-next-line no-param-reassign\n          value = innerValue;\n        } else if (value instanceof Map) {\n          value.set(innerKey, innerValue);\n        } else if (value instanceof Set) {\n          value.add(innerValue);\n        } else if (isObject(value)) {\n          if (innerValue !== undefined || innerKey in value) {\n            value[innerKey] = innerValue;\n          }\n        }\n      }\n    }\n  }\n\n  if (status !== 'not_valid') {\n    for (const failure of struct.refiner(value as Type, context)) {\n      failure.explanation = options.message;\n      status = 'not_refined';\n      yield [failure, undefined];\n    }\n  }\n\n  if (status === 'valid') {\n    yield [undefined, value as Type];\n  }\n}\n\n/**\n * Convert a union of type to an intersection.\n */\nexport type UnionToIntersection<Union> = (\n  Union extends any ? (arg: Union) => any : never\n) extends (arg: infer Type) => void\n  ? Type\n  : never;\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\nexport type Assign<Type, OtherType> = Simplify<\n  OtherType & Omit<Type, keyof OtherType>\n>;\n\n/**\n * A schema for enum structs.\n */\nexport type EnumSchema<Type extends string | number | undefined | null> = {\n  [Key in NonNullable<Type>]: Key;\n};\n\n/**\n * Check if a type is a match for another whilst treating overlapping\n * unions as a match.\n */\nexport type IsMatch<Type, OtherType> = Type extends OtherType\n  ? OtherType extends Type\n    ? Type\n    : never\n  : never;\n\n/**\n * Check if a type is an exact match.\n */\nexport type IsExactMatch<Type, OtherType> = (<Inner>() => Inner extends Type\n  ? 1\n  : 2) extends <Inner>() => Inner extends OtherType ? 1 : 2\n  ? Type\n  : never;\n\n/**\n * Check if a type is a record type.\n */\nexport type IsRecord<Type> = Type extends object\n  ? string extends keyof Type\n    ? Type\n    : never\n  : never;\n\n/**\n * Check if a type is a tuple.\n */\nexport type IsTuple<Type> = Type extends [any]\n  ? Type\n  : Type extends [any, any]\n  ? Type\n  : Type extends [any, any, any]\n  ? Type\n  : Type extends [any, any, any, any]\n  ? Type\n  : Type extends [any, any, any, any, any]\n  ? Type\n  : never;\n\n/**\n * Check if a type is a union.\n */\nexport type IsUnion<Type, Union extends Type = Type> = (\n  Type extends any ? (Union extends Type ? false : true) : false\n) extends false\n  ? never\n  : Type;\n\n/**\n * A schema for object structs.\n */\nexport type ObjectSchema = Record<string, Struct<any, any>>;\n\n/**\n * Infer a type from an object struct schema.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  // ExactOptionalize first ensures that properties of `exactOptional()` structs\n  // are optional, then Optionalize ensures that properties that can have the\n  // value `undefined` are optional.\n  Optionalize<ExactOptionalize<Schema>>\n>;\n\n/**\n * Make properties of `exactOptional()` structs optional.\n */\nexport type ExactOptionalize<Schema extends ObjectSchema> = {\n  [K in keyof OmitExactOptional<Schema>]: Infer<OmitExactOptional<Schema>[K]>;\n} & {\n  [K in keyof PickExactOptional<Schema>]?: Infer<PickExactOptional<Schema>[K]>;\n};\n\ntype OmitExactOptional<Schema extends ObjectSchema> = Omit<\n  Schema,\n  {\n    [K in keyof Schema]: Schema[K] extends ExactOptionalStruct<any, any>\n      ? Schema[K] extends never\n        ? never\n        : K\n      : never;\n  }[keyof Schema]\n>;\n\ntype PickExactOptional<Schema extends ObjectSchema> = Pick<\n  Schema,\n  {\n    [K in keyof Schema]: Schema[K] extends ExactOptionalStruct<any, any>\n      ? Schema[K] extends never\n        ? never\n        : K\n      : never;\n  }[keyof Schema]\n>;\n\n/**\n * Make properties that can have the value `undefined` optional.\n */\nexport type Optionalize<Schema extends object> = OmitBy<Schema, undefined> &\n  Partial<PickBy<Schema, undefined>>;\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\nexport type OmitBy<Type, Value> = Omit<\n  Type,\n  {\n    [Key in keyof Type]: Value extends Extract<Type[Key], Value> ? Key : never;\n  }[keyof Type]\n>;\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\nexport type PickBy<Type, Value> = Pick<\n  Type,\n  {\n    [Key in keyof Type]: Value extends Extract<Type[Key], Value> ? Key : never;\n  }[keyof Type]\n>;\n\n/**\n * Transform an object schema type to represent a partial.\n */\nexport type PartialObjectSchema<Schema extends ObjectSchema> = {\n  [K in keyof Schema]: Struct<Infer<Schema[K]> | undefined>;\n};\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\nexport type Simplify<Type> = Type extends any[] | Date\n  ? Type\n  : // eslint-disable-next-line @typescript-eslint/ban-types\n    { [Key in keyof Type]: Type[Key] } & {};\n\nexport type If<Condition extends boolean, Then, Else> = Condition extends true\n  ? Then\n  : Else;\n\n/**\n * A schema for any type of struct.\n */\nexport type StructSchema<Type> = [Type] extends [string | undefined | null]\n  ? [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer Inner)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<Inner>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : { [K in keyof Type]: Describe<Type[K]> }\n  : null;\n\n/**\n * A schema for tuple structs.\n */\nexport type TupleSchema<Type> = { [K in keyof Type]: Struct<Type[K]> };\n\n/**\n * Shorthand type for matching any `Struct`.\n */\nexport type AnyStruct = Struct<any, any>;\n\n/**\n * Infer a tuple of types from a tuple of `Struct`s.\n *\n * This is used to recursively retrieve the type from `union` `intersection` and\n * `tuple` structs.\n */\nexport type InferStructTuple<\n  Tuple extends AnyStruct[],\n  Length extends number = Tuple['length'],\n> = Length extends Length\n  ? number extends Length\n    ? Tuple\n    : InferTuple<Tuple, Length, []>\n  : never;\n\ntype InferTuple<\n  Tuple extends AnyStruct[],\n  Length extends number,\n  Accumulated extends unknown[],\n  Index extends number = Accumulated['length'],\n> = Index extends Length\n  ? Accumulated\n  : InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>;\n","import {\n  arbitrum,\n  arbitrumSepolia,\n  base,\n  baseSepolia,\n  mainnet,\n  optimism,\n  optimismSepolia,\n  polygon,\n  polygonAmoy,\n  sepolia,\n} from \"viem/chains\";\n\nimport packageJson from \"../package.json\";\n\nconst DEFAULT_BACKEND_URL = \"https://keys.gemini.com\";\n\nexport const SDK_BACKEND_URL =\n  (typeof process !== \"undefined\" && \"undefined\") ||\n  DEFAULT_BACKEND_URL;\nexport const ENS_API_URL = \"https://horizon-api.gemini.com/api/ens\";\nexport const SDK_VERSION = packageJson.version;\nexport const DEFAULT_CHAIN_ID = 42161; // Arbitrum One\n\n// Mainnet chain IDs\nexport const MAINNET_CHAIN_IDS = {\n  ARBITRUM_ONE: 42161,\n  BASE: 8453,\n  ETHEREUM: 1,\n  OP_MAINNET: 10,\n  POLYGON: 137,\n} as const;\n\n// Testnet chain IDs\nexport const TESTNET_CHAIN_IDS = {\n  ARBITRUM_SEPOLIA: 421614,\n  BASE_SEPOLIA: 84532,\n  OP_SEPOLIA: 11155420,\n  POLYGON_AMOY: 80002,\n  SEPOLIA: 11155111,\n} as const;\n\n// All supported chain IDs\nexport const SUPPORTED_CHAIN_IDS = [\n  ...Object.values(MAINNET_CHAIN_IDS),\n  ...Object.values(TESTNET_CHAIN_IDS),\n];\n\n// Helper function to get default RPC URL for a chain using viem chains\nexport function getDefaultRpcUrl(chainId: number): string | undefined {\n  const chainMap: Record<number, string> = {\n    [mainnet.id]: mainnet.rpcUrls.default.http[0],\n    [arbitrum.id]: arbitrum.rpcUrls.default.http[0],\n    [optimism.id]: optimism.rpcUrls.default.http[0],\n    [base.id]: base.rpcUrls.default.http[0],\n    [polygon.id]: polygon.rpcUrls.default.http[0],\n    [sepolia.id]: sepolia.rpcUrls.default.http[0],\n    [arbitrumSepolia.id]: arbitrumSepolia.rpcUrls.default.http[0],\n    [optimismSepolia.id]: optimismSepolia.rpcUrls.default.http[0],\n    [baseSepolia.id]: baseSepolia.rpcUrls.default.http[0],\n    [polygonAmoy.id]: polygonAmoy.rpcUrls.default.http[0],\n  };\n\n  return chainMap[chainId];\n}\n\n// Popup window dimensions\nexport const POPUP_WIDTH = 420;\nexport const POPUP_HEIGHT = 650;\n","import type {\n  Json,\n  JsonRpcError as SerializedJsonRpcError,\n} from '@metamask/utils';\nimport { hasProperty, isPlainObject } from '@metamask/utils';\nimport safeStringify from 'fast-safe-stringify';\n\nimport type { OptionalDataWithOptionalCause } from './utils';\nimport { dataHasCause, serializeCause } from './utils';\n\nexport type { SerializedJsonRpcError };\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors\n * per EIP-1474.\n *\n * Permits any integer error code.\n */\nexport class JsonRpcError<\n  Data extends OptionalDataWithOptionalCause,\n> extends Error {\n  // The `cause` definition can be removed when tsconfig lib and/or target have changed to >=es2022\n  public cause?: unknown;\n\n  public code: number;\n\n  public data?: Data;\n\n  constructor(code: number, message: string, data?: Data) {\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n\n    if (!message || typeof message !== 'string') {\n      throw new Error('\"message\" must be a non-empty string.');\n    }\n\n    if (dataHasCause(data)) {\n      // @ts-expect-error - Error class does accept options argument depending on runtime, but types are mapping to oldest supported\n      super(message, { cause: data.cause });\n\n      // Browser backwards-compatibility fallback\n      if (!hasProperty(this, 'cause')) {\n        Object.assign(this, { cause: data.cause });\n      }\n    } else {\n      super(message);\n    }\n\n    if (data !== undefined) {\n      this.data = data;\n    }\n\n    this.code = code;\n  }\n\n  /**\n   * Get the error as JSON-serializable object.\n   *\n   * @returns A plain object with all public class properties.\n   */\n  serialize(): SerializedJsonRpcError {\n    const serialized: SerializedJsonRpcError = {\n      code: this.code,\n      message: this.message,\n    };\n\n    if (this.data !== undefined) {\n      // `this.data` is not guaranteed to be a plain object, but this simplifies\n      // the type guard below. We can safely cast it because we know it's a\n      // JSON-serializable value.\n      serialized.data = this.data as { [key: string]: Json };\n\n      if (isPlainObject(this.data)) {\n        serialized.data.cause = serializeCause(this.data.cause);\n      }\n    }\n\n    if (this.stack) {\n      serialized.stack = this.stack;\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Get a string representation of the serialized error, omitting any circular\n   * references.\n   *\n   * @returns A string representation of the serialized error.\n   */\n  toString(): string {\n    return safeStringify(this.serialize(), stringifyReplacer, 2);\n  }\n}\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * Permits integer error codes in the [ 1000 <= 4999 ] range.\n */\nexport class EthereumProviderError<\n  Data extends OptionalDataWithOptionalCause,\n> extends JsonRpcError<Data> {\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   *\n   * @param code - The JSON-RPC error code. Must be an integer in the\n   * `1000 <= n <= 4999` range.\n   * @param message - The JSON-RPC error message.\n   * @param data - Optional data to include in the error.\n   */\n  constructor(code: number, message: string, data?: Data) {\n    if (!isValidEthProviderCode(code)) {\n      throw new Error(\n        '\"code\" must be an integer such that: 1000 <= code <= 4999',\n      );\n    }\n\n    super(code, message, data);\n  }\n}\n\n/**\n * Check if the given code is a valid JSON-RPC error code.\n *\n * @param code - The code to check.\n * @returns Whether the code is valid.\n */\nfunction isValidEthProviderCode(code: number): boolean {\n  return Number.isInteger(code) && code >= 1000 && code <= 4999;\n}\n\n/**\n * A JSON replacer function that omits circular references.\n *\n * @param _ - The key being replaced.\n * @param value - The value being replaced.\n * @returns The value to use in place of the original value.\n */\nfunction stringifyReplacer(_: unknown, value: unknown): unknown {\n  if (value === '[Circular]') {\n    return undefined;\n  }\n\n  return value;\n}\n","'use strict';\n\n/**\n * @template {Error} T\n * @param {unknown} err\n * @param {new(...args: any[]) => T} reference\n * @returns {T|undefined}\n */\nexport const findCauseByReference = (err, reference) => {\n  if (!err || !reference) return;\n  if (!(err instanceof Error)) return;\n  if (\n    !(reference.prototype instanceof Error) &&\n    // @ts-ignore\n    reference !== Error\n  ) return;\n\n  /**\n   * Ensures we don't go circular\n   *\n   * @type {Set<Error>}\n   */\n  const seen = new Set();\n\n  /** @type {Error|undefined} */\n  let currentErr = err;\n\n  while (currentErr && !seen.has(currentErr)) {\n    seen.add(currentErr);\n\n    if (currentErr instanceof reference) {\n      return currentErr;\n    }\n\n    currentErr = getErrorCause(currentErr);\n  }\n};\n\n/**\n * @param {Error|{ cause?: unknown|(()=>err)}} err\n * @returns {Error|undefined}\n */\nexport const getErrorCause = (err) => {\n  if (!err || typeof err !== 'object' || !('cause' in err)) {\n    return;\n  }\n\n  // VError / NError style causes\n  if (typeof err.cause === 'function') {\n    const causeResult = err.cause();\n\n    return causeResult instanceof Error\n      ? causeResult\n      : undefined;\n  } else {\n    return err.cause instanceof Error\n      ? err.cause\n      : undefined;\n  }\n};\n\n/**\n * Internal method that keeps a track of which error we have already added, to avoid circular recursion\n *\n * @private\n * @param {Error} err\n * @param {Set<Error>} seen\n * @returns {string}\n */\nconst _stackWithCauses = (err, seen) => {\n  if (!(err instanceof Error)) return '';\n\n  const stack = err.stack || '';\n\n  // Ensure we don't go circular or crazily deep\n  if (seen.has(err)) {\n    return stack + '\\ncauses have become circular...';\n  }\n\n  const cause = getErrorCause(err);\n\n  // TODO: Follow up in https://github.com/nodejs/node/issues/38725#issuecomment-920309092 on how to log stuff\n\n  if (cause) {\n    seen.add(err);\n    return (stack + '\\ncaused by: ' + _stackWithCauses(cause, seen));\n  } else {\n    return stack;\n  }\n};\n\n/**\n * @param {Error} err\n * @returns {string}\n */\nexport const stackWithCauses = (err) => _stackWithCauses(err, new Set());\n\n/**\n * Internal method that keeps a track of which error we have already added, to avoid circular recursion\n *\n * @private\n * @param {Error} err\n * @param {Set<Error>} seen\n * @param {boolean} [skip]\n * @returns {string}\n */\nconst _messageWithCauses = (err, seen, skip) => {\n  if (!(err instanceof Error)) return '';\n\n  const message = skip ? '' : (err.message || '');\n\n  // Ensure we don't go circular or crazily deep\n  if (seen.has(err)) {\n    return message + ': ...';\n  }\n\n  const cause = getErrorCause(err);\n\n  if (cause) {\n    seen.add(err);\n\n    const skipIfVErrorStyleCause = 'cause' in err && typeof err.cause === 'function';\n\n    return (message +\n      (skipIfVErrorStyleCause ? '' : ': ') +\n      _messageWithCauses(cause, seen, skipIfVErrorStyleCause));\n  } else {\n    return message;\n  }\n};\n\n/**\n * @param {Error} err\n * @returns {string}\n */\nexport const messageWithCauses = (err) => _messageWithCauses(err, new Set());\n","import { EventEmitter } from \"eventemitter3\";\nimport type {\n  Address,\n  Hex,\n  SignMessageParameters,\n  SignTypedDataParameters,\n  TransactionRequest,\n} from \"viem\";\n\nimport { type IStorage } from \"./storage/storageInterface\";\n\nexport enum GeminiSdkEvent {\n  // Popup events\n  POPUP_LOADED = \"POPUP_LOADED\",\n  POPUP_UNLOADED = \"POPUP_UNLOADED\",\n  POPUP_APP_CONTEXT = \"POPUP_APP_CONTEXT\",\n\n  // SDK events\n  SDK_CONNECT = \"SDK_CONNECT\",\n  SDK_DISCONNECT = \"SDK_DISCONNECT\",\n  SDK_SEND_TRANSACTION = \"SDK_SEND_TRANSACTION\",\n  SDK_SIGN_DATA = \"SDK_SIGN_DATA\",\n  SDK_SIGN_TYPED_DATA = \"SDK_SIGN_TYPED_DATA\",\n  SDK_SWITCH_CHAIN = \"SDK_SWITCH_CHAIN\",\n  SDK_OPEN_SETTINGS = \"SDK_OPEN_SETTINGS\",\n  SDK_CURRENT_ACCOUNT = \"SDK_CURRENT_ACCOUNT\",\n}\n\nexport interface AppMetadata {\n  appName?: string;\n  appLogoUrl?: string;\n  name?: string;\n  description?: string;\n  url?: string;\n  icons?: string[];\n}\n\nexport interface AppContext {\n  appMetadata: AppMetadata;\n  origin: string;\n  sdkVersion: string;\n}\n\nexport interface Chain {\n  id: number;\n  rpcUrl?: string;\n}\n\n// Using const object with 'as const' assertion instead of enum\n// This avoids TypeScript's isolatedModules re-export limitations\nexport const PlatformType = {\n  REACT_NATIVE: \"REACT_NATIVE\",\n  WEB: \"WEB\",\n} as const;\n\n// Extract type from const object for type safety\nexport type PlatformType = (typeof PlatformType)[keyof typeof PlatformType];\n\nexport type GeminiProviderConfig = {\n  appMetadata: AppMetadata;\n  chain: Chain;\n  platform?: PlatformType;\n  onDisconnectCallback?: () => void;\n  storage?: IStorage;\n};\n\nexport interface RpcRequestArgs {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object | Hex[];\n}\n\nexport interface ProviderRpcError extends Error {\n  code: number;\n  data?: unknown;\n  message: string;\n}\n\nexport type ProviderEventMap = {\n  accountsChanged: string[];\n  chainChanged: string; // hex string\n  connect: {\n    readonly chainId: string;\n  };\n  disconnect: ProviderRpcError;\n};\n\nexport type ProviderEventCallback = ProviderInterface[\"emit\"];\n\nexport class ProviderEventEmitter extends EventEmitter<\n  keyof ProviderEventMap\n> {}\n\nexport interface ProviderInterface extends ProviderEventEmitter {\n  disconnect(): Promise<void>;\n  emit<K extends keyof ProviderEventMap>(\n    event: K,\n    ...args: [ProviderEventMap[K]]\n  ): boolean;\n  on<K extends keyof ProviderEventMap>(\n    event: K,\n    listener: (_: ProviderEventMap[K]) => void,\n  ): this;\n  request(args: RpcRequestArgs): Promise<any>;\n}\n\nexport interface GeminiSdkMessage {\n  chainId: number;\n  data?: unknown;\n  event: GeminiSdkEvent;\n  origin: string;\n  requestId?: string;\n  wcData?: any;\n}\n\nexport interface GeminiSdkMessageResponse {\n  data?: unknown;\n  event: GeminiSdkEvent;\n  requestId?: string;\n}\n\nexport interface ConnectResponse\n  extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { address: Address };\n}\n\nexport interface SendTransactionResponse\n  extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { hash?: Hex; error?: string };\n}\n\nexport interface SignMessageResponse\n  extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { hash?: Hex; error?: string };\n}\n\nexport interface SignTypedDataResponse\n  extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { hash?: Hex; error?: string };\n}\n\nexport interface SwitchChainResponse\n  extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { chainId?: number; error?: string };\n}\n\nexport interface GeminiSdkSendTransaction\n  extends Omit<GeminiSdkMessage, \"data\"> {\n  data: TransactionRequest;\n}\n\nexport interface GeminiSdkSignMessage extends Omit<GeminiSdkMessage, \"data\"> {\n  data: SignMessageParameters;\n}\n\nexport interface GeminiSdkSignTypedData extends Omit<GeminiSdkMessage, \"data\"> {\n  data: SignTypedDataParameters;\n}\n\nexport interface GeminiSdkSwitchChain extends Omit<GeminiSdkMessage, \"data\"> {\n  data: number;\n}\n\nexport interface GeminiSdkAppContextMessage\n  extends Omit<GeminiSdkMessage, \"data\"> {\n  data: AppContext;\n}\n\nexport interface ReverseEnsResponse {\n  address: Address;\n  name: string | null;\n}\n","/**\n * Utility functions for base64 encoding and decoding\n * Compatible with both browser and Node.js environments\n */\n\n/**\n * Encodes a Uint8Array to a base64url string\n * @param array - The Uint8Array to encode\n * @returns The base64url encoded string\n */\nexport function encodeBase64(array: Uint8Array): string {\n  let base64: string;\n\n  // Check if we're in a Node.js environment (Buffer is available)\n  if (typeof Buffer !== \"undefined\") {\n    // Node.js environment\n    base64 = Buffer.from(array).toString(\"base64\");\n  } else {\n    // Browser environment\n    base64 = btoa(\n      Array.from(array)\n        .map((b) => String.fromCharCode(b))\n        .join(\"\"),\n    );\n  }\n\n  // Convert to base64url format by replacing characters\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\n\n/**\n * Decodes a base64url string to a Uint8Array\n * @param base64url - The base64url encoded string\n * @returns The decoded Uint8Array\n */\nexport function decodeBase64(base64url: string): Uint8Array {\n  // Convert base64url to standard base64 by restoring special chars\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n  // Add padding if needed\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n\n  // Check if we're in a Node.js environment (Buffer is available)\n  if (typeof Buffer !== \"undefined\") {\n    // Node.js environment\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  } else {\n    // Browser environment\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\n\n/**\n * Convert an ArrayBuffer or Uint8Array to a base64url string\n * @param buffer - The buffer to convert\n * @returns The base64url encoded string\n */\nexport function bufferToBase64URLString(\n  buffer: ArrayBuffer | Uint8Array,\n): string {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return encodeBase64(bytes);\n}\n\n/**\n * Convert a string to UTF-8 encoded Uint8Array\n * @param value - The string to convert\n * @returns The UTF-8 encoded Uint8Array\n */\nexport function utf8StringToBuffer(value: string): Uint8Array {\n  if (typeof TextEncoder !== \"undefined\") {\n    // Modern browsers and Node.js with TextEncoder support\n    return new TextEncoder().encode(value);\n  } else if (typeof Buffer !== \"undefined\") {\n    // Node.js fallback\n    return new Uint8Array(Buffer.from(value, \"utf8\"));\n  } else {\n    // Very old browsers fallback (not recommended)\n    const bytes = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i++) {\n      bytes[i] = value.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\n\n/**\n * Convert a base64 string to hex string\n * @param base64 - The base64 string to convert\n * @returns The hex string\n */\nexport function base64ToHex(base64: string): string {\n  const bytes = decodeBase64(base64);\n  return Array.from(bytes)\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n","import {\n  type Address,\n  encodeAbiParameters,\n  encodeFunctionData,\n  encodePacked,\n  getCreate2Address,\n  type Hex,\n  keccak256,\n} from \"viem\";\n\n// WebAuthn validator data structure\nexport interface WebAuthnValidatorData {\n  pubKeyX: bigint;\n  pubKeyY: bigint;\n}\n\n// Parameters for calculating wallet address\nexport interface CalculateWalletAddressParams {\n  publicKey: Hex; // Combined 64-byte hex string (32 bytes X + 32 bytes Y)\n  credentialId: string; // Base64URL encoded credential ID\n  index?: bigint; // Optional, defaults to 0\n}\n\n// Shared contract addresses across versions\nconst SHARED_CONTRACT_ADDRESSES = {\n  ATTESTER: \"0x000474392a9cd86a4687354f1Ce2964B52e97484\" as const,\n  BOOTSTRAPPER: \"0x00000000D3254452a909E4eeD47455Af7E27C289\" as const,\n  REGISTRY: \"0x000000000069E2a187AEFFb852bF3cCdC95151B2\" as const,\n};\n\n// V2 contract addresses (current Horizon deployment)\nconst V2_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x00000000029d9c8b864DD51d6bb0d99FB72D650b\" as const,\n  FACTORY: \"0x000000000452377e1Bd9e72E939855ECb9363Cab\" as const,\n  WEBAUTHN_VALIDATOR: \"0x7ab16Ff354AcB328452F1D445b3Ddee9a91e9e69\" as const,\n};\n\n// V1 contract addresses\nconst V1_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x0006050168DE255a8672ACaD4821e721CBA44337\" as const,\n  FACTORY: \"0x00E58DF70FaB983a324c4C068c82d20407579FaC\" as const,\n  WEBAUTHN_VALIDATOR: \"0xbA45a2BFb8De3D24cA9D7F1B551E14dFF5d690Fd\" as const,\n};\n\n/**\n * Internal helper to process and validate wallet address calculation parameters\n */\nfunction processWalletAddressParams(\n  params: CalculateWalletAddressParams,\n  contractAddresses:\n    | typeof V1_CONTRACT_ADDRESSES\n    | typeof V2_CONTRACT_ADDRESSES,\n): Address {\n  const { publicKey, credentialId, index = 0n } = params;\n\n  // Validate input\n  if (!publicKey.startsWith(\"0x\") || publicKey.length !== 130) {\n    throw new Error(\n      \"Invalid public key: must be 64-byte hex string (0x + 128 chars)\",\n    );\n  }\n\n  // Extract X and Y coordinates\n  const pubKeyX = `0x${publicKey.slice(2, 66)}` as Hex;\n  const pubKeyY = `0x${publicKey.slice(66, 130)}` as Hex;\n\n  // Convert to WebAuthnValidatorData\n  const webAuthnData: WebAuthnValidatorData = {\n    pubKeyX: BigInt(pubKeyX),\n    pubKeyY: BigInt(pubKeyY),\n  };\n\n  // Validate the key is on the secp256r1 curve\n  if (!validateWebAuthnKey(webAuthnData)) {\n    throw new Error(\n      \"Invalid WebAuthn key: coordinates are not on secp256r1 curve\",\n    );\n  }\n\n  // Calculate authenticator ID hash from credential ID\n  const authenticatorIdHash = generateAuthenticatorIdHash(credentialId);\n\n  // Use the internal calculation with provided addresses\n  return calculateAddressInternal({\n    authenticatorIdHash,\n    contractAddresses,\n    index,\n    webAuthnData,\n  });\n}\n\n/**\n * Calculate smart wallet address from public key and credential ID (V2)\n * This handles all validation and setup internally\n */\nexport function calculateWalletAddress(\n  params: CalculateWalletAddressParams,\n): Address {\n  return processWalletAddressParams(params, V2_CONTRACT_ADDRESSES);\n}\n\n/**\n * Calculate smart wallet address from public key and credential ID (V1)\n * This handles all validation and setup internally\n */\nexport function calculateV1Address(\n  params: CalculateWalletAddressParams,\n): Address {\n  return processWalletAddressParams(params, V1_CONTRACT_ADDRESSES);\n}\n\n/**\n * Generate authenticator ID hash from credential ID\n */\nexport function generateAuthenticatorIdHash(credentialId: string): Hex {\n  // Convert base64url to bytes\n  const padding = \"=\".repeat((4 - (credentialId.length % 4)) % 4);\n  const base64 = credentialId.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  return keccak256(bytes);\n}\n\n/**\n * Validate WebAuthn public key offchain\n * Mirrors the contract's _validateWebAuthnKey function\n */\nexport function validateWebAuthnKey(\n  webAuthnData: WebAuthnValidatorData,\n): boolean {\n  const SECP256R1_P =\n    0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn;\n  const SECP256R1_B =\n    0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn;\n\n  const { pubKeyX, pubKeyY } = webAuthnData;\n\n  // Check if coordinates are valid\n  if (\n    pubKeyX === 0n ||\n    pubKeyY === 0n ||\n    pubKeyX >= SECP256R1_P ||\n    pubKeyY >= SECP256R1_P\n  ) {\n    return false;\n  }\n\n  // Validate curve membership: YÂ² â‰¡ XÂ³ - 3X + B (mod P)\n  const ySquared = (pubKeyY * pubKeyY) % SECP256R1_P;\n  const xCubed = (pubKeyX * pubKeyX * pubKeyX) % SECP256R1_P;\n  const threeX = (3n * pubKeyX) % SECP256R1_P;\n  const rightSide = (xCubed + SECP256R1_P - threeX + SECP256R1_B) % SECP256R1_P;\n\n  return ySquared === rightSide;\n}\n\n/**\n * Internal calculation method using provided contract addresses\n */\nfunction calculateAddressInternal(params: {\n  webAuthnData: WebAuthnValidatorData;\n  authenticatorIdHash: Hex;\n  index: bigint;\n  contractAddresses:\n    | typeof V1_CONTRACT_ADDRESSES\n    | typeof V2_CONTRACT_ADDRESSES;\n}): Address {\n  const { webAuthnData, authenticatorIdHash, index, contractAddresses } =\n    params;\n\n  // Use provided contract addresses\n  const factoryAddress = contractAddresses.FACTORY;\n  const accountImplementation = contractAddresses.ACCOUNT_IMPLEMENTATION;\n  const webAuthnValidator = contractAddresses.WEBAUTHN_VALIDATOR;\n  const attester = contractAddresses.ATTESTER;\n  const bootstrapper = contractAddresses.BOOTSTRAPPER;\n  const registry = contractAddresses.REGISTRY;\n\n  // Generate cross-chain consistent salt (same as contract)\n  const salt = keccak256(\n    encodePacked(\n      [\"uint256\", \"uint256\", \"bytes32\", \"uint256\"],\n      [webAuthnData.pubKeyX, webAuthnData.pubKeyY, authenticatorIdHash, index],\n    ),\n  );\n\n  // Prepare validator initialization data (WebAuthnValidatorData + authenticatorIdHash)\n  const validatorInitData = encodeAbiParameters(\n    [\n      {\n        components: [\n          { name: \"pubKeyX\", type: \"uint256\" },\n          { name: \"pubKeyY\", type: \"uint256\" },\n        ],\n        type: \"tuple\",\n      },\n      { type: \"bytes32\" },\n    ],\n    [webAuthnData, authenticatorIdHash],\n  );\n\n  // Create RegistryConfig struct\n  const registryConfig = {\n    attesters: [attester],\n    registry,\n    threshold: 1n,\n  };\n\n  // Encode the bootstrap call\n  const bootstrapCall = encodeFunctionData({\n    abi: [\n      {\n        inputs: [\n          { name: \"validator\", type: \"address\" },\n          { name: \"validatorInitData\", type: \"bytes\" },\n          {\n            components: [\n              { name: \"registry\", type: \"address\" },\n              { name: \"attesters\", type: \"address[]\" },\n              { name: \"threshold\", type: \"uint8\" },\n            ],\n            name: \"registryConfig\",\n            type: \"tuple\",\n          },\n        ],\n        name: \"initNexusWithSingleValidator\",\n        type: \"function\",\n      },\n    ],\n    args: [webAuthnValidator, validatorInitData, registryConfig],\n    functionName: \"initNexusWithSingleValidator\",\n  });\n\n  // Format initialization data as expected by ProxyLib\n  const initData = encodeAbiParameters(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [bootstrapper, bootstrapCall],\n  );\n\n  // Calculate CREATE2 address using the same logic as ProxyLib.predictProxyAddress\n  return predictProxyAddress(\n    accountImplementation,\n    salt,\n    initData,\n    factoryAddress,\n  );\n}\n\n/**\n * Predicts the proxy address using CREATE2\n * Mirrors ProxyLib.predictProxyAddress functionality exactly\n */\nfunction predictProxyAddress(\n  implementation: Address,\n  salt: Hex,\n  initData: Hex,\n  deployer: Address,\n): Address {\n  // Encode the call to INexus.initializeAccount with initData\n  const initializeCall = encodeFunctionData({\n    abi: [\n      {\n        inputs: [{ name: \"data\", type: \"bytes\" }],\n        name: \"initializeAccount\",\n        type: \"function\",\n      },\n    ],\n    args: [initData],\n    functionName: \"initializeAccount\",\n  });\n\n  // Encode constructor arguments for NexusProxy\n  const constructorArgs = encodeAbiParameters(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [implementation, initializeCall],\n  );\n\n  // Calculate initCodeHash using actual compiled NexusProxy creation bytecode\n  const nexusProxyCreationCode =\n    \"0x60806040526102c8803803806100148161018c565b92833981016040828203126101885781516001600160a01b03811692909190838303610188576020810151906001600160401b03821161018857019281601f8501121561018857835161006e610069826101c5565b61018c565b9481865260208601936020838301011161018857815f926020809301865e8601015260017f90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef8293005d823b15610176577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561015e575f8091610146945190845af43d15610156573d91610137610069846101c5565b9283523d5f602085013e6101e0565b505b6040516089908161023f8239f35b6060916101e0565b50505034156101485763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176101b157604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b0381116101b157601f01601f191660200190565b9061020457508051156101f557805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610235575b610215575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561020d56fe608060405236156051577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545f9081906001600160a01b0316368280378136915af43d5f803e15604d573d5ff35b3d5ffd5b00fea264697066735822122041b5f70a351952142223f22504ca7b4e6d975f3a302d114ff820442fcf815ac264736f6c634300081b0033\" as const;\n\n  const initCodeHash = keccak256(\n    encodePacked([\"bytes\", \"bytes\"], [nexusProxyCreationCode, constructorArgs]),\n  );\n\n  // Standard CREATE2 formula\n  return getCreate2Address({\n    bytecodeHash: initCodeHash,\n    from: deployer,\n    salt,\n  });\n}\n","import type { Address } from \"viem\";\n\nimport { ENS_API_URL } from \"@/constants\";\nimport type { ReverseEnsResponse } from \"@/types\";\n\nexport async function reverseResolveEns(\n  address: Address,\n): Promise<ReverseEnsResponse> {\n  try {\n    const response = await fetch(`${ENS_API_URL}/reverse/${address}`);\n\n    if (!response.ok) {\n      throw new Error(\n        `ENS API request failed: ${response.status} ${response.statusText}`,\n      );\n    }\n\n    const data: ReverseEnsResponse = await response.json();\n\n    return {\n      address: data.address,\n      name: data.name || null,\n    };\n  } catch (error) {\n    console.error(\"Failed to resolve ENS name:\", error);\n    return {\n      address,\n      name: null,\n    };\n  }\n}\n","import { rpcErrors } from \"@metamask/rpc-errors\";\n\nconst POPUP_WIDTH = 420;\nconst POPUP_HEIGHT = 650;\n\nexport const openPopup = (url: URL): Window => {\n  const left = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;\n  const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;\n\n  const popupId = `wallet_${window?.crypto?.randomUUID()}`;\n  const popup = window.open(\n    url,\n    popupId,\n    `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left}, top=${top}`,\n  );\n\n  popup?.focus();\n\n  if (!popup) {\n    throw rpcErrors.internal(\"Pop up window failed to open\");\n  }\n\n  return popup;\n};\n\nexport const closePopup = (popup: Window | null) => {\n  if (popup && !popup.closed) {\n    popup.opener?.focus();\n    popup.close();\n  }\n};\n"],"names":[],"mappings":"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GFmB,CHIb,AQGE,ALPgC,AIApB,ACMpB,CCP0C,AIAA,CbM1C,AQGA,CCT4C,AHQtC,CQHe,AZEZ,EgBHM,AHKA,ACNA,AGAA,AFKA,AfAf,CYFD,CKFC,AJMA,CEDD,AjBHQ,AgBFR,AECA,CZGS,CNDR,AMCa,CUFe,ALGhB,ATSA,AcZgB,ChBC1B,AcDG,ATEQ,ACAK,CcHd,ApBwBiB,CArBrB,AgBJK,ACKA,ACJA,AdFiB,ADDA,AGOhB,AMRkD,CAAA,AJQ1C,AaTS,AhBQA,CQNC,AXMb,ASP8C,AKKrB,AZHZ,AgBGzB,AdGqB,CECrB,AHF0B,AG+BF,CN9BvB,ACNwB,AYwES,ATlEP,CYeD,ATrBA,AMwEQ,CbtDV,AkBrBuC,ARSnD,CGCG,AfFP,AmBJO,CPMd,AIHgC,AdehC,CFbA,AeEA,AINA,AHEgC,CPP8B,ALCI,AeyEvB,CLpEzB,AKoEyB,CLpEzB,ARGgB,CULhB,ACKA,ACJA,CAAA,ADIA,ADLA,GhBKV,EEAO,AFCf,AMDyC,CAAC,CcF+B,AlBGzE,CkBHyE,CXJ9B,CHMG,CAAA,ANCxC,EACN,AQDuB,AFD0B,CAAA,ESE5B,AINA,EbMhB,CSCN,AINA,AnBKO,CEWoB,AIXV,GNAN,AEDM,AAajB,EaXM,AINA,AjBKL,IAYK,CIZqB,CAAA,KJAf,AUAa,CNAW,CJEnC,AaDkB,AINA,CAAA,AJMA,AHAnB,CZD4B,AMAqB,ENChD,GYAK,INCwB,CJUH,AeoCwB,AjB/C1C,CEWkB,AUXf,AK+C+C,APtD7B,COsD6B,AjB9C1D,AYDW,GIkC8C,EIjCO,AJiCL,CIjCK,ApBA1D,CoBA0D,CpBChE,CMDyC,CAAC,AJAlB,EIAwB,CJIjD,CIJmD,ANC5C,CMDyC,AAAI,CNEnD,CMFqD,CAAC,CJIjD,EFFA,EACL,EECW,AIJ6C,CJI7C,AIJkD,CAAE,CAAC,CAAA,CNGzD,AMHsD,ENI7D,MAAM,CMHyB,CNI/B,MAAM,AMJyB,ENKhC,UMHS,KACU,GAAA,CAAA,CAAA,OAAO,CAAA,CAAO,CNEH,EMFQ,GAAO,CoBAC,AEZC,ItBYK,UMC1C,CAAG,uEG0D4C,CAAA,CAAE,+BAkBnD,EAAA,eAAA,EAAsC,GAAA,CAAA,wCAGpC,4CACQ,Ea9EjB,AdgCiB,CJpCG,AQ2BJ,AKGR,CAAA,2BRsDmB,IAAI,CAAC,WAAA,MACd,WAEA,IAAA,CAAK,EH/DE,CgBPO,MAAA,CAAA,IbsEK,CAAC,IAAI,OACtB,COlCW,SAAA,qBPuCH,CAAC,WACoB,IAAI,CAAC,IAAI,CAAC,CAAA,AD7CC,2CCkD5C,CAAA,QAAA,CAAS,CAAA,eAAA,CAAA,kBAAkB,CAAA,CAAkB,CAAG,CAAA,CAAE,uCAG/C,IAAA,CAAA,CADE,CAAC,UACc,GACrB,EAAE,CAAA,cAAA,iBAIO,CHhEjB,AMUA,CHsD4B,CVyBjB,EHxCA,GaeuB,IAAA,CAAK,CbfnB,EclBE,AdkBA,Qae4B,EAAE,CAAA,KAAA,CAAA,IAAa,GAAE,CAAC,CAAA,UAIrE,EACK,GAAU,SRzCN,EAAA,cQ0CsB,EAAI,CClCP,AFXW,AGwDN,CFXa,CdnEhC,CAAC,ScmE0C,EAAE,CAAC,CACzC,CClCP,CMMU,ANNT,KflCsB,OekCtB,CAAA,EDmCQ,MAAA,EAAU,cAAA,CAAe,OACtB,CClCG,aDkCH,GAEX,EAAA,WAAA,GACP,EAAsB,MAAA,EAAA,WAAqB,CAAC,IbjBY,Ae6BN,MFX7B,CN/Ca,AP8BF,CAAC,CAAA,QAAA,CAAA,MAAA,CakB/B,CWlEe,MXkEP,CWlEe,CXkEJ,CEYF,UFZa,CAAA,MAAO,MC/BA,CAAC,KDkCzB,IAAI,CAAC,GF3Ea,EJ0BwB,CAChE,CAAC,II3BuC,OE6ER,MAAA,EAAA,OAAiB,EAAA,CAAE,CAAa,AAC9B,CAD8B,EGlDL,AHmDtB,CGnDuB,AHmDtB,AAAC,CH7DsB,AMUD,AHmDpB,CH7DsB,CG6DpB,AH7DoB,CG6DlB,EAAC,EAAA,UAAA,AAAU,EAAC,CAAC,CAAC,CAAC,AP5Bc,CO4Bd,AP3B7D,CAAC,MO+BwB,MAAA,IAAU,CAAC,CD9CiD,SC8CvC,CC/Be,CD+Bb,CAAW,AACxD,CADwD,EACxD,GAAe,IAAmB,EAAS,CAAC,MAC5B,GD5C4C,CAAC,CAAA,CC4CvC,IAAI,CAAC,WAAY,CAAC,SAAE,CD3CE,AC2CK,CAAE,EAAE,GAAJ,CEgBS,CFhBA,CAAE,AAAD,KAAM,EAAE,EAAE,IACnD,GAAA,EAAA,wBAA6B,CAAA,IAAK,CAAA,MAAQ,QACjD,CAAE,GAAA,CAAkB,CAAE,AblBM,CAAA,AakBN,IAEd,GAAO,IAAA,eAIf,GDhDsD,CAAC,CAAA,CC+ClD,Md/DgE,EcgErE,CAAe,cAAe,UAC1B,CbnBG,MauBP,CEgBK,AJrFI,CIqFJ,ARrDpB,EMqCmB,CAAA,iBAAA,oBAEF,mBblBP,GAAA,EAAA,IAAA,CAAA,cAAA,CauBF,sDAOS,CAAC,ED5CkB,AEaxB,mBDgC6B,UACzB,GAEP,MACe,IAAA,CAAK,iBAAiB,CAAA,IAAK,CAAC,IAAI,CAAC,CAAA,2BAGhD,MACY,IAAA,CAAK,cAAA,CAAA,IAAmB,CAAC,GEiBC,CFjBG,CAAC,CAAA,wBAG1C,WACe,YAAY,CAAC,IAAA,CAAA,IAAS,CAAC,CAAA,EAChC,EAAE,CAAA,aAAe,GIeG,WJVlB,EAAA,EAAA,GAAA,CAAA,AACO,GAAa,OAAD,KAAY,IChCM,CAAC,QDgCO,CAAA,CAAE,CAAA,CAAE,CAAC,CAAC,mBAIzD,EAAA,IACO,EACJ,CADmB,AEoBZ,ChBzDT,AWvBI,CAAA,CAAA,GG6DO,EAAA,wBAAA,CAAyB,IAAA,CAAA,MACpC,IAAA,EAAA,wBAA4B,CAAC,CbhBC,OaiB5B,CbhBF,AU9CO,AXwBJ,GAAA,GcsCQ,CJJO,CAAA,2BIIoB,CAAC,IAAI,CAAA,MAC3C,CIkBG,GAAA,EAAA,2BAAA,CJlB6B,mBAItC,CfqBS,kBepBI,MAAA,IAAU,CAAC,WAAW,EAAE,sBAIf,eAAgB,mBAI/B,cAAc,CAAC,aAAc,CJDG,SIE5B,GAEV,WACY,SAAA,CAAA,IAAc,CAAA,IAAA,qBAI/B,MAAM,CfsBG,CetBC,SAAS,EACrB,QACM,kBACE,EAAA,MAAA,IAAqB,CAAC,CbbT,UaaoB,UACrB,MAAA,EAAA,OAAsB,CAAC,8BAGrB,GAAA,CAAA,EAAA,EAAA,UAAA,AAAiB,EAAC,8BAGrB,EbXF,CwBvBS,GAAA,IAAA,CAAA,WXkCe,UAIhC,OAHD,AAGQ,EAHR,UAAA,IAEH,MAAM,GAAA,QAAA,CAAoB,CbZD,AGgDM,CYnBT,KFjBY,aAAa,GAEpD,CAAC,CNhBG,MMiBE,qCAII,EAAA,MAAA,CAAA,aACE,CNVK,QMUM,CAAG,AEmBJ,CFnBM,CAAG,MAAA,EAAA,CAAA,CAAA,cACzB,AAAmB,UAAU,EAAzB,OAAO,GAA6C,UAAU,EAAjC,OAAO,CEmBH,CFnBO,CAAD,MAAQ,CAC1C,EAAI,OAAA,CACN,CRSS,CQRlB,CAAC,KAEoC,CAAA,MAChC,IAAA,KAAe,CG/CG,AX2DE,CAAA,MQZQ,CAAA,CACjB,CAAA,CAAA,Cbdc,Cacd,EAAA,WAAY,AAAZ,EAAa,EW/BE,AX+BG,EAAG,CAAH,AAAI,CAAC,CAAA,GAAkB,sBAElC,CCnCK,AEbA,CFaC,QDmCI,IAC3B,CAAC,EAAA,OAEG,EAAY,CJyCO,CH9CC,AG8CA,2DItCP,CW/BG,ARlBC,uBHoD4B,CV0C5B,+BUvCvB,GAAG,EAAW,GbbC,GiBgCO,MJnBI,QAET,CIiBoB,WJjBpB,EAAc,ECnCE,GAAA,EDoClB,YAAY,CEiBS,CAAA,KAAA,YFf/B,CImBG,CAAA,YAAA,EAAA,IJlBJ,EAAA,YAAuB,CgBpOe,ChBoOb,GAAG,CAAA,gCAKrB,EImBI,AJnBO,CbXH,UaWc,GAAI,IAAI,IAEvC,EAAS,CCnCH,KAAA,EDmCa,IAAI,EImBA,AJnBE,CAAA,AImBF,AJfvB,EWrCwC,AVFhB,ADwC5B,ACnCC,CAAA,EAAA,eDmCkC,CAAP,CAAO,CW/BrB,aX+BqB,CACnC,EAAW,WAAW,EAAE,AJoEE,IIlExB,CAAC,EAAA,MAAA,IAAoB,GAAA,qBAAA,QAClB,CACT,CAAC,OAEI,IACE,AAAL,EE+CyD,CAAA,CAAA,EFhD5C,AAC2B,GAAA,IAC7B,MAAM,EIsBE,CJpBd,4BAcL,MAAO,CAAA,CAAE,CAPQ,MAAA,CAAA,EAAM,GAAA,SAAA,EACrB,GAAG,AIuB6B,CAAA,CAAA,EJvB1B,GAAA,WAAA,AAAW,EAAC,GAAG,CAAG,CAAD,GAAK,CAAC,WAAW,EAAE,CAAE,CAAE,OAAO,IAAA,CAAE,CAAC,CACxD,OACS,IACP,CJsES,KIvEQ,KACL,CAAC,EbXJ,EacK,CEiDD,KAAA,AFhDnB,CAAC,AAAC,KAAM,CAAC,OACA,EAEX,CAAC,CACD,KAAK,CAAC,YAAY,CCjCH,0BDiCK,CAAA,CAA2B,SAAO,CAAE,CCjCH,CDkCnD,AClCoD,CAAA,GDkC9C,EAAW,MAAA,IAAU,CAAC,UIuB0B,CJvBf,CIuBiB,CAAA,AJvBf,CAAA,AAEnC,EAAA,EAAA,MAAqB,CAAC,IAAI,CAAC,GAAO,CAAC,CAAC,EAAA,GAAA,GAC1C,GAAA,CAAK,EAAA,MAAA,IAAiB,EAAA,gBAAgB,CAAC,IAAI,EJyEJ,uBAAA,6BItEd,4CAEb,aAAY,EbXC,CAAA,UAAA,AaWU,EAAC,IAAW,wBAWtC,CACT,CAAC,AAAC,MAAO,EAAK,CAAC,AAGb,GAAA,AAFM,EAEI,IAAI,EImBoB,CnB6FX,AmB7FW,AJnBf,EAAA,wBAAwB,CAAC,IAAI,CAC9C,MAAA,IAAU,EAAA,wBAAwB,CAH9B,MAOW,OAPX,EAOE,IAAI,EAGT,AAVG,CIyBW,AnBuGQ,EerHnB,EAD6D,AfyHxB,IexH/B,OiBnRmB,QjBmRJ,IAAI,GAAK,IAAI,CAEtC,CADA,CAAC,CACG,CAAC,AJgGQ,AI7DX,CJ6DY,AMhDJ,CNgDK,KI/Fb,CJgGW,CAAC,IIhGN,CEiDO,CFjDE,OAAO,CAAC,QACb,0BACR,GEiDS,IFjDD,CACN,CACE,KE+CiB,CAAA,YF/CjB,AAAoB,GAAG,EAAE,IACjB,CAAE,QAAS,CAAa,CAAE,GAAG,EAAgB,CACjD,EAAM,CEgDgC,CAAC,CFhDlC,MAD0C,KAC3B,EAAI,CAAA,CAAE,CAAA,OACxB,GJ+Fe,AI/FY,iBAAiB,CACvC,CAAP,CAAiC,iBAAiB,CAAA,EAE3C,CEgDe,AF/CpB,CJ+FmB,CIlGW,AAGhB,GAAG,IACd,Cf0IuB,CAAC,CAAC,Ae5I9B,IAEY,MAAM,CAAC,EJiGc,CIjGE,GAAG,CAAC,AAAC,CAAC,EAAE,AAAG,CAAC,AAAF,CAAG,GAAG,CAAC,CACnD,CAAA,MAEL,aiB5Q+C,GjB6QtC,CImBK,CAAA,WAAA,AJnBM,EAAC,CImBK,EJlB1B,EImBI,QAAA,GJnBkC,SAAS,EAAI,EAAM,GAAD,CAAK,CAC7D,SAAU,GAA2B,QAAQ,CAC7C,EEkDc,aFjDZ,GAA2B,cAAc,EACzC,CEkDa,CAAA,AFlDP,CiB/PqB,ajB+PP,CACtB,QACE,AAAI,CADG,CAAC,CACuB,EADpB,CIkBO,CJlBL,GACyB,EAAE,MAAM,Cf2IpB,Ce1IxB,CAAiC,Cf0IT,GWtCuB,GIpGP,CAAA,AACnC,CAAC,CJmG+C,CAAC,AInG1C,MIkBc,CJlBP,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,EAAI,EAAE,CAAC,CAAA,CAGlD,GAGH,CEiDS,AAFM,CAAC,CAAA,GF/CV,IACN,IImBQ,CAAA,CJnBF,CEiDO,CFjDmB,GAEzB,EACP,EAHuC,CAAC,AAE5B,CAF4B,AAE5B,EACZ,EAAY,CAAC,AIkBY,CAAA,EnBgIJ,AehJjB,EAAM,CE+CS,GF/CL,GAAK,EfmJY,AiBlGJ,CjBkGK,CAAC,EiBlGN,oBFjDgB,CAAC,IAAI,CAC9C,MAAM,IAAI,EAAA,wBAAwB,CAAC,Af+IhB,Ee9IrB,GAD0C,CAAC,CAAA,EACrC,CEiDmC,GFjD/B,EAAA,gBAAgB,CAAC,Af8IN,Ke9IW,CAAC,CAAA,EAI/B,CJuGK,GIvGD,EJuGM,AAAI,EAAF,EAAE,YIvGM,CAAC,AAzDrB,EA0DR,CAAC,AAED,eAAA,IAGE,MAAA,CAAA,EAAA,GAAA,SAAA,EAAA,cAEU,EAAQ,CAAA,EAAH,AAAG,CEwDF,CFxDE,WAAA,EAEX,CfoJN,KepJY,EAAS,MAAD,CAAQ,CAAC,CAAE,OAAQ,aAAa,CAAE,CAAC,CAAQ,CAC3D,CAAA,CfqJkB,CenJf,IAAU,EIiBM,KJjBC,CIiBD,AJhBZ,AAAI,KAAK,CAAA,wDAGnB,CACE,MAAO,EAAE,CACT,EIeQ,CFyCK,QFxDD,EAAE,EAAE,AAGtB,CAAC,AfsJI,CmBzIe,cJXL,EAA0B,CAAe,EACtD,EIegB,IJfV,IAAI,QAAc,IACtB,IAAA,EAAkB,AAAC,IACb,AADiB,IEuDP,QFtDG,GAAQ,EEsDQ,AFtDH,CEsDO,CFtDR,AEsDM,KFtDE,GAAK,IACxC,EAAO,GAD0C,CEsDO,AFtDN,AAC5C,CEqDmD,CAAA,AEpCxC,CJjBH,CAAC,GAAG,CAAC,SAAU,GAC7B,IAEJ,CAAC,AAHwC,CAGW,AACpD,AAJ0C,CAC/B,AAEyC,AAHV,CAInC,CAHM,AImBD,CJnBC,KAGC,CAAC,EAAE,CAAA,SAAW,KACrB,GAD6B,CAAC,CAAA,EACvB,CAAC,GfsJa,CAAA,CetJR,SAAU,SAAE,cAIhC,kBAAkB,CAAQ,EAE9B,EJyGI,CAAA,AIzGe,GAAQ,CJyGvB,AIzGwB,EAAf,MAAM,KAEb,EIeE,iBJfmB,EAAE,CIeC,YAAA,IJfK,CAAC,YAAY,CIgB1B,OJXjB,GAAI,EAAO,IEwDN,CAAC,EAAA,CFxDa,CEwDV,YFxDuB,CAAC,WAAY,CAAC,MACjC,CAAC,MAAM,IAAI,CAAC,UAAU,EAAA,CAAE,CAAC,AAAC,QAAQ,EAAE,CAAA,AACpD,CJ2GK,GI3GD,CAAC,SAAS,CAAC,SAAE,CIiBG,AJjBI,CAAE,CAAC,CAAA,EIiBK,GJbhC,EAAO,IAAD,GAAQ,CAAC,IAAI,CAAC,QAAQ,CAAA,CAC1B,SAAU,EAAA,GAAA,CAAA,GAAA,CAAA,EAAoB,EAAA,UAAA,AAAU,EAAC,CAAC,CAAC,CAAC,EAElD,CAAC,CACD,eAAe,CAAA,EACb,IAAM,EIkBI,IAAA,GJlBa,GACvB,EAAO,OAAO,CAAC,IAAI,CAAA,SAAW,CIkBD,WJjB/B,CAAC,OACK,UAAA,CAAqB,EACzB,IAAM,EAAW,EJ8GD,II9GO,GE2DH,CAAA,CAAA,WF3DmB,EAAE,CACzC,AIiBwC,AJlBC,GJ+GvB,AI9GlB,IAAA,EAAa,CJ8GK,KAAA,CI9GS,IJ+GjB,GI/GuB,IAE3B,EAAA,OAAiB,EAAY,OAAO,CAAC,CAAA,AAC3C,CfyKK,CezKE,OAAO,CAAC,IAAA,CAAK,IE4DF,CAAA,KF5Da,UAAE,OIkBK,CJlBG,EAAE,CAAO,CAAE,AIkBF,CJlBG,AIkBF,CJhBnD,AIgBmD,AJlBE,GAAH,CAE5C,EAAA,MAAiB,GIiBC,CAAA,CJjBI,WAAW,EAAE,CAAA,AACrC,MACO,GADE,CAAC,AIkBG,UJjBQ,CAAC,SAAS,CAAE,KACzB,QAEP,CAFgB,CAAA,IAGD,IAAI,CAAC,MADH,CAAC,UACmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,EAC1C,EAAE,CAAC,kBAAmB,IAE7B,MACa,IAAA,CAAK,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAC7C,AAD6C,EACpC,EAAE,CAAC,cAAc,CAAE,IAEzB,IACH,CE0DC,CF1DY,AE0DX,CerQS,AfqQT,CF7DkD,CAAC,CAAA,AAGpC,CAAC,CJ+HS,AIhIZ,WACe,CAAA,IAAK,CAAC,EJ+HU,EAAA,II9HrC,EAAE,CAAC,aAAc,UAAsB,CAAC,AAG/C,CAH+C,AJkI9C,YAAA,CAAA,MI9HC,EAAW,MAAA,IAAA,CAAA,WAAsB,EAAE,CAIrC,AAJqC,CJ+HE,CAAC,CAAC,AI3H/B,AAAyB,CJ2HO,AMjEhC,KF1DwC,CAAC,EAAhB,IAAA,EACjC,GAAc,CAAA,MAAO,EAAT,EAAa,CAAC,WAAW,EAAA,CAAE,CAAE,MAAM,IJ+HI,CAAC,AI5HnD,OAAO,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA,AAGjC,MACW,GEyDG,KF1DI,CAAC,KACM,CAAA,eAAiB,GACxC,OAAe,EADqC,CAAC,AAGvD,CAHuD,CACzC,IAAY,AAGf,CEyDC,ANuEM,AInIQ,KAEV,CAAC,OJiIC,CAAA,aIhIsB,UAAU,AACnC,CADoC,CAAA,CAG9C,IACH,EAAU,CIkBK,EJnBH,CAAC,AACC,CAAP,AAAQ,MfqLc,GerLL,CAAC,IAAA,CAAK,IAAI,CAAC,CAAA,EAC1B,EAAE,CAAC,UAAW,MAG3B,aAAa,CAAA,IACJ,OAAO,CAAC,IAAA,CAAA,UAAgB,CAAE,IAAI,CAAE,aAAa,CAAE,IAAI,CAAE,CAAG,CAAE,CAAF,AAAG,AACpE,CADoE,AACnE,CACF,smNC/cM,EAAA,eAAA,AAAe,EAAA,AAAwB,oBAC7B,CDuC4B,CAAA,MAAA,ECvCN,ERHS,IAAD,AF5B3C,CE4B4C,CQGQ,EAAI,CV/B1C,AAAC,CU+B2C,CAAA,AAEtD,CIlC0B,GlB6BpB,AcMM,CUjCL,AnBEE,SS+Ba,CIlCO,EAAA,UAAA,GJmCf,UAAA,CAUpB,CdoBC,KcpBM,CACL,MAAA,QAAA,CAAA,QAAA,EAA0B,CAAM,CAAC,EAAA,CAAG,EAAE,CAAA,GAAA,EAAA,CAAc,CAAA,CAAE,6BAE7B,ETNuB,CAAC,ASMhB,CAAJ,ATNqB,CSMZ,EAAD,YAAe,CAAC,EAAI,IAErD,CAF0D,CAAA,mBAEnC,GAAQ,EAAK,EAAD,cAAiB,CAAC,EAAI,KAAK,CAAA,aAMnC,CAAG,MAAM,QAAQ,GAAA,CAAI,CJ5BD,gBI6B7B,GAAA,KAAA,CAAA,IAAe,ChBuCW,CgBvCT,CAAC,CAClC,GJ7BwC,CI6BxC,AJ7ByC,CI6BzC,AJ7ByC,UI6BzC,GAAA,KAAA,CAAA,IAAA,KAAA,KAEE,GAAW,IAAA,GAA4B,CUhCS,AdIT,AI4BC,AAC1C,EC+C4C,CAAC,Af5BtC,CU/CD,AK2EuC,ED/C/B,MAAA,ANjDmF,IMiDzE,CAAC,WAAA,CAAa,CdmBK,QcnBH,CAAO,AdmBF,CcnBI,AdmBH,CcnBI,AdmBJ,CcnBK,GAAJ,EAAS,CACtD,AAAC,IACC,CADI,EAAE,AACF,EADI,AACE,IAAI,EPnBR,COmBa,EPnBF,MAAA,kBOmB0B,CAAC,IAAA,CAAA,MAAY,SAC/C,CLZO,EKYH,EACf,CAAC,AFTI,IEWU,GAAO,CFXkB,CEWhB,AFXgB,EEWZ,MAI5B,EAAY,MAAM,GdmBC,CcnBG,CAAC,WAAW,CdmBD,CcnBG,CAAa,CAAA,MAGjD,CAAC,GAAA,QAAoB,CAAC,EAAgB,CAAC,ADiCoB,MChCjD,GdkBO,ADpDM,EAAE,CekCT,CflCW,CekCF,CC8CF,KAAY,CD9CH,CAAC,CC8CK,qDD1CZ,EAClB,CACE,CAFoB,CDkCS,WChCf,CAAC,EAAC,IC6Cc,CAAA,CD7CR,CACpB,GAAU,cAAc,CAAC,YAAY,CACrC,EAAK,EAAD,UAAa,EAAI,CAAA,CAAE,CACxB,EAEH,CAAA,CAAE,CAAC,AACP,SAAU,CC2CS,GdjFS,qBawCvB,EACA,KD+BW,CAAA,CC/BJ,AAAC,CAAC,EAAE,AAAG,CAAD,AAAE,CAAC,EAAA,GAAO,GACvB,GAAG,CAAC,AAAC,CAAC,EAAK,AAAH,CAAE,EAAA,EAAY,KAAA,MAAA,EAAC,CAAC,CAAC,EAAE,CAAC,CAAC,QAK7B,EAAI,IEnBQ,CAAA,AI+BO,CAAU,AVzCf,CAAA,AUyCgB,CNZlB,CAAA,AACvB,CdcO,CAAA,EagBqB,KC9BJ,EFXM,AEWF,CAAD,AFXM,CNiBO,MQNJ,CAAA,EAAG,CAAC,CAG1C,AAH0C,GAGtC,CAAA,AFd+C,EAAE,AEcjD,EFdmD,INiBU,AQH7D,CRG8D,CAAC,EQH/D,EAAA,uBAAA,QAIJ,IACE,EAAA,GADW,WACX,CAAA,UAAmC,aAGhC,iCAC0C,CAAA,IAAK,CAAC,CAAA,IAGxC,CAAA,kBAAA,UAGI,GhByCa,CgBzCT,CAAC,KPNV,SOMwB,CAAA,IAAK,CAAA,IAAK,CAAC,CAAA,KACjC,CU/BW,cV+BK,CEjBO,aFoBlB,CAAA,CADF,CAAC,UACc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,kBACf,IAGrB,YACc,EG6CI,CH7CD,CAAA,aAElB,SAAO,ChByCS,AEhCE,CcTQ,ETaQ,ASbE,EAAA,OAAe,CAAA,GAE/C,ETW2D,CAC1E,CAAC,ISZuB,EG8CQ,AH9CC,aAAc,CAAA,CAAE,CG8CQ,AH9CN,CG8CO,AH7C7C,CG6C8C,yBHvClD,EAAA,IAAA,GAAe,EAAA,wBAAA,CAAyB,GG8CqB,CAAA,CAAA,MH7CzD,GDgCO,ARZM,CQYN,EAAA,wBAAA,UClCD,mCAOO,IAAI,CAAC,WAAW,GAEvC,MACW,QADO,CAAC,KACR,CAAA,eAAA,KACM,CLsBS,mBKpBV,SACU,CXyDK,YWzDS,IDgCE,SAGzC,MC/BW,IAAA,CAAK,SAAS,CAAC,IAAI,CAAA,IAAA,iBACN,YAGV,OAAO,CAAA,oEAGM,CGgDC,GPhFY,CAAC,MIgCH,SAIhC,CJhCG,AG8DE,QCjCoB,EdeE,KcfK,CAAA,0BDiC3B,GAAA,CAAA,AC9BS,GAAM,CfPH,EAAA,EAAA,UAAA,AeOa,EAAC,CAAC,AfPJ,CeOK,AfPJ,CeOK,CAAA,EhBmDe,KgBjDpD,mBACa,CPUK,KOVC,IAAI,CAAC,CPUK,UAAA,iBOT3B,AAGQ,MAHR,EAAA,OAAmC,CAAC,yDAMxB,CAAA,8DAGD,mBACK,GCiDyB,CAAA,CDjDpB,IACf,CDgCO,CAAA,AGjDc,CCsEhB,ADrEJ,eFmBZ,GACM,CJhCC,KAAA,GIkCV,CUJC,AXoCA,AHhEA,CGgEC,AJKE,IAAA,oBKpCK,CAAA,MAAA,IAAA,CAAY,CDgCG,AGhDR,eAAA,EAAA,EAAA,QAAA,EFkBhB,CDgCG,IAAA,goKC7BD,GAAA,SAIW,CGsDC,AHvDO,MAAA,CAAA,EAAA,GAAA,SAAA,AAAe,EAAC,CPmBO,GOnBD,EdqBJ,EAAA,CcrBS,WAAW,GAAE,CAAC,CAAA,AACxC,CDiCK,KCjCC,CRsBS,AQtBT,cAG1B,CAAC,AGuDA,OHrDG,QACN,CEZC,KFYK,kBAAA,CAA0B,CT2CK,CAAC,CAAC,QS1ClB,CAAC,CCsDJ,ASlDS,CnBuCG,EAAA,CS3CH,EGsDoB,MHtDZ,CAAE,UACvB,EAAA,GAAY,CAAC,AAAC,CAAC,EAAE,CAAE,EAAC,EAAA,UAAA,AAAU,EAAC,CAAC,CAAC,CAAC,IAGhD,eAAe,CDmCJ,CAAA,OClCO,OAAA,KACJ,OAAA,CAAA,IAAA,CAAa,SAAA,cAE3B,MAAM,CL6EK,SAAA,CK7EgB,QACR,MAAM,IAAA,CAAK,WAAW,EAAE,CAAA,2BAGnC,EAAU,ChB0DS,CWoBL,KAAA,EK9Ee,ChB0DS,CAAC,CEnCP,AFmCQ,IgB1DJ,CAAC,CAAA,eAClB,GCqDG,CjBYS,MAAA,UgBjEC,WAAiB,CAAE,CAAC,CAAA,IAGpD,EAAW,MAAA,IAAU,CAAC,MUGI,KVHO,EAAE,CAAA,IAEnC,MACO,GADE,ChByES,AgBzER,UACW,CAAC,UAAW,GACnC,IAD0C,CAAC,CAAA,CACjC,cAGa,KUCK,CVFR,WACoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,AAGnD,EAAA,EAAW,CAAC,kBAAmB,ECqDM,EDnDlC,IACH,EAAe,ECqDL,AECJ,EHtDa,CAAA,GADF,WACiB,CAAC,GGsDK,CHtDD,CAAA,IAAK,CAAC,CAAA,AAC7C,EAAS,EAAA,CAAG,IGqD6C,CAAC,CAAA,SHrD9C,IAET,WACe,EGsDI,UHtDQ,CAAC,IAAI,CAAC,CGsDG,GHtDC,CAAC,CAAA,IAC9B,CAAA,KGqD2C,CAAC,CAAA,MHrD7B,ECqDM,IDjDtC,MAAA,aAAA,CAAyB,EACvB,ELqGiC,EKrG3B,EGuDO,CAAA,KAAA,IHvDc,CAAC,WAAW,EAAE,CAAA,UAErB,ChBsHS,GAAA,CgBtHJ,cAGrB,IACE,CGqDO,AJrBF,KCjCG,AAED,CAFE,OACK,CdoBD,KcnBQ,CAAC,CLoGO,cAAA,GKnG/B,EAAA,KAAA,SAGS,MADK,QACS,CAAC,GGoDO,MAAM,IHpDC,GLqGO,AKpG7C,OAAa,GAEV,GCgFS,CD/EZ,Ce3Ka,CAAA,Gf0KD,CAAC,Ae3KU,Af4KT,CAAC,GGqDE,MHrDO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,AACnC,EAAS,EAAE,CAAC,UAAW,IAG7B,CAAC,CACD,MAAA,QACE,CLuGO,AItEJ,ECjCC,CAAC,EAAS,CAAC,CLuGO,GKtGd,EAAA,MAAA,IAAqB,CAAC,WAAW,SACzB,CAAC,EdsBA,OctBS,CAAC,IAAA,CAAK,IAAI,CAAC,CAAA,EAC1B,EAAA,CAAG,KCkFkC,CAAC,CAAA,GDlFnC,WAGV,YAAY,CAAA,QAAA,CAAS,CAAE,EdsBJ,Ge6DK,CDlFtB,EAAQ,CdsBH,CctBU,GdsBD,CctBK,CAAC,AAAC,CAAC,EAAK,AAAH,CAAE,AAAE,CAAC,EAAA,GAAO,SAC9B,CL2GD,KAAA,IK3GW,EDmCJ,gBAAA,CAAA,IAAA,EAAA,uBCnCgD,EAAE,CAAC,CAAA,UAE9C,IAAI,CAAA,WAAY,CCmFD,AE3BE,iBHvDzB,CL0GK,EAAE,IK1GA,CAAC,CL0GK,AKzG1B,GL0GS,AQlDF,IHxDC,EL0GQ,kCKzGR,CAAC,CDkCG,AClCD,GCoFK,KAAA,CAAA,EAAA,EAAA,WAAA,EAAA,IDpF2B,GAGtC,CACT,CGsDG,AHtDF,iBAGL,CAAC,CAAC,CAAA,cFzQ8C,CAAA,CAAA,QAC1C,gBAAE,EQeI,CAAA,CAAA,CAAA,CRfuB,SGyBS,EHfrC,EAAA,eAAA,AAAe,EAAoC,GAAA,CAAA,CACxD,GAAA,wBAEM,CLjBsB,CJiFlB,AQlGE,CCkCD,IAAI,CACf,MAAM,QAAQ,kBAAE,CAAA,CAAkB,CAAA,CAAA,CAAA,QACf,MAAA,IAAA,CAAA,WAAA,MACb,CAAC,CTgEK,AkBvEqB,CTOhB,MAAM,IAAI,GITT,CAAA,AXYI,AeSE,oBRZwB,CAE9C,IAAM,EAAA,MAAiB,IAAI,CAAC,QITT,GJSoB,EAAE,CAAA,EACzB,EFlBA,IAAA,IEkBU,CAAA,UAAW,GAUrC,OARA,IACE,CEOG,AEjBA,CFiBA,IAAA,CFPe,CADH,WACe,CAAA,IAAK,CAAA,IAAA,EACnC,EAAS,EAAE,CAAA,aAAe,mCAIyB,qBAErD,iBAGkB,CAAC,AAAC,IAAa,MAAD,KAAY,aAAc,CAAA,CAAE,CAAA,CAAE,CAAC,CAAC,AAC1D,YAGR,oDAGE,GJpCK,CAAA,EAAA,MAAA,IAAA,GAAA,qBIoCyC,CAE1C,oBACqB,CAAC,aAAc,KACzB,CC8CsB,ACnCrB,OX8Df,GAAA,MSpEO,EAAA,OAAc,CYtBO,CAAA,QZsBG,MEWA,cFXqB,CGyDA,CAAC,CHxDxD,CAAC,AZ6BA,CY5BD,CTqEC,CElEG,IAAA,cOFF,CcvBK,GduBC,EAAA,MAAA,IAAqB,CAAA,WAAA,GAC3B,GAAA,CAAA,EAAA,MAAA,IAAA,GAAA,qBAAA,QACQ,MAAA,EAAe,OAAO,CAAC,QAAU,CLHG,gBKGc,CAAC,AAAC,GAAG,CAC7D,EAAA,UAAU,CACX,CAAA,OAEG,CJtCC,qEIuEA,EAAA,MAAA,IAAoB,EbbP,AS1BA,CAAA,qBIuC4B,EAAE,CAAA,KACzC,OAAA,EAAA,OAAA,2DAO4B,2BACN,GAG3B,CQ2BK,KR3BE,CAAA,CADD,AACC,CADD,MAAA,IAAA,CAAA,WAAA,EAAA,EACY,GK2DmB,EJhBhB,CAAA,sCDpCzB,EACA,4CAIiB,IAAA,CAAA,gBAElB,WK3Ba,GAAA,CAAA,MA8BV,IAIA,EACJ,EdSI,EcPA,CSnFD,A1BiDA,CiBmCC,EACA,EAtCE,EAAmB,EAAA,gBAA2B,EAAI,CPjDE,AI8BrB,AEpBqB,AHmDf,8BI4BgB,GAAW,CAAA,CACpE,ChBrFC,EgBqFG,CFHC,AEE+D,eAEpE,KAAM,gBACN,CdSC,IcTK,GAAc,IAAI,CACxB,MAAA,QACE,IAAA,EAAiB,MAAM,IAAA,CAAK,WAAW,CP9ED,AMUA,CCoEG,CAAC,KAAK,CAAC,GAAG,CDpED,CAAC,ACoEE,KAChD,IACA,IACH,EAFa,AAEH,GADE,CACF,CAAK,CR7DO,QQ6DE,CAAC,IAAI,CAAA,IAAA,EAC7B,EAAS,EAAE,CAAC,UAAA,IAEV,MACc,IAAI,CAAA,IADF,CAAC,CDjEJ,SCkEqB,CAAC,IAAI,CAAA,IAAK,CAAC,CAAA,AAC/C,CnBRuD,AeTtD,CIiBQ,EAAE,CAAC,iBAAkB,MAGlC,CFAC,KEAK,QAAQ,SAAE,CAAA,kBAAS,CAAgB,CH/CP,AG+CS,GAAG,CS7EtB,CT6E4B,CAAG,CAAL,AAAK,CAAA,MAEnD,IAAA,EAAA,MAAuB,IAAI,CAAA,WAAY,EAAE,CAAA,AACzC,CnBLK,EmBKD,CAAA,EAAW,MAAM,IAAA,GAAA,qBAAA,CAChB,CFGC,ATlCM,KWgCG,IAAI,CAAC,CZlCO,CAAC,SEfd,CAAA,CUkDZ,CR5Bc,CAAC,Ae3CP,APuEC,EAAE,CAAC,cAAA,YAId,GAAI,CAAC,EAAe,CAClB,CGhCO,GHgCD,EAAS,MAAM,EH9CJ,AG8CW,IH9CF,GG8CS,CTlGW,CSkGT,OAAO,CAAC,CH9CL,SG8CkB,CAAA,CAAE,CAAA,EACnC,EAAO,CP5ED,CgBD0B,CAC5D,AfV0C,CeUzC,ET4EwC,CAAC,IAAI,CACzC,AAAC,CAAC,EAAE,AAAG,CNvF6C,AMuF5C,ANvF8C,AMuFhD,CAAG,CNvF+C,CMuF7C,GAAK,EAAM,GAAD,IAAQ,CAC9B,CAAA,EAC2C,CH/CnB,MG+C0B,CAAA,AjBpCxC,EAAA,CMK8B,KWgCP,CAAC,CAAC,AD/DC,CC+DA,EAAE,EAAE,CAE3C,ADjE6C,AC+DF,CD/DG,ECiE1C,CAAC,EAAe,MAAA,AAAU,CD9DjB,KC8DuB,EDjE6B,CAAC,CAAA,Sddb,oBeiFrD,IAAM,CV7CkB,CU6CF,GZ3BS,GY2BH,IAAI,CAAC,aAAa,GAK9C,GOlES,EP+DI,OAAO,EAAA,GAAA,MAAyB,EAAA,UAAA,GAGzC,CAAC,EAAS,OAAO,EAAA,EAAmB,CH/CC,AG+CA,CH/CA,GGgDjC,EJfE,AIee,CJfC,CIeM,MAAA,CAC3B,MAAM,CAAA,AAAE,GAAA,EAAgB,EAAE,GAAK,CFGG,EEFlC,GAAG,CAAC,AAAC,ERxBY,AKtBR,CG8Cc,EAAc,EAAE,CAAC,AAC3C,CAD2C,MAC3C,EAAe,OAAO,CAAC,CACrB,eAAgB,CAAC,IVzCY,IU0C7B,GAAI,iBAAA,EACA,CAAE,aAAc,EAAA,YAAiB,CAAE,CACnC,CAAA,CAAA,GAGN,IAAI,CAAA,qBAAsB,CAAC,EAAO,MAAM,CAAC,GAAG,CAAC,AAAC,GAAM,EAAE,EAAE,CAAC,CAAC,CAAA,AAI5D,IAAA,EAAA,CAAkB,MAAM,EAAS,IjBtCU,CAAC,CACrC,AiBqCgC,CjBrChC,CiBqCgC,CAAE,CAAC,AlBvDJ,AkBuDK,GAAG,CAAC,GAAA,CAAA,EAAO,CH/CC,CElBW,AhBgCG,Acdd,CElBY,CAAA,AhBgCC,CAAC,CAAA,MAAA,AiBiCL,EAAC,CAAC,CAAC,CAAC,CAAA,EAG/C,CRtBO,KQsBD,GGhCS,CHgCL,CAAC,UAAU,CGhCO,KHiC7C,CRrBD,EAAA,IQqB+B,EAAS,CAAC,AAC1C,GJnB2C,CAAC,AImBtC,CJnBsC,CImB9B,GlBxDW,GkBwDL,IAAI,CAAC,ClBxDS,CeQL,SGgDQ,CAAC,CAAE,ElBxDS,OkBwDF,GAAI,GRrBM,EQqBD,CACtD,AAAC,ERtB4D,CAAC,MQwBpD,IAAI,GAAK,EAAA,wBAAwB,CAAA,IAAK,EAC3C,EAAM,KAA8B,EAAE,EjBnCxB,QAAA,gEAAA,MiBsCT,QACD,CAAE,GAAI,CAAc,CFFM,AEEJ,AAC/B,CAD+B,AFFI,AjBGtB,AmBAZ,CGnCwC,CAAC,EHqC3B,GAAO,CPrFS,GAAA,COsFnC,CA2BA,OAzBI,IACF,EAAS,MADK,CAAC,AZxBM,ACRF,OWiCI,CAAC,cAAe,EO7DU,WPgE/C,MACO,GADE,WACY,CAAC,CO5DO,AlB2BJ,CAAC,AkB3BI,CAAC,OAAA,GP6DjC,EAAA,KAAA,GAEE,IACF,EAAkB,IAAI,CAAC,MADH,CAAC,CHrDH,ECkDa,OEIS,CAAC,EDrEF,ECqEM,CAAC,IAAI,EAClD,CXlCW,CWkCF,EAAE,CAAA,kBAAoB,IAE5B,MACY,IAAI,CAAC,AAH0B,CAAC,CAAA,CAE9B,IFNgC,OEOf,CAAC,IAAI,CAAC,IAAI,IACnC,CPrFG,COqFD,CAAC,eAAgB,IAE1B,MACW,IAAI,CAAC,CADH,WACe,CAAA,IAAK,CAAC,IAAI,CAAC,CAAA,AACzC,CFJuC,ANZpC,CQgBM,EAAE,CAAC,aAAc,CRhBG,GQkB1B,IACH,CHrDG,CGqDa,IAAI,CAAA,IADF,WACkB,CAAC,ElBnDM,EkBmDF,CAAC,EJpBI,EIoBA,ClBnDK,Ac+BF,AIoBF,CAC/C,AJrBkD,AIoBH,AlBnDK,Cc+BF,CWlC1C,APuDC,EAAE,CAAA,iBAAA,IAGN,UACM,EACP,EAAS,GAAG,CAAC,AAAC,IAAa,MAAD,GAAG,EAAS,YAAY,CAAE,CAAA,CAAE,CAAE,CAAC,CAAC,CAC1D,EACJ,CRjBG,OAAA,GQmBL,MAAO,EAAO,CAAC,AACf,CHtDG,EGuDD,EZZU,0CYYkC,IAAI,CAC7C,GAA4B,EAAF,KAAS,CACrC,CAED,CJxBE,AIuBF,CAAC,IACK,CH1DG,GG0DC,EAAA,wBAAwB,CAAC,EAErC,CH1DC,CAAC,CAAA,AT+CK,AYS4C,CAAC,CAAA,EZT7C,CYYT,CAAC,AH1DA,AG2DH,CAAC,CACD,MAAM,aACJ,IAAA,EAAiB,MAAM,IAAI,CAAC,WAAW,GACvC,GAAA,CACE,MAAA,GAAA,YACF,CAAE,AAAD,MAAQ,EAAO,CACd,GAAA,CAAK,CYzQS,kBAAA,IZyQc,CAAE,EAAgB,GAAD,IAAQ,EAAA,MAAS,UAE1D,IACF,CnBmBS,EmBnBC,OADM,QACS,eAAgB,YAAY,CAAC,AAGpD,CAHoD,MAI5C,CDnEK,ClB2GO,C0B7FL,YPqDQ,GnByCpB,UAAA,GmBxCL,EAAA,KAAA,GAEG,IACH,EAAU,CFDK,GECD,CAAC,CYtPW,QZsPF,CAAC,IAAI,CAAA,IAAK,CAAC,CACnC,GAAU,EJnBJ,ACnCI,AdwBA,AiB8BE,CAAC,UAAW,CnB4CS,GmB1CnC,IACE,GAAU,CFDK,SEAI,CAAC,AnB0DQ,AExFd,IiB+BW,kBAAA,GACzB,OAAkB,GAEhB,OACQ,QADO,CAAC,MACO,iBAAkB,GAC3C,OAAgB,CJnBG,OIsBhB,qBAAA,CAAsB,EAAE,CAAC,AAChC,CAAC,AHvDA,AGwDH,AAFkC,CAEjC,CACD,MAAM,cAEJ,CnBkEK,AWnBJ,KQ/CM,CADU,MAAM,IAAI,CAAA,WAAY,EAAA,CAAE,AHtDF,ADgCW,CIsBT,AJtBS,AChCV,AGuDxB,CHvDwB,OGuDhB,CAAC,GAAG,CAAC,AAAC,CAAC,EAAA,CAAA,EAAK,EAAA,UAAU,AAAV,EAAW,CAAC,CAAC,CAAC,AACpD,CADoD,CAEpD,MAAM,CR+CC,WQ/CW,CAAA,QAAA,CAAS,CHrDL,AGqDO,CAAG,CAAA,CAAE,CjBhCP,CiBiCzB,eAAe,IACb,IAAM,EAAiB,EAAO,CjBhCR,CcrBM,IGqDQ,CAAC,GAAG,CAAC,AAAC,CAAC,EAAE,AAAG,CAAC,AAAF,CAAG,EAAE,CAAa,CAAA,AACjE,CR+CK,EQ/CD,CAAC,EAAe,MAAM,CjBhCH,OiBiCvB,GAAM,CjB9BH,iBAAA,CiB8BqB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAG7B,OAAO,MAAM,EF0BM,AE1BW,GHtDhB,CdsBG,AiBgCiB,CAAC,CACjC,GAAG,CAAU,sBACQ,EnBkEY,emBjEjC,CF0BO,CEzBP,UAAW,CHtDD,CGsDY,GHtDC,MGsDQ,CAC/B,CHtDC,CAD+B,CAAC,CAAA,GGuDzB,CJvBG,CEiDC,Af1DN,KAAA,WiBgCoB,CACxB,EnBqEiB,AmBrEV,MAAM,CAAC,GAAG,CAAC,AAAC,IACjB,CADsB,EAChB,AADkB,CACjB,CADmB,CACf,CAAG,GAAe,CJvB5B,Cf4FoB,kBmBnEP,EAAO,UAAU,GAE/B,MAAO,CAAC,CJrBG,CAAA,EAAA,CIqBO,EAAI,AACxB,CAAC,CAAC,CACH,aACY,EAAW,GjBlCR,GctBK,AAAS,CAAC,CAAA,GGwDI,GAAI,IAAI,AAU/C,OANK,IACC,AAAC,GAAA,CAAA,EAAmC,CAD1B,EAC0B,IAC5B,MAAM,KACP,OAAO,gBAAgB,OAAO,CHxDA,ACmFF,OEzBtB,IAAI,CAAC,IAFoC,CAAC,CAAA,KAErC,GAAc,SAAE,GjBhCR,CiBiChC,CACF,CAAC,CACD,MAAM,aAEJ,MAAO,CADU,MAAM,GjB9BH,CAAA,CiB8BQ,WAAW,EAAA,CAAE,CACzB,AADyB,OAClB,AACzB,CADyB,AACxB,CACD,MAAM,eACJ,GAAA,IACQ,CAAC,EAAU,EAAS,CAAG,MAAM,CRqDD,OQrDS,CRqDD,EQrDI,CAAC,CAC7C,IAAI,CAAC,CjB5BG,EeyDA,AjBqDQ,QmBlFA,CjB5BG,CiB4BD,CAClB,IAAI,CAAA,WAAY,GACjB,CAAC,CAAA,GAGE,CAAC,EAAS,GJrBe,CAAA,EIqBT,CAAE,KJnBb,EImBoB,EAI7B,GADsB,AAClB,MADwB,EazSU,CAAC,CbySP,CAAC,aAAa,EAAE,CAAA,CAC3B,EJlBA,AIkBS,GnBuGI,ImBvGG,CAEnC,CAFqC,CAAC,IF+BW,CAAC,AE9BlD,CF8BkD,KE9B5C,AF0B+D,CejUpD,AfsUR,CAAA,AE/BM,MAAD,IAAW,EAAE,CAAC,KAAK,CAAC,GAAG,EAAI,CAAC,CAAC,CAAA,AAC3C,CAAA,EAEF,MR6Ec,CQ7EP,CJlBH,AEiDQ,AE9Bd,CAAE,GRgFK,EAAA,CQ/EL,KRgFW,CQhFJ,CnB8GO,AiB7EN,CEhCV,CAAC,EAEH,MAAM,YAAY,2BAAE,CAAyB,SAAE,CAAO,CAAE,EACtD,IAAM,EAAW,ERgFP,EM/CA,CN+CY,CQhFC,IAAA,CAAK,CRgFC,UQhFU,EAAE,CAAA,AACzC,AFgCwC,CFjDX,EIiBzB,CAAC,EAAU,MAAM,IAAI,GAAA,qBAAqB,CAE9C,CAFgD,CAAA,EAE1C,EAAQ,EAAO,MAAA,CAAO,CRiFH,GQjFO,CAAC,AAAC,CAAC,EAAE,AAAG,CAAC,AAAF,CAAG,EAAE,CJfb,EIekB,GACjD,GAAA,CADwD,AACnD,CADoD,CAAA,AAC7C,MAAM,IAAI,EAAA,gBAAgB,CAAA,IAAK,EAAA,uBAAuB,EAAE,AAEpE,CAFqE,AnB6HhE,AiB1FJ,CNgDuD,AQnFa,CRmFZ,AQjFrD,CACF,AADG,IFmCG,CjBwFM,CmB1HN,QAAQ,GAAG,CAAC,CAChB,IAAI,QAAc,AAAC,IACjB,IAAM,EAAW,CAAC,CAChB,QAAS,CRmFqB,AQnFP,CAGxB,EAAE,EAAE,AACC,IAAmB,IACrB,EAAA,GAD8B,CAAC,GJnBD,AIoBhB,CJpBiB,AiBnQkB,AbuRlC,GAAG,CAAC,EF8BY,CAAA,KE9BJ,CAAE,OAGjC,CAHyC,AAGxC,CAHyC,AFmCpC,AEhCL,AACD,CAJ0C,CJnBA,AIuBnC,GahRe,IbgRR,CAAC,EAAE,CAAC,CJlBL,QIkBe,EAC9B,CAAC,CAAC,CACF,EAAA,CAFsC,CAAC,CAAA,IAEvB,CAAC,CACf,CFgCO,MEhCC,6BACR,MAAM,CAAE,CAAC,CAAE,QAAA,CAAA,EAAS,EAAA,WAAA,AAAW,EAAC,EAAQ,CAAE,CAAC,GAAJ,AAE1C,CAF2C,AAE1C,CAEF,IAAM,EAAkB,MAAM,IAAI,CAAC,qBAAqB,EAAE,CAAA,AAG1D,OAFA,IAAI,CAAC,qBAAqB,CAAC,CAAC,GAAG,EAAiB,CJlBlB,CIkB0B,CJlBxB,AIkByB,CJlBzB,AIoBzB,AAFkD,CAG3D,CAAC,AAAC,CAHuD,KAGhD,CAHuC,CAGlC,CAAC,AAGb,GAAI,mBAAmB,IAAI,CAAC,EAAM,CF8BD,ME9BQ,CF8BD,AE9BE,CAAA,MAClC,CF6ByC,CAAC,CAAA,CE7BtC,EAAA,wBAAwB,CAAC,AAHvB,GAMd,GAAA,KACM,EAQA,EANF,EADE,CRmFO,EQnFoB,GRoFhB,eQnFO,ERoFgB,EIvGR,CAAC,CAAA,EJuGO,WQpF2B,CAAA,AAE3C,EAAM,cAAc,EAAE,QAAA,IACtC,CAAC,EAAM,cAAc,EAAA,QAAU,GAAG,CAAC,CACnC,EAAA,CAIJ,EADE,GAA2B,CFyCnB,CExCH,OAD+B,OAC5B,EAA0B,AFwCpB,IAA4B,GExCD,CAAA,AAC9B,CAAC,GAAG,CFuCoC,CAAC,AEvC/B,CFuC+B,EEvChC,IAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,AAE9C,IAAM,EAAmB,CJjBd,CAJ6E,mBIuBtF,QAAA,CAAA,EAAS,EAAA,WAAA,AAAW,EAAC,GACrB,KRoFiB,KQpFN,GAA2B,SAAS,EAAI,EAAM,GAAD,CAAK,CAC7D,SAAU,GAA2B,QAAQ,CAC7C,eACE,GAA2B,OJjByB,OIiBX,EAAI,EAAM,GAAD,WAAe,CACnE,OAAO,CnBsIa,EmBnItB,OAAM,EAAS,OAAO,CAAC,CACrB,OAAQ,CJhBK,AADqB,yBIkBlC,CFsCS,MEtCD,CAAC,CJhBG,CIgBc,GAG5B,EFqCM,EErCA,EAAkB,MAAM,IAAI,CAAC,qBAAqB,EAAE,CAAA,AAE1D,OADA,IAAI,CAAC,qBAAqB,CAAC,CAAC,GAAG,EAAiB,EAAQ,CAAC,CAAA,AAClD,CACT,CAAC,AFsCE,AEtCD,MAAO,CAFuC,CAEhC,CJhBR,AIiBN,MAAM,IAAI,EAAA,wBAAwB,CAAC,CFuCC,EErCxC,CAAC,AJlB0C,AAE1C,AIiBH,CAAC,AJhBA,mBIiBiB,CAAQ,EACA,CAAC,CJjBJ,EIiBjB,EAAS,MAAM,CAAQ,IAAI,CAAC,YAAY,EAAE,GAErC,OAAO,CAAC,IAAI,CAAC,SAAU,CAC5B,SAAU,EAAS,CJhB2B,EIgBxB,CAAC,AAAC,CFuCqB,AEvCpB,CFuCoB,CEvClB,CAAE,EAAC,EAAA,UAAA,AAAU,EAAC,CAAC,CAAC,CAAC,EAElD,CAAC,CACD,eAAe,CAAK,EAClB,CJjBC,GIiBK,EAAU,ARyFI,MQzFE,CAAC,CR0FH,EQzFpB,EAAO,OAAO,CAAC,IAAI,CAAC,CFuCT,QEvCmB,SAAE,CAAO,CAAE,CAAC,AAC5C,CAAC,iBACe,CAAW,CFwCW,CEvCpC,IAAM,EAAU,OAAO,EAAY,GJjBT,GEyDS,CExCO,EACpC,CR0FC,CQ1FU,KR2FD,CQ3FO,IAAI,CAAC,WAAW,EAAE,CAAA,AACzC,EAAO,OFuCoC,AEvC7B,CAAC,IAAI,CAAC,GJjBG,MIiBM,CAAE,CAAE,QAAQ,GAAE,OAAO,EAAA,CAAE,CAAC,AACvD,CADuD,AACtD,CACD,MAAM,aAAa,CAAM,EACvB,IAAI,CAAC,qBAAqB,CAAC,EAAE,EAC7B,EAAO,OAAO,CAAC,IAAI,CAAC,GFwCL,WEtCf,IAAM,EAAW,MAAH,AAAS,EFuCN,EAAA,CEvCW,WAAW,EAAE,CAAA,AACrC,IACF,EAAS,IFqCiC,OEtCvB,CAAC,EFuCN,AEtCS,CAAC,CJlBG,CAAA,AEyDP,gBEvCuB,GAC3C,Ca5OuD,Mb4OrC,GFwCL,AEtCX,IACF,EAAS,QADO,CAAC,KACR,CAAe,eAAgB,UACzB,CazOS,CbwO4B,CAAC,AAGvD,CAHuD,GAIrD,EJlBI,AIkBK,MADK,CAAC,CnBuJO,MmBtJC,CAAC,CJlBG,AfyKI,YmBvJO,GACtC,OAAa,GAEX,IACF,EAAS,SADQ,CAAC,IACK,CAAC,gBAAgB,CAAE,GAC1C,CFyCC,MEzCe,GADuC,AAGpD,CAHqD,CAAA,CAC3C,CAGb,EAAU,AAHe,CRiHd,AQjHc,AAEf,EAAE,CAAC,AACC,CAAC,GJlBA,MIkBS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,AACnC,EAAS,EAAE,CR8GA,AQ9GC,KJlB8C,CAAC,CAAA,GIkBpC,KAG3B,EAHkC,CAAC,CAAA,SAGtB,CAAG,IACP,GnB2JJ,AiBlHK,IEzCM,CAAC,IAAI,CAAC,UAAW,CAAE,KAAM,aAAa,CAAE,EnB6JhC,GmB7JsC,CAAG,CAAE,CAAC,AAAH,AACjE,CADoE,AACnE,CACD,EnB4JY,CACb,CAAC,cmB5JE,IAAI,CAAC,YAAY,EAAE,CAAA,QJjBO,mBIoBrB,AAAL,CFyCM,CExCW,AAGV,EAHoB,AADvB,OAAY,AACkB,EAAE,UAAU,CAAC,AAzVjC,QAyV6C,CAAH,CAAC,MAAU,EAAE,GAAG,CACtE,AAAC,GAAY,IAAL,EAAE,AAAS,CAAC,QAAQ,CAAC,EAAQ,KAAD,AAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAI,EAAE,CAAE,EAAE,CAAC,CAC9D,CAAA,CACkB,EAAE,CAJE,AAIF,CR2GT,CQ/Ga,CAAA,AAM3B,AJtBgB,MIsBV,CFsC4B,CAAC,CAAA,qBErCjC,OACG,GFwCO,GExCD,EAAO,IAAD,GAAQ,EAAE,OAAO,CAAC,IAAI,CAAC,CFwCK,wBExCoB,CAAC,CAAC,CAAI,EAAE,AAEzE,CADG,CAAA,AAaH,MAAM,gBACJ,GAAI,CAAC,EAAkB,KJlBb,EIkBoB,EnBoKf,AmBlKf,IAAM,EAAkB,EAAO,CnBmKlB,GmBnKiB,EAAO,CAAC,GAAG,CAAC,AAAC,CAAC,EAAE,AAAG,CAAC,AAAF,CAAG,EAAE,CAAC,CAAA,AAChD,EAAA,IAAsB,CAAC,qBAAqB,EAAE,CAAA,AACpD,GACE,EAAgB,MAAM,EACtB,CJpB2B,AIoB1B,EAAgB,IAAI,CAAC,AAAC,EAAE,CAAK,CAAH,AAAE,CAAiB,QAAQ,CAAC,EAAE,CAAC,CAAC,AAE3D,AAF6C,OAEtC,EAET,IAAM,EAAkB,CR8GT,KQ9Ge,IAAI,CAAC,qBAAqB,EAAE,CAAA,AAC1D,GRgHO,GQhHA,CAAC,EAAe,CRgHR,EAAE,CAAC,CQhHW,CAAC,AAAC,EAAE,CAAK,CAAH,AAAE,CAAiB,EAA/B,MAAuC,CAAC,EAAE,CAAC,AACpE,CADuD,AAAc,AACpE,CADoE,AAErE,MAAA,sBAA4B,CAAM,EAChC,ERiHI,IQjHE,ERiHI,AQjHG,IAAD,GAAQ,EAAE,OAAO,CAAC,IAAI,CAAC,yBAAyB,CAAE,EAChE,EACA,EAFsE,CAAC,CAAA,AAEvE,2BAAA,CACE,MAAO,CAAA,EAAA,IAAO,CAAC,CRiHD,CQjHG,CAAA,gBAAA,CAA6D,AAChF,CAAC,CACF,CAAC,CnBiKI,AmBjKH,AACL,CADK,AACJ,GL9fI,Cd+pBG,Gc/pBH,CAAO,OK2CZ,EGxEE,CCAC,AJwEW,IAAI,CAAA,kLlBzEH","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]}