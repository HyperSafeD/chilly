module.exports=[788475,a=>{"use strict";a.i(730025);var b=a.i(637573),c=a.i(178506);a.i(53218);var d=a.i(799188);a.i(852094);var e=a.i(396426),f=a.i(490610),g=a.i(739741),h=a.i(203479),i=a.i(426779),j=a.i(848800);a.i(675998);var k=a.i(140833);a.i(803675),a.i(801214),a.i(235577),a.i(583717),a.i(934670),a.i(731826),a.i(515820),a.i(161739),a.i(899469),a.i(606291),a.i(104497),a.i(863654);var l=a.i(511854),m=a.i(791477),n=a.i(50516),o=a.i(577248),p=a.i(881791),q=a.i(884353),r=a.i(802320);let s="INVALID_PAYMENT_CONFIG",t="INVALID_RECIPIENT",u="INVALID_ASSET",v="INVALID_AMOUNT",w="UNABLE_TO_INITIATE_PAYMENT",x="INVALID_CHAIN_NAMESPACE",y="GENERIC_PAYMENT_ERROR",z="UNABLE_TO_GET_EXCHANGES",A="ASSET_NOT_SUPPORTED",B="UNABLE_TO_GET_PAY_URL",C="UNABLE_TO_GET_BUY_STATUS",D={[s]:"Invalid payment configuration",[t]:"Invalid recipient address",[u]:"Invalid asset specified",[v]:"Invalid payment amount",UNKNOWN_ERROR:"Unknown payment error occurred",[w]:"Unable to initiate payment",[x]:"Invalid chain namespace",[y]:"Unable to process payment",[z]:"Unable to get exchanges",[A]:"Asset not supported by the selected exchange",[B]:"Unable to get payment URL",[C]:"Unable to get buy status"};class E extends Error{get message(){return D[this.code]}constructor(a,b){super(D[a]),this.name="AppKitPayError",this.code=a,this.details=b,Error.captureStackTrace&&Error.captureStackTrace(this,E)}}var F=a.i(351428);class G extends Error{}async function H(a,b){let c,d=(c=F.OptionsController.getSnapshot().projectId,`https://rpc.walletconnect.org/v1/json-rpc?projectId=${c}`),{sdkType:e,sdkVersion:f,projectId:g}=F.OptionsController.getSnapshot(),h={jsonrpc:"2.0",id:1,method:a,params:{...b||{},st:e,sv:f,projectId:g}},i=await fetch(d,{method:"POST",body:JSON.stringify(h),headers:{"Content-Type":"application/json"}}),j=await i.json();if(j.error)throw new G(j.error.message);return j}async function I(a){return(await H("reown_getExchanges",a)).result}async function J(a){return(await H("reown_getExchangePayUrl",a)).result}async function K(a){return(await H("reown_getExchangeBuyStatus",a)).result}let L=["eip155","solana"],M={eip155:{native:{assetNamespace:"slip44",assetReference:"60"},defaultTokenNamespace:"erc20"},solana:{native:{assetNamespace:"slip44",assetReference:"501"},defaultTokenNamespace:"token"}};function N(a,b){let{chainNamespace:c,chainId:d}=o.ParseUtil.parseCaipNetworkId(a),e=M[c];if(!e)throw Error(`Unsupported chain namespace for CAIP-19 formatting: ${c}`);let f=e.native.assetNamespace,g=e.native.assetReference;"native"!==b&&(f=e.defaultTokenNamespace,g=b);let h=`${c}:${d}`;return`${h}/${f}:${g}`}var O=a.i(164360);async function P(a){let{paymentAssetNetwork:b,activeCaipNetwork:c,approvedCaipNetworkIds:d,requestedCaipNetworks:e}=a,g=h.CoreHelperUtil.sortRequestedNetworks(d,e).find(a=>a.caipNetworkId===b);if(!g)throw new E(s);if(g.caipNetworkId===c.caipNetworkId)return;let i=f.ChainController.getNetworkProp("supportsAllNetworks",g.chainNamespace);if(!(d?.includes(g.caipNetworkId)||i))throw new E(s);try{await f.ChainController.switchActiveNetwork(g)}catch(a){throw new E(y,a)}}async function Q(a,b,c){if(b!==n.ConstantsUtil.CHAIN.EVM)throw new E(x);if(!c.fromAddress)throw new E(s,"fromAddress is required for native EVM payments.");let d="string"==typeof c.amount?parseFloat(c.amount):c.amount;if(isNaN(d))throw new E(s);let e=a.metadata?.decimals??18,f=g.ConnectionController.parseUnits(d.toString(),e);if("bigint"!=typeof f)throw new E(y);return await g.ConnectionController.sendTransaction({chainNamespace:b,to:c.recipient,address:c.fromAddress,value:f,data:"0x"})??void 0}async function R(a,b){if(!b.fromAddress)throw new E(s,"fromAddress is required for ERC20 EVM payments.");let c=a.asset,d=b.recipient,e=Number(a.metadata.decimals),f=g.ConnectionController.parseUnits(b.amount.toString(),e);if(void 0===f)throw new E(y);return await g.ConnectionController.writeContract({fromAddress:b.fromAddress,tokenAddress:c,args:[d,f],method:"transfer",abi:O.ContractUtil.getERC20Abi(c),chainNamespace:n.ConstantsUtil.CHAIN.EVM})??void 0}async function S(a,b){if(a!==n.ConstantsUtil.CHAIN.SOLANA)throw new E(x);if(!b.fromAddress)throw new E(s,"fromAddress is required for Solana payments.");let c="string"==typeof b.amount?parseFloat(b.amount):b.amount;if(isNaN(c)||c<=0)throw new E(s,"Invalid payment amount.");try{if(!q.ProviderController.getProvider(a))throw new E(y,"No Solana provider available.");let d=await g.ConnectionController.sendTransaction({chainNamespace:n.ConstantsUtil.CHAIN.SOLANA,to:b.recipient,value:c,tokenMint:b.tokenMint});if(!d)throw new E(y,"Transaction failed.");return d}catch(a){if(a instanceof E)throw a;throw new E(y,`Solana payment failed: ${a}`)}}let T="unknown",U=(0,l.proxy)({paymentAsset:{network:"eip155:1",asset:"0x0",metadata:{name:"0x0",symbol:"0x0",decimals:0}},recipient:"0x0",amount:0,isConfigured:!1,error:null,isPaymentInProgress:!1,exchanges:[],isLoading:!1,openInNewTab:!0,redirectUrl:void 0,payWithExchange:void 0,currentPayment:void 0,analyticsSet:!1,paymentId:void 0}),V={state:U,subscribe:a=>(0,l.subscribe)(U,()=>a(U)),subscribeKey:(a,b)=>(0,m.subscribeKey)(U,a,b),async handleOpenPay(a){this.resetState(),this.setPaymentConfig(a),this.subscribeEvents(),this.initializeAnalytics(),U.isConfigured=!0,p.EventsController.sendEvent({type:"track",event:"PAY_MODAL_OPEN",properties:{exchanges:U.exchanges,configuration:{network:U.paymentAsset.network,asset:U.paymentAsset.asset,recipient:U.recipient,amount:U.amount}}}),await i.ModalController.open({view:"Pay"})},resetState(){U.paymentAsset={network:"eip155:1",asset:"0x0",metadata:{name:"0x0",symbol:"0x0",decimals:0}},U.recipient="0x0",U.amount=0,U.isConfigured=!1,U.error=null,U.isPaymentInProgress=!1,U.isLoading=!1,U.currentPayment=void 0},setPaymentConfig(a){if(!a.paymentAsset)throw new E(s);try{U.paymentAsset=a.paymentAsset,U.recipient=a.recipient,U.amount=a.amount,U.openInNewTab=a.openInNewTab??!0,U.redirectUrl=a.redirectUrl,U.payWithExchange=a.payWithExchange,U.error=null}catch(a){throw new E(s,a.message)}},getPaymentAsset:()=>U.paymentAsset,getExchanges:()=>U.exchanges,async fetchExchanges(){try{U.isLoading=!0;let a=await I({page:0,asset:N(U.paymentAsset.network,U.paymentAsset.asset),amount:U.amount.toString()});U.exchanges=a.exchanges.slice(0,2)}catch(a){throw j.SnackController.showError(D.UNABLE_TO_GET_EXCHANGES),new E(z)}finally{U.isLoading=!1}},async getAvailableExchanges(a){try{let b=a?.asset&&a?.network?N(a.network,a.asset):void 0;return await I({page:a?.page??0,asset:b,amount:a?.amount?.toString()})}catch(a){throw new E(z)}},async getPayUrl(a,b,c=!1){try{let d=Number(b.amount),e=await J({exchangeId:a,asset:N(b.network,b.asset),amount:d.toString(),recipient:`${b.network}:${b.recipient}`});return p.EventsController.sendEvent({type:"track",event:"PAY_EXCHANGE_SELECTED",properties:{source:"pay",exchange:{id:a},configuration:{network:b.network,asset:b.asset,recipient:b.recipient,amount:d},currentPayment:{type:"exchange",exchangeId:a},headless:c}}),c&&(this.initiatePayment(),p.EventsController.sendEvent({type:"track",event:"PAY_INITIATED",properties:{source:"pay",paymentId:U.paymentId||T,configuration:{network:b.network,asset:b.asset,recipient:b.recipient,amount:d},currentPayment:{type:"exchange",exchangeId:a}}})),e}catch(a){if(a instanceof Error&&a.message.includes("is not supported"))throw new E(A);throw Error(a.message)}},async openPayUrl(a,b,c=!1){try{let d=await this.getPayUrl(a.exchangeId,b,c);if(!d)throw new E(B);let e=a.openInNewTab??!0;return h.CoreHelperUtil.openHref(d.url,e?"_blank":"_self"),d}catch(a){throw a instanceof E?U.error=a.message:U.error=D.GENERIC_PAYMENT_ERROR,new E(B)}},subscribeEvents(){U.isConfigured||(g.ConnectionController.subscribeKey("connections",a=>{a.size>0&&this.handlePayment()}),f.ChainController.subscribeChainProp("accountState",a=>{let b=g.ConnectionController.hasAnyConnection(n.ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT);a?.caipAddress&&(b?setTimeout(()=>{this.handlePayment()},100):this.handlePayment())}))},async handlePayment(){U.currentPayment={type:"wallet",status:"IN_PROGRESS"};let a=f.ChainController.getActiveCaipAddress();if(!a)return;let{chainId:b,address:c}=o.ParseUtil.parseCaipAddress(a),d=f.ChainController.state.activeChain;if(!c||!b||!d||!q.ProviderController.getProvider(d))return;let e=f.ChainController.state.activeCaipNetwork;if(e&&!U.isPaymentInProgress)try{this.initiatePayment();let a=f.ChainController.getAllRequestedCaipNetworks(),b=f.ChainController.getAllApprovedCaipNetworkIds();switch(await P({paymentAssetNetwork:U.paymentAsset.network,activeCaipNetwork:e,approvedCaipNetworkIds:b,requestedCaipNetworks:a}),await i.ModalController.open({view:"PayLoading"}),d){case n.ConstantsUtil.CHAIN.EVM:"native"===U.paymentAsset.asset&&(U.currentPayment.result=await Q(U.paymentAsset,d,{recipient:U.recipient,amount:U.amount,fromAddress:c})),U.paymentAsset.asset.startsWith("0x")&&(U.currentPayment.result=await R(U.paymentAsset,{recipient:U.recipient,amount:U.amount,fromAddress:c})),U.currentPayment.status="SUCCESS";break;case n.ConstantsUtil.CHAIN.SOLANA:U.currentPayment.result=await S(d,{recipient:U.recipient,amount:U.amount,fromAddress:c,tokenMint:"native"===U.paymentAsset.asset?void 0:U.paymentAsset.asset}),U.currentPayment.status="SUCCESS";break;default:throw new E(x)}}catch(a){a instanceof E?U.error=a.message:U.error=D.GENERIC_PAYMENT_ERROR,U.currentPayment.status="FAILED",j.SnackController.showError(U.error)}finally{U.isPaymentInProgress=!1}},getExchangeById:a=>U.exchanges.find(b=>b.id===a),validatePayConfig(a){let{paymentAsset:b,recipient:c,amount:d}=a;if(!b)throw new E(s);if(!c)throw new E(t);if(!b.asset)throw new E(u);if(null==d||d<=0)throw new E(v)},handlePayWithWallet(){let a=f.ChainController.getActiveCaipAddress();if(!a)return void r.RouterController.push("Connect");let{chainId:b,address:c}=o.ParseUtil.parseCaipAddress(a),d=f.ChainController.state.activeChain;c&&b&&d?this.handlePayment():r.RouterController.push("Connect")},async handlePayWithExchange(a){try{U.currentPayment={type:"exchange",exchangeId:a};let{network:b,asset:c}=U.paymentAsset,d={network:b,asset:c,amount:U.amount,recipient:U.recipient},e=await this.getPayUrl(a,d);if(!e)throw new E(w);return U.currentPayment.sessionId=e.sessionId,U.currentPayment.status="IN_PROGRESS",U.currentPayment.exchangeId=a,this.initiatePayment(),{url:e.url,openInNewTab:U.openInNewTab}}catch(a){return a instanceof E?U.error=a.message:U.error=D.GENERIC_PAYMENT_ERROR,U.isPaymentInProgress=!1,j.SnackController.showError(U.error),null}},async getBuyStatus(a,b){try{let c=await K({sessionId:b,exchangeId:a});return("SUCCESS"===c.status||"FAILED"===c.status)&&p.EventsController.sendEvent({type:"track",event:"SUCCESS"===c.status?"PAY_SUCCESS":"PAY_ERROR",properties:{message:"FAILED"===c.status?h.CoreHelperUtil.parseError(U.error):void 0,source:"pay",paymentId:U.paymentId||T,configuration:{network:U.paymentAsset.network,asset:U.paymentAsset.asset,recipient:U.recipient,amount:U.amount},currentPayment:{type:"exchange",exchangeId:U.currentPayment?.exchangeId,sessionId:U.currentPayment?.sessionId,result:c.txHash}}}),c}catch(a){throw new E(C)}},async updateBuyStatus(a,b){try{let c=await this.getBuyStatus(a,b);U.currentPayment&&(U.currentPayment.status=c.status,U.currentPayment.result=c.txHash),("SUCCESS"===c.status||"FAILED"===c.status)&&(U.isPaymentInProgress=!1)}catch(a){throw new E(C)}},initiatePayment(){U.isPaymentInProgress=!0,U.paymentId=crypto.randomUUID()},initializeAnalytics(){U.analyticsSet||(U.analyticsSet=!0,this.subscribeKey("isPaymentInProgress",a=>{if(U.currentPayment?.status&&"UNKNOWN"!==U.currentPayment.status){let a={IN_PROGRESS:"PAY_INITIATED",SUCCESS:"PAY_SUCCESS",FAILED:"PAY_ERROR"}[U.currentPayment.status];p.EventsController.sendEvent({type:"track",event:a,properties:{message:"FAILED"===U.currentPayment.status?h.CoreHelperUtil.parseError(U.error):void 0,source:"pay",paymentId:U.paymentId||T,configuration:{network:U.paymentAsset.network,asset:U.paymentAsset.asset,recipient:U.recipient,amount:U.amount},currentPayment:{type:U.currentPayment.type,exchangeId:U.currentPayment.exchangeId,sessionId:U.currentPayment.sessionId,result:U.currentPayment.result}}})}}))}};var W=a.i(896120);let X=W.css`
  wui-separator {
    margin: var(--apkt-spacing-3) calc(var(--apkt-spacing-3) * -1) var(--apkt-spacing-2)
      calc(var(--apkt-spacing-3) * -1);
    width: calc(100% + var(--apkt-spacing-3) * 2);
  }

  .token-display {
    padding: var(--apkt-spacing-3) var(--apkt-spacing-3);
    border-radius: var(--apkt-borderRadius-5);
    background-color: var(--apkt-tokens-theme-backgroundPrimary);
    margin-top: var(--apkt-spacing-3);
    margin-bottom: var(--apkt-spacing-3);
  }

  .token-display wui-text {
    text-transform: none;
  }

  wui-loading-spinner {
    padding: var(--apkt-spacing-2);
  }
`;var Y=function(a,b,c,d){var e,f=arguments.length,g=f<3?b:null===d?d=Object.getOwnPropertyDescriptor(b,c):d;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)g=Reflect.decorate(a,b,c,d);else for(var h=a.length-1;h>=0;h--)(e=a[h])&&(g=(f<3?e(g):f>3?e(b,c,g):e(b,c))||g);return f>3&&g&&Object.defineProperty(b,c,g),g};let Z=class extends b.LitElement{constructor(){super(),this.unsubscribe=[],this.amount="",this.tokenSymbol="",this.networkName="",this.exchanges=V.state.exchanges,this.isLoading=V.state.isLoading,this.loadingExchangeId=null,this.connectedWalletInfo=f.ChainController.getAccountData()?.connectedWalletInfo,this.initializePaymentDetails(),this.unsubscribe.push(V.subscribeKey("exchanges",a=>this.exchanges=a)),this.unsubscribe.push(V.subscribeKey("isLoading",a=>this.isLoading=a)),this.unsubscribe.push(f.ChainController.subscribeChainProp("accountState",a=>{this.connectedWalletInfo=a?.connectedWalletInfo})),V.fetchExchanges()}get isWalletConnected(){let a=f.ChainController.getAccountData();return a?.status==="connected"}render(){return c.html`
      <wui-flex flexDirection="column">
        <wui-flex flexDirection="column" .padding=${["0","4","4","4"]} gap="3">
          ${this.renderPaymentHeader()}

          <wui-flex flexDirection="column" gap="3">
            ${this.renderPayWithWallet()} ${this.renderExchangeOptions()}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `}initializePaymentDetails(){let a=V.getPaymentAsset();this.networkName=a.network,this.tokenSymbol=a.metadata.symbol,this.amount=V.state.amount.toString()}renderPayWithWallet(){return!function(a){let{chainNamespace:b}=o.ParseUtil.parseCaipNetworkId(a);return L.includes(b)}(this.networkName)?c.html``:c.html`<wui-flex flexDirection="column" gap="3">
        ${this.isWalletConnected?this.renderConnectedView():this.renderDisconnectedView()}
      </wui-flex>
      <wui-separator text="or"></wui-separator>`}renderPaymentHeader(){let a=this.networkName;if(this.networkName){let b=f.ChainController.getAllRequestedCaipNetworks().find(a=>a.caipNetworkId===this.networkName);b&&(a=b.name)}return c.html`
      <wui-flex flexDirection="column" alignItems="center">
        <wui-flex alignItems="center" gap="2">
          <wui-text variant="h1-regular" color="primary">${this.amount||"0.0000"}</wui-text>
          <wui-flex class="token-display" alignItems="center" gap="1">
            <wui-text variant="md-medium" color="primary">
              ${this.tokenSymbol||"Unknown Asset"}
            </wui-text>
            ${a?c.html`
                  <wui-text variant="sm-medium" color="secondary">
                    on ${a}
                  </wui-text>
                `:""}
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `}renderConnectedView(){let a=this.connectedWalletInfo?.name||"connected wallet";return c.html`
      <wui-list-item
        @click=${this.onWalletPayment}
        ?chevron=${!0}
        ?fullSize=${!0}
        ?rounded=${!0}
        data-testid="wallet-payment-option"
        imageSrc=${(0,e.ifDefined)(this.connectedWalletInfo?.icon)}
      >
        <wui-text variant="lg-regular" color="primary">Pay with ${a}</wui-text>
      </wui-list-item>

      <wui-list-item
        icon="power"
        ?rounded=${!0}
        iconColor="error"
        @click=${this.onDisconnect}
        data-testid="disconnect-button"
        ?chevron=${!1}
      >
        <wui-text variant="lg-regular" color="secondary">Disconnect</wui-text>
      </wui-list-item>
    `}renderDisconnectedView(){return c.html`<wui-list-item
      variant="icon"
      iconVariant="overlay"
      icon="wallet"
      ?rounded=${!0}
      @click=${this.onWalletPayment}
      ?chevron=${!0}
      data-testid="wallet-payment-option"
    >
      <wui-text variant="lg-regular" color="primary">Pay from wallet</wui-text>
    </wui-list-item>`}renderExchangeOptions(){return this.isLoading?c.html`<wui-flex justifyContent="center" alignItems="center">
        <wui-spinner size="md"></wui-spinner>
      </wui-flex>`:0===this.exchanges.length?c.html`<wui-flex justifyContent="center" alignItems="center">
        <wui-text variant="md-medium" color="primary">No exchanges available</wui-text>
      </wui-flex>`:this.exchanges.map(a=>c.html`
        <wui-list-item
          @click=${()=>this.onExchangePayment(a.id)}
          data-testid="exchange-option-${a.id}"
          ?chevron=${!0}
          ?disabled=${null!==this.loadingExchangeId}
          ?loading=${this.loadingExchangeId===a.id}
          imageSrc=${(0,e.ifDefined)(a.imageUrl)}
        >
          <wui-flex alignItems="center" gap="3">
            <wui-text flexGrow="1" variant="md-medium" color="primary"
              >Pay with ${a.name} <wui-spinner size="sm" color="secondary"></wui-spinner
            ></wui-text>
          </wui-flex>
        </wui-list-item>
      `)}onWalletPayment(){V.handlePayWithWallet()}async onExchangePayment(a){try{this.loadingExchangeId=a;let b=await V.handlePayWithExchange(a);b&&(await i.ModalController.open({view:"PayLoading"}),h.CoreHelperUtil.openHref(b.url,b.openInNewTab?"_blank":"_self"))}catch(a){console.error("Failed to pay with exchange",a),j.SnackController.showError("Failed to pay with exchange")}finally{this.loadingExchangeId=null}}async onDisconnect(a){a.stopPropagation();try{await g.ConnectionController.disconnect()}catch{console.error("Failed to disconnect"),j.SnackController.showError("Failed to disconnect")}}disconnectedCallback(){this.unsubscribe.forEach(a=>a())}};Z.styles=X,Y([(0,d.state)()],Z.prototype,"amount",void 0),Y([(0,d.state)()],Z.prototype,"tokenSymbol",void 0),Y([(0,d.state)()],Z.prototype,"networkName",void 0),Y([(0,d.state)()],Z.prototype,"exchanges",void 0),Y([(0,d.state)()],Z.prototype,"isLoading",void 0),Y([(0,d.state)()],Z.prototype,"loadingExchangeId",void 0),Y([(0,d.state)()],Z.prototype,"connectedWalletInfo",void 0),Z=Y([(0,k.customElement)("w3m-pay-view")],Z),a.s(["W3mPayView",()=>Z],650862);var $=b,_=a.i(508144),aa=a.i(832557),ab=a.i(68822);a.i(666309);let ac=W.css`
  :host {
    display: block;
    height: 100%;
    width: 100%;
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }
`;var ad=function(a,b,c,d){var e,f=arguments.length,g=f<3?b:null===d?d=Object.getOwnPropertyDescriptor(b,c):d;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)g=Reflect.decorate(a,b,c,d);else for(var h=a.length-1;h>=0;h--)(e=a[h])&&(g=(f<3?e(g):f>3?e(b,c,g):e(b,c))||g);return f>3&&g&&Object.defineProperty(b,c,g),g};let ae=class extends $.LitElement{constructor(){super(),this.loadingMessage="",this.subMessage="",this.paymentState="in-progress",this.paymentState=V.state.isPaymentInProgress?"in-progress":"completed",this.updateMessages(),this.setupSubscription(),this.setupExchangeSubscription()}disconnectedCallback(){clearInterval(this.exchangeSubscription)}render(){return c.html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["7","5","5","5"]}
        gap="9"
      >
        <wui-flex justifyContent="center" alignItems="center"> ${this.getStateIcon()} </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="2">
          <wui-text align="center" variant="lg-medium" color="primary">
            ${this.loadingMessage}
          </wui-text>
          <wui-text align="center" variant="lg-regular" color="secondary">
            ${this.subMessage}
          </wui-text>
        </wui-flex>
      </wui-flex>
    `}updateMessages(){switch(this.paymentState){case"completed":this.loadingMessage="Payment completed",this.subMessage="Your transaction has been successfully processed";break;case"error":this.loadingMessage="Payment failed",this.subMessage="There was an error processing your transaction";break;default:V.state.currentPayment?.type==="exchange"?(this.loadingMessage="Payment initiated",this.subMessage="Please complete the payment on the exchange"):(this.loadingMessage="Awaiting payment confirmation",this.subMessage="Please confirm the payment transaction in your wallet")}}getStateIcon(){switch(this.paymentState){case"completed":return this.successTemplate();case"error":return this.errorTemplate();default:return this.loaderTemplate()}}setupExchangeSubscription(){V.state.currentPayment?.type==="exchange"&&(this.exchangeSubscription=setInterval(async()=>{let a=V.state.currentPayment?.exchangeId,b=V.state.currentPayment?.sessionId;a&&b&&(await V.updateBuyStatus(a,b),V.state.currentPayment?.status==="SUCCESS"&&clearInterval(this.exchangeSubscription))},4e3))}setupSubscription(){V.subscribeKey("isPaymentInProgress",a=>{a||"in-progress"!==this.paymentState||(V.state.error||!V.state.currentPayment?.result?this.paymentState="error":this.paymentState="completed",this.updateMessages(),setTimeout(()=>{"disconnected"!==g.ConnectionController.state.status&&i.ModalController.close()},3e3))}),V.subscribeKey("error",a=>{a&&"in-progress"===this.paymentState&&(this.paymentState="error",this.updateMessages())})}loaderTemplate(){let a=ab.ThemeController.state.themeVariables["--w3m-border-radius-master"],b=a?parseInt(a.replace("px",""),10):4,d=this.getPaymentIcon();return c.html`
      <wui-flex justifyContent="center" alignItems="center" style="position: relative;">
        ${d?c.html`<wui-wallet-image size="lg" imageSrc=${d}></wui-wallet-image>`:null}
        <wui-loading-thumbnail radius=${9*b}></wui-loading-thumbnail>
      </wui-flex>
    `}getPaymentIcon(){let a=V.state.currentPayment;if(a){if("exchange"===a.type){let b=a.exchangeId;if(b){let a=V.getExchangeById(b);return a?.imageUrl}}if("wallet"===a.type){let a=f.ChainController.getAccountData()?.connectedWalletInfo?.icon;if(a)return a;let b=f.ChainController.state.activeChain;if(!b)return;let c=aa.ConnectorController.getConnectorId(b);if(!c)return;let d=aa.ConnectorController.getConnectorById(c);if(!d)return;return _.AssetUtil.getConnectorImage(d)}}}successTemplate(){return c.html`<wui-icon size="xl" color="success" name="checkmark"></wui-icon>`}errorTemplate(){return c.html`<wui-icon size="xl" color="error" name="close"></wui-icon>`}};async function af(a){return V.handleOpenPay(a)}async function ag(a,b=3e5){if(b<=0)throw new E(s,"Timeout must be greater than 0");try{await af(a)}catch(a){if(a instanceof E)throw a;throw new E(w,a.message)}return new Promise((a,c)=>{var d;let e=!1,f=setTimeout(()=>{e||(e=!0,h(),c(new E(y,"Payment timeout")))},b);function g(){if(e)return;let b=V.state.currentPayment,c=V.state.error,d=V.state.isPaymentInProgress;if(b?.status==="SUCCESS"){e=!0,h(),clearTimeout(f),a({success:!0,result:b.result});return}if(b?.status==="FAILED"){e=!0,h(),clearTimeout(f),a({success:!1,error:c||"Payment failed"});return}!c||d||b||(e=!0,h(),clearTimeout(f),a({success:!1,error:c}))}let h=(d=[al("currentPayment",g),al("error",g),al("isPaymentInProgress",g)],()=>{d.forEach(a=>{try{a()}catch{}})});g()})}function ah(){return V.getExchanges()}function ai(){return V.state.currentPayment?.result}function aj(){return V.state.error}function ak(){return V.state.isPaymentInProgress}function al(a,b){return V.subscribeKey(a,b)}ae.styles=ac,ad([(0,d.state)()],ae.prototype,"loadingMessage",void 0),ad([(0,d.state)()],ae.prototype,"subMessage",void 0),ad([(0,d.state)()],ae.prototype,"paymentState",void 0),ae=ad([(0,k.customElement)("w3m-pay-loading-view")],ae),a.s(["W3mPayLoadingView",()=>ae],3240);let am={network:"eip155:8453",asset:"native",metadata:{name:"Ethereum",symbol:"ETH",decimals:18}},an={network:"eip155:8453",asset:"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},ao={network:"eip155:84532",asset:"native",metadata:{name:"Ethereum",symbol:"ETH",decimals:18}},ap={network:"eip155:1",asset:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},aq={network:"eip155:10",asset:"0x0b2c639c533813f4aa9d7837caf62653d097ff85",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},ar={network:"eip155:42161",asset:"0xaf88d065e77c8cC2239327C5EDb3A432268e5831",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},as={network:"eip155:137",asset:"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},at={network:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",asset:"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",metadata:{name:"USD Coin",symbol:"USDC",decimals:6}},au={network:"eip155:1",asset:"0xdAC17F958D2ee523a2206206994597C13D831ec7",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},av={network:"eip155:10",asset:"0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},aw={network:"eip155:42161",asset:"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},ax={network:"eip155:137",asset:"0xc2132d05d31c914a87c6611c10748aeb04b58e8f",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},ay={network:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",asset:"Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",metadata:{name:"Tether USD",symbol:"USDT",decimals:6}},az={network:"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",asset:"native",metadata:{name:"Solana",symbol:"SOL",decimals:9}};a.s(["arbitrumUSDC",0,ar,"arbitrumUSDT",0,aw,"baseETH",0,am,"baseSepoliaETH",0,ao,"baseUSDC",0,an,"ethereumUSDC",0,ap,"ethereumUSDT",0,au,"optimismUSDC",0,aq,"optimismUSDT",0,av,"polygonUSDC",0,as,"polygonUSDT",0,ax,"solanaSOL",0,az,"solanaUSDC",0,at,"solanaUSDT",0,ay],824948),a.s([],438529),a.i(438529),a.i(650862),a.i(3240),a.i(824948),a.s(["W3mPayLoadingView",()=>ae,"W3mPayView",()=>Z,"arbitrumUSDC",0,ar,"arbitrumUSDT",0,aw,"baseETH",0,am,"baseSepoliaETH",0,ao,"baseUSDC",0,an,"ethereumUSDC",0,ap,"ethereumUSDT",0,au,"getExchanges",()=>ah,"getIsPaymentInProgress",()=>ak,"getPayError",()=>aj,"getPayResult",()=>ai,"openPay",()=>af,"optimismUSDC",0,aq,"optimismUSDT",0,av,"pay",()=>ag,"polygonUSDC",0,as,"polygonUSDT",0,ax,"solanaSOL",0,az,"solanaUSDC",0,at,"solanaUSDT",0,ay],788475)}];

//# sourceMappingURL=89298_%40reown_appkit-pay_dist_esm_exports_index_70129acd.js.map