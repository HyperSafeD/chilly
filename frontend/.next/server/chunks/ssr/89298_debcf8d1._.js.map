{"version":3,"sources":["turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/abitype/src/human-readable/parseAbiItem.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/abitype/src/human-readable/parseAbiParameters.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/wallet/waitForCallsStatus.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/wallet/sendCalls.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/wallet/getCallsStatus.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/errors/calls.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getCode.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/errors/eip712.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getEip712Domain.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Hash.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Caches.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/internal/lru.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Address.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/PublicKey.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/AbiItem.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/internal/abiItem.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Solidity.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/AbiParameters.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/internal/abiParameters.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/internal/cursor.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Rlp.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/constants/address.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/AbiFunction.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/erc6492/SignatureErc6492.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Signature.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Authorization.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/internal/entropy.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/Secp256k1.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/signature/serializeSignature.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/erc8010/SignatureErc8010.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/authorization/verifyAuthorization.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/verifyHash.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/constants/strings.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/signature/toPrefixedMessage.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/signature/hashMessage.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/errors/typedData.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/typedData.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/signature/hashTypedData.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/wallet/prepareAuthorization.ts"],"sourcesContent":["import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n> =\n  | (signature extends string\n      ? string extends signature\n        ? Abi[number]\n        : signature extends Signature<signature> // Validate signature\n          ? ParseSignature<signature>\n          : never\n      : never)\n  | (signature extends readonly string[]\n      ? string[] extends signature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : signature extends Signatures<signature> // Validate signature\n          ? ParseStructs<signature> extends infer structs\n            ? {\n                [key in keyof signature]: ParseSignature<\n                  signature[key] extends string ? signature[key] : never,\n                  structs\n                >\n              } extends infer mapped extends readonly unknown[]\n              ? // Filter out `never` since those are structs\n                Filter<mapped, never>[0] extends infer result\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                  ? never\n                  : result\n                : never\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<signature> &\n    (\n      | (signature extends string\n          ? string extends signature\n            ? unknown\n            : Signature<signature>\n          : never)\n      | (signature extends readonly string[]\n          ? signature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends signature\n              ? unknown\n              : Signatures<signature>\n          : never)\n    ),\n): ParseAbiItem<signature> {\n  let abiItem: ParseAbiItem<signature> | undefined\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<signature>\n}\n","import type { AbiParameter } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiParametersError } from './errors/abiParameter.js'\nimport { isStructSignature, modifiers } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { splitParameters } from './runtime/utils.js'\nimport { parseAbiParameter as parseAbiParameter_ } from './runtime/utils.js'\nimport type { IsStructSignature, Modifier } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { SplitParameters } from './types/utils.js'\nimport type { ParseAbiParameters as ParseAbiParameters_ } from './types/utils.js'\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * type Result = ParseAbiParameters('address from, address to, uint256 amount')\n * //   ^? type Result: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * type Result = ParseAbiParameters<\n *   // ^? type Result: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   ['Baz bar', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n> =\n  | (params extends string\n      ? params extends ''\n        ? never\n        : string extends params\n          ? readonly AbiParameter[]\n          : ParseAbiParameters_<SplitParameters<params>, { modifier: Modifier }>\n      : never)\n  | (params extends readonly string[]\n      ? string[] extends params\n        ? AbiParameter // Return generic AbiParameter item since type was no inferrable\n        : ParseStructs<params> extends infer structs\n          ? {\n              [key in keyof params]: params[key] extends string\n                ? IsStructSignature<params[key]> extends true\n                  ? never\n                  : ParseAbiParameters_<\n                      SplitParameters<params[key]>,\n                      { modifier: Modifier; structs: structs }\n                    >\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends readonly [...infer content]\n              ? content['length'] extends 0\n                ? never\n                : DeepFlatten<content>\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Flatten all members of {@link T}\n *\n * @param T - List of items to flatten\n * @param Acc - The accumulator used while recursing\n * @returns The flattened array\n *\n * @example\n * type Result = DeepFlatten<[['a', 'b'], [['c']]]>\n * //   ^? type Result = ['a', 'b', 'c']\n */\ntype DeepFlatten<\n  T extends readonly unknown[],\n  Acc extends readonly unknown[] = readonly [],\n> = T extends readonly [infer head, ...infer tail]\n  ? tail extends undefined\n    ? never\n    : head extends readonly unknown[]\n      ? DeepFlatten<tail, readonly [...Acc, ...DeepFlatten<head>]>\n      : DeepFlatten<tail, readonly [...Acc, head]>\n  : Acc\n\n/**\n * Parses human-readable ABI parameters into {@link AbiParameter}s\n *\n * @param params - Human-readable ABI parameters\n * @returns Parsed {@link AbiParameter}s\n *\n * @example\n * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')\n * //    ^? const abiParameters: [{ type: \"address\"; name: \"from\"; }, { type: \"address\";...\n *\n * @example\n * const abiParameters = parseAbiParameters([\n *   //  ^? const abiParameters: [{ type: \"tuple\"; components: [{ type: \"string\"; name:...\n *   'Baz bar',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiParameters<\n  params extends string | readonly string[] | readonly unknown[],\n>(\n  params: Narrow<params> &\n    (\n      | (params extends string\n          ? params extends ''\n            ? Error<'Empty string is not allowed.'>\n            : unknown\n          : never)\n      | (params extends readonly string[]\n          ? params extends readonly [] // empty array\n            ? Error<'At least one parameter required.'>\n            : string[] extends params\n              ? unknown\n              : unknown // TODO: Validate param string\n          : never)\n    ),\n): ParseAbiParameters<params> {\n  const abiParameters: AbiParameter[] = []\n  if (typeof params === 'string') {\n    const parameters = splitParameters(params)\n    const length = parameters.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter_(parameters[i]!, { modifiers }))\n    }\n  } else {\n    const structs = parseStructs(params as readonly string[])\n    const length = params.length as number\n    for (let i = 0; i < length; i++) {\n      const signature = (params as readonly string[])[i]!\n      if (isStructSignature(signature)) continue\n      const parameters = splitParameters(signature)\n      const length = parameters.length\n      for (let k = 0; k < length; k++) {\n        abiParameters.push(\n          parseAbiParameter_(parameters[k]!, { modifiers, structs }),\n        )\n      }\n    }\n  }\n\n  if (abiParameters.length === 0)\n    throw new InvalidAbiParametersError({ params })\n\n  return abiParameters as ParseAbiParameters<params>\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport { BundleFailedError } from '../../errors/calls.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from './getCallsStatus.js'\n\nexport type WaitForCallsStatusParameters = {\n  /**\n   * The id of the call batch to wait for.\n   */\n  id: string\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   *\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the call bundle failed.\n   * @default 4 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * The status range to wait for.\n   *\n   * @default (status) => status >= 200\n   */\n  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined\n  /**\n   * Whether to throw an error if the call bundle fails.\n   *\n   * @default false\n   */\n  throwOnFailure?: boolean | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   *\n   * @default 60_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForCallsStatusReturnType = GetCallsStatusReturnType\n\nexport type WaitForCallsStatusErrorType =\n  | ObserveErrorType\n  | PollErrorType\n  | GetCallsStatusErrorType\n  | WaitForCallsStatusTimeoutError\n  | ErrorType\n\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: WaitForCallsStatusParameters,\n): Promise<WaitForCallsStatusReturnType> {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({ statusCode }) => statusCode === 200 || statusCode >= 300,\n    retryCount = 4,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000,\n    throwOnFailure = false,\n  } = parameters\n  const observerId = stringify(['waitForCallsStatus', client.uid, id])\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForCallsStatusReturnType>()\n\n  let timer: Timer | undefined\n\n  const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n    const unpoll = poll(\n      async () => {\n        const done = (fn: () => void) => {\n          clearTimeout(timer)\n          unpoll()\n          fn()\n          unobserve()\n        }\n\n        try {\n          const result = await withRetry(\n            async () => {\n              const result = await getAction(\n                client,\n                getCallsStatus,\n                'getCallsStatus',\n              )({ id })\n              if (throwOnFailure && result.status === 'failure')\n                throw new BundleFailedError(result)\n              return result\n            },\n            {\n              retryCount,\n              delay: retryDelay,\n            },\n          )\n          if (!status(result)) return\n          done(() => emit.resolve(result))\n        } catch (error) {\n          done(() => emit.reject(error))\n        }\n      },\n      {\n        interval: pollingInterval,\n        emitOnBegin: true,\n      },\n    )\n\n    return unpoll\n  })\n\n  timer = timeout\n    ? setTimeout(() => {\n        unobserve()\n        clearTimeout(timer)\n        reject(new WaitForCallsStatusTimeoutError({ id }))\n      }, timeout)\n    : undefined\n\n  return await promise\n}\n\nexport type WaitForCallsStatusTimeoutErrorType =\n  WaitForCallsStatusTimeoutError & {\n    name: 'WaitForCallsStatusTimeoutError'\n  }\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({ id }: { id: string }) {\n    super(\n      `Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`,\n      { name: 'WaitForCallsStatusTimeoutError' },\n    )\n  }\n}\n","import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  AtomicityNotSupportedError,\n  UnsupportedNonOptionalCapabilityError,\n} from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type { WalletSendCallsParameters } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { concat } from '../../utils/data/concat.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js'\nimport { sendTransaction } from './sendTransaction.js'\n\nexport const fallbackMagicIdentifier =\n  '0x5792579257925792579257925792579257925792579257925792579257925792'\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n  size: 32,\n})\n\nexport type SendCallsParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _chain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  chain?: chainOverride | Chain | undefined\n  calls: Calls<Narrow<calls>>\n  capabilities?: ExtractCapabilities<'sendCalls', 'Request'> | undefined\n  experimental_fallback?: boolean | undefined\n  experimental_fallbackDelay?: number | undefined\n  forceAtomic?: boolean | undefined\n  id?: string | undefined\n  version?: WalletSendCallsParameters[number]['version'] | undefined\n} & GetAccountParameter<account, Account | Address, false, true>\n\nexport type SendCallsReturnType = Prettify<{\n  capabilities?: ExtractCapabilities<'sendCalls', 'ReturnType'> | undefined\n  id: string\n}>\n\nexport type SendCallsErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n): Promise<SendCallsReturnType> {\n  const {\n    account: account_ = client.account,\n    capabilities,\n    chain = client.chain,\n    experimental_fallback,\n    experimental_fallbackDelay = 32,\n    forceAtomic = false,\n    id,\n    version = '2.0.0',\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : null\n\n  const calls = parameters.calls.map((call_: unknown) => {\n    const call = call_ as Call\n\n    const data = call.abi\n      ? encodeFunctionData({\n          abi: call.abi,\n          functionName: call.functionName,\n          args: call.args,\n        })\n      : call.data\n\n    return {\n      data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n      to: call.to,\n      value: call.value ? numberToHex(call.value) : undefined,\n    }\n  })\n\n  try {\n    const response = await client.request(\n      {\n        method: 'wallet_sendCalls',\n        params: [\n          {\n            atomicRequired: forceAtomic,\n            calls,\n            capabilities,\n            chainId: numberToHex(chain!.id),\n            from: account?.address,\n            id,\n            version,\n          },\n        ],\n      },\n      { retryCount: 0 },\n    )\n    if (typeof response === 'string') return { id: response }\n    return response as never\n  } catch (err) {\n    const error = err as BaseError\n\n    // If the transport does not support EIP-5792, fall back to\n    // `eth_sendTransaction`.\n    if (\n      experimental_fallback &&\n      (error.name === 'MethodNotFoundRpcError' ||\n        error.name === 'MethodNotSupportedRpcError' ||\n        error.name === 'UnknownRpcError' ||\n        error.details\n          .toLowerCase()\n          .includes('does not exist / is not available') ||\n        error.details.toLowerCase().includes('missing or invalid. request()') ||\n        error.details\n          .toLowerCase()\n          .includes('did not match any variant of untagged enum') ||\n        error.details\n          .toLowerCase()\n          .includes('account upgraded to unsupported contract') ||\n        error.details.toLowerCase().includes('eip-7702 not supported') ||\n        error.details.toLowerCase().includes('unsupported wc_ method') ||\n        // magic.link\n        error.details\n          .toLowerCase()\n          .includes('feature toggled misconfigured') ||\n        // Trust Wallet\n        error.details\n          .toLowerCase()\n          .includes(\n            'jsonrpcengine: response has no error or result for request',\n          ))\n    ) {\n      if (capabilities) {\n        const hasNonOptionalCapability = Object.values(capabilities).some(\n          (capability) => !capability.optional,\n        )\n        if (hasNonOptionalCapability) {\n          const message =\n            'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.'\n          throw new UnsupportedNonOptionalCapabilityError(\n            new BaseError(message, {\n              details: message,\n            }),\n          )\n        }\n      }\n      if (forceAtomic && calls.length > 1) {\n        const message =\n          '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.'\n        throw new AtomicityNotSupportedError(\n          new BaseError(message, {\n            details: message,\n          }),\n        )\n      }\n\n      const promises: Promise<Hex>[] = []\n      for (const call of calls) {\n        const promise = sendTransaction(client, {\n          account,\n          chain,\n          data: call.data,\n          to: call.to,\n          value: call.value ? hexToBigInt(call.value) : undefined,\n        })\n        promises.push(promise)\n\n        // Note: some browser wallets require a small delay between transactions\n        // to prevent duplicate JSON-RPC requests.\n        if (experimental_fallbackDelay > 0)\n          await new Promise((resolve) =>\n            setTimeout(resolve, experimental_fallbackDelay),\n          )\n      }\n\n      const results = await Promise.allSettled(promises)\n      if (results.every((r) => r.status === 'rejected')) throw results[0].reason\n\n      const hashes = results.map((result) => {\n        if (result.status === 'fulfilled') return result.value\n        return fallbackTransactionErrorMagicIdentifier\n      })\n      return {\n        id: concat([\n          ...hashes,\n          numberToHex(chain!.id, { size: 32 }),\n          fallbackMagicIdentifier,\n        ]),\n      }\n    }\n\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain!,\n    })\n  }\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletGetCallsStatusReturnType } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { sliceHex } from '../../utils/data/slice.js'\nimport { trim } from '../../utils/data/trim.js'\nimport { hexToBigInt, hexToNumber } from '../../utils/encoding/fromHex.js'\nimport { receiptStatuses } from '../../utils/formatters/transactionReceipt.js'\nimport {\n  fallbackMagicIdentifier,\n  fallbackTransactionErrorMagicIdentifier,\n} from './sendCalls.js'\n\nexport type GetCallsStatusParameters = { id: string }\n\nexport type GetCallsStatusReturnType = Prettify<\n  Omit<\n    WalletGetCallsStatusReturnType<\n      ExtractCapabilities<'getCallsStatus', 'ReturnType'>,\n      number,\n      bigint,\n      'success' | 'reverted'\n    >,\n    'status'\n  > & {\n    statusCode: number\n    status: 'pending' | 'success' | 'failure' | undefined\n  }\n>\n\nexport type GetCallsStatusErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the status of a call batch that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link GetCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function getCallsStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetCallsStatusParameters,\n): Promise<GetCallsStatusReturnType> {\n  async function getStatus(id: Hex) {\n    const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2))\n    if (isTransactions) {\n      const chainId = trim(sliceHex(id, -64, -32))\n      const hashes = sliceHex(id, 0, -64)\n        .slice(2)\n        .match(/.{1,64}/g)\n\n      const receipts = await Promise.all(\n        hashes!.map((hash) =>\n          fallbackTransactionErrorMagicIdentifier.slice(2) !== hash\n            ? client.request(\n                {\n                  method: 'eth_getTransactionReceipt',\n                  params: [`0x${hash}`],\n                },\n                { dedupe: true },\n              )\n            : undefined,\n        ),\n      )\n\n      const status = (() => {\n        if (receipts.some((r) => r === null)) return 100 // pending\n        if (receipts.every((r) => r?.status === '0x1')) return 200 // success\n        if (receipts.every((r) => r?.status === '0x0')) return 500 // complete failure\n        return 600 // partial failure\n      })()\n\n      return {\n        atomic: false,\n        chainId: hexToNumber(chainId),\n        receipts: receipts.filter(Boolean) as RpcTransactionReceipt[],\n        status,\n        version: '2.0.0',\n      }\n    }\n    return client.request({\n      method: 'wallet_getCallsStatus',\n      params: [id],\n    })\n  }\n\n  const {\n    atomic = false,\n    chainId,\n    receipts,\n    version = '2.0.0',\n    ...response\n  } = await getStatus(parameters.id as Hex)\n  const [status, statusCode] = (() => {\n    const statusCode = response.status\n    if (statusCode >= 100 && statusCode < 200)\n      return ['pending', statusCode] as const\n    if (statusCode >= 200 && statusCode < 300)\n      return ['success', statusCode] as const\n    if (statusCode >= 300 && statusCode < 700)\n      return ['failure', statusCode] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'CONFIRMED') return ['success', 200] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'PENDING') return ['pending', 100] as const\n    return [undefined, statusCode]\n  })()\n  return {\n    ...response,\n    atomic,\n    // @ts-expect-error: for backwards compatibility\n    chainId: chainId ? hexToNumber(chainId) : undefined,\n    receipts:\n      receipts?.map((receipt) => ({\n        ...receipt,\n        blockNumber: hexToBigInt(receipt.blockNumber),\n        gasUsed: hexToBigInt(receipt.gasUsed),\n        status: receiptStatuses[receipt.status as '0x0' | '0x1'],\n      })) ?? [],\n    statusCode,\n    status,\n    version,\n  }\n}\n","import type { GetCallsStatusReturnType } from '../actions/wallet/getCallsStatus.js'\nimport { BaseError } from './base.js'\n\nexport type BundleFailedErrorType = BundleFailedError & {\n  name: 'BundleFailedError'\n}\nexport class BundleFailedError extends BaseError {\n  result: GetCallsStatusReturnType\n\n  constructor(result: GetCallsStatusReturnType) {\n    super(`Call bundle failed with status: ${result.statusCode}`, {\n      name: 'BundleFailedError',\n    })\n\n    this.result = result\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetCodeParameters = {\n  address: Address\n} & (\n  | {\n      blockNumber?: undefined\n      blockTag?: BlockTag | undefined\n    }\n  | {\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n)\n\nexport type GetCodeReturnType = Hex | undefined\n\nexport type GetCodeErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Retrieves the bytecode at an address.\n *\n * - Docs: https://viem.sh/docs/contract/getCode\n * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)\n *\n * @param client - Client to use\n * @param parameters - {@link GetCodeParameters}\n * @returns The contract's bytecode. {@link GetCodeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCode } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getCode(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n * })\n */\nexport async function getCode<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { address, blockNumber, blockTag = 'latest' }: GetCodeParameters,\n): Promise<GetCodeReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n  const hex = await client.request(\n    {\n      method: 'eth_getCode',\n      params: [address, blockNumberHex || blockTag],\n    },\n    { dedupe: Boolean(blockNumberHex) },\n  )\n  if (hex === '0x') return undefined\n  return hex\n}\n","import type { Address } from 'abitype'\nimport { BaseError } from './base.js'\n\nexport type Eip712DomainNotFoundErrorType = Eip712DomainNotFoundError & {\n  name: 'Eip712DomainNotFoundError'\n}\nexport class Eip712DomainNotFoundError extends BaseError {\n  constructor({ address }: { address: Address }) {\n    super(`No EIP-712 domain found on contract \"${address}\".`, {\n      metaMessages: [\n        'Ensure that:',\n        `- The contract is deployed at the address \"${address}\".`,\n        '- `eip712Domain()` function exists on the contract.',\n        '- `eip712Domain()` function matches signature to ERC-5267 specification.',\n      ],\n      name: 'Eip712DomainNotFoundError',\n    })\n  }\n}\n","import type { Address, TypedDataDomain } from 'abitype'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  Eip712DomainNotFoundError,\n  type Eip712DomainNotFoundErrorType,\n} from '../../errors/eip712.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequiredBy } from '../../types/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from './readContract.js'\n\nexport type GetEip712DomainParameters = {\n  address: Address\n} & Pick<ReadContractParameters, 'factory' | 'factoryData'>\n\nexport type GetEip712DomainReturnType = {\n  domain: RequiredBy<\n    TypedDataDomain,\n    'chainId' | 'name' | 'verifyingContract' | 'salt' | 'version'\n  >\n  fields: Hex\n  extensions: readonly bigint[]\n}\n\nexport type GetEip712DomainErrorType =\n  | Eip712DomainNotFoundErrorType\n  | ReadContractErrorType\n  | ErrorType\n\n/**\n * Reads the EIP-712 domain from a contract, based on the ERC-5267 specification.\n *\n * @param client - A {@link Client} instance.\n * @param parameters - The parameters of the action. {@link GetEip712DomainParameters}\n * @returns The EIP-712 domain, fields, and extensions. {@link GetEip712DomainReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, getEip712Domain } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const domain = await getEip712Domain(client, {\n *   address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n * })\n * // {\n * //   domain: {\n * //     name: 'ExampleContract',\n * //     version: '1',\n * //     chainId: 1,\n * //     verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n * //   },\n * //   fields: '0x0f',\n * //   extensions: [],\n * // }\n * ```\n */\nexport async function getEip712Domain(\n  client: Client<Transport>,\n  parameters: GetEip712DomainParameters,\n): Promise<GetEip712DomainReturnType> {\n  const { address, factory, factoryData } = parameters\n\n  try {\n    const [\n      fields,\n      name,\n      version,\n      chainId,\n      verifyingContract,\n      salt,\n      extensions,\n    ] = await getAction(\n      client,\n      readContract,\n      'readContract',\n    )({\n      abi,\n      address,\n      functionName: 'eip712Domain',\n      factory,\n      factoryData,\n    })\n\n    return {\n      domain: {\n        name,\n        version,\n        chainId: Number(chainId),\n        verifyingContract,\n        salt,\n      },\n      extensions,\n      fields,\n    }\n  } catch (e) {\n    const error = e as ReadContractErrorType\n    if (\n      error.name === 'ContractFunctionExecutionError' &&\n      error.cause.name === 'ContractFunctionZeroDataError'\n    ) {\n      throw new Eip712DomainNotFoundError({ address })\n    }\n    throw error\n  }\n}\n\nconst abi = [\n  {\n    inputs: [],\n    name: 'eip712Domain',\n    outputs: [\n      { name: 'fields', type: 'bytes1' },\n      { name: 'name', type: 'string' },\n      { name: 'version', type: 'string' },\n      { name: 'chainId', type: 'uint256' },\n      { name: 'verifyingContract', type: 'address' },\n      { name: 'salt', type: 'bytes32' },\n      { name: 'extensions', type: 'uint256[]' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160'\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3'\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: keccak256.Options<as> = {},\n): keccak256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_keccak256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace keccak256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: ripemd160.Options<as> = {},\n): ripemd160.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_ripemd160(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace ripemd160 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: sha256.Options<as> = {},\n): sha256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_sha256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace sha256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 32\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n","import type * as Address from './Address.js'\nimport { LruMap } from './internal/lru.js'\n\nconst caches = {\n  checksum: /*#__PURE__*/ new LruMap<Address.Address>(8192),\n}\n\nexport const checksum = caches.checksum\n\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nexport function clear() {\n  for (const cache of Object.values(caches)) cache.clear()\n}\n","/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override get(key: string) {\n    const value = super.get(key)\n\n    if (super.has(key) && value !== undefined) {\n      this.delete(key)\n      super.set(key, value)\n    }\n\n    return value\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      const firstKey = this.keys().next().value\n      if (firstKey) this.delete(firstKey)\n    }\n    return this\n  }\n}\n","import type { Address as abitype_Address } from 'abitype'\nimport * as Bytes from './Bytes.js'\nimport * as Caches from './Caches.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as PublicKey from './PublicKey.js'\n\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/\n\n/** Root type for Address. */\nexport type Address = abitype_Address\n\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nexport function assert(\n  value: string,\n  options: assert.Options = {},\n): asserts value is Address {\n  const { strict = true } = options\n\n  if (!addressRegex.test(value))\n    throw new InvalidAddressError({\n      address: value,\n      cause: new InvalidInputError(),\n    })\n\n  if (strict) {\n    if (value.toLowerCase() === value) return\n    if (checksum(value as Address) !== value)\n      throw new InvalidAddressError({\n        address: value,\n        cause: new InvalidChecksumError(),\n      })\n  }\n}\n\nexport declare namespace assert {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = InvalidAddressError | Errors.GlobalErrorType\n}\n\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nexport function checksum(address: string): Address {\n  if (Caches.checksum.has(address)) return Caches.checksum.get(address)!\n\n  assert(address, { strict: false })\n\n  const hexAddress = address.substring(2).toLowerCase()\n  const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' })\n\n  const characters = hexAddress.split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1]! >> 4 >= 8 && characters[i]) {\n      characters[i] = characters[i]!.toUpperCase()\n    }\n    if ((hash[i >> 1]! & 0x0f) >= 8 && characters[i + 1]) {\n      characters[i + 1] = characters[i + 1]!.toUpperCase()\n    }\n  }\n\n  const result = `0x${characters.join('')}` as const\n  Caches.checksum.set(address, result)\n  return result\n}\n\nexport declare namespace checksum {\n  type ErrorType =\n    | assert.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nexport function from(address: string, options: from.Options = {}): Address {\n  const { checksum: checksumVal = false } = options\n  assert(address)\n  if (checksumVal) return checksum(address)\n  return address as Address\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | checksum.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nexport function fromPublicKey(\n  publicKey: PublicKey.PublicKey,\n  options: fromPublicKey.Options = {},\n): Address {\n  const address = Hash.keccak256(\n    `0x${PublicKey.toHex(publicKey).slice(4)}`,\n  ).substring(26)\n  return from(`0x${address}`, options)\n}\n\nexport declare namespace fromPublicKey {\n  type Options = {\n    /**\n     * Whether to checksum the address.\n     *\n     * @default false\n     */\n    checksum?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nexport function isEqual(addressA: Address, addressB: Address): boolean {\n  assert(addressA, { strict: false })\n  assert(addressB, { strict: false })\n  return addressA.toLowerCase() === addressB.toLowerCase()\n}\n\nexport declare namespace isEqual {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nexport function validate(\n  address: string,\n  options: validate.Options = {},\n): address is Address {\n  const { strict = true } = options ?? {}\n  try {\n    assert(address, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /**\n     * Enables strict mode. Whether or not to compare the address against its checksum.\n     *\n     * @default true\n     */\n    strict?: boolean | undefined\n  }\n}\n\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nexport class InvalidAddressError<\n  cause extends InvalidInputError | InvalidChecksumError =\n    | InvalidInputError\n    | InvalidChecksumError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'Address.InvalidAddressError'\n\n  constructor({ address, cause }: { address: string; cause: cause }) {\n    super(`Address \"${address}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nexport class InvalidInputError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidInputError'\n\n  constructor() {\n    super('Address is not a 20 byte (40 hexadecimal character) value.')\n  }\n}\n\n/** Thrown when an address does not match its checksum counterpart. */\nexport class InvalidChecksumError extends Errors.BaseError {\n  override readonly name = 'Address.InvalidChecksumError'\n\n  constructor() {\n    super('Address does not match its checksum counterpart.')\n  }\n}\n","import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, ExactPartial } from './internal/types.js'\nimport * as Json from './Json.js'\n\n/** Root type for an ECDSA Public Key. */\nexport type PublicKey<\n  compressed extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  compressed extends true\n    ? {\n        prefix: numberType\n        x: bigintType\n        y?: undefined\n      }\n    : {\n        prefix: numberType\n        x: bigintType\n        y: bigintType\n      }\n>\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function assert(\n  publicKey: ExactPartial<PublicKey>,\n  options: assert.Options = {},\n): asserts publicKey is PublicKey {\n  const { compressed } = options\n  const { prefix, x, y } = publicKey\n\n  // Uncompressed\n  if (\n    compressed === false ||\n    (typeof x === 'bigint' && typeof y === 'bigint')\n  ) {\n    if (prefix !== 4)\n      throw new InvalidPrefixError({\n        prefix,\n        cause: new InvalidUncompressedPrefixError(),\n      })\n    return\n  }\n\n  // Compressed\n  if (\n    compressed === true ||\n    (typeof x === 'bigint' && typeof y === 'undefined')\n  ) {\n    if (prefix !== 3 && prefix !== 2)\n      throw new InvalidPrefixError({\n        prefix,\n        cause: new InvalidCompressedPrefixError(),\n      })\n    return\n  }\n\n  // Unknown/invalid\n  throw new InvalidError({ publicKey })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the public key should be compressed. */\n    compressed?: boolean\n  }\n\n  type ErrorType = InvalidError | InvalidPrefixError | Errors.GlobalErrorType\n}\n\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport function compress(publicKey: PublicKey<false>): PublicKey<true> {\n  const { x, y } = publicKey\n  return {\n    prefix: y % 2n === 0n ? 2 : 3,\n    x,\n  }\n}\n\nexport declare namespace compress {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nexport function from<\n  const publicKey extends\n    | CompressedPublicKey\n    | UncompressedPublicKey\n    | Hex.Hex\n    | Bytes.Bytes,\n>(value: from.Value<publicKey>): from.ReturnType<publicKey> {\n  const publicKey = (() => {\n    if (Hex.validate(value)) return fromHex(value)\n    if (Bytes.validate(value)) return fromBytes(value)\n\n    const { prefix, x, y } = value\n    if (typeof x === 'bigint' && typeof y === 'bigint')\n      return { prefix: prefix ?? 0x04, x, y }\n    return { prefix, x }\n  })()\n\n  assert(publicKey)\n\n  return publicKey as never\n}\n\n/** @internal */\ntype CompressedPublicKey = PublicKey<true>\n\n/** @internal */\ntype UncompressedPublicKey = Omit<PublicKey<false>, 'prefix'> & {\n  prefix?: PublicKey['prefix'] | undefined\n}\n\nexport declare namespace from {\n  type Value<\n    publicKey extends\n      | CompressedPublicKey\n      | UncompressedPublicKey\n      | Hex.Hex\n      | Bytes.Bytes = PublicKey,\n  > = publicKey | CompressedPublicKey | UncompressedPublicKey\n\n  type ReturnType<\n    publicKey extends\n      | CompressedPublicKey\n      | UncompressedPublicKey\n      | Hex.Hex\n      | Bytes.Bytes = PublicKey,\n  > = publicKey extends CompressedPublicKey | UncompressedPublicKey\n    ? publicKey extends UncompressedPublicKey\n      ? Compute<publicKey & { readonly prefix: 0x04 }>\n      : publicKey\n    : PublicKey\n\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromBytes(publicKey: Bytes.Bytes): PublicKey {\n  return fromHex(Hex.fromBytes(publicKey))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType =\n    | fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromHex(publicKey: Hex.Hex): PublicKey {\n  if (\n    publicKey.length !== 132 &&\n    publicKey.length !== 130 &&\n    publicKey.length !== 68\n  )\n    throw new InvalidSerializedSizeError({ publicKey })\n\n  if (publicKey.length === 130) {\n    const x = BigInt(Hex.slice(publicKey, 0, 32))\n    const y = BigInt(Hex.slice(publicKey, 32, 64))\n    return {\n      prefix: 4,\n      x,\n      y,\n    } as never\n  }\n\n  if (publicKey.length === 132) {\n    const prefix = Number(Hex.slice(publicKey, 0, 1))\n    const x = BigInt(Hex.slice(publicKey, 1, 33))\n    const y = BigInt(Hex.slice(publicKey, 33, 65))\n    return {\n      prefix,\n      x,\n      y,\n    } as never\n  }\n\n  const prefix = Number(Hex.slice(publicKey, 0, 1))\n  const x = BigInt(Hex.slice(publicKey, 1, 33))\n  return {\n    prefix,\n    x,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType = Hex.slice.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toBytes(\n  publicKey: PublicKey<boolean>,\n  options: toBytes.Options = {},\n): Bytes.Bytes {\n  return Bytes.fromHex(toHex(publicKey, options))\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /**\n     * Whether to include the prefix in the serialized public key.\n     * @default true\n     */\n    includePrefix?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toHex(\n  publicKey: PublicKey<boolean>,\n  options: toHex.Options = {},\n): Hex.Hex {\n  assert(publicKey)\n\n  const { prefix, x, y } = publicKey\n  const { includePrefix = true } = options\n\n  const publicKey_ = Hex.concat(\n    includePrefix ? Hex.fromNumber(prefix, { size: 1 }) : '0x',\n    Hex.fromNumber(x, { size: 32 }),\n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? Hex.fromNumber(y, { size: 32 }) : '0x',\n  )\n\n  return publicKey_\n}\n\nexport declare namespace toHex {\n  type Options = {\n    /**\n     * Whether to include the prefix in the serialized public key.\n     * @default true\n     */\n    includePrefix?: boolean | undefined\n  }\n\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function validate(\n  publicKey: ExactPartial<PublicKey>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(publicKey, options)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the public key should be compressed. */\n    compressed?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nexport class InvalidError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidError'\n\n  constructor({ publicKey }: { publicKey: unknown }) {\n    super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n      metaMessages: [\n        'Public key must contain:',\n        '- an `x` and `prefix` value (compressed)',\n        '- an `x`, `y`, and `prefix` value (uncompressed)',\n      ],\n    })\n  }\n}\n\n/** Thrown when a public key has an invalid prefix. */\nexport class InvalidPrefixError<\n  cause extends InvalidCompressedPrefixError | InvalidUncompressedPrefixError =\n    | InvalidCompressedPrefixError\n    | InvalidUncompressedPrefixError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'PublicKey.InvalidPrefixError'\n\n  constructor({ prefix, cause }: { prefix: number | undefined; cause: cause }) {\n    super(`Prefix \"${prefix}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nexport class InvalidCompressedPrefixError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidCompressedPrefixError'\n\n  constructor() {\n    super('Prefix must be 2 or 3 for compressed public keys.')\n  }\n}\n\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nexport class InvalidUncompressedPrefixError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidUncompressedPrefixError'\n\n  constructor() {\n    super('Prefix must be 4 for uncompressed public keys.')\n  }\n}\n\n/** Thrown when the public key has an invalid serialized size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidSerializedSizeError'\n\n  constructor({ publicKey }: { publicKey: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n      metaMessages: [\n        'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n        `Received ${Hex.size(Hex.from(publicKey))} bytes.`,\n      ],\n    })\n  }\n}\n","import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/abiItem.js'\nimport type { UnionCompute } from './internal/types.js'\n\n/** Root type for an item on an {@link ox#Abi.Abi}. */\nexport type AbiItem = Abi.Abi[number]\n\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'function foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type Foo = AbiItem.FromAbi<typeof abi, 'Foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = Extract<abi[number], { name: name }>\n\n/**\n * Extracts the names of all {@link ox#AbiItem.AbiItem} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'function foo(string)',\n *   'event Bar(uint256)',\n * ])\n *\n * type names = AbiItem.Name<typeof abi>\n * //   ^?\n *\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<abi extends Abi.Abi> = Extract<\n  abi[number],\n  { name: string }\n>['name']\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nexport function format<const abiItem extends AbiItem>(\n  abiItem: abiItem | AbiItem,\n): abitype.FormatAbiItem<abiItem> {\n  return abitype.formatAbiItem(abiItem) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nexport function from<\n  const abiItem extends AbiItem | string | readonly string[],\n>(\n  abiItem: (abiItem | AbiItem | string | readonly string[]) &\n    (\n      | (abiItem extends string ? internal.Signature<abiItem> : never)\n      | (abiItem extends readonly string[]\n          ? internal.Signatures<abiItem>\n          : never)\n      | AbiItem\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiItem> {\n  const { prepare = true } = options\n  const item = (() => {\n    if (Array.isArray(abiItem)) return abitype.parseAbiItem(abiItem)\n    if (typeof abiItem === 'string')\n      return abitype.parseAbiItem(abiItem as never)\n    return abiItem\n  })() as AbiItem\n  return {\n    ...item,\n    ...(prepare ? { hash: getSignatureHash(item) } : {}),\n  } as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted item (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<abiItem extends AbiItem | string | readonly string[]> =\n    abiItem extends string\n      ? abitype.ParseAbiItem<abiItem>\n      : abiItem extends readonly string[]\n        ? abitype.ParseAbiItem<abiItem>\n        : abiItem\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends internal.ExtractArgs<abi, name> | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: fromAbi.Options<abi, name, args>,\n): fromAbi.ReturnType<abi, name, args> {\n  const { args = [], prepare = true } = (options ??\n    {}) as unknown as fromAbi.Options\n\n  const isSelector = Hex.validate(name, { strict: false })\n  const abiItems = (abi as Abi.Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function' || abiItem.type === 'error')\n        return getSelector(abiItem) === Hex.slice(name, 0, 4)\n      if (abiItem.type === 'event') return getSignatureHash(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0) throw new NotFoundError({ name: name as string })\n  if (abiItems.length === 1)\n    return {\n      ...abiItems[0],\n      ...(prepare ? { hash: getSignatureHash(abiItems[0]!) } : {}),\n    } as never\n\n  let matchedAbiItem: AbiItem | undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return {\n          ...abiItem,\n          ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n        } as never\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return internal.isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = internal.getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0]!,\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1]!,\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  const abiItem = (() => {\n    if (matchedAbiItem) return matchedAbiItem\n    const [abiItem, ...overloads] = abiItems\n    return { ...abiItem!, overloads }\n  })()\n\n  if (!abiItem) throw new NotFoundError({ name: name as string })\n  return {\n    ...abiItem,\n    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n  } as never\n}\n\nexport declare namespace fromAbi {\n  type Options<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | internal.ExtractArgs<abi, name>\n      | undefined = internal.ExtractArgs<abi, name>,\n    ///\n    allArgs = internal.ExtractArgs<abi, name>,\n  > = {\n    /**\n     * Whether or not to prepare the extracted item (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  } & UnionCompute<\n    readonly [] extends allArgs\n      ? {\n          args?:\n            | allArgs // show all options\n            // infer value, widen inferred value of `args` conditionally to match `allArgs`\n            | (abi extends Abi.Abi\n                ? args extends allArgs\n                  ? internal.Widen<args>\n                  : never\n                : never)\n            | undefined\n        }\n      : {\n          args?:\n            | allArgs // show all options\n            | (internal.Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n            | undefined\n        }\n  >\n\n  type ReturnType<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | internal.ExtractArgs<abi, name>\n      | undefined = internal.ExtractArgs<abi, name>,\n    fallback = AbiItem,\n  > = abi extends Abi.Abi\n    ? Abi.Abi extends abi\n      ? fallback\n      : internal.ExtractForArgs<\n          abi,\n          name,\n          args extends internal.ExtractArgs<abi, name>\n            ? args\n            : internal.ExtractArgs<abi, name>\n        >\n    : fallback\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiItem } from 'ox'\n *\n * const erc20Abi = Abi.from([...])\n *\n * const selector = AbiItem.getSelector(erc20Abi, 'ownerOf')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector<\n  abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n>(abi: abi | Abi.Abi | readonly unknown[], name: name): Hex.Hex\nexport function getSelector(abiItem: string | AbiItem): Hex.Hex\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSelector(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], name: string]\n    | [string | AbiItem]\n): Hex.Hex {\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters as [Abi.Abi | readonly unknown[], string]\n      return fromAbi(abi, name)\n    }\n    return parameters[0] as string | AbiItem\n  })()\n  return Hex.slice(getSignatureHash(abiItem), 0, 4)\n}\n\nexport declare namespace getSelector {\n  type ErrorType =\n    | getSignatureHash.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiItem } from 'ox'\n *\n * const erc20Abi = Abi.from([...])\n *\n * const signature = AbiItem.getSignature(erc20Abi, 'ownerOf')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */\nexport function getSignature<\n  abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n>(abi: abi | Abi.Abi | readonly unknown[], name: name): string\nexport function getSignature(abiItem: string | AbiItem): string\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignature(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], name: string]\n    | [string | AbiItem]\n): string {\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters as [Abi.Abi | readonly unknown[], string]\n      return fromAbi(abi, name)\n    }\n    return parameters[0] as string | AbiItem\n  })()\n  const signature = (() => {\n    if (typeof abiItem === 'string') return abiItem\n    return abitype.formatAbiItem(abiItem)\n  })()\n  return internal.normalizeSignature(signature)\n}\n\nexport declare namespace getSignature {\n  type ErrorType =\n    | internal.normalizeSignature.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiItem } from 'ox'\n *\n * const erc20Abi = Abi.from([...])\n *\n * const hash = AbiItem.getSignatureHash(erc20Abi, 'Transfer')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */\nexport function getSignatureHash<\n  abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n>(abi: abi | Abi.Abi | readonly unknown[], name: name): Hex.Hex\nexport function getSignatureHash(abiItem: string | AbiItem): Hex.Hex\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function getSignatureHash(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], name: string]\n    | [string | AbiItem]\n): Hex.Hex {\n  const abiItem = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name] = parameters as [Abi.Abi | readonly unknown[], string]\n      return fromAbi(abi, name)\n    }\n    return parameters[0] as string | AbiItem\n  })()\n  if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n    return abiItem.hash as Hex.Hex\n  return Hash.keccak256(Hex.fromString(getSignature(abiItem)))\n}\n\nexport declare namespace getSignatureHash {\n  type ErrorType =\n    | getSignature.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nexport class AmbiguityError extends Errors.BaseError {\n  override readonly name = 'AbiItem.AmbiguityError'\n  constructor(\n    x: { abiItem: Abi.Abi[number]; type: string },\n    y: { abiItem: Abi.Abi[number]; type: string },\n  ) {\n    super('Found ambiguous types in overloaded ABI Items.', {\n      metaMessages: [\n        // TODO: abitype to add support for signature-formatted ABI items.\n        `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n        `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n        '',\n        'These types encode differently and cannot be distinguished at runtime.',\n        'Remove one of the ambiguous items in the ABI.',\n      ],\n    })\n  }\n}\n\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nexport class NotFoundError extends Errors.BaseError {\n  override readonly name = 'AbiItem.NotFoundError'\n  constructor({\n    name,\n    data,\n    type = 'item',\n  }: {\n    name?: string | undefined\n    data?: Hex.Hex | undefined\n    type?: string | undefined\n  }) {\n    const selector = (() => {\n      if (name) return ` with name \"${name}\"`\n      if (data) return ` with data \"${data}\"`\n      return ''\n    })()\n    super(`ABI ${type}${selector} not found.`)\n  }\n}\n\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nexport class InvalidSelectorSizeError extends Errors.BaseError {\n  override readonly name = 'AbiItem.InvalidSelectorSizeError'\n  constructor({ data }: { data: Hex.Hex }) {\n    super(\n      `Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`,\n    )\n  }\n}\n","import type * as abitype from 'abitype'\nimport type * as Abi from '../Abi.js'\nimport type * as AbiItem from '../AbiItem.js'\nimport type * as AbiParameters from '../AbiParameters.js'\nimport * as Address from '../Address.js'\nimport * as Errors from '../Errors.js'\nimport type {\n  Compute,\n  IsNever,\n  IsUnion,\n  TypeErrorMessage,\n  UnionToTuple,\n} from './types.js'\n\n/** @internal */\nexport type ExtractArgs<\n  abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n  name extends AbiItem.Name<abi> = AbiItem.Name<abi>,\n> = abitype.AbiParametersToPrimitiveTypes<\n  AbiItem.FromAbi<abi extends Abi.Abi ? abi : Abi.Abi, name>['inputs'],\n  'inputs'\n> extends infer args\n  ? [args] extends [never]\n    ? readonly unknown[]\n    : args\n  : readonly unknown[]\n\n/** @internal */\nexport type ExtractForArgs<\n  abi extends Abi.Abi,\n  name extends AbiItem.Name<abi>,\n  args extends ExtractArgs<abi, name>,\n> = IsUnion<name> extends true\n  ? {\n      [key in keyof abi]: abi[key] extends { name: name } ? abi[key] : never\n    }[number]\n  : AbiItem.FromAbi<abi, name> extends infer abiItem extends AbiItem.AbiItem & {\n        inputs: readonly abitype.AbiParameter[]\n      }\n    ? IsUnion<abiItem> extends true // narrow overloads using `args` by converting to tuple and filtering out overloads that don't match\n      ? UnionToTuple<abiItem> extends infer abiItems extends\n          readonly (AbiItem.AbiItem & {\n            inputs: readonly abitype.AbiParameter[]\n          })[]\n        ? IsNever<TupleToUnion<abiItems, abi, name, args>> extends true\n          ? Compute<\n              abiItems[0] & {\n                readonly overloads: UnionToTuple<\n                  Exclude<abiItems[number], abiItems[0]>\n                >\n              }\n            >\n          : TupleToUnion<abiItems, abi, name, args> // convert back to union (removes `never` tuple entries: `['foo', never, 'bar'][number]` => `'foo' | 'bar'`)\n        : never\n      : abiItem\n    : never\n\n/** @internal */\nexport type TupleToUnion<\n  abiItems extends readonly {\n    inputs: readonly abitype.AbiParameter[]\n  }[],\n  abi extends Abi.Abi,\n  name extends AbiItem.Name<abi>,\n  args extends ExtractArgs<abi, name>,\n> = {\n  [k in keyof abiItems]: (\n    readonly [] extends args\n      ? readonly [] // fallback to `readonly []` if `args` has no value (e.g. `args` property not provided)\n      : args\n  ) extends abitype.AbiParametersToPrimitiveTypes<\n    abiItems[k]['inputs'],\n    'inputs'\n  >\n    ? abiItems[k]\n    : never\n}[number]\n\n/** @internal */\nexport type ErrorSignature<\n  name extends string = string,\n  parameters extends string = string,\n> = `error ${name}(${parameters})`\n\n/** @internal */\nexport type IsErrorSignature<signature extends string> =\n  signature extends ErrorSignature<infer name> ? IsName<name> : false\n\n/** @internal */\nexport type EventSignature<\n  name extends string = string,\n  parameters extends string = string,\n> = `event ${name}(${parameters})`\n\n/** @internal */\nexport type IsEventSignature<signature extends string> =\n  signature extends EventSignature<infer name> ? IsName<name> : false\n\n/** @internal */\nexport type FunctionSignature<\n  name extends string = string,\n  tail extends string = string,\n> = `function ${name}(${tail}`\nexport type IsFunctionSignature<signature> =\n  signature extends FunctionSignature<infer name>\n    ? IsName<name> extends true\n      ? signature extends ValidFunctionSignatures\n        ? true\n        : // Check that `Parameters` is not absorbing other types (e.g. `returns`)\n          signature extends `function ${string}(${infer parameters})`\n          ? parameters extends InvalidFunctionParameters\n            ? false\n            : true\n          : false\n      : false\n    : false\n/** @internal */\nexport type Scope = 'public' | 'external' // `internal` or `private` functions wouldn't make it to ABI so can ignore\n\n/** @internal */\nexport type Returns = `returns (${string})` | `returns(${string})`\n\n// Almost all valid function signatures, except `function ${string}(${infer parameters})` since `parameters` can absorb returns\n/** @internal */\nexport type ValidFunctionSignatures =\n  | `function ${string}()`\n  // basic\n  | `function ${string}() ${Returns}`\n  | `function ${string}() ${abitype.AbiStateMutability}`\n  | `function ${string}() ${Scope}`\n  // combinations\n  | `function ${string}() ${abitype.AbiStateMutability} ${Returns}`\n  | `function ${string}() ${Scope} ${Returns}`\n  | `function ${string}() ${Scope} ${abitype.AbiStateMutability}`\n  | `function ${string}() ${Scope} ${abitype.AbiStateMutability} ${Returns}`\n  // Parameters\n  | `function ${string}(${string}) ${Returns}`\n  | `function ${string}(${string}) ${abitype.AbiStateMutability}`\n  | `function ${string}(${string}) ${Scope}`\n  | `function ${string}(${string}) ${abitype.AbiStateMutability} ${Returns}`\n  | `function ${string}(${string}) ${Scope} ${Returns}`\n  | `function ${string}(${string}) ${Scope} ${abitype.AbiStateMutability}`\n  | `function ${string}(${string}) ${Scope} ${abitype.AbiStateMutability} ${Returns}`\n\n/** @internal */\nexport type StructSignature<\n  name extends string = string,\n  properties extends string = string,\n> = `struct ${name} {${properties}}`\n\n/** @internal */\nexport type IsStructSignature<signature extends string> =\n  signature extends StructSignature<infer name> ? IsName<name> : false\n\n/** @internal */\nexport type ConstructorSignature<tail extends string = string> =\n  `constructor(${tail}`\n\n/** @internal */\nexport type IsConstructorSignature<signature> =\n  signature extends ConstructorSignature\n    ? signature extends ValidConstructorSignatures\n      ? true\n      : false\n    : false\n\n/** @internal */\nexport type ValidConstructorSignatures =\n  | `constructor(${string})`\n  | `constructor(${string}) payable`\n\n/** @internal */\nexport type FallbackSignature<abiStateMutability extends '' | ' payable' = ''> =\n  `fallback() external${abiStateMutability}`\n\n/** @internal */\nexport type ReceiveSignature = 'receive() external payable'\n\n// TODO: Maybe use this for signature validation one day\n// https://twitter.com/devanshj__/status/1610423724708343808\n/** @internal */\nexport type IsSignature<type extends string> =\n  | (IsErrorSignature<type> extends true ? true : never)\n  | (IsEventSignature<type> extends true ? true : never)\n  | (IsFunctionSignature<type> extends true ? true : never)\n  | (IsStructSignature<type> extends true ? true : never)\n  | (IsConstructorSignature<type> extends true ? true : never)\n  | (type extends FallbackSignature ? true : never)\n  | (type extends ReceiveSignature ? true : never) extends infer condition\n  ? [condition] extends [never]\n    ? false\n    : true\n  : false\n\n/** @internal */\nexport type Signature<\n  string1 extends string,\n  string2 extends string | unknown = unknown,\n> = IsSignature<string1> extends true\n  ? string1\n  : string extends string1 // if exactly `string` (not narrowed), then pass through as valid\n    ? string1\n    : TypeErrorMessage<`Signature \"${string1}\" is invalid${string2 extends string\n        ? ` at position ${string2}`\n        : ''}.`>\n\n/** @internal */\nexport type Signatures<signatures extends readonly string[]> = {\n  [key in keyof signatures]: Signature<signatures[key], key>\n}\n\n/** @internal */\nexport type IsName<name extends string> = name extends ''\n  ? false\n  : ValidateName<name> extends name\n    ? true\n    : false\n\n/** @internal */\nexport type ValidateName<\n  name extends string,\n  checkCharacters extends boolean = false,\n> = name extends `${string}${' '}${string}`\n  ? TypeErrorMessage<`Identifier \"${name}\" cannot contain whitespace.`>\n  : IsSolidityKeyword<name> extends true\n    ? TypeErrorMessage<`\"${name}\" is a protected Solidity keyword.`>\n    : name extends `${number}`\n      ? TypeErrorMessage<`Identifier \"${name}\" cannot be a number string.`>\n      : name extends `${number}${string}`\n        ? TypeErrorMessage<`Identifier \"${name}\" cannot start with a number.`>\n        : checkCharacters extends true\n          ? IsValidCharacter<name> extends true\n            ? name\n            : TypeErrorMessage<`\"${name}\" contains invalid character.`>\n          : name\n\n/** @internal */\nexport type IsSolidityKeyword<type extends string> =\n  type extends SolidityKeywords ? true : false\n\n/** @internal */\nexport type SolidityKeywords =\n  | 'after'\n  | 'alias'\n  | 'anonymous'\n  | 'apply'\n  | 'auto'\n  | 'byte'\n  | 'calldata'\n  | 'case'\n  | 'catch'\n  | 'constant'\n  | 'copyof'\n  | 'default'\n  | 'defined'\n  | 'error'\n  | 'event'\n  | 'external'\n  | 'false'\n  | 'final'\n  | 'function'\n  | 'immutable'\n  | 'implements'\n  | 'in'\n  | 'indexed'\n  | 'inline'\n  | 'internal'\n  | 'let'\n  | 'mapping'\n  | 'match'\n  | 'memory'\n  | 'mutable'\n  | 'null'\n  | 'of'\n  | 'override'\n  | 'partial'\n  | 'private'\n  | 'promise'\n  | 'public'\n  | 'pure'\n  | 'reference'\n  | 'relocatable'\n  | 'return'\n  | 'returns'\n  | 'sizeof'\n  | 'static'\n  | 'storage'\n  | 'struct'\n  | 'super'\n  | 'supports'\n  | 'switch'\n  | 'this'\n  | 'true'\n  | 'try'\n  | 'typedef'\n  | 'typeof'\n  | 'var'\n  | 'view'\n  | 'virtual'\n  | `address${`[${string}]` | ''}`\n  | `bool${`[${string}]` | ''}`\n  | `string${`[${string}]` | ''}`\n  | `tuple${`[${string}]` | ''}`\n  | `bytes${number | ''}${`[${string}]` | ''}`\n  | `${'u' | ''}int${number | ''}${`[${string}]` | ''}`\n\n/** @internal */\nexport type IsValidCharacter<character extends string> =\n  character extends `${ValidCharacters}${infer tail}`\n    ? tail extends ''\n      ? true\n      : IsValidCharacter<tail>\n    : false\n\n// biome-ignore format: no formatting\n/** @internal */\nexport type ValidCharacters =\n  // uppercase letters\n  | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'\n  // lowercase letters\n  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'\n  // numbers\n  | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n  // special characters\n  | '_' | '$'\n\n// Template string inference can absorb `returns`:\n// type Result = `function foo(string) return s (uint256)` extends `function ${string}(${infer Parameters})` ? Parameters : never\n// //   ^? type Result = \"string ) return s (uint256\"\n// So we need to validate against `returns` keyword with all combinations of whitespace\n/** @internal */\nexport type InvalidFunctionParameters =\n  | `${string}${MangledReturns} (${string}`\n  | `${string}) ${MangledReturns}${string}`\n  | `${string})${string}${MangledReturns}${string}(${string}`\n\n// r_e_t_u_r_n_s\n/** @internal */\nexport type MangledReturns =\n  // Single\n  | `r${string}eturns`\n  | `re${string}turns`\n  | `ret${string}urns`\n  | `retu${string}rns`\n  | `retur${string}ns`\n  | `return${string}s`\n  // Double\n  // `r_e*`\n  | `r${string}e${string}turns`\n  | `r${string}et${string}urns`\n  | `r${string}etu${string}rns`\n  | `r${string}etur${string}ns`\n  | `r${string}eturn${string}s`\n  // `re_t*`\n  | `re${string}t${string}urns`\n  | `re${string}tu${string}rns`\n  | `re${string}tur${string}ns`\n  | `re${string}turn${string}s`\n  // `ret_u*`\n  | `ret${string}u${string}rns`\n  | `ret${string}ur${string}ns`\n  | `ret${string}urn${string}s`\n  // `retu_r*`\n  | `retu${string}r${string}ns`\n  | `retu${string}rn${string}s`\n  // `retur_n*`\n  | `retur${string}n${string}s`\n  // Triple\n  // `r_e_t*`\n  | `r${string}e${string}t${string}urns`\n  | `r${string}e${string}tu${string}rns`\n  | `r${string}e${string}tur${string}ns`\n  | `r${string}e${string}turn${string}s`\n  // `re_t_u*`\n  | `re${string}t${string}u${string}rns`\n  | `re${string}t${string}ur${string}ns`\n  | `re${string}t${string}urn${string}s`\n  // `ret_u_r*`\n  | `ret${string}u${string}r${string}ns`\n  | `ret${string}u${string}rn${string}s`\n  // `retu_r_n*`\n  | `retu${string}r${string}n${string}s`\n  // Quadruple\n  // `r_e_t_u*`\n  | `r${string}e${string}t${string}u${string}rns`\n  | `r${string}e${string}t${string}ur${string}ns`\n  | `r${string}e${string}t${string}urn${string}s`\n  // `re_t_u_r*`\n  | `re${string}t${string}u${string}r${string}ns`\n  | `re${string}t${string}u${string}rn${string}s`\n  // `ret_u_r_n*`\n  | `ret${string}u${string}r${string}n${string}s`\n  // Quintuple\n  // `r_e_t_u_r*`\n  | `r${string}e${string}t${string}u${string}r${string}ns`\n  | `r${string}e${string}t${string}u${string}rn${string}s`\n  // `re_t_u_r_n*`\n  | `re${string}t${string}u${string}r${string}n${string}s`\n  // Sextuple\n  // `r_e_t_u_r_n_s`\n  | `r${string}e${string}t${string}u${string}r${string}n${string}s`\n\n/** @internal */\nexport type Widen<type> =\n  | ([unknown] extends [type] ? unknown : never)\n  | (type extends Function ? type : never)\n  | (type extends abitype.ResolvedRegister['bigIntType'] ? bigint : never)\n  | (type extends boolean ? boolean : never)\n  | (type extends abitype.ResolvedRegister['intType'] ? number : never)\n  | (type extends string\n      ? type extends abitype.ResolvedRegister['addressType']\n        ? abitype.ResolvedRegister['addressType']\n        : type extends abitype.ResolvedRegister['bytesType']['inputs']\n          ? abitype.ResolvedRegister['bytesType']\n          : string\n      : never)\n  | (type extends readonly [] ? readonly [] : never)\n  | (type extends Record<string, unknown>\n      ? { [K in keyof type]: Widen<type[K]> }\n      : never)\n  | (type extends { length: number }\n      ? {\n          [K in keyof type]: Widen<type[K]>\n        } extends infer Val extends readonly unknown[]\n        ? readonly [...Val]\n        : never\n      : never)\n\n/** @internal */\nexport function normalizeSignature(signature: string): string {\n  let active = true\n  let current = ''\n  let level = 0\n  let result = ''\n  let valid = false\n\n  for (let i = 0; i < signature.length; i++) {\n    const char = signature[i]!\n\n    // If the character is a separator, we want to reactivate.\n    if (['(', ')', ','].includes(char)) active = true\n\n    // If the character is a \"level\" token, we want to increment/decrement.\n    if (char === '(') level++\n    if (char === ')') level--\n\n    // If we aren't active, we don't want to mutate the result.\n    if (!active) continue\n\n    // If level === 0, we are at the definition level.\n    if (level === 0) {\n      if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n        result = ''\n      else {\n        result += char\n\n        // If we are at the end of the definition, we must be finished.\n        if (char === ')') {\n          valid = true\n          break\n        }\n      }\n\n      continue\n    }\n\n    // Ignore spaces\n    if (char === ' ') {\n      // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n      if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n        current = ''\n        active = false\n      }\n      continue\n    }\n\n    result += char\n    current += char\n  }\n\n  if (!valid) throw new Errors.BaseError('Unable to normalize signature.')\n\n  return result\n}\n\n/** @internal */\nexport declare namespace normalizeSignature {\n  export type ErrorType = Errors.BaseError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function isArgOfType(\n  arg: unknown,\n  abiParameter: AbiParameters.Parameter,\n): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return Address.validate(arg as Address.Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameters.Parameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameters.Parameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\n/** @internal */\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameters.Parameter[],\n  targetParameters: readonly AbiParameters.Parameter[],\n  args: ExtractArgs,\n): AbiParameters.Parameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]!\n    const targetParameter = targetParameters[parameterIndex]!\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return Address.validate(args[parameterIndex] as Address.Address, {\n          strict: false,\n        })\n      if (types.includes('address') && types.includes('bytes'))\n        return Address.validate(args[parameterIndex] as Address.Address, {\n          strict: false,\n        })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","import * as abitype from 'abitype'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as internal from './internal/abiParameters.js'\nimport * as Cursor from './internal/cursor.js'\nimport * as Solidity from './Solidity.js'\n\n/** Root type for ABI parameters. */\nexport type AbiParameters = readonly abitype.AbiParameter[]\n\n/** A parameter on an {@link ox#AbiParameters.AbiParameters}. */\nexport type Parameter = abitype.AbiParameter\n\n/** A packed ABI type. */\nexport type PackedAbiType =\n  | abitype.SolidityAddress\n  | abitype.SolidityBool\n  | abitype.SolidityBytes\n  | abitype.SolidityInt\n  | abitype.SolidityString\n  | abitype.SolidityArrayWithoutTuple\n\n/**\n * Decodes ABI-encoded data into its respective primitive values based on ABI Parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * You can pass **JSON ABI** Parameters:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.decode(\n *   [\n *     { name: 'x', type: 'string' },\n *     { name: 'y', type: 'uint' },\n *     { name: 'z', type: 'bool' },\n *   ],\n *   '0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001a4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000057761676d69000000000000000000000000000000000000000000000000000000',\n * )\n * // @log: ['wagmi', 420n, true]\n * ```\n *\n * @param parameters - The set of ABI parameters to decode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param data - ABI encoded data.\n * @param options - Decoding options.\n * @returns Array of decoded values.\n */\nexport function decode<\n  const parameters extends AbiParameters,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  parameters: parameters,\n  data: Bytes.Bytes | Hex.Hex,\n  options?: decode.Options<as>,\n): decode.ReturnType<parameters, as>\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  parameters: AbiParameters,\n  data: Bytes.Bytes | Hex.Hex,\n  options: {\n    as?: 'Array' | 'Object' | undefined\n    checksumAddress?: boolean | undefined\n  } = {},\n): readonly unknown[] | Record<string, unknown> {\n  const { as = 'Array', checksumAddress = false } = options\n\n  const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data\n  const cursor = Cursor.create(bytes)\n\n  if (Bytes.size(bytes) === 0 && parameters.length > 0)\n    throw new ZeroDataError()\n  if (Bytes.size(bytes) && Bytes.size(bytes) < 32)\n    throw new DataSizeTooSmallError({\n      data: typeof data === 'string' ? data : Hex.fromBytes(data),\n      parameters: parameters as readonly Parameter[],\n      size: Bytes.size(bytes),\n    })\n\n  let consumed = 0\n  const values: any = as === 'Array' ? [] : {}\n  for (let i = 0; i < parameters.length; ++i) {\n    const param = parameters[i] as Parameter\n    cursor.setPosition(consumed)\n    const [data, consumed_] = internal.decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: 0,\n    })\n    consumed += consumed_\n    if (as === 'Array') values.push(data)\n    else values[param.name ?? i] = data\n  }\n  return values\n}\n\nexport declare namespace decode {\n  type Options<as extends 'Object' | 'Array'> = {\n    /**\n     * Whether the decoded values should be returned as an `Object` or `Array`.\n     *\n     * @default \"Array\"\n     */\n    as?: as | 'Object' | 'Array' | undefined\n    /**\n     * Whether decoded addresses should be checksummed.\n     *\n     * @default false\n     */\n    checksumAddress?: boolean | undefined\n  }\n\n  type ReturnType<\n    parameters extends AbiParameters = AbiParameters,\n    as extends 'Object' | 'Array' = 'Array',\n  > = parameters extends readonly []\n    ? as extends 'Object'\n      ? {}\n      : []\n    : as extends 'Object'\n      ? internal.ToObject<parameters>\n      : internal.ToPrimitiveTypes<parameters>\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | internal.decodeParameter.ErrorType\n    | ZeroDataError\n    | DataSizeTooSmallError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nexport function encode<\n  const parameters extends AbiParameters | readonly unknown[],\n>(\n  parameters: parameters,\n  values: parameters extends AbiParameters\n    ? internal.ToPrimitiveTypes<parameters>\n    : never,\n  options?: encode.Options,\n): Hex.Hex {\n  const { checksumAddress = false } = options ?? {}\n\n  if (parameters.length !== values.length)\n    throw new LengthMismatchError({\n      expectedLength: parameters.length as number,\n      givenLength: values.length as any,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParameters = internal.prepareParameters({\n    checksumAddress,\n    parameters: parameters as readonly Parameter[],\n    values: values as any,\n  })\n  const data = internal.encode(preparedParameters)\n  if (data.length === 0) return '0x'\n  return data\n}\n\nexport declare namespace encode {\n  type ErrorType =\n    | LengthMismatchError\n    | internal.encode.ErrorType\n    | internal.prepareParameters.ErrorType\n    | Errors.GlobalErrorType\n\n  type Options = {\n    /**\n     * Whether addresses should be checked against their checksum.\n     *\n     * @default false\n     */\n    checksumAddress?: boolean | undefined\n  }\n}\n\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: encodePacked.Values<packedAbiTypes>): Hex.Hex {\n  if (types.length !== values.length)\n    throw new LengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex.Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encodePacked.encode(type, value))\n  }\n  return Hex.concat(...data)\n}\n\nexport namespace encodePacked {\n  export type ErrorType =\n    | Hex.concat.ErrorType\n    | LengthMismatchError\n    | Errors.GlobalErrorType\n\n  export type Values<\n    packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n  > = {\n    [key in keyof packedAbiTypes]: packedAbiTypes[key] extends abitype.AbiType\n      ? abitype.AbiParameterToPrimitiveType<{ type: packedAbiTypes[key] }>\n      : unknown\n  }\n\n  // eslint-disable-next-line jsdoc/require-jsdoc\n  export function encode<const packedAbiType extends PackedAbiType | unknown>(\n    type: packedAbiType,\n    value: Values<[packedAbiType]>[0],\n    isArray = false,\n  ): Hex.Hex {\n    if (type === 'address') {\n      const address = value as Address.Address\n      Address.assert(address)\n      return Hex.padLeft(\n        address.toLowerCase() as Hex.Hex,\n        isArray ? 32 : 0,\n      ) as Address.Address\n    }\n    if (type === 'string') return Hex.fromString(value as string)\n    if (type === 'bytes') return value as Hex.Hex\n    if (type === 'bool')\n      return Hex.padLeft(Hex.fromBoolean(value as boolean), isArray ? 32 : 1)\n\n    const intMatch = (type as string).match(Solidity.integerRegex)\n    if (intMatch) {\n      const [_type, baseType, bits = '256'] = intMatch\n      const size = Number.parseInt(bits, 10) / 8\n      return Hex.fromNumber(value as number, {\n        size: isArray ? 32 : size,\n        signed: baseType === 'int',\n      })\n    }\n\n    const bytesMatch = (type as string).match(Solidity.bytesRegex)\n    if (bytesMatch) {\n      const [_type, size] = bytesMatch\n      if (Number.parseInt(size!, 10) !== ((value as Hex.Hex).length - 2) / 2)\n        throw new BytesSizeMismatchError({\n          expectedSize: Number.parseInt(size!, 10),\n          value: value as Hex.Hex,\n        })\n      return Hex.padRight(value as Hex.Hex, isArray ? 32 : 0) as Hex.Hex\n    }\n\n    const arrayMatch = (type as string).match(Solidity.arrayRegex)\n    if (arrayMatch && Array.isArray(value)) {\n      const [_type, childType] = arrayMatch\n      const data: Hex.Hex[] = []\n      for (let i = 0; i < value.length; i++) {\n        data.push(encode(childType, value[i], true))\n      }\n      if (data.length === 0) return '0x'\n      return Hex.concat(...data)\n    }\n\n    throw new InvalidTypeError(type as string)\n  }\n}\n\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nexport function format<\n  const parameters extends readonly [\n    Parameter | abitype.AbiEventParameter,\n    ...(readonly (Parameter | abitype.AbiEventParameter)[]),\n  ],\n>(\n  parameters:\n    | parameters\n    | readonly [\n        Parameter | abitype.AbiEventParameter,\n        ...(readonly (Parameter | abitype.AbiEventParameter)[]),\n      ],\n): abitype.FormatAbiParameters<parameters> {\n  return abitype.formatAbiParameters(parameters)\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nexport function from<\n  const parameters extends AbiParameters | string | readonly string[],\n>(\n  parameters: parameters | AbiParameters | string | readonly string[],\n): from.ReturnType<parameters> {\n  if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n    return abitype.parseAbiParameters(parameters) as never\n  if (typeof parameters === 'string')\n    return abitype.parseAbiParameters(parameters) as never\n  return parameters as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    parameters extends AbiParameters | string | readonly string[],\n  > = parameters extends string\n    ? abitype.ParseAbiParameters<parameters>\n    : parameters extends readonly string[]\n      ? abitype.ParseAbiParameters<parameters>\n      : parameters\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                               2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nexport class DataSizeTooSmallError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.DataSizeTooSmallError'\n  constructor({\n    data,\n    parameters,\n    size,\n  }: { data: Hex.Hex; parameters: readonly Parameter[]; size: number }) {\n    super(`Data size of ${size} bytes is too small for given parameters.`, {\n      metaMessages: [\n        `Params: (${abitype.formatAbiParameters(parameters as readonly [Parameter])})`,\n        `Data:   ${data} (${size} bytes)`,\n      ],\n    })\n  }\n}\n\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                             zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                               32 bytes\n * ```\n */\nexport class ZeroDataError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.ZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                                expected: 3    length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                           length: 3\n * ```\n */\nexport class ArrayLengthMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.ArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      `Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`,\n    )\n  }\n}\n\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                             expected: 8 bytes    size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                         size: 8 bytes\n * ```\n */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    value,\n  }: { expectedSize: number; value: Hex.Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${Hex.size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nexport class LengthMismatchError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.LengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding parameters/values length mismatch.',\n        `Expected length (parameters): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nexport class InvalidArrayError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.InvalidArrayError'\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is not a valid array.`)\n  }\n}\n\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                               invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nexport class InvalidTypeError extends Errors.BaseError {\n  override readonly name = 'AbiParameters.InvalidTypeError'\n  constructor(type: string) {\n    super(`Type \\`${type}\\` is not a valid ABI Type.`)\n  }\n}\n","import type {\n  AbiParameter,\n  AbiParameterKind,\n  AbiParametersToPrimitiveTypes,\n  AbiParameterToPrimitiveType,\n} from 'abitype'\nimport * as AbiParameters from '../AbiParameters.js'\nimport * as Address from '../Address.js'\nimport * as Bytes from '../Bytes.js'\nimport * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport { integerRegex } from '../Solidity.js'\nimport type * as Cursor from './cursor.js'\nimport type { Compute, IsNarrowable, UnionToIntersection } from './types.js'\n\n/** @internal */\nexport type ParameterToPrimitiveType<\n  abiParameter extends AbiParameter | { name: string; type: unknown },\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParameterToPrimitiveType<abiParameter, abiParameterKind>\n\n/** @internal */\nexport type PreparedParameter = { dynamic: boolean; encoded: Hex.Hex }\n\n/** @internal */\nexport type ToObject<\n  parameters extends readonly AbiParameter[],\n  kind extends AbiParameterKind = AbiParameterKind,\n> = IsNarrowable<parameters, AbiParameters.AbiParameters> extends true\n  ? Compute<\n      UnionToIntersection<\n        {\n          [index in keyof parameters]: parameters[index] extends {\n            name: infer name extends string\n          }\n            ? {\n                [key in name]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n            : {\n                [key in index]: AbiParameterToPrimitiveType<\n                  parameters[index],\n                  kind\n                >\n              }\n        }[number]\n      >\n    >\n  : unknown\n\n/** @internal */\nexport type ToPrimitiveTypes<\n  abiParameters extends readonly AbiParameter[],\n  abiParameterKind extends AbiParameterKind = AbiParameterKind,\n> = AbiParametersToPrimitiveTypes<abiParameters, abiParameterKind>\n\n/** @internal */\nexport type Tuple = ParameterToPrimitiveType<TupleAbiParameter>\n\n/** @internal */\nexport function decodeParameter(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(\n      cursor,\n      { ...param, type },\n      { checksumAddress, length, staticPosition },\n    )\n  }\n  if (param.type === 'tuple')\n    return decodeTuple(cursor, param as TupleAbiParameter, {\n      checksumAddress,\n      staticPosition,\n    })\n  if (param.type === 'address')\n    return decodeAddress(cursor, { checksum: checksumAddress })\n  if (param.type === 'bool') return decodeBool(cursor)\n  if (param.type.startsWith('bytes'))\n    return decodeBytes(cursor, param, { staticPosition })\n  if (param.type.startsWith('uint') || param.type.startsWith('int'))\n    return decodeNumber(cursor, param)\n  if (param.type === 'string') return decodeString(cursor, { staticPosition })\n  throw new AbiParameters.InvalidTypeError(param.type)\n}\n\nexport declare namespace decodeParameter {\n  type ErrorType =\n    | decodeArray.ErrorType\n    | decodeTuple.ErrorType\n    | decodeAddress.ErrorType\n    | decodeBool.ErrorType\n    | decodeBytes.ErrorType\n    | decodeNumber.ErrorType\n    | decodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\nconst sizeOfLength = 32\nconst sizeOfOffset = 32\n\n/** @internal */\nexport function decodeAddress(\n  cursor: Cursor.Cursor,\n  options: { checksum?: boolean | undefined } = {},\n) {\n  const { checksum = false } = options\n  const value = cursor.readBytes(32)\n  const wrap = (address: Hex.Hex) =>\n    checksum ? Address.checksum(address) : address\n  return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32]\n}\n\nexport declare namespace decodeAddress {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeArray(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    staticPosition: number\n  },\n) {\n  const { checksumAddress, length, staticPosition } = options\n\n  // If the length of the array is not known in advance (dynamic array),\n  // this means we will need to wonder off to the pointer and decode.\n  if (!length) {\n    // Dealing with a dynamic type, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n    const startOfData = start + sizeOfLength\n\n    // Get the length of the array from the offset.\n    cursor.setPosition(start)\n    const length = Bytes.toNumber(cursor.readBytes(sizeOfLength))\n\n    // Check if the array has any dynamic children.\n    const dynamicChild = hasDynamicChild(param)\n\n    let consumed = 0\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n      // Otherwise, elements will be the size of their encoding (consumed bytes).\n      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed))\n      const [data, consumed_] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: startOfData,\n      })\n      consumed += consumed_\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the array data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset\n\n    const value: unknown[] = []\n    for (let i = 0; i < length; ++i) {\n      // Move cursor along to the next slot (next offset pointer).\n      cursor.setPosition(start + i * 32)\n      const [data] = decodeParameter(cursor, param, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      value.push(data)\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the length of the array is known in advance and the array is deeply static,\n  // then we can just decode each element in sequence.\n  let consumed = 0\n  const value: unknown[] = []\n  for (let i = 0; i < length; ++i) {\n    const [data, consumed_] = decodeParameter(cursor, param, {\n      checksumAddress,\n      staticPosition: staticPosition + consumed,\n    })\n    consumed += consumed_\n    value.push(data)\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeArray {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBool(cursor: Cursor.Cursor) {\n  return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32]\n}\n\nexport declare namespace decodeBool {\n  type ErrorType = Bytes.toBoolean.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeBytes(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n  { staticPosition }: { staticPosition: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // Dealing with dynamic types, so get the offset of the bytes data.\n    const offset = Bytes.toNumber(cursor.readBytes(32))\n\n    // Set position of the cursor to start of bytes data.\n    cursor.setPosition(staticPosition + offset)\n\n    const length = Bytes.toNumber(cursor.readBytes(32))\n\n    // If there is no length, we have zero data.\n    if (length === 0) {\n      // As we have gone wondering, restore to the original position + next slot.\n      cursor.setPosition(staticPosition + 32)\n      return ['0x', 32]\n    }\n\n    const data = cursor.readBytes(length)\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [Hex.fromBytes(data), 32]\n  }\n\n  const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32))\n  return [value, 32]\n}\n\nexport declare namespace decodeBytes {\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeNumber(\n  cursor: Cursor.Cursor,\n  param: AbiParameters.Parameter,\n) {\n  const signed = param.type.startsWith('int')\n  const size = Number.parseInt(param.type.split('int')[1] || '256', 10)\n  const value = cursor.readBytes(32)\n  return [\n    size > 48\n      ? Bytes.toBigInt(value, { signed })\n      : Bytes.toNumber(value, { signed }),\n    32,\n  ]\n}\n\nexport declare namespace decodeNumber {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport type TupleAbiParameter = AbiParameters.Parameter & {\n  components: readonly AbiParameters.Parameter[]\n}\n\n/** @internal */\nexport function decodeTuple(\n  cursor: Cursor.Cursor,\n  param: TupleAbiParameter,\n  options: { checksumAddress?: boolean | undefined; staticPosition: number },\n) {\n  const { checksumAddress, staticPosition } = options\n\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    // Dealing with dynamic types, so get the offset of the tuple data.\n    const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset))\n\n    // Start is the static position of referencing slot + offset.\n    const start = staticPosition + offset\n\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]!\n      cursor.setPosition(start + consumed)\n      const [data, consumed_] = decodeParameter(cursor, component, {\n        checksumAddress,\n        staticPosition: start,\n      })\n      consumed += consumed_\n      value[hasUnnamedChild ? i : component?.name!] = data\n    }\n\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32)\n    return [value, 32]\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]!\n    const [data, consumed_] = decodeParameter(cursor, component, {\n      checksumAddress,\n      staticPosition,\n    })\n    value[hasUnnamedChild ? i : component?.name!] = data\n    consumed += consumed_\n  }\n  return [value, consumed]\n}\n\nexport declare namespace decodeTuple {\n  type ErrorType = Bytes.toNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function decodeString(\n  cursor: Cursor.Cursor,\n  { staticPosition }: { staticPosition: number },\n) {\n  // Get offset to start of string data.\n  const offset = Bytes.toNumber(cursor.readBytes(32))\n\n  // Start is the static position of current slot + offset.\n  const start = staticPosition + offset\n  cursor.setPosition(start)\n\n  const length = Bytes.toNumber(cursor.readBytes(32))\n\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) {\n    cursor.setPosition(staticPosition + 32)\n    return ['', 32]\n  }\n\n  const data = cursor.readBytes(length, 32)\n  const value = Bytes.toString(Bytes.trimLeft(data))\n\n  // As we have gone wondering, restore to the original position + next slot.\n  cursor.setPosition(staticPosition + 32)\n\n  return [value, 32]\n}\n\nexport declare namespace decodeString {\n  type ErrorType =\n    | Bytes.toNumber.ErrorType\n    | Bytes.toString.ErrorType\n    | Bytes.trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameters<\n  const parameters extends AbiParameters.AbiParameters,\n>({\n  checksumAddress,\n  parameters,\n  values,\n}: {\n  checksumAddress?: boolean | undefined\n  parameters: parameters\n  values: parameters extends AbiParameters.AbiParameters\n    ? ToPrimitiveTypes<parameters>\n    : never\n}) {\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameters.length; i++) {\n    preparedParameters.push(\n      prepareParameter({\n        checksumAddress,\n        parameter: parameters[i]!,\n        value: values[i],\n      }),\n    )\n  }\n  return preparedParameters\n}\n\n/** @internal */\nexport declare namespace prepareParameters {\n  type ErrorType = prepareParameter.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function prepareParameter<\n  const parameter extends AbiParameters.Parameter,\n>({\n  checksumAddress = false,\n  parameter: parameter_,\n  value,\n}: {\n  parameter: parameter\n  value: parameter extends AbiParameters.Parameter\n    ? ParameterToPrimitiveType<parameter>\n    : never\n  checksumAddress?: boolean | undefined\n}): PreparedParameter {\n  const parameter = parameter_ as AbiParameters.Parameter\n\n  const arrayComponents = getArrayComponents(parameter.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, {\n      checksumAddress,\n      length,\n      parameter: {\n        ...parameter,\n        type,\n      },\n    })\n  }\n  if (parameter.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      checksumAddress,\n      parameter: parameter as TupleAbiParameter,\n    })\n  }\n  if (parameter.type === 'address') {\n    return encodeAddress(value as unknown as Hex.Hex, {\n      checksum: checksumAddress,\n    })\n  }\n  if (parameter.type === 'bool') {\n    return encodeBoolean(value as unknown as boolean)\n  }\n  if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n    const signed = parameter.type.startsWith('int')\n    const [, , size = '256'] = integerRegex.exec(parameter.type) ?? []\n    return encodeNumber(value as unknown as number, {\n      signed,\n      size: Number(size),\n    })\n  }\n  if (parameter.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex.Hex, { type: parameter.type })\n  }\n  if (parameter.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new AbiParameters.InvalidTypeError(parameter.type)\n}\n\n/** @internal */\nexport declare namespace prepareParameter {\n  type ErrorType =\n    | encodeArray.ErrorType\n    | encodeTuple.ErrorType\n    | encodeAddress.ErrorType\n    | encodeBoolean.ErrorType\n    | encodeBytes.ErrorType\n    | encodeString.ErrorType\n    | AbiParameters.InvalidTypeError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encode(preparedParameters: PreparedParameter[]): Hex.Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) staticSize += 32\n    else staticSize += Hex.size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParameters: Hex.Hex[] = []\n  const dynamicParameters: Hex.Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParameters.length; i++) {\n    const { dynamic, encoded } = preparedParameters[i]!\n    if (dynamic) {\n      staticParameters.push(\n        Hex.fromNumber(staticSize + dynamicSize, { size: 32 }),\n      )\n      dynamicParameters.push(encoded)\n      dynamicSize += Hex.size(encoded)\n    } else {\n      staticParameters.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return Hex.concat(...staticParameters, ...dynamicParameters)\n}\n\n/** @internal */\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeAddress(\n  value: Hex.Hex,\n  options: { checksum: boolean },\n): PreparedParameter {\n  const { checksum = false } = options\n  Address.assert(value, { strict: checksum })\n  return {\n    dynamic: false,\n    encoded: Hex.padLeft(value.toLowerCase() as Hex.Hex),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeAddress {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | Hex.padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeArray<const parameter extends AbiParameters.Parameter>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    length: number | null\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, length, parameter } = options\n\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new AbiParameters.InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiParameters.ArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${parameter.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter,\n      value: value[i],\n    })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParameters.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encode(preparedParameters)\n    if (dynamic) {\n      const length = Hex.fromNumber(preparedParameters.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded:\n          preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeArray {\n  type ErrorType =\n    | AbiParameters.InvalidArrayError\n    | AbiParameters.ArrayLengthMismatchError\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBytes(\n  value: Hex.Hex,\n  { type }: { type: string },\n): PreparedParameter {\n  const [, parametersize] = type.split('bytes')\n  const bytesSize = Hex.size(value)\n  if (!parametersize) {\n    let value_ = value\n    // If the size is not divisible by 32 bytes, pad the end\n    // with empty bytes to the ceiling 32 bytes.\n    if (bytesSize % 32 !== 0)\n      value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32)\n    return {\n      dynamic: true,\n      encoded: Hex.concat(\n        Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })),\n        value_,\n      ),\n    }\n  }\n  if (bytesSize !== Number.parseInt(parametersize, 10))\n    throw new AbiParameters.BytesSizeMismatchError({\n      expectedSize: Number.parseInt(parametersize, 10),\n      value,\n    })\n  return { dynamic: false, encoded: Hex.padRight(value) }\n}\n\n/** @internal */\nexport declare namespace encodeBytes {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeBoolean(value: boolean): PreparedParameter {\n  if (typeof value !== 'boolean')\n    throw new Errors.BaseError(\n      `Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`,\n    )\n  return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) }\n}\n\n/** @internal */\nexport declare namespace encodeBoolean {\n  type ErrorType =\n    | Hex.padLeft.ErrorType\n    | Hex.fromBoolean.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeNumber(\n  value: number,\n  { signed, size }: { signed: boolean; size: number },\n): PreparedParameter {\n  if (typeof size === 'number') {\n    const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n\n    const min = signed ? -max - 1n : 0n\n    if (value > max || value < min)\n      throw new Hex.IntegerOutOfRangeError({\n        max: max.toString(),\n        min: min.toString(),\n        signed,\n        size: size / 8,\n        value: value.toString(),\n      })\n  }\n  return {\n    dynamic: false,\n    encoded: Hex.fromNumber(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeNumber {\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeString(value: string): PreparedParameter {\n  const hexValue = Hex.fromString(value)\n  const partsLength = Math.ceil(Hex.size(hexValue) / 32)\n  const parts: Hex.Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)))\n  }\n  return {\n    dynamic: true,\n    encoded: Hex.concat(\n      Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })),\n      ...parts,\n    ),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeString {\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Hex.padRight.ErrorType\n    | Hex.slice.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeTuple<\n  const parameter extends AbiParameters.Parameter & {\n    components: readonly AbiParameters.Parameter[]\n  },\n>(\n  value: ParameterToPrimitiveType<parameter>,\n  options: {\n    checksumAddress?: boolean | undefined\n    parameter: parameter\n  },\n): PreparedParameter {\n  const { checksumAddress, parameter } = options\n\n  let dynamic = false\n  const preparedParameters: PreparedParameter[] = []\n  for (let i = 0; i < parameter.components.length; i++) {\n    const param_ = parameter.components[i]!\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParameter({\n      checksumAddress,\n      parameter: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParameters.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encode(preparedParameters)\n      : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n  }\n}\n\n/** @internal */\nexport declare namespace encodeTuple {\n  type ErrorType = Hex.concat.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2]! ? Number(matches[2]!) : null, matches[1]!]\n    : undefined\n}\n\n/** @internal */\nexport function hasDynamicChild(param: AbiParameters.Parameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({\n      ...param,\n      type: arrayComponents[1],\n    } as AbiParameters.Parameter)\n  )\n    return true\n\n  return false\n}\n","import type { Bytes } from '../Bytes.js'\nimport * as Errors from '../Errors.js'\n\n/** @internal */\nexport type Cursor = {\n  bytes: Bytes\n  dataView: DataView\n  position: number\n  positionReadCount: Map<number, number>\n  recursiveReadCount: number\n  recursiveReadLimit: number\n  remaining: number\n  assertReadLimit(position?: number): void\n  assertPosition(position: number): void\n  decrementPosition(offset: number): void\n  getReadCount(position?: number): number\n  incrementPosition(offset: number): void\n  inspectByte(position?: number): Bytes[number]\n  inspectBytes(length: number, position?: number): Bytes\n  inspectUint8(position?: number): number\n  inspectUint16(position?: number): number\n  inspectUint24(position?: number): number\n  inspectUint32(position?: number): number\n  pushByte(byte: Bytes[number]): void\n  pushBytes(bytes: Bytes): void\n  pushUint8(value: number): void\n  pushUint16(value: number): void\n  pushUint24(value: number): void\n  pushUint32(value: number): void\n  readByte(): Bytes[number]\n  readBytes(length: number, size?: number): Bytes\n  readUint8(): number\n  readUint16(): number\n  readUint24(): number\n  readUint32(): number\n  setPosition(position: number): () => void\n  _touch(): void\n}\n\nconst staticCursor: Cursor = {\n  bytes: new Uint8Array(),\n  dataView: new DataView(new ArrayBuffer(0)),\n  position: 0,\n  positionReadCount: new Map(),\n  recursiveReadCount: 0,\n  recursiveReadLimit: Number.POSITIVE_INFINITY,\n  assertReadLimit() {\n    if (this.recursiveReadCount >= this.recursiveReadLimit)\n      throw new RecursiveReadLimitExceededError({\n        count: this.recursiveReadCount + 1,\n        limit: this.recursiveReadLimit,\n      })\n  },\n  assertPosition(position) {\n    if (position < 0 || position > this.bytes.length - 1)\n      throw new PositionOutOfBoundsError({\n        length: this.bytes.length,\n        position,\n      })\n  },\n  decrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position - offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  getReadCount(position) {\n    return this.positionReadCount.get(position || this.position) || 0\n  },\n  incrementPosition(offset) {\n    if (offset < 0) throw new NegativeOffsetError({ offset })\n    const position = this.position + offset\n    this.assertPosition(position)\n    this.position = position\n  },\n  inspectByte(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]!\n  },\n  inspectBytes(length, position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + length - 1)\n    return this.bytes.subarray(position, position + length)\n  },\n  inspectUint8(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position)\n    return this.bytes[position]!\n  },\n  inspectUint16(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 1)\n    return this.dataView.getUint16(position)\n  },\n  inspectUint24(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 2)\n    return (\n      (this.dataView.getUint16(position) << 8) +\n      this.dataView.getUint8(position + 2)\n    )\n  },\n  inspectUint32(position_) {\n    const position = position_ ?? this.position\n    this.assertPosition(position + 3)\n    return this.dataView.getUint32(position)\n  },\n  pushByte(byte: Bytes[number]) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = byte\n    this.position++\n  },\n  pushBytes(bytes: Bytes) {\n    this.assertPosition(this.position + bytes.length - 1)\n    this.bytes.set(bytes, this.position)\n    this.position += bytes.length\n  },\n  pushUint8(value: number) {\n    this.assertPosition(this.position)\n    this.bytes[this.position] = value\n    this.position++\n  },\n  pushUint16(value: number) {\n    this.assertPosition(this.position + 1)\n    this.dataView.setUint16(this.position, value)\n    this.position += 2\n  },\n  pushUint24(value: number) {\n    this.assertPosition(this.position + 2)\n    this.dataView.setUint16(this.position, value >> 8)\n    this.dataView.setUint8(this.position + 2, value & ~4294967040)\n    this.position += 3\n  },\n  pushUint32(value: number) {\n    this.assertPosition(this.position + 3)\n    this.dataView.setUint32(this.position, value)\n    this.position += 4\n  },\n  readByte() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectByte()\n    this.position++\n    return value\n  },\n  readBytes(length, size) {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectBytes(length)\n    this.position += size ?? length\n    return value\n  },\n  readUint8() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint8()\n    this.position += 1\n    return value\n  },\n  readUint16() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint16()\n    this.position += 2\n    return value\n  },\n  readUint24() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint24()\n    this.position += 3\n    return value\n  },\n  readUint32() {\n    this.assertReadLimit()\n    this._touch()\n    const value = this.inspectUint32()\n    this.position += 4\n    return value\n  },\n  get remaining() {\n    return this.bytes.length - this.position\n  },\n  setPosition(position) {\n    const oldPosition = this.position\n    this.assertPosition(position)\n    this.position = position\n    return () => (this.position = oldPosition)\n  },\n  _touch() {\n    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return\n    const count = this.getReadCount()\n    this.positionReadCount.set(this.position, count + 1)\n    if (count > 0) this.recursiveReadCount++\n  },\n}\n\n/** @internal */\nexport function create(\n  bytes: Bytes,\n  { recursiveReadLimit = 8_192 }: create.Config = {},\n): Cursor {\n  const cursor: Cursor = Object.create(staticCursor)\n  cursor.bytes = bytes\n  cursor.dataView = new DataView(\n    bytes.buffer,\n    bytes.byteOffset,\n    bytes.byteLength,\n  )\n  cursor.positionReadCount = new Map()\n  cursor.recursiveReadLimit = recursiveReadLimit\n  return cursor\n}\n\n/** @internal */\nexport declare namespace create {\n  type Config = { recursiveReadLimit?: number | undefined }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport class NegativeOffsetError extends Errors.BaseError {\n  override readonly name = 'Cursor.NegativeOffsetError'\n\n  constructor({ offset }: { offset: number }) {\n    super(`Offset \\`${offset}\\` cannot be negative.`)\n  }\n}\n\n/** @internal */\nexport class PositionOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Cursor.PositionOutOfBoundsError'\n\n  constructor({ length, position }: { length: number; position: number }) {\n    super(\n      `Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`,\n    )\n  }\n}\n\n/** @internal */\nexport class RecursiveReadLimitExceededError extends Errors.BaseError {\n  override readonly name = 'Cursor.RecursiveReadLimitExceededError'\n\n  constructor({ count, limit }: { count: number; limit: number }) {\n    super(\n      `Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`,\n    )\n  }\n}\n","import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Cursor from './internal/cursor.js'\nimport type { ExactPartial, RecursiveArray } from './internal/types.js'\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nexport function toBytes(\n  value: Bytes.Bytes | Hex.Hex,\n): RecursiveArray<Bytes.Bytes> {\n  return to(value, 'Bytes')\n}\n\nexport declare namespace toBytes {\n  type ErrorType = to.ErrorType\n}\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value: Bytes.Bytes | Hex.Hex): RecursiveArray<Hex.Hex> {\n  return to(value, 'Hex')\n}\n\nexport declare namespace toHex {\n  type ErrorType = to.ErrorType\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport function to<\n  value extends Bytes.Bytes | Hex.Hex,\n  to extends 'Hex' | 'Bytes',\n>(value: value, to: to | 'Hex' | 'Bytes'): to.ReturnType<to> {\n  const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes')\n\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0)\n        throw new Hex.InvalidLengthError(value)\n      return Bytes.fromHex(value)\n    }\n    return value as Bytes.Bytes\n  })()\n\n  const cursor = Cursor.create(bytes, {\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n  })\n  const result = decodeRlpCursor(cursor, to_)\n\n  return result as to.ReturnType<to>\n}\n\n/** @internal */\nexport declare namespace to {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (to extends 'Bytes' ? RecursiveArray<Bytes.Bytes> : never)\n    | (to extends 'Hex' ? RecursiveArray<Hex.Hex> : never)\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | decodeRlpCursor.ErrorType\n    | Cursor.create.ErrorType\n    | Hex.InvalidLengthError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\n\n/** @internal */\nexport function decodeRlpCursor<to extends 'Hex' | 'Bytes' = 'Hex'>(\n  cursor: Cursor.Cursor,\n  to: to | 'Hex' | 'Bytes' | undefined = 'Hex',\n): decodeRlpCursor.ReturnType<to> {\n  if (cursor.bytes.length === 0)\n    return (\n      to === 'Hex' ? Hex.fromBytes(cursor.bytes) : cursor.bytes\n    ) as decodeRlpCursor.ReturnType<to>\n\n  const prefix = cursor.readByte()\n  if (prefix < 0x80) cursor.decrementPosition(1)\n\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80)\n    const bytes = cursor.readBytes(length)\n    return (\n      to === 'Hex' ? Hex.fromBytes(bytes) : bytes\n    ) as decodeRlpCursor.ReturnType<to>\n  }\n\n  // list\n  const length = readLength(cursor, prefix, 0xc0)\n  return readList(cursor, length, to) as {} as decodeRlpCursor.ReturnType<to>\n}\n\n/** @internal */\nexport declare namespace decodeRlpCursor {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex'> = to.ReturnType<to>\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | readLength.ErrorType\n    | readList.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function readLength(\n  cursor: Cursor.Cursor,\n  prefix: number,\n  offset: number,\n) {\n  if (offset === 0x80 && prefix < 0x80) return 1\n  if (prefix <= offset + 55) return prefix - offset\n  if (prefix === offset + 55 + 1) return cursor.readUint8()\n  if (prefix === offset + 55 + 2) return cursor.readUint16()\n  if (prefix === offset + 55 + 3) return cursor.readUint24()\n  if (prefix === offset + 55 + 4) return cursor.readUint32()\n  throw new Errors.BaseError('Invalid RLP prefix')\n}\n\n/** @internal */\nexport declare namespace readLength {\n  type ErrorType = Errors.BaseError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function readList<to extends 'Hex' | 'Bytes'>(\n  cursor: Cursor.Cursor,\n  length: number,\n  to: to | 'Hex' | 'Bytes',\n) {\n  const position = cursor.position\n  const value: decodeRlpCursor.ReturnType<to>[] = []\n  while (cursor.position - position < length)\n    value.push(decodeRlpCursor(cursor, to))\n  return value\n}\n\n/** @internal */\nexport declare namespace readList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor.Cursor): void\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function from<as extends 'Hex' | 'Bytes'>(\n  value: RecursiveArray<Bytes.Bytes> | RecursiveArray<Hex.Hex>,\n  options: from.Options<as>,\n): from.ReturnType<as> {\n  const { as } = options\n\n  const encodable = getEncodable(value)\n  const cursor = Cursor.create(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (as === 'Hex') return Hex.fromBytes(cursor.bytes) as from.ReturnType<as>\n  return cursor.bytes as from.ReturnType<as>\n}\n\nexport declare namespace from {\n  type Options<as extends 'Hex' | 'Bytes'> = {\n    /** The type to convert the RLP value to. */\n    as: as | 'Hex' | 'Bytes'\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Cursor.create.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromBytes<as extends 'Hex' | 'Bytes' = 'Bytes'>(\n  bytes: RecursiveArray<Bytes.Bytes>,\n  options: fromBytes.Options<as> = {},\n): fromBytes.ReturnType<as> {\n  const { as = 'Bytes' } = options\n  return from(bytes, { as }) as never\n}\n\nexport declare namespace fromBytes {\n  type Options<as extends 'Hex' | 'Bytes' = 'Bytes'> = ExactPartial<\n    from.Options<as>\n  >\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Bytes'> = from.ReturnType<as>\n\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nexport function fromHex<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  hex: RecursiveArray<Hex.Hex>,\n  options: fromHex.Options<as> = {},\n): fromHex.ReturnType<as> {\n  const { as = 'Hex' } = options\n  return from(hex, { as }) as never\n}\n\nexport declare namespace fromHex {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = ExactPartial<\n    from.Options<as>\n  >\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = from.ReturnType<as>\n\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n\nfunction getEncodable(\n  bytes: RecursiveArray<Bytes.Bytes> | RecursiveArray<Hex.Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor.Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: Bytes.Bytes | Hex.Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? Bytes.fromHex(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0]! < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor.Cursor) {\n      if (bytes.length === 1 && bytes[0]! < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new Errors.BaseError('Length is too large.')\n}\n","export const entryPoint06Address =\n  '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789' as const\nexport const entryPoint07Address =\n  '0x0000000071727De22E5E9d8BAf0edAc6f37da032' as const\nexport const entryPoint08Address =\n  '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108' as const\n\nexport const ethAddress = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' as const\n\nexport const zeroAddress = '0x0000000000000000000000000000000000000000' as const\n","import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiFunction.js'\nimport type * as AbiItem_internal from './internal/abiItem.js'\nimport type * as AbiParameters_internal from './internal/abiParameters.js'\nimport type { IsNarrowable } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with a `function` type. */\nexport type AbiFunction = abitype.AbiFunction & {\n  hash?: Hex.Hex | undefined\n  overloads?: readonly AbiFunction[] | undefined\n}\n\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo(string)',\n *   'function bar(uint256)',\n * ])\n *\n * type Foo = AbiFunction.FromAbi<typeof abi, 'foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = abitype.ExtractAbiFunction<abi, name>\n\n/**\n * Extracts the names of all {@link ox#AbiFunction.AbiFunction} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo(string)',\n *   'function bar(uint256)',\n * ])\n *\n * type names = AbiFunction.Name<typeof abi>\n * //   ^?\n *\n *\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<\n  abi extends Abi.Abi,\n  abiStateMutability extends\n    abitype.AbiStateMutability = abitype.AbiStateMutability,\n> = abitype.ExtractAbiFunctionNames<abi, abiStateMutability>\n\n/**\n * ABI-decodes function arguments according to the ABI Item's input types (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n *\n * const input = AbiFunction.decodeData(approve, data) // [!code focus]\n * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object and a function name as parameters to {@link ox#AbiFunction.(decodeData:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([...])\n * const data = '0x...\n *\n * const input = AbiFunction.decodeData(\n *   abi, // [!code focus]\n *   'approve', // [!code focus]\n *   data\n * )\n * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * ```\n *\n * @param abiFunction - The ABI Item to decode.\n * @param data - The data to decode.\n */\nexport function decodeData<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  abiFunction extends AbiFunction = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiFunction\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  data: Hex.Hex,\n): decodeData.ReturnType<abiFunction>\nexport function decodeData<const abiItem extends AbiFunction>(\n  abiFunction: abiItem | AbiFunction,\n  data: Hex.Hex,\n): decodeData.ReturnType<abiItem>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decodeData(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], name: Hex.Hex | string, data: Hex.Hex]\n    | [abiFunction: AbiFunction, data: Hex.Hex]\n) {\n  const [abiFunction, data] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, data] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        Hex.Hex,\n      ]\n      return [fromAbi(abi, name), data]\n    }\n    return parameters as [AbiFunction, Hex.Hex]\n  })()\n\n  const { overloads } = abiFunction\n\n  if (Hex.size(data) < 4) throw new AbiItem.InvalidSelectorSizeError({ data })\n  if (abiFunction.inputs.length === 0) return undefined\n\n  const item = overloads\n    ? fromAbi([abiFunction, ...overloads], data as never)\n    : abiFunction\n\n  if (Hex.size(data) <= 4) return undefined\n  return AbiParameters.decode(item.inputs, Hex.slice(data, 4))\n}\n\nexport declare namespace decodeData {\n  type ReturnType<abiFunction extends AbiFunction = AbiFunction> = IsNarrowable<\n    abiFunction,\n    AbiFunction\n  > extends true\n    ? abiFunction['inputs'] extends readonly []\n      ? undefined\n      :\n          | AbiParameters_internal.ToPrimitiveTypes<abiFunction['inputs']>\n          | (abiFunction['overloads'] extends readonly AbiFunction[]\n              ? AbiParameters_internal.ToPrimitiveTypes<\n                  abiFunction['overloads'][number]['inputs']\n                >\n              : never)\n    : unknown\n\n  type ErrorType =\n    | fromAbi.ErrorType\n    | AbiParameters.decode.ErrorType\n    | Hex.size.ErrorType\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * ABI-decodes a function's result according to the ABI Item's output types (`outputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function return values (e.g. the response of an `eth_call` or the `input` property of a Transaction).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const totalSupply = AbiFunction.fromAbi(erc20Abi, 'totalSupply') // [!code hl]\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object and a function name as parameters to {@link ox#AbiFunction.(decodeResult:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const erc20Abi = Abi.from([...])\n *\n * const output = AbiFunction.decodeResult(\n *   erc20Abi, // [!code focus]\n *   'totalSupply', // [!code focus]\n *   data\n * )\n * // @log: 42n\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.decodeResult` to decode the result of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   balanceOf,\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B']\n * )\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output. // [!code focus]\n * const balance = AbiFunction.decodeResult(balanceOf, response) // [!code focus]\n * // @log: 42n\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to decode\n * @param data - ABI-encoded function output\n * @param options - Decoding options\n * @returns Decoded function output\n */\nexport function decodeResult<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  abiFunction extends AbiFunction = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiFunction\n  >,\n  allNames = Name<abi>,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  data: Hex.Hex,\n  options?: decodeResult.Options<as> | undefined,\n): decodeResult.ReturnType<abiFunction, as>\nexport function decodeResult<\n  const abiFunction extends AbiFunction,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiFunction: abiFunction | AbiFunction,\n  data: Hex.Hex,\n  options?: decodeResult.Options<as> | undefined,\n): decodeResult.ReturnType<abiFunction, as>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decodeResult(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        data: Hex.Hex,\n        options?: decodeResult.Options | undefined,\n      ]\n    | [\n        abiFunction: AbiFunction,\n        data: Hex.Hex,\n        options?: decodeResult.Options | undefined,\n      ]\n) {\n  const [abiFunction, data, options = {}] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, data, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        Hex.Hex,\n        decodeResult.Options | undefined,\n      ]\n      return [fromAbi(abi, name), data, options]\n    }\n    return parameters as [\n      AbiFunction,\n      Hex.Hex,\n      decodeResult.Options | undefined,\n    ]\n  })()\n\n  const values = AbiParameters.decode(abiFunction.outputs, data, options)\n  if (values && Object.keys(values).length === 0) return undefined\n  if (values && Object.keys(values).length === 1) {\n    if (Array.isArray(values)) return values[0]\n    return Object.values(values)[0]\n  }\n  return values\n}\n\nexport declare namespace decodeResult {\n  type Options<as extends 'Object' | 'Array' = 'Array'> = {\n    /**\n     * Whether the decoded values should be returned as an `Object` or `Array`.\n     *\n     * @default \"Array\"\n     */\n    as?: as | 'Array' | 'Object' | undefined\n  }\n\n  type ReturnType<\n    abiFunction extends AbiFunction = AbiFunction,\n    as extends 'Object' | 'Array' = 'Array',\n  > = IsNarrowable<abiFunction, AbiFunction> extends true\n    ? abiFunction['outputs'] extends readonly []\n      ? undefined\n      : abiFunction['outputs'] extends readonly [\n            infer type extends abitype.AbiParameter,\n          ]\n        ? abitype.AbiParameterToPrimitiveType<type>\n        : AbiParameters.decode.ReturnType<\n              abiFunction['outputs'],\n              as\n            > extends infer types\n          ? types extends readonly []\n            ? undefined\n            : types extends readonly [infer type]\n              ? type\n              : types\n          : never\n    : unknown\n\n  type ErrorType = AbiParameters.decode.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes function arguments (`inputs`), prefixed with the 4 byte function selector.\n *\n * :::tip\n *\n * This function is typically used to encode a contract function and its arguments for contract calls (e.g. `data` parameter of an `eth_call` or `eth_sendTransaction`).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const approve = AbiFunction.fromAbi(erc20Abi, 'approve') // [!code hl]\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can specify an entire ABI object and a function name as parameters to {@link ox#AbiFunction.(encodeData:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const erc20Abi = Abi.from([...])\n *\n * const data = AbiFunction.encodeData(\n *   erc20Abi, // [!code focus]\n *   'approve', // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.encodeData` to encode the input of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input. // [!code focus]\n * const data = AbiFunction.encodeData( // [!code focus]\n *   balanceOf, // [!code focus]\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B'] // [!code focus]\n * ) // [!code focus]\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output.\n * const balance = AbiFunction.decodeResult(balanceOf, response)\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to encode\n * @param args - Function arguments\n * @returns ABI-encoded function name and arguments\n */\nexport function encodeData<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  abiFunction extends AbiFunction = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiFunction\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  ...args: encodeData.Args<abiFunction>\n): Hex.Hex\nexport function encodeData<const abiFunction extends AbiFunction>(\n  abiFunction: abiFunction | AbiFunction,\n  ...args: encodeData.Args<abiFunction>\n): Hex.Hex\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encodeData(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        ...args: readonly unknown[],\n      ]\n    | [abiFunction: AbiFunction, ...args: readonly unknown[]]\n) {\n  const [abiFunction, args = []] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, args] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        readonly unknown[],\n      ]\n      return [fromAbi(abi, name, { args }), args]\n    }\n    const [abiFunction, args] = parameters as [AbiFunction, readonly unknown[]]\n    return [abiFunction, args]\n  })()\n\n  const { overloads } = abiFunction\n\n  const item = overloads\n    ? (fromAbi([abiFunction as AbiFunction, ...overloads], abiFunction.name, {\n        args,\n      }) as AbiFunction)\n    : abiFunction\n\n  const selector = getSelector(item)\n\n  const data =\n    args.length > 0 ? AbiParameters.encode(item.inputs, args) : undefined\n\n  return data ? Hex.concat(selector, data) : selector\n}\n\nexport declare namespace encodeData {\n  type Args<abiFunction extends AbiFunction = AbiFunction> = IsNarrowable<\n    abiFunction,\n    AbiFunction\n  > extends true\n    ?\n        | (abitype.AbiParametersToPrimitiveTypes<\n            abiFunction['inputs']\n          > extends readonly []\n            ? []\n            : [abitype.AbiParametersToPrimitiveTypes<abiFunction['inputs']>])\n        | (abiFunction['overloads'] extends readonly AbiFunction[]\n            ? [\n                abitype.AbiParametersToPrimitiveTypes<\n                  abiFunction['overloads'][number]['inputs']\n                >,\n              ]\n            : [])\n    : readonly unknown[]\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes a function's result (`outputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n * const output = AbiFunction.decodeResult(totalSupply, '0x000000000000000000000000000000000000000000000000000000000000002a')\n * // 42n\n *\n * const data = AbiFunction.encodeResult(totalSupply, 42n) // [!code focus]\n * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object and a function name as parameters to {@link ox#AbiFunction.(encodeResult:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiFunction.encodeResult(\n *   abi, // [!code focus]\n *   'totalSupply', // [!code focus]\n *   42n\n * )\n * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'\n * ```\n *\n * @param abiFunction - The ABI item to encode the function output for.\n * @param output - The function output to encode.\n * @param options - Encoding options.\n * @returns The encoded function output.\n */\nexport function encodeResult<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  as extends 'Object' | 'Array' = 'Array',\n  //\n  abiFunction extends AbiFunction = AbiItem.fromAbi.ReturnType<\n    abi,\n    name,\n    args,\n    AbiFunction\n  >,\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  output: encodeResult.Output<abiFunction, as>,\n  options?: encodeResult.Options<as>,\n): Hex.Hex\nexport function encodeResult<\n  const abiFunction extends AbiFunction,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiFunction: abiFunction | AbiFunction,\n  output: encodeResult.Output<abiFunction, as>,\n  options?: encodeResult.Options<as>,\n): Hex.Hex\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encodeResult(\n  ...parameters:\n    | [\n        abi: Abi.Abi | readonly unknown[],\n        name: Hex.Hex | string,\n        output: any,\n        options?: encodeResult.Options<any> | undefined,\n      ]\n    | [\n        abiFunction: AbiFunction,\n        output: any,\n        options?: encodeResult.Options<any> | undefined,\n      ]\n) {\n  const [abiFunction, output, options = {}] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, name, output, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        Hex.Hex | string,\n        any,\n        encodeResult.Options<any> | undefined,\n      ]\n      return [fromAbi(abi, name), output, options]\n    }\n    return parameters as [\n      AbiFunction,\n      any,\n      encodeResult.Options<any> | undefined,\n    ]\n  })()\n\n  const { as = 'Array' } = options\n\n  const values = (() => {\n    if (abiFunction.outputs.length === 1) return [output]\n    if (Array.isArray(output)) return output\n    if (as === 'Object') return Object.values(output as any)\n    return [output]\n  })()\n\n  return AbiParameters.encode(abiFunction.outputs, values)\n}\n\nexport declare namespace encodeResult {\n  type Output<\n    abiFunction extends AbiFunction = AbiFunction,\n    as extends 'Object' | 'Array' = 'Array',\n  > = abiFunction['outputs'] extends readonly []\n    ? never\n    : abiFunction['outputs']['length'] extends 1\n      ? AbiParameters_internal.ToPrimitiveTypes<abiFunction['outputs']>[0]\n      : as extends 'Object'\n        ? AbiParameters_internal.ToObject<abiFunction['outputs']>\n        : AbiParameters_internal.ToPrimitiveTypes<abiFunction['outputs']>\n\n  type Options<as extends 'Object' | 'Array'> = {\n    as?: as | 'Object' | 'Array' | undefined\n  }\n\n  type ErrorType = AbiParameters.encode.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nexport function format<const abiFunction extends AbiFunction>(\n  abiFunction: abiFunction | AbiFunction,\n): abitype.FormatAbiItem<abiFunction> {\n  return abitype.formatAbiItem(abiFunction) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nexport function from<\n  const abiFunction extends AbiFunction | string | readonly string[],\n>(\n  abiFunction: (abiFunction | AbiFunction | string | readonly string[]) &\n    (\n      | (abiFunction extends string ? internal.Signature<abiFunction> : never)\n      | (abiFunction extends readonly string[]\n          ? internal.Signatures<abiFunction>\n          : never)\n      | AbiFunction\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiFunction> {\n  return AbiItem.from(abiFunction as AbiFunction, options) as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted function (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<\n    abiFunction extends AbiFunction | string | readonly string[],\n  > = AbiItem.from.ReturnType<abiFunction>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: AbiItem.fromAbi.Options<\n    abi,\n    name,\n    args,\n    AbiItem_internal.ExtractArgs<abi, name>\n  >,\n): AbiItem.fromAbi.ReturnType<abi, name, args, AbiFunction> {\n  const item = AbiItem.fromAbi(abi, name, options as any)\n  if (item.type !== 'function')\n    throw new AbiItem.NotFoundError({ name, type: 'function' })\n  return item as never\n}\n\nexport declare namespace fromAbi {\n  type ErrorType = AbiItem.fromAbi.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nexport function getSelector(abiItem: string | AbiFunction): Hex.Hex {\n  return AbiItem.getSelector(abiItem)\n}\n\nexport declare namespace getSelector {\n  type ErrorType = AbiItem.getSelector.ErrorType | Errors.GlobalErrorType\n}\n","import type * as Abi from '../core/Abi.js'\nimport * as AbiParameters from '../core/AbiParameters.js'\nimport type * as Address from '../core/Address.js'\nimport * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport type * as Signature from '../core/Signature.js'\n\n/** Unwrapped ERC-6492 signature. */\nexport type Unwrapped = {\n  /** Calldata to pass to the target address for counterfactual verification. */\n  data: Hex.Hex\n  /** The original signature. */\n  signature: Hex.Hex\n  /** The target address to use for counterfactual verification. */\n  to: Address.Address\n}\n\n/** Wrapped ERC-6492 signature. */\nexport type Wrapped = Hex.Hex\n\n/**\n * Magic bytes used to identify ERC-6492 wrapped signatures.\n */\nexport const magicBytes =\n  '0x6492649264926492649264926492649264926492649264926492649264926492' as const\n\n/**\n * Deployless ERC-6492 signature verification bytecode.\n */\nexport const universalSignatureValidatorBytecode =\n  '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572'\n\n/**\n * ABI for the ERC-6492 universal deployless signature validator contract.\n *\n * Constructor return value is `0x1` (valid) or `0x0` (invalid).\n */\nexport const universalSignatureValidatorAbi = [\n  {\n    inputs: [\n      {\n        name: '_signer',\n        type: 'address',\n      },\n      {\n        name: '_hash',\n        type: 'bytes32',\n      },\n      {\n        name: '_signature',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n  {\n    inputs: [\n      {\n        name: '_signer',\n        type: 'address',\n      },\n      {\n        name: '_hash',\n        type: 'bytes32',\n      },\n      {\n        name: '_signature',\n        type: 'bytes',\n      },\n    ],\n    outputs: [\n      {\n        type: 'bool',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n    name: 'isValidSig',\n  },\n] as const satisfies Abi.Abi\n\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * SignatureErc6492.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-6492 wrapped signature.\n * ```\n *\n * @param wrapped - The wrapped signature to assert.\n */\nexport function assert(wrapped: Wrapped) {\n  if (Hex.slice(wrapped, -32) !== magicBytes)\n    throw new InvalidWrappedSignatureError(wrapped)\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | InvalidWrappedSignatureError\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc6492.from('0x...') // [!code focus]\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc6492.from({ // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n *   to: '0x...', // [!code focus]\n * })\n * // @log: { data: '0x...', signature: { ... }, to: '0x...', }\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function from(wrapped: Unwrapped | Wrapped): Unwrapped {\n  if (typeof wrapped === 'string') return unwrap(wrapped)\n  return wrapped\n}\n\nexport declare namespace from {\n  type ReturnType = Unwrapped\n\n  type ErrorType =\n    | AbiParameters.from.ErrorType\n    | AbiParameters.decode.ErrorType\n    | Signature.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const { data, signature, to } = SignatureErc6492.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to parse.\n * @returns Wrapped signature.\n */\nexport function unwrap(wrapped: Wrapped): Unwrapped {\n  assert(wrapped)\n\n  const [to, data, signature] = AbiParameters.decode(\n    AbiParameters.from('address, bytes, bytes'),\n    wrapped,\n  )\n\n  return { data, signature, to }\n}\n\nexport declare namespace unwrap {\n  type ErrorType =\n    | AbiParameters.from.ErrorType\n    | AbiParameters.decode.ErrorType\n    | Signature.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes an [ERC-6492 wrapped signature](https://eips.ethereum.org/EIPS/eip-6492#specification).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc6492 } from 'ox/erc6492' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc6492.wrap({ // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n *   to: '0x00000000219ab540356cBB839Cbe05303d7705Fa', // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Wrapped signature to serialize.\n * @returns Serialized wrapped signature.\n */\nexport function wrap(value: Unwrapped): Wrapped {\n  const { data, signature, to } = value\n\n  return Hex.concat(\n    AbiParameters.encode(AbiParameters.from('address, bytes, bytes'), [\n      to,\n      data,\n      signature,\n    ]),\n    magicBytes,\n  )\n}\n\nexport declare namespace wrap {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hex.concat.ErrorType\n    | Signature.toHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc6492 } from 'ox/erc6492'\n *\n * const valid = SignatureErc6492.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param wrapped - The wrapped signature to validate.\n * @returns `true` if the wrapped signature is valid, `false` otherwise.\n */\nexport function validate(wrapped: Wrapped): boolean {\n  try {\n    assert(wrapped)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** Thrown when the ERC-6492 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n  override readonly name = 'SignatureErc6492.InvalidWrappedSignatureError'\n\n  constructor(wrapped: Wrapped) {\n    super(`Value \\`${wrapped}\\` is an invalid ERC-6492 wrapped signature.`)\n  }\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, ExactPartial, OneOf } from './internal/types.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\n\n/** Root type for an ECDSA signature. */\nexport type Signature<\n  recovered extends boolean = true,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  recovered extends true\n    ? {\n        r: bigintType\n        s: bigintType\n        yParity: numberType\n      }\n    : {\n        r: bigintType\n        s: bigintType\n        yParity?: numberType | undefined\n      }\n>\n\n/** RPC-formatted ECDSA signature. */\nexport type Rpc<recovered extends boolean = true> = Signature<\n  recovered,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/** (Legacy) ECDSA signature. */\nexport type Legacy<bigintType = bigint, numberType = number> = {\n  r: bigintType\n  s: bigintType\n  v: numberType\n}\n\n/** RPC-formatted (Legacy) ECDSA signature. */\nexport type LegacyRpc = Legacy<Hex.Hex, Hex.Hex>\n\nexport type Tuple = readonly [yParity: Hex.Hex, r: Hex.Hex, s: Hex.Hex]\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(\n  signature: ExactPartial<Signature>,\n  options: assert.Options = {},\n): asserts signature is Signature {\n  const { recovered } = options\n  if (typeof signature.r === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (typeof signature.s === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (recovered && typeof signature.yParity === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (signature.r < 0n || signature.r > Solidity.maxUint256)\n    throw new InvalidRError({ value: signature.r })\n  if (signature.s < 0n || signature.s > Solidity.maxUint256)\n    throw new InvalidSError({ value: signature.s })\n  if (\n    typeof signature.yParity === 'number' &&\n    signature.yParity !== 0 &&\n    signature.yParity !== 1\n  )\n    throw new InvalidYParityError({ value: signature.yParity })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType =\n    | MissingPropertiesError\n    | InvalidRError\n    | InvalidSError\n    | InvalidYParityError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature: Bytes.Bytes): Signature {\n  return fromHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature: Hex.Hex): Signature {\n  if (signature.length !== 130 && signature.length !== 132)\n    throw new InvalidSerializedSizeError({ signature })\n\n  const r = BigInt(Hex.slice(signature, 0, 32))\n  const s = BigInt(Hex.slice(signature, 32, 64))\n\n  const yParity = (() => {\n    const yParity = Number(`0x${signature.slice(130)}`)\n    if (Number.isNaN(yParity)) return undefined\n    try {\n      return vToYParity(yParity)\n    } catch {\n      throw new InvalidYParityError({ value: yParity })\n    }\n  })()\n\n  if (typeof yParity === 'undefined')\n    return {\n      r,\n      s,\n    } as never\n  return {\n    r,\n    s,\n    yParity,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType =\n    | Hex.from.ErrorType\n    | InvalidSerializedSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value: extract.Value): Signature | undefined {\n  if (typeof value.r === 'undefined') return undefined\n  if (typeof value.s === 'undefined') return undefined\n  return from(value as any)\n}\n\nexport declare namespace extract {\n  type Value = {\n    r?: bigint | Hex.Hex | undefined\n    s?: bigint | Hex.Hex | undefined\n    yParity?: number | Hex.Hex | undefined\n    v?: number | Hex.Hex | undefined\n  }\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from<\n  const signature extends\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n>(\n  signature:\n    | signature\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n): from.ReturnType<signature> {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature)\n    if (signature instanceof Uint8Array) return fromBytes(signature)\n    if (typeof signature.r === 'string') return fromRpc(signature)\n    if (signature.v) return fromLegacy(signature)\n    return {\n      r: signature.r,\n      s: signature.s,\n      ...(typeof signature.yParity !== 'undefined'\n        ? { yParity: signature.yParity }\n        : {}),\n    }\n  })()\n  assert(signature_)\n  return signature_ as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    signature extends\n      | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n      | Hex.Hex\n      | Bytes.Bytes,\n  > = signature extends Signature<boolean> & { v?: undefined }\n    ? signature\n    : Signature\n\n  type ErrorType =\n    | assert.ErrorType\n    | fromBytes.ErrorType\n    | fromHex.ErrorType\n    | vToYParity.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature: Bytes.Bytes): Signature<false> {\n  return fromDerHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature: Hex.Hex): Signature<false> {\n  const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2))\n  return { r, s }\n}\n\nexport declare namespace fromDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature: Legacy): Signature {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v),\n  }\n}\n\nexport declare namespace fromLegacy {\n  type ErrorType = vToYParity.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature: {\n  r: Hex.Hex\n  s: Hex.Hex\n  yParity?: Hex.Hex | undefined\n  v?: Hex.Hex | undefined\n}): Signature {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined\n    if (typeof v === 'number' && typeof yParity !== 'number')\n      yParity = vToYParity(v)\n    if (typeof yParity !== 'number')\n      throw new InvalidYParityError({ value: signature.yParity })\n    return yParity\n  })()\n\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple: Tuple): Signature {\n  const [yParity, r, s] = tuple\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity),\n  })\n}\n\nexport declare namespace fromTuple {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature: Signature<boolean>): Bytes.Bytes {\n  return Bytes.fromHex(toHex(signature))\n}\n\nexport declare namespace toBytes {\n  type ErrorType =\n    | toHex.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature: Signature<boolean>): Hex.Hex {\n  assert(signature)\n\n  const r = signature.r\n  const s = signature.s\n\n  const signature_ = Hex.concat(\n    Hex.fromNumber(r, { size: 32 }),\n    Hex.fromNumber(s, { size: 32 }),\n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n      ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n      : '0x',\n  )\n\n  return signature_\n}\n\nexport declare namespace toHex {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature: Signature<boolean>): Bytes.Bytes {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return sig.toDERRawBytes()\n}\n\nexport declare namespace toDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature: Signature<boolean>): Hex.Hex {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return `0x${sig.toDERHex()}`\n}\n\nexport declare namespace toDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature: Signature): Legacy {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity),\n  }\n}\n\nexport declare namespace toLegacy {\n  type ErrorType = yParityToV.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature: Signature): Rpc {\n  const { r, s, yParity } = signature\n  return {\n    r: Hex.fromNumber(r, { size: 32 }),\n    s: Hex.fromNumber(s, { size: 32 }),\n    yParity: yParity === 0 ? '0x0' : '0x1',\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature: Signature): Tuple {\n  const { r, s, yParity } = signature\n\n  return [\n    yParity ? '0x01' : '0x',\n    r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r!)),\n    s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s!)),\n  ] as const\n}\n\nexport declare namespace toTuple {\n  type ErrorType =\n    | Hex.trimLeft.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(\n  signature: ExactPartial<Signature>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(signature, options)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v: number): Signature['yParity'] {\n  if (v === 0 || v === 27) return 0\n  if (v === 1 || v === 28) return 1\n  if (v >= 35) return v % 2 === 0 ? 1 : 0\n  throw new InvalidVError({ value: v })\n}\n\nexport declare namespace vToYParity {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity: number): number {\n  if (yParity === 0) return 27\n  if (yParity === 1) return 28\n  throw new InvalidYParityError({ value: yParity })\n}\n\nexport declare namespace yParityToV {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSerializedSizeError'\n\n  constructor({ signature }: { signature: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${signature}\\` is an invalid signature size.`, {\n      metaMessages: [\n        'Expected: 64 bytes or 65 bytes.',\n        `Received ${Hex.size(Hex.from(signature))} bytes.`,\n      ],\n    })\n  }\n}\n\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'Signature.MissingPropertiesError'\n\n  constructor({ signature }: { signature: unknown }) {\n    super(\n      `Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidRError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidYParityError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidVError'\n\n  constructor({ value }: { value: number }) {\n    super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`)\n  }\n}\n","import type * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute, Mutable, Undefined } from './internal/types.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\n\n/** Root type for an EIP-7702 Authorization. */\nexport type Authorization<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  {\n    /** Address of the contract to set as code for the Authority. */\n    address: Address.Address\n    /** Chain ID to authorize. */\n    chainId: numberType\n    /** Nonce of the Authority to authorize. */\n    nonce: bigintType\n  } & (signed extends true\n    ? Signature.Signature<true, bigintType, numberType>\n    : Undefined<Signature.Signature>)\n>\n\n/** RPC representation of an {@link ox#Authorization.Authorization}. */\nexport type Rpc = Authorization<true, Hex.Hex, Hex.Hex>\n\n/** List of {@link ox#Authorization.Authorization}. */\nexport type List<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<readonly Authorization<signed, bigintType, numberType>[]>\n\n/** RPC representation of an {@link ox#Authorization.List}. */\nexport type ListRpc = List<true, Hex.Hex, Hex.Hex>\n\n/** Signed representation of a list of {@link ox#Authorization.Authorization}. */\nexport type ListSigned<bigintType = bigint, numberType = number> = List<\n  true,\n  bigintType,\n  numberType\n>\n\n/** Signed representation of an {@link ox#Authorization.Authorization}. */\nexport type Signed<bigintType = bigint, numberType = number> = Authorization<\n  true,\n  bigintType,\n  numberType\n>\n\n/** Tuple representation of an {@link ox#Authorization.Authorization}. */\nexport type Tuple<signed extends boolean = boolean> = signed extends true\n  ? readonly [\n      chainId: Hex.Hex,\n      address: Hex.Hex,\n      nonce: Hex.Hex,\n      yParity: Hex.Hex,\n      r: Hex.Hex,\n      s: Hex.Hex,\n    ]\n  : readonly [chainId: Hex.Hex, address: Hex.Hex, nonce: Hex.Hex]\n\n/** Tuple representation of a signed {@link ox#Authorization.Authorization}. */\nexport type TupleSigned = Tuple<true>\n\n/** Tuple representation of a list of {@link ox#Authorization.Authorization}. */\nexport type TupleList<signed extends boolean = boolean> =\n  readonly Tuple<signed>[]\n\n/** Tuple representation of a list of signed {@link ox#Authorization.Authorization}. */\nexport type TupleListSigned = TupleList<true>\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function from<\n  const authorization extends Authorization | Rpc,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  authorization: authorization | Authorization,\n  options: from.Options<signature> = {},\n): from.ReturnType<authorization, signature> {\n  if (typeof authorization.chainId === 'string')\n    return fromRpc(authorization) as never\n  return { ...authorization, ...options.signature } as never\n}\n\nexport declare namespace from {\n  type Options<\n    signature extends Signature.Signature | undefined =\n      | Signature.Signature\n      | undefined,\n  > = {\n    /** The {@link ox#Signature.Signature} to attach to the Authorization. */\n    signature?: signature | Signature.Signature | undefined\n  }\n\n  type ReturnType<\n    authorization extends Authorization | Rpc = Authorization,\n    signature extends Signature.Signature | undefined =\n      | Signature.Signature\n      | undefined,\n  > = Compute<\n    authorization extends Rpc\n      ? Signed\n      : authorization &\n          (signature extends Signature.Signature ? Readonly<signature> : {})\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nexport function fromRpc(authorization: Rpc): Signed {\n  const { address, chainId, nonce } = authorization\n  const signature = Signature.extract(authorization)!\n\n  return {\n    address,\n    chainId: Number(chainId),\n    nonce: BigInt(nonce),\n    ...signature,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nexport function fromRpcList(authorizationList: ListRpc): ListSigned {\n  return authorizationList.map(fromRpc)\n}\n\nexport declare namespace fromRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nexport function fromTuple<const tuple extends Tuple>(\n  tuple: tuple,\n): fromTuple.ReturnType<tuple> {\n  const [chainId, address, nonce, yParity, r, s] = tuple\n  let args = {\n    address,\n    chainId: chainId === '0x' ? 0 : Number(chainId),\n    nonce: nonce === '0x' ? 0n : BigInt(nonce),\n  }\n  if (yParity && r && s)\n    args = { ...args, ...Signature.fromTuple([yParity, r, s]) }\n  return from(args) as never\n}\n\nexport declare namespace fromTuple {\n  type ReturnType<authorization extends Tuple = Tuple> = Compute<\n    Authorization<authorization extends Tuple<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nexport function fromTupleList<const tupleList extends TupleList>(\n  tupleList: tupleList,\n): fromTupleList.ReturnType<tupleList> {\n  const list: Mutable<List> = []\n  for (const tuple of tupleList) list.push(fromTuple(tuple))\n  return list as never\n}\n\nexport declare namespace fromTupleList {\n  type ReturnType<tupleList extends TupleList> = Compute<\n    TupleList<tupleList extends TupleList<true> ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nexport function getSignPayload(authorization: Authorization): Hex.Hex {\n  return hash(authorization, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nexport function hash(\n  authorization: Authorization,\n  options: hash.Options = {},\n): Hex.Hex {\n  const { presign } = options\n  return Hash.keccak256(\n    Hex.concat(\n      '0x05',\n      Rlp.fromHex(\n        toTuple(\n          presign\n            ? {\n                address: authorization.address,\n                chainId: authorization.chainId,\n                nonce: authorization.nonce,\n              }\n            : authorization,\n        ),\n      ),\n    ),\n  )\n}\n\nexport declare namespace hash {\n  type ErrorType =\n    | toTuple.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n\n  type Options = {\n    /** Whether to hash this authorization for signing. @default false */\n    presign?: boolean | undefined\n  }\n}\n\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nexport function toRpc(authorization: Signed): Rpc {\n  const { address, chainId, nonce, ...signature } = authorization\n\n  return {\n    address,\n    chainId: Hex.fromNumber(chainId),\n    nonce: Hex.fromNumber(nonce),\n    ...Signature.toRpc(signature),\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nexport function toRpcList(authorizationList: ListSigned): ListRpc {\n  return authorizationList.map(toRpc)\n}\n\nexport declare namespace toRpcList {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nexport function toTuple<const authorization extends Authorization>(\n  authorization: authorization,\n): toTuple.ReturnType<authorization> {\n  const { address, chainId, nonce } = authorization\n  const signature = Signature.extract(authorization)\n  return [\n    chainId ? Hex.fromNumber(chainId) : '0x',\n    address,\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    ...(signature ? Signature.toTuple(signature) : []),\n  ] as never\n}\n\nexport declare namespace toTuple {\n  type ReturnType<authorization extends Authorization = Authorization> =\n    Compute<Tuple<authorization extends Signature.Signature ? true : false>>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nexport function toTupleList<\n  const list extends\n    | readonly Authorization<true>[]\n    | readonly Authorization<false>[],\n>(list?: list | undefined): toTupleList.ReturnType<list> {\n  if (!list || list.length === 0) return []\n\n  const tupleList: Mutable<TupleList> = []\n  for (const authorization of list) tupleList.push(toTuple(authorization))\n\n  return tupleList as never\n}\n\nexport declare namespace toTupleList {\n  type ReturnType<\n    list extends\n      | readonly Authorization<true>[]\n      | readonly Authorization<false>[],\n  > = Compute<\n    TupleList<list extends readonly Authorization<true>[] ? true : false>\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","export let extraEntropy = false\n\n/** @internal */\nexport function setExtraEntropy(entropy: boolean) {\n  extraEntropy = entropy\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Entropy from './internal/entropy.js'\nimport type { OneOf } from './internal/types.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/** Re-export of noble/curves secp256k1 utilities. */\nexport const noble = secp256k1\n\n/**\n * Creates a new secp256k1 ECDSA key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey, publicKey } = Secp256k1.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey: PublicKey.PublicKey\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the secp256k1 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const publicKey = Secp256k1.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256k1.ProjectivePoint.fromPrivateKey(\n    Hex.from(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType =\n    | Hex.from.ErrorType\n    | PublicKey.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const { privateKey: privateKeyA } = Secp256k1.createKeyPair()\n * const { publicKey: publicKeyB } = Secp256k1.createKeyPair()\n *\n * const sharedSecret = Secp256k1.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const point = secp256k1.ProjectivePoint.fromHex(\n    PublicKey.toHex(publicKey).slice(2),\n  )\n  const sharedPoint = point.multiply(\n    secp256k1.utils.normPrivateKeyToScalar(Hex.from(privateKey).slice(2)),\n  )\n  const sharedSecret = sharedPoint.toRawBytes(true) // compressed format\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.from.ErrorType\n    | PublicKey.toHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random ECDSA private key on the secp256k1 curve.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = Secp256k1.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256k1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing address from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const address = Secp256k1.recoverAddress({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered address.\n */\nexport function recoverAddress(\n  options: recoverAddress.Options,\n): recoverAddress.ReturnType {\n  return Address.fromPublicKey(recoverPublicKey(options))\n}\n\nexport declare namespace recoverAddress {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ReturnType = Address.Address\n\n  type ErrorType =\n    | Address.fromPublicKey.ErrorType\n    | recoverPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = Secp256k1.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256k1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const point = signature_.recoverPublicKey(Hex.from(payload).substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.from.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256k1.sign(\n    Bytes.from(payload),\n    Bytes.from(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     *  If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided address.\n *\n * @example\n * ### Verify with Ethereum Address\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   address: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266', // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Verify with Public Key\n *\n * ```ts twoslash\n * import { Secp256k1 } from 'ox'\n *\n * const privateKey = '0x...'\n * const publicKey = Secp256k1.getPublicKey({ privateKey })\n * const signature = Secp256k1.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Secp256k1.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided address.\n */\nexport function verify(options: verify.Options): boolean {\n  const { address, hash, payload, publicKey, signature } = options\n  if (address)\n    return Address.isEqual(address, recoverAddress({ payload, signature }))\n  return secp256k1.verify(\n    signature,\n    Bytes.from(payload),\n    PublicKey.toBytes(publicKey),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  } & OneOf<\n    | {\n        /** Address that signed the payload. */\n        address: Address.Address\n        /** Signature of the payload. */\n        signature: Signature.Signature\n      }\n    | {\n        /** Public key that signed the payload. */\n        publicKey: PublicKey.PublicKey<boolean>\n        /** Signature of the payload. */\n        signature: Signature.Signature<false>\n      }\n  >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport { type HexToBigIntErrorType, hexToBigInt } from '../encoding/fromHex.js'\nimport { hexToBytes } from '../encoding/toBytes.js'\nimport type { ToHexErrorType } from '../encoding/toHex.js'\n\ntype To = 'bytes' | 'hex'\n\nexport type SerializeSignatureParameters<to extends To = 'hex'> = Signature & {\n  to?: to | To | undefined\n}\n\nexport type SerializeSignatureReturnType<to extends To = 'hex'> =\n  | (to extends 'hex' ? Hex : never)\n  | (to extends 'bytes' ? ByteArray : never)\n\nexport type SerializeSignatureErrorType =\n  | HexToBigIntErrorType\n  | ToHexErrorType\n  | ErrorType\n\n/**\n * @description Converts a signature into hex format.\n *\n * @param signature The signature to convert.\n * @returns The signature in hex format.\n *\n * @example\n * serializeSignature({\n *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',\n *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',\n *   yParity: 1\n * })\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n */\nexport function serializeSignature<to extends To = 'hex'>({\n  r,\n  s,\n  to = 'hex',\n  v,\n  yParity,\n}: SerializeSignatureParameters<to>): SerializeSignatureReturnType<to> {\n  const yParity_ = (() => {\n    if (yParity === 0 || yParity === 1) return yParity\n    if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0\n    throw new Error('Invalid `v` or `yParity` value')\n  })()\n  const signature = `0x${new secp256k1.Signature(\n    hexToBigInt(r),\n    hexToBigInt(s),\n  ).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}` as const\n\n  if (to === 'hex') return signature as SerializeSignatureReturnType<to>\n  return hexToBytes(signature) as SerializeSignatureReturnType<to>\n}\n","import * as AbiParameters from '../core/AbiParameters.js'\nimport type * as Address from '../core/Address.js'\nimport * as Authorization from '../core/Authorization.js'\nimport * as Errors from '../core/Errors.js'\nimport * as Hex from '../core/Hex.js'\nimport * as Secp256k1 from '../core/Secp256k1.js'\nimport * as Signature from '../core/Signature.js'\n\n/** Unwrapped ERC-8010 signature. */\nexport type Unwrapped = {\n  /** Authorization signed by the delegatee. */\n  authorization: Authorization.Authorization<true>\n  /** Data to initialize the delegation. */\n  data?: Hex.Hex | undefined\n  /** The original signature. */\n  signature: Hex.Hex\n  /** Address of the initializer. */\n  to?: Address.Address | undefined\n}\n\n/** Wrapped ERC-8010 signature. */\nexport type Wrapped = Hex.Hex\n\n/**\n * Magic bytes used to identify ERC-8010 wrapped signatures.\n */\nexport const magicBytes =\n  '0x8010801080108010801080108010801080108010801080108010801080108010' as const\n\n/** Suffix ABI parameters for the ERC-8010 wrapped signature. */\nexport const suffixParameters = AbiParameters.from(\n  '(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data',\n)\n\n/**\n * Asserts that the wrapped signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * SignatureErc8010.assert('0xdeadbeef')\n * // @error: InvalidWrappedSignatureError: Value `0xdeadbeef` is an invalid ERC-8010 wrapped signature.\n * ```\n *\n * @param value - The value to assert.\n */\nexport function assert(value: Unwrapped | Wrapped) {\n  if (typeof value === 'string') {\n    if (Hex.slice(value, -32) !== magicBytes)\n      throw new InvalidWrappedSignatureError(value)\n  } else Signature.assert(value.authorization)\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | InvalidWrappedSignatureError\n    | Hex.slice.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Parses an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1 } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * // Instantiate from serialized format. // [!code focus]\n * const wrapped = SignatureErc8010.from('0x...') // [!code focus]\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } } // [!code focus]\n *\n * // Instantiate from constituent parts. // [!code focus]\n * const wrapped = SignatureErc8010.from({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0x...', // [!code focus]\n *   signature, // [!code focus]\n * })\n * // @log: { authorization: { ... }, data: '0x...', signature: { ... } }\n * ```\n *\n * @param value - Value to parse.\n * @returns Parsed value.\n */\nexport function from(value: Unwrapped | Wrapped): Unwrapped {\n  if (typeof value === 'string') return unwrap(value)\n  return value\n}\n\nexport declare namespace from {\n  type ErrorType = unwrap.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Unwraps an [ERC-8010 wrapped signature](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md) into its constituent parts.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const { authorization, data, signature } = SignatureErc8010.unwrap('0x...')\n * ```\n *\n * @param wrapped - Wrapped signature to unwrap.\n * @returns Unwrapped signature.\n */\nexport function unwrap(wrapped: Wrapped): Unwrapped {\n  assert(wrapped)\n\n  const suffixLength = Hex.toNumber(Hex.slice(wrapped, -64, -32))\n  const suffix = Hex.slice(wrapped, -suffixLength - 64, -64)\n  const signature = Hex.slice(wrapped, 0, -suffixLength - 64)\n\n  const [auth, to, data] = AbiParameters.decode(suffixParameters, suffix)\n\n  const authorization = Authorization.from({\n    address: auth.delegation,\n    chainId: Number(auth.chainId),\n    nonce: auth.nonce,\n    yParity: auth.yParity,\n    r: auth.r,\n    s: auth.s,\n  })\n\n  return {\n    authorization,\n    signature,\n    ...(data && data !== '0x' ? { data, to } : {}),\n  }\n}\n\nexport declare namespace unwrap {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Wraps a signature into [ERC-8010 format](https://github.com/jxom/ERCs/blob/16f7e3891fff2e1e9c25dea0485497739db8a816/ERCS/erc-8010.md).\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, Signature } from 'ox'\n * import { SignatureErc8010 } from 'ox/erc8010' // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload: '0x...',\n *   privateKey: '0x...',\n * })\n *\n * const wrapped = SignatureErc8010.wrap({ // [!code focus]\n *   authorization: { ... }, // [!code focus]\n *   data: '0xdeadbeef', // [!code focus]\n *   signature: Signature.toHex(signature), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param value - Values to wrap.\n * @returns Wrapped signature.\n */\nexport function wrap(value: Unwrapped): Wrapped {\n  const { data, signature } = value\n\n  assert(value)\n\n  const self = Secp256k1.recoverAddress({\n    payload: Authorization.getSignPayload(value.authorization),\n    signature: Signature.from(value.authorization),\n  })\n\n  const suffix = AbiParameters.encode(suffixParameters, [\n    {\n      ...value.authorization,\n      delegation: value.authorization.address,\n      chainId: BigInt(value.authorization.chainId),\n    },\n    value.to ?? self,\n    data ?? '0x',\n  ])\n  const suffixLength = Hex.fromNumber(Hex.size(suffix), { size: 32 })\n  return Hex.concat(signature, suffix, suffixLength, magicBytes)\n}\n\nexport declare namespace wrap {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Validates a wrapped signature. Returns `true` if the wrapped signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { SignatureErc8010 } from 'ox/erc8010'\n *\n * const valid = SignatureErc8010.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param value - The value to validate.\n * @returns `true` if the value is valid, `false` otherwise.\n */\nexport function validate(value: Unwrapped | Wrapped): boolean {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** Thrown when the ERC-8010 wrapped signature is invalid. */\nexport class InvalidWrappedSignatureError extends Errors.BaseError {\n  override readonly name = 'SignatureErc8010.InvalidWrappedSignatureError'\n\n  constructor(wrapped: Wrapped) {\n    super(`Value \\`${wrapped}\\` is an invalid ERC-8010 wrapped signature.`)\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport { type GetAddressErrorType, getAddress } from '../address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../address/isAddressEqual.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  type RecoverAuthorizationAddressParameters,\n  recoverAuthorizationAddress,\n} from './recoverAuthorizationAddress.js'\n\nexport type VerifyAuthorizationParameters =\n  RecoverAuthorizationAddressParameters & {\n    /** The address that signed the Authorization object. */\n    address: Address\n  }\n\nexport type VerifyAuthorizationReturnType = boolean\n\nexport type VerifyAuthorizationErrorType =\n  | IsAddressEqualErrorType\n  | GetAddressErrorType\n  | RecoverAuthorizationAddressErrorType\n  | ErrorType\n\n/**\n * Verify that an Authorization object was signed by the provided address.\n *\n * - Docs {@link https://viem.sh/docs/utilities/verifyAuthorization}\n *\n * @param parameters - {@link VerifyAuthorizationParameters}\n * @returns Whether or not the signature is valid. {@link VerifyAuthorizationReturnType}\n */\nexport async function verifyAuthorization({\n  address,\n  authorization,\n  signature,\n}: VerifyAuthorizationParameters): Promise<VerifyAuthorizationReturnType> {\n  return isAddressEqual(\n    getAddress(address),\n    await recoverAuthorizationAddress({\n      authorization,\n      signature,\n    }),\n  )\n}\n","import type { Address } from 'abitype'\nimport { SignatureErc6492 } from 'ox/erc6492'\nimport { SignatureErc8010 } from 'ox/erc8010'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  erc1271Abi,\n  erc6492SignatureValidatorAbi,\n  multicall3Abi,\n} from '../../constants/abis.js'\nimport {\n  erc6492SignatureValidatorByteCode,\n  multicall3Bytecode,\n} from '../../constants/contracts.js'\nimport {\n  CallExecutionError,\n  ContractFunctionExecutionError,\n} from '../../errors/contract.js'\nimport type { InvalidHexBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../../utils/abi/encodeDeployData.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetAddressErrorType,\n  getAddress,\n} from '../../utils/address/getAddress.js'\nimport {\n  type IsAddressEqualErrorType,\n  isAddressEqual,\n} from '../../utils/address/isAddressEqual.js'\nimport { verifyAuthorization } from '../../utils/authorization/verifyAuthorization.js'\nimport { type ConcatHexErrorType, concatHex } from '../../utils/data/concat.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { hexToBool } from '../../utils/encoding/fromHex.js'\nimport {\n  type BytesToHexErrorType,\n  bytesToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type RecoverAddressErrorType,\n  recoverAddress,\n} from '../../utils/signature/recoverAddress.js'\nimport {\n  type SerializeSignatureErrorType,\n  serializeSignature,\n} from '../../utils/signature/serializeSignature.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\nimport { type GetCodeErrorType, getCode } from './getCode.js'\nimport { type ReadContractErrorType, readContract } from './readContract.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The address of the ERC-6492 signature verifier contract. */\n  erc6492VerifierAddress?: Address | undefined\n  /** The hash to be verified. */\n  hash: Hex\n  /** Multicall3 address for ERC-8010 verification. */\n  multicallAddress?: Address | undefined\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray | Signature\n  /** @deprecated use `erc6492VerifierAddress` instead. */\n  universalSignatureVerifierAddress?: Address | undefined\n} & OneOf<{ factory: Address; factoryData: Hex } | {}>\n\nexport type VerifyHashReturnType = boolean\n\nexport type VerifyHashErrorType =\n  | BytesToHexErrorType\n  | CallErrorType\n  | ConcatHexErrorType\n  | EncodeDeployDataErrorType\n  | EncodeFunctionDataErrorType\n  | ErrorType\n  | GetAddressErrorType\n  | GetCodeErrorType\n  | InvalidHexBooleanError\n  | IsAddressEqualErrorType\n  | IsHexErrorType\n  | NumberToHexErrorType\n  | ReadContractErrorType\n  | RecoverAddressErrorType\n  | SerializeSignatureErrorType\n\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const {\n    address,\n    hash,\n    erc6492VerifierAddress:\n      verifierAddress = parameters.universalSignatureVerifierAddress ??\n      client.chain?.contracts?.erc6492Verifier?.address,\n    multicallAddress = parameters.multicallAddress ??\n      client.chain?.contracts?.multicall3?.address,\n  } = parameters\n\n  const signature = (() => {\n    const signature = parameters.signature\n    if (isHex(signature)) return signature\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n      return serializeSignature(signature)\n    return bytesToHex(signature)\n  })()\n\n  try {\n    if (SignatureErc8010.validate(signature))\n      return await verifyErc8010(client, {\n        ...parameters,\n        multicallAddress,\n        signature,\n      })\n    return await verifyErc6492(client, {\n      ...parameters,\n      verifierAddress,\n      signature,\n    })\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(\n        getAddress(address),\n        await recoverAddress({ hash, signature }),\n      )\n      if (verified) return true\n    } catch {}\n\n    if (error instanceof VerificationError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n\n/** @internal */\nexport async function verifyErc8010(\n  client: Client,\n  parameters: verifyErc8010.Parameters,\n) {\n  const { address, blockNumber, blockTag, hash, multicallAddress } = parameters\n\n  const {\n    authorization: authorization_ox,\n    data: initData,\n    signature,\n    to,\n  } = SignatureErc8010.unwrap(parameters.signature)\n\n  // Check if already delegated\n  const code = await getCode(client, {\n    address,\n    blockNumber,\n    blockTag,\n  } as never)\n\n  // If already delegated, perform standard ERC-1271 verification.\n  if (code === concatHex(['0xef0100', authorization_ox.address]))\n    return await verifyErc1271(client, {\n      address,\n      blockNumber,\n      blockTag,\n      hash,\n      signature,\n    })\n\n  const authorization = {\n    address: authorization_ox.address,\n    chainId: Number(authorization_ox.chainId),\n    nonce: Number(authorization_ox.nonce),\n    r: numberToHex(authorization_ox.r, { size: 32 }),\n    s: numberToHex(authorization_ox.s, { size: 32 }),\n    yParity: authorization_ox.yParity,\n  } as const\n\n  const valid = await verifyAuthorization({\n    address,\n    authorization,\n  })\n  if (!valid) throw new VerificationError()\n\n  // Deployless verification.\n  const results = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    ...(multicallAddress\n      ? { address: multicallAddress }\n      : { code: multicall3Bytecode }),\n    authorizationList: [authorization],\n    abi: multicall3Abi,\n    blockNumber,\n    blockTag: 'pending',\n    functionName: 'aggregate3',\n    args: [\n      [\n        ...(initData\n          ? [\n              {\n                allowFailure: true,\n                target: to ?? address,\n                callData: initData,\n              },\n            ]\n          : []),\n        {\n          allowFailure: true,\n          target: address,\n          callData: encodeFunctionData({\n            abi: erc1271Abi,\n            functionName: 'isValidSignature',\n            args: [hash, signature],\n          }),\n        },\n      ],\n    ],\n  })\n\n  const data = results[results.length - 1]?.returnData\n\n  if (data?.startsWith('0x1626ba7e')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc8010 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** Multicall3 address for ERC-8010 verification. */\n    multicallAddress?: Address | undefined\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n  }\n}\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nasync function verifyErc6492(\n  client: Client,\n  parameters: verifyErc6492.Parameters,\n) {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    verifierAddress,\n    ...rest\n  } = parameters\n\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signature\n\n    // If the signature is already wrapped, return the signature.\n    if (SignatureErc6492.validate(signature)) return signature\n\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return SignatureErc6492.wrap({\n      data: factoryData!,\n      signature,\n      to: factory!,\n    })\n  })()\n\n  const args = verifierAddress\n    ? ({\n        to: verifierAddress,\n        data: encodeFunctionData({\n          abi: erc6492SignatureValidatorAbi,\n          functionName: 'isValidSig',\n          args: [address, hash, wrappedSignature],\n        }),\n        ...rest,\n      } as unknown as CallParameters)\n    : ({\n        data: encodeDeployData({\n          abi: erc6492SignatureValidatorAbi,\n          args: [address, hash, wrappedSignature],\n          bytecode: erc6492SignatureValidatorByteCode,\n        }),\n        ...rest,\n      } as unknown as CallParameters)\n\n  const { data } = await getAction(\n    client,\n    call,\n    'call',\n  )(args).catch((error) => {\n    if (error instanceof CallExecutionError) throw new VerificationError()\n    throw error\n  })\n\n  if (hexToBool(data ?? '0x0')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc6492 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n    /** The address of the ERC-6492 signature verifier contract. */\n    verifierAddress?: Address | undefined\n  } & OneOf<{ factory: Address; factoryData: Hex } | {}>\n}\n\n/** @internal */\nexport async function verifyErc1271(\n  client: Client,\n  parameters: verifyErc1271.Parameters,\n) {\n  const { address, blockNumber, blockTag, hash, signature } = parameters\n\n  const result = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address,\n    abi: erc1271Abi,\n    args: [hash, signature],\n    blockNumber,\n    blockTag,\n    functionName: 'isValidSignature',\n  }).catch((error) => {\n    if (error instanceof ContractFunctionExecutionError)\n      throw new VerificationError()\n    throw error\n  })\n\n  if (result.startsWith('0x1626ba7e')) return true\n  throw new VerificationError()\n}\n\nexport namespace verifyErc1271 {\n  export type Parameters = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The hash to be verified. */\n    hash: Hex\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex\n  }\n}\n\nclass VerificationError extends Error {}\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport { size } from '../data/size.js'\nimport {\n  type BytesToHexErrorType,\n  bytesToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\n\nexport type ToPrefixedMessageErrorType =\n  | ConcatErrorType\n  | StringToHexErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\nexport function toPrefixedMessage(message_: SignableMessage): Hex {\n  const message = (() => {\n    if (typeof message_ === 'string') return stringToHex(message_)\n    if (typeof message_.raw === 'string') return message_.raw\n    return bytesToHex(message_.raw)\n  })()\n  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`)\n  return concat([prefix, message])\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport { toPrefixedMessage } from './toPrefixedMessage.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessageReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType = Keccak256ErrorType | ErrorType\n\nexport function hashMessage<to extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: to | undefined,\n): HashMessageReturnType<to> {\n  return keccak256(toPrefixedMessage(message), to_)\n}\n","import type { TypedData } from 'abitype'\n\nimport { stringify } from '../utils/stringify.js'\nimport { BaseError } from './base.js'\n\nexport type InvalidDomainErrorType = InvalidDomainError & {\n  name: 'InvalidDomainError'\n}\nexport class InvalidDomainError extends BaseError {\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\nexport type InvalidPrimaryTypeErrorType = InvalidPrimaryTypeError & {\n  name: 'InvalidPrimaryTypeError'\n}\nexport class InvalidPrimaryTypeError extends BaseError {\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\nexport type InvalidStructTypeErrorType = InvalidStructTypeError & {\n  name: 'InvalidStructTypeError'\n}\nexport class InvalidStructTypeError extends BaseError {\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n      name: 'InvalidStructTypeError',\n    })\n  }\n}\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport {\n  InvalidDomainError,\n  InvalidPrimaryTypeError,\n  InvalidStructTypeError,\n} from '../errors/typedData.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\nimport { stringify } from './stringify.js'\n\nexport type SerializeTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function serializeTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = parameters as unknown as TypedDataDefinition\n\n  const normalizeData = (\n    struct: readonly TypedDataParameter[],\n    data_: Record<string, unknown>,\n  ) => {\n    const data = { ...data_ }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!types.EIP712Domain) return {}\n    if (!domain_) return {}\n    return normalizeData(types.EIP712Domain, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return stringify({ domain, message, primaryType, types })\n}\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_, 10) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_, 10))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_, 10),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: {\n  domain?: TypedDataDomain | undefined\n}): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nexport type HashStructErrorType =\n  | EncodeDataErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nexport function hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nexport function encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, readonly MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, readonly MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, readonly MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Authorization,\n  AuthorizationRequest,\n} from '../../types/authorization.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { PartialBy } from '../../types/utils.js'\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { getChainId } from '../public/getChainId.js'\nimport { getTransactionCount } from '../public/getTransactionCount.js'\n\nexport type PrepareAuthorizationParameters<\n  account extends Account | undefined = Account | undefined,\n> = GetAccountParameter<account> &\n  PartialBy<AuthorizationRequest, 'chainId' | 'nonce'> & {\n    /**\n     * Whether the EIP-7702 Transaction will be executed by the EOA (signing this Authorization) or another Account.\n     *\n     * By default, it will be assumed that the EIP-7702 Transaction will\n     * be executed by another Account.\n     */\n    executor?: 'self' | Account | Address | undefined\n  }\n\nexport type PrepareAuthorizationReturnType = Authorization\n\nexport type PrepareAuthorizationErrorType =\n  | ParseAccountErrorType\n  | RequestErrorType\n  | AccountNotFoundErrorType\n  | ErrorType\n\n/**\n * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.\n * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).\n *\n * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.\n *\n * @param client - Client to use\n * @param parameters - {@link PrepareAuthorizationParameters}\n * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   account: privateKeyToAccount('0x..'),\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function prepareAuthorization<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: PrepareAuthorizationParameters<account>,\n): Promise<PrepareAuthorizationReturnType> {\n  const { account: account_ = client.account, chainId, nonce } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/eip7702/prepareAuthorization',\n    })\n  const account = parseAccount(account_)\n\n  const executor = (() => {\n    if (!parameters.executor) return undefined\n    if (parameters.executor === 'self') return parameters.executor\n    return parseAccount(parameters.executor)\n  })()\n\n  const authorization = {\n    address: parameters.contractAddress ?? parameters.address,\n    chainId,\n    nonce,\n  } as Authorization\n\n  if (typeof authorization.chainId === 'undefined')\n    authorization.chainId =\n      client.chain?.id ??\n      (await getAction(client, getChainId, 'getChainId')({}))\n\n  if (typeof authorization.nonce === 'undefined') {\n    authorization.nonce = await getAction(\n      client,\n      getTransactionCount,\n      'getTransactionCount',\n    )({\n      address: account.address,\n      blockTag: 'pending',\n    })\n    if (\n      executor === 'self' ||\n      (executor?.address && isAddressEqual(executor.address, account.address))\n    )\n      authorization.nonce += 1\n  }\n\n  return authorization\n}\n"],"names":[],"mappings":"wCAGA,IAAA,EAAoC,CAA7B,CAAkD,CAAA,AAAhD,CAAgD,OAAA,CACzD,AADyD,EACvB,CAA3B,CAAoD,CAAlD,AAAkD,CAAA,IAD/B,EAAE,EAE9B,CAD2D,CAC9B,AAD8B,CACpD,CAA4C,AAFf,CAE3B,AAA0C,CAAA,CAAA,CAAA,AADzB,EAAE,IAE5B,EAA+B,AAFG,CACb,AACd,CAA4C,CAD5B,AACd,AAA0C,CAAA,EAAA,CAAA,EADtB,EAuEvB,MAtEiB,EAAE,CAsET,EAGd,CAcG,EAEH,AAzF6B,IAyFzB,EACJ,CApB0B,EAoBD,EADuB,CAAA,KACf,EAA7B,OAAO,EACT,EAAO,CAAA,EAAG,EAAH,AADW,AACR,cAAA,AAAc,EAAC,OACtB,CAAC,AACJ,CAFkC,CAA4B,CAAA,CAExD,EAAO,CAAA,EAAG,EAAH,AAAG,YAAA,AAAY,EAAC,GACvB,EAAS,EAAU,EADkC,AAC/C,CADgD,CAAA,EACnB,CAAjB,AAAiB,AACzC,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAQ,CAAC,EAAE,CAAL,AAAO,CAAC,AAChC,IAAM,EAAc,CAA+B,CAAC,CAAC,CAAE,CAAA,AACvD,GADgB,CAChB,CAAA,EAAI,EAAA,iBAAiB,AAAjB,EAAkB,IACtB,EAAO,CAAA,EAAG,CADsB,CAAC,AACvB,AAAH,EAD4B,SAAQ,GACjC,AAAc,EAAC,EAAY,GACrC,IAD4C,CAA4B,AAArC,CAAqC,AACnE,AACP,CAAC,AACH,CAAC,AAED,GAAI,CAAC,EAAS,KAAF,CAAQ,IAAI,EAAA,mBAAmB,CAAC,WAAE,CAAS,CAAE,CAAC,CAAA,AAC1D,KADuD,EAChD,CACT,CAAC,KAD0C,CAAA,+CC3G3C,IAAA,EAA0C,CAAnC,CAA6D,CAA3D,AAA2D,CAAA,QACpE,EAA6C,CAAtC,CAAsC,CAApC,AAAoC,CAAyB,CAAA,OACtE,EAA6B,AAFK,CAE3B,CAA4C,AAFf,CAE3B,AAA0C,CAAA,CAAA,CADzB,AACyB,EAFT,AACd,IAE5B,EAAgC,CAAzB,AADc,CAC+B,CAA3C,AAA2C,AAD7B,AADc,CAEe,CAFb,EAEa,CAAA,CADvB,EAgGvB,AAjGuC,OAErB,EAAE,AA+FV,EAGd,CAcG,EAEH,CAlH8B,GAkHxB,EAAgC,EAAE,CACxC,AADwC,GAClB,CApBU,IAmBb,GACW,EAA1B,OAAO,EAAqB,CAAC,AAC/B,GADe,CACT,EAAU,CAAA,EAAG,EAAA,GAAH,YAAG,AAAe,EAAC,GAC7B,EAAS,CAD0B,CACf,AADgB,CAAA,CAC9B,IAAoB,CAAA,AAChC,CADyB,GACpB,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAQ,CAAC,EAAE,CAAL,AAAO,AAC/B,CADgC,CAClB,IAAI,CAAA,CAAA,EAAC,EAAA,CAAN,gBAAM,AAAkB,EAAC,CAAU,CAAC,CAAC,CAAE,CAAE,WAAE,EAAA,SAAS,CAAE,CAAC,CAAC,AAEzE,CAAC,AAFwE,IAElE,CAAC,AACN,IAAM,EAAO,CAAA,EAAG,EAAH,AAAG,YAAY,AAAZ,EAAa,GACvB,EAAS,CADyC,CAAC,AACnC,CADmC,CAC7C,EAAS,EAAiB,CAAA,AACtC,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAQ,CAAC,EAAE,CAAL,AAAO,CAAC,AAChC,IAAM,EAAa,CAA4B,CAAC,CAAC,CAAE,CAAA,AACnD,EADe,CACf,CAAA,EAAI,EAAA,iBAAA,AAAiB,EAAC,GAAY,MAAH,CAAC,EAChC,AAD0C,IACpC,EAAU,CAAA,EAAG,EAAA,GAAH,YAAkB,AAAf,EAAgB,GAC7B,EAAS,EAAW,EAAd,AADgC,CAAC,CAAA,EACb,CAAA,AAChC,CADyB,GACpB,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAQ,CAAC,EAAE,CAC7B,AADwB,AAAO,CAAC,CAClB,IAAI,CAAA,CAAA,EAChB,EAAA,CADW,gBACX,AAAkB,EAAC,CAAU,CAAC,CAAC,CAAE,CAAE,WAAE,EAAA,SAAS,SAAE,CAAO,CAAE,CAAC,CAC3D,AAEL,CAAC,AAFI,AAGP,CAAC,AAED,CAN+D,EAMlC,CAAC,GAA1B,EAAc,MAAM,CACtB,IADe,EACT,IAAI,EAAA,yBAAyB,CAAC,QAAE,CAAM,CAAE,CAAC,CAAA,AAEjD,EAF8C,KAEvC,CACT,CAAC,WADmD,CAAA,mEChJpD,IAAA,EGDqC,CDU9B,ADVA,ADCA,AGDA,CHCyC,ACDmB,CDCnB,AESvC,AFTA,AGDA,AFAA,AAA0D,CAAA,ECUf,CAAA,IAAnC,CFTC,AGDA,CDUC,CCVC,AHCA,CCDC,EAAE,ECUE,CCVC,AHCA,CCDyC,CEKtD,CFLgB,CCWd,GDRG,EAAE,CCQC,CCXgB,CAAA,AAKE,EDMQ,CFTrB,ACCA,EDDE,EGGG,CDMgB,GFTb,AESa,CCH7C,GFJK,ACQA,AFPA,EAAE,ACAP,ACOO,OCJK,CHHM,CAAF,AAAE,CGIhB,CDGgB,AFPA,ACWX,ACHA,AFPuB,IGGvB,CAAC,CAAA,CHH6B,EAAE,MEOjB,AFPuB,EEOrB,CDGC,EAAE,GCHG,GDGG,YAAA,EEPU,EAAO,IAAD,MAAW,CAAA,CAAE,CAAE,CAC5D,CHH2B,EAAE,ACWpB,AAF2D,CENhE,AFMgE,CAEzD,AERL,EDGkE,CFNrC,AEMqC,EDKvD,SCHE,EACvB,GCN6B,GAJ7B,CHKA,ACSO,CDbqD,CAAA,IAI5D,ICOiD,CAAA,SDPjD,CAAA,IAAA,CAAA,MEKuC,GFLvC,AEMD,MAAM,gBAAgB,CAAA,mCCJnB,IAAI,CAAC,MAAM,CAAG,CAChB,CAAC,CACF,GAFuB,CAAA,kFHLxB,EAAO,CCWA,ADXA,CAAA,CAAA,CAAA,yLCgBA,IAAM,EACX,oEAAoE,CACzD,AADyD,EACzD,CAAA,EAA0C,EAAA,WAAA,AAAW,EAAC,CAAC,CAAE,CACpE,KAAM,CErB0B,CFqBxB,CACT,CAAC,CAAA,AA2DK,eAAe,EAAA,CAMqB,CACzC,CAAqE,EAErE,GAAM,CACJ,QAAS,EAAW,EAAO,OAAA,cAC3B,CAAY,GD0BC,IAAI,ACzBjB,EDyBmB,ACzBX,EAAO,CAAV,GAAS,CAAM,uBACpB,CAAqB,4BACrB,EAA6B,EAAE,aAC/B,GAAc,CAAK,IACnB,CAAE,AAFwB,EACf,OAEX,EAAU,KAAH,EAAU,CAClB,CAAG,EAEE,EAAA,EAAA,CAAA,EAAqB,CDkBH,ACpBV,CAAA,ADoBU,YAAA,AClBe,EAAC,GAAY,CDmBhC,ICjBd,EAAQ,EAAW,KAAK,CAAC,GAAA,CAAI,AAAC,IAGlC,IAAM,EAAO,AAFA,CCfH,CACC,ADgBO,GAAG,CAAA,ADoBE,CAAA,ECnBnB,EAAA,kBAAkB,AAAlB,EAAmB,CChBD,IDiBX,CChBD,CDgBM,EAAD,CAAI,CDqBC,aCpBA,EChBA,ADgBK,EAAD,ADqBG,UCrBU,MACzB,EAAK,EAAD,EAAK,GAEjB,EAAK,IAAI,CAAA,AAEb,GDmBiC,GCnB1B,kBACgB,EAAI,EAAM,CAAA,CAAF,CAAC,AAAE,CAAD,CAAC,MAAA,AAAM,EAAC,CAAC,EAAM,EAAK,AAAP,EAAM,QAAW,CAAC,CAAC,CAAC,AAAE,CAAD,GAAK,CAClE,EAAK,EAAE,CDmBK,AClBhB,MAAO,CDmBC,CAAA,KCnBS,CAAC,ADmBC,CCnBA,ADmBA,EAAA,EAAA,WAAA,ACnBY,EAAA,EAAM,KAAK,CAAC,CAAC,CAAC,IAAC,EAElD,CAAC,CAAC,CAAA,AAEF,GAAA,CAJ2D,IAKnD,EDmBS,MCnBD,ACXA,ADWS,CDmBR,CCnBe,KCXK,EDWE,CAAA,QAEzB,SCZO,iBDaP,CDoBC,ACnBP,CCbQ,AFgCD,AClBL,ECZM,aDYU,OCZW,gBDc3B,CDqBK,CCpBL,CDoBO,CEhCD,AFgCC,EACC,IAAA,CAAA,CCtBI,CACH,CDqBK,CAAC,AEjCO,CFiCP,MEjCO,IAAA,ADYF,EAAC,EAAO,EAAE,CAAH,AAAI,CAC/B,KAAM,GCbmC,ADa1B,CCbyC,MDalC,IACtB,EAAE,KDoBmC,GCnBrC,ECbM,CDeT,EAEH,YAAc,CAAC,CAAE,CAClB,CACD,AADC,GACuB,QAAQ,EAA5B,ADwBoC,OCxB7B,EAAuB,MAAO,CAAE,EAAE,CAAE,CAAQ,CAAE,CAAA,KAAF,EAChD,CACT,CAAC,AAAC,MADwB,AACjB,CADiB,CACZ,CAKZ,AALU,CCdH,EDmBP,IAEkB,2BANJ,AAMX,EAAM,CANqB,CAAA,ACbpB,CDmBF,ACfE,CDeG,EACT,AAAe,4BAA4B,KAArC,IAAI,EACK,iBAAiB,GAAhC,EAAM,ACfA,GDeD,CAAK,EACV,EAAM,GAAD,IAAQ,CACV,WAAW,EAAE,CACb,QAAQ,CAAC,mCAAmC,CAAC,EAChD,EAAM,GAAD,IAAQ,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,+BAA+B,CAAC,EACrE,EAAM,GAAD,IAAQ,CACV,WAAW,EAAE,CACb,QAAQ,CAAC,4CAA4C,CAAC,EACzD,EAAM,GAAD,IAAQ,CACV,WAAW,EAAE,CACb,QAAQ,CAAC,0CAA0C,CAAC,EACvD,EAAM,GAAD,IAAQ,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,wBAAwB,CAAC,EAC9D,EAAM,GAAD,IAAQ,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,wBAAwB,CAAC,EAE9D,EADA,AACM,GAAD,IAAQ,CACV,KAFU,MAEC,EAAE,CACb,QAAQ,CAAC,+BAA+B,CAAC,EAE5C,EAAM,AADN,GACK,IAAQ,CACV,OAFY,IAED,EAAE,CACb,QAAQ,CACP,6DAA4D,CAC7D,CAAC,AACN,CAAC,AACD,GAAI,GAC+B,MAAM,CAAC,EAD1B,EAAE,CAAC,CAC6B,CAAC,GAAc,IAAI,CAC9D,AAAD,GAAgB,CAAC,AADwC,CAAC,CAC9B,IAAjB,EAAE,EAAc,AAAS,CACrC,CAAA,AAC6B,CAAC,AAC7B,IAAM,EACJ,KADW,gFAC0E,AACvF,CADuF,MACjF,IAAI,EAAA,qCAAqC,CAC7C,IAAI,EAAA,SAAS,CAAC,EAAS,CACrB,IADmB,GACZ,CAAE,EACV,CAAC,CACH,AACH,CADG,AACF,AAEH,EALwB,CAKpB,GAAe,EAAM,GAAD,GAAT,AAAgB,CAAG,CAAC,CAAE,CAAC,AACpC,IAAM,EACJ,KADW,iEAC2D,AACxE,CADwE,MAClE,IAAI,EAAA,0BAA0B,CAClC,IAAI,EAAA,SAAS,CAAC,EAAS,CACrB,IADmB,GACZ,CAAE,EACV,CAAC,CAEN,AADG,CACF,AAED,AAHG,EAFmB,EAKhB,EAA2B,EAAE,CAAA,AACnC,GADc,CACT,IAAM,IAAI,CAAI,EAAO,CAAC,AACzB,EADsB,EAChB,EAAU,CAAA,EAAA,EAAA,AAAH,eAAG,AAAe,EAAC,EAAQ,IAAF,KACpC,OAAO,CACP,EACA,GADK,CACD,CAAE,EAAK,EAAD,EAAK,CACf,EAAE,CAAE,EAAK,EAAD,AAAG,CACX,KAAK,CAAE,EAAK,EAAD,GAAM,CAAE,AAAD,CAAC,EAAC,EAAA,WAAA,AAAW,EAAC,EAAK,EAAD,GAAM,CAAC,CAAC,CAAC,IAAC,EAC/C,CAAC,CAAA,AACF,EAAS,GAFgD,CAE5C,CAAC,CAAN,EAIJ,EAA6B,CAAC,CAJb,CAAC,AAKpB,CALoB,KAKd,IAAI,OAAO,CAAC,AAAC,GADS,AAE1B,CAD4B,GAAJ,EAAE,IAChB,CAAC,EAAS,GAE1B,CAEA,AAFC,CAFuB,GAIlB,EAAU,KAAH,CAAS,OAAO,CAAC,EAJsB,CAAC,CAChD,CAAA,KAGmC,CAAC,GACzC,GAAI,EAD6C,AACrC,CADsC,CAAA,GACvC,AAAM,CAAC,AAAC,CAAC,EAAkB,AAAhB,UAA0B,CAAC,EAAxB,CAAD,AAAE,CAAC,MAAM,EAAkB,MAAM,CAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAE1E,AAF0E,IAEpE,EAAS,EAAQ,EAAX,CAAc,CAAC,AAAC,CAAN,EACpB,AAAsB,GADU,EAAE,EAAE,IACH,EAAE,CAA/B,EAAO,IAAD,EAAO,CAAyB,EAAO,IAAD,CAAM,CAAA,AAC/C,GAET,MAAO,CACL,EAAE,CAAA,CAAA,EAAE,EAAA,MAAA,AAAM,EAAC,IACN,KACH,CADS,CACT,EAL4C,CAAA,QAK5C,AAAW,EAAC,EAAO,EAAE,CAAH,AAAK,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CACpC,EACD,CAAC,CAEN,AADG,CACF,AAED,AAHG,KAGH,CAAA,EAAM,EAAA,QALuB,WAKvB,AAAmB,EAAC,EAAkB,CAAF,AACxC,GAAG,CAAU,SACb,EACA,KADO,AACF,CAAE,EAAW,KAAM,CACzB,CAAC,AACJ,CACF,AAHuB,AAEpB,AADG,CAEL,AC3LM,KAAK,UAAU,EAIpB,CAAyC,CACzC,CAAoC,QAEpC,CAPkC,IAO7B,UAAU,EAAU,CAAO,EAE9B,GADuB,CADD,AAElB,CADqB,AAAC,QAAQ,CAAC,EAAwB,EACzC,GAD8C,CAAC,CAAC,CAAC,CAAC,CAChD,AADgD,CAC/C,AACnB,IAAM,EAAO,CAAA,EAAG,CAFwC,CAE3C,AAAG,IAAA,AAAI,EAAA,CAAA,EAAC,EAAA,QAAA,AAAQ,EAAC,EAAE,AAAE,CAAC,EAAE,CAAE,CAAC,EAAE,CAAC,CAAC,CAAA,AACtC,EAAM,CAAA,EAAG,CAAH,CAAG,QAAA,AAAQ,EAAC,EAAE,AAAE,CAAC,CAAE,CAAC,EAAE,CAAC,CAChC,KAAA,CAAM,CAAC,CAAC,CACR,KAAK,CAAC,QF2BI,AANqB,EErBf,EAEb,EAAW,MAAM,CF8BX,OE9BmB,GAAG,CAAA,EACxB,GAAG,CAAC,AAAC,CF8BL,CAAA,CE7BN,CADe,AAAI,CACqB,CADvB,IAC4B,CAAC,CAAC,CAAC,GAAK,EACjD,EADqD,AF8BjD,AE7BG,OAAA,CAAA,CAEH,OAAA,MAH+B,sBAI/B,MAAM,CAAE,CAAC,CAAA,EAAA,EAAK,EAAI,CAAE,CAAF,AAAG,GAErB,OAAA,CAAA,CAAY,CAAE,CACjB,MACD,CF6BwB,CACtB,IEzBJ,EAAS,IAAI,CAAA,AADJ,CAAC,AACF,AF4BE,EADgB,AE3BL,AAAM,CADd,AACS,CF2BM,CE5Bb,CACgB,CAAC,EAAE,EF6B9B,CE7BqC,CF6BnC,CAAA,CE7BsC,CAAA,CAAC,CACpC,KAAK,CAAC,AAAC,CAAC,EAAE,AAAG,AADiC,CAClC,AAAE,EAAE,MAAM,GAAK,KAAK,CAAC,CF8BnC,CE9BqC,GAC5C,CADuD,CAC9C,AF6BF,KE7BO,CAAE,AAAR,AAAO,CAAE,EAAE,AAAG,AAD2C,CAC5C,AAAE,EAAE,MAAM,GAAK,KAAK,CAAC,CAAS,CAAP,EAAU,CAAA,ADHnC,ACIhB,GAAG,CAAA,AAGZ,GDeO,GCfA,CACL,EDeM,KAAA,CAAA,CCpBwE,CAM9E,EDgBM,MAAA,CAAA,EChBG,EAAA,WAAA,AAAW,EAAC,OAAO,CAAC,IACnB,EAAS,MAAM,CAAC,OAAO,CAA4B,0BAG9D,AACH,CAAC,AADE,AAEH,IDgBE,CAAC,EChBI,EAAO,CDgBN,MChBa,CAAC,CACpB,OAAA,+BACQ,CAAC,CDiBC,CCjBE,CACb,CAAC,AACJ,CADI,AACH,AAED,GAAM,CAAA,OAAA,GACK,CAAK,SACd,CAAO,UACP,CAAQ,SACR,EAAU,KAAH,EAAU,CACjB,GAAG,EACJ,CAAG,KADS,CACH,EAAU,EAAW,EAAS,CAAC,CAAA,AACnC,CAAA,AADa,EACJ,CADe,CACJ,EAClB,CADqB,CACR,AADS,EACA,CADG,AF+BF,CE/BN,AF+BX,CE/BqB,GACN,AAAO,CAAA,EAChB,GAAG,AF8BA,EE9BI,EAAa,EDWT,CCXY,CAChC,CAAP,MDYQ,ICZW,EAAoB,CAAA,GACvB,CDWY,ECXT,CADU,CACN,EAAa,GAAG,CAChC,CAAP,AAAQ,GADyB,MAChB,CAAE,EAAoB,CAAA,AFkCtC,GEjCe,GAAG,CADU,CACN,CDYH,CCZgB,CDYH,ECZM,CAChC,CAAP,UAAmB,EAAoB,CAEzC,AAFyC,AAEtB,OAFY,OAE/B,EAAmB,WAAgC,EDa9B,CCbiC,EAEnC,SAAS,EAAE,CAA1B,EAAiC,CAAC,IFkC3B,AAEO,CAAA,IEpC6B,CAAE,GAAG,CAAU,CAAA,AACvD,MAAC,EAAW,EAAW,CAAA,IAAb,EAEZ,CAFwB,GAG1B,CAAA,UAGH,QAAS,EAAS,CAAA,EAAC,EAAA,AAAH,CAAC,CAAC,SAAC,AAAW,EAAC,QAAW,SAAS,EAEjD,CDaS,ECbC,GAAG,CAAC,AAAC,IAAa,CAC1B,EADoB,CACjB,CAAO,AADY,CAEtB,AAFyB,WAEd,CAAA,CAAA,EAAE,EAAA,WAAA,AAAW,EAAC,EAAQ,KAAD,MAAY,CAAC,YACpC,EAAA,WAAA,AAAW,EAAA,EAAS,OAAO,CAAC,QAC7B,EAAA,eAAe,CAAC,EAAQ,KAAD,CAAwB,CAAC,CDelB,ACdvC,CAAC,CAAC,EAAI,EAAE,IDeF,QCdT,SACA,MAAM,IACN,EACD,AACH,CFrDO,AEqDN,AADE,IADQ,CFnDC,UAAU,EACpB,CAAgC,CAChC,CAAwC,EAExC,IAcI,EAdE,GAcsB,CAb1B,AAa0B,CAbxB,iBACF,EAAA,EAAyB,eAAe,QACxC,EAAS,CAAC,CAAE,EAAN,UAAgB,CAAE,EAAE,CAAkB,GAAG,GAAlB,CAAD,EAAuB,GAAc,GAAG,CAA7B,GAAsB,QAC7D,EAAa,CAAC,OAAJ,KACV,EAAa,CAAC,OAAE,AAAN,CAAW,CAAE,EAAE,CAAoB,IAAjB,CAAC,CAAC,CAAC,CAAC,EAAI,CAAA,CAAK,AAAO,CAAN,QAAQ,EACxC,GAAM,EAAT,cACP,GAAiB,CAFuD,AE5BxD,AF8BM,CACvB,CE/BiC,AF+B9B,EACE,CE/BO,CAEF,CAAA,EF6BQ,CE7BD,AAAR,CAAC,AAAO,SAAA,EF6BW,CAAC,oBAAoB,CAAE,EAAO,GAAG,CAAJ,AAAM,EAAE,AAAC,CAAC,CAAA,AAE9D,CAAE,SAAO,SAAE,CAAO,IE7BF,IF6BI,CAAM,CAAE,CAAA,CAAA,EAChC,EAAA,aAAA,AAAa,CE9BoC,CF8BJ,CAAA,CAIzC,EAAA,CAAA,EAAY,EE/BI,GAAA,IAAA,EF+BI,EAAY,CE/BV,QF+BY,OAAO,EAAE,CAAM,CAAE,CAAE,AAAC,GAAL,CAAS,AAC9D,EADgE,EAAE,AAC5D,EE9BE,AAAC,CAAA,EF8BM,EAAA,IAAA,AAAI,EACjB,CE7BC,CAAA,GF6BI,IAAI,EAAE,GACH,EAAO,AAAC,EAAJ,EE5BA,AF6BR,aAAA,GACA,IACA,EAAE,EACF,GACF,CAAC,CAAA,AAED,GAAI,CAAC,AACH,GC1BC,CD0BK,EAAS,MAAA,CAAA,EAAM,CC1BD,CAAA,SAAA,AD0BU,EAC5B,UACE,IAAM,EClBM,ADkBG,CClBF,CAAC,IDkBC,CAAA,EAAM,EAAA,SAAS,AAAT,EACnB,CCnBkC,CDoBlC,ACpBmC,CAAO,AAAN,CAAM,AAAL,ADqBrC,YADc,IACE,CACjB,CAAC,IAAE,CAAE,CAAE,AAAF,CAAG,CAAA,AACT,GAAI,GAAkB,AAAkB,CCrB5B,EAA0B,EAAE,CDqBZ,GAAqB,KAArB,MAAO,CACjC,ECrBc,CAAA,ECfT,CFoCC,IAAI,EAAkB,GAC9B,GADoC,CAAC,CAAA,EAC9B,CACT,CAAC,CACD,EAH+B,GElC3B,OFsCF,EACA,GErCC,GFqCM,CCrBC,GDwBZ,GAAI,CAAC,EAAO,GAAS,CAAV,AErCJ,EFqCW,CAAC,GACnB,EErCE,AFqCG,GAAG,CAAG,CAAD,CAAM,EAAD,KAAQ,CAAC,GAC1B,AEtC6B,CFsC5B,AAAC,EAD8B,AClBhC,AADE,CDmB+B,CAAC,CAAA,CACzB,CCnBH,CDmBU,CAAC,AACf,CCnBC,CDmBI,ECnBE,EDmBI,EAAK,MAAM,CAAC,GACzB,CACF,AADG,CACF,CACD,CACE,EErCE,GAMK,IF+BG,EE9BE,AF+BZ,YAAA,CAAA,EACD,CACF,CAAA,AAED,OAAO,CACT,CAAC,CCrBW,ADqBV,CAAA,AAUF,OARA,EAAQ,EACJ,KADW,MACA,GAAG,CCrBH,CDqBK,AACd,GElCe,CFmCf,aAAa,GACb,EAAO,IAAD,AAAK,CCrBH,CDqBkC,IAAE,CAAE,CAAA,AAAE,CAAC,CAAC,AACpD,CADoD,AACnD,CAAE,OAAO,CAAC,AACX,EAEG,MAAM,CACf,CAAC,+IAMK,OAAO,UAAuC,AC1BlC,ED0BkC,SAAS,CAC3D,YAAY,IAAE,CAAE,CAAkB,CAAA,GCzBb,GD0Bd,CACH,CAAA,iDAAA,EAAoD,EAAE,kBAAA,CAAoB,CAC1E,CAAE,IAAI,CAAE,gCAAgC,CAAE,CAC3C,AACH,CADG,AACF,CACF,yGIxKD,IAAA,EAGO,CAHA,CAG+B,CADpC,AACoC,CAAA,MA6C/B,IA9CM,CA8CD,CA7C0B,CAAA,AAArC,MAAM,EA6Ce,EACpB,CAAgC,CAChC,CAAE,EAFyB,OAElB,aAAE,CAAW,UAAE,EAAW,MAAH,EAAW,CAAqB,EAEhE,IAAM,OACY,IAAhB,EAA2B,CADT,AACS,EAAF,AAAG,CAAF,CAAE,AAAD,IAAhB,OAAiB,AAAW,EAAC,QAAe,EACnD,CAD+C,CAAC,AAC1C,CAD2C,AAC9C,CAD+C,GAAU,CAAA,AAChD,EAAO,IAAD,GAAQ,CAC9B,CACE,MAAM,CAAE,aAAa,CACrB,MAAM,CAAE,CAAC,EAAS,GAAkB,EAAS,AAA7B,CACjB,CACD,CAAE,GAF4C,GAEtC,AAF0B,EAExB,CAAQ,CAAe,CAAE,CACpC,CAAA,AACD,EAFmB,CAEP,IAAI,EAAE,CAFgB,AAE9B,CAF+B,CAGnC,CADO,GAAkB,GAClB,CACT,CAAC,CADW,CAAA,EADwB,CAAA,2CCrEpC,IAAA,ECKO,CDLA,ACEA,CAGwB,CAF7B,ADHO,ACKsB,CAAA,QDLb,EAAE,IAKP,EALa,CCKK,EAIb,EAAE,GANO,ADEoB,ECIK,CDTf,ACKpC,AAIyB,CDTW,CCSe,CAAA,GAJ7C,EDAiD,CACtD,GADqC,ACKhC,EAGL,ODPY,SAAE,CAAO,CAAwB,CCOjC,ADPiC,CCQxC,ADPH,ECOH,GDPQ,CAAC,CAAA,YCOgB,CAAA,wBDPhB,EAAwC,EAAO,EAAA,CAAI,CAAE,CAAN,AACnD,YAAY,CAAE,CACZ,cAAc,CACd,CAAA,2CAAA,EAA8C,EAAO,EAAA,CAAI,CACzD,CADqD,oDACA,CACrD,0EAA0E,CAC3E,CACD,IAAI,CAAE,2BAA2B,CAClC,CAAC,AACJ,CADI,AACH,CACF,ACRD,IAAA,EDJM,EAAA,CAAA,CAAA,QCKN,EAAA,EAAA,CAAA,CAAA,QAwDO,KAAK,UAAU,EACpB,CAAyB,CACzB,CAAqC,EAErC,GAAM,KAJ6B,IAI3B,CAAO,SAAE,CAAO,aAAE,CAAW,CAAE,CAAG,EAE1C,GAAI,CAAC,AACH,GAAM,CACJ,AAJgD,CAAA,CAKhD,EACA,EAFM,AACF,AAEJ,EACA,EACA,CAHO,CAIP,CAHO,CAEH,AAEL,CAAG,MAAA,CADQ,AACR,EAAM,CAHS,CAGT,SAAA,AAAS,EACjB,EACA,EAAA,EADM,UACM,CACZ,cAAc,CACf,CAAC,CACA,GAAG,WACH,EACA,KADO,OACK,CAAE,cAAc,SAC5B,EACA,KADO,MACI,GACZ,CAAC,CAAA,AAEF,MAAO,CACL,MAAM,CAAE,MACN,IAAI,MACJ,EACA,KADO,EACA,CAAE,MAAM,CAAC,OAAO,CAAC,aACxB,OACA,EACD,EADK,MADa,IAGnB,SACA,CADU,CAGd,AADG,CACD,AAAD,AADE,GADO,GAED,CAAC,CAAE,CAAC,AAEX,GACiB,gCAAgC,GAA/C,EAAM,GAAD,CAAK,EACW,+BAA+B,EACpD,CAAC,AADD,EAAM,GAAD,EAAM,CAAC,IAAI,CAEhB,MAAM,IAAI,EAA0B,SAAE,CAAO,CAAE,CAAC,AAElD,CAFkD,GAAH,EAEzC,CAPQ,CAA0B,AAQ1C,CAAC,AACH,AAT4C,CAS3C,AAED,CANyC,AAE1B,CAAA,EAIT,EAAM,CAAH,AACP,CACE,MAAM,CAAE,EAAE,CACV,IAAI,CAAE,cAAc,CACpB,OAAO,CAAE,CACP,CAAE,IAAI,CAAE,QAAQ,CAAE,IAAI,CAAE,QAAQ,CAAE,CAClC,CAAE,IAAI,CAAE,MAAM,CAAE,IAAI,CAAE,QAAQ,CAAE,CAChC,CAAE,IAAI,CAAE,SAAS,CAAE,IAAI,CAAE,QAAQ,CAAE,CACnC,CAAE,IAAI,CAAE,SAAS,CAAE,IAAI,CAAE,SAAS,CAAE,CACpC,CAAE,IAAI,CAAE,mBAAmB,CAAE,IAAI,CAAE,SAAS,CAAE,CAC9C,CAAE,IAAI,CAAE,MAAM,CAAE,IAAI,CAAE,SAAS,CAAE,CACjC,CAAE,IAAI,CAAE,YAAY,CAAE,IAAI,CAAE,WAAW,CAAE,CAC1C,CACD,eAAe,CAAE,MAAM,CACvB,IAAI,CAAE,UAAU,CACjB,CACO,CAAA,+DCrImC,EAAA,CAAA,CAAyB,CAAA,OACtE,IAAA,EAA8C,CAAvC,CAA2D,CAAzD,AAAyD,CAAA,QAClE,CADmB,CACoB,CAAhC,CAAsD,CAAA,AADtC,AACd,CAAoD,EADK,CAAA,EACnD,GACf,CADmB,CACgB,CAD0B,AACtD,CADsD,AAC1B,CAAA,CAFG,AAEH,EAFK,AAE5B,KADmB,AAG/B,AAFiB,EADgB,AAGF,CAAxB,CAAwB,CAAA,CAAA,AAFR,EAEX,AAH2B,GAGxB,GAuCT,GAvCe,CAFc,CAAA,IAyCnB,EAMd,CAAoC,CA7CP,AA8C7B,CA9C6B,CA8CI,CAAA,CAAE,CAPZ,CASvB,GAAM,IAAE,EAAE,AAAG,AAAiB,QAAQ,CAAC,CAAC,OAApB,EAAqB,GAAhB,EAAqB,CAAC,AAAE,CAAD,MAAQ,CAAE,CAAG,EACvD,EAAK,CAAA,EADyD,AACzD,AAAG,CADsD,CACtD,UAAA,AAAe,EAAC,EAAM,GAAD,CAAK,AAAJ,CAAK,KAAK,CAAC,CAAC,CAAA,EACrC,AAAX,OAAkB,EAAE,CAAhB,EAAuB,AAArB,EACC,EAAI,CAD8B,AAC/B,CAD+B,AAC9B,OAAS,CAAC,EACvB,CAAC,AAmFK,EApFsB,CAAU,CAAA,KAoFtB,EAMd,CAAoC,CACpC,EAPoB,AAOU,CAAA,CAAE,EAEhC,GAAM,IAAE,EAAE,AAAoB,QAAQ,CAAC,CAA1B,AAA2B,OAApB,EAAqB,GAAhB,EAAqB,CAAC,AAAE,CAAD,MAAQ,CAAE,CAAG,EACvD,EAAK,CAAA,EADyD,AACzD,AAAG,CADsD,CACtD,MAAA,AAAY,EAAC,EAAM,GAAD,CAAC,AAAI,CAAC,KAAK,CAAC,CAAC,CAAA,EAC7C,AAAW,OAAO,EAAE,CAAhB,EAAE,AAAqB,EACpB,EAAI,CAAD,AAD+B,CAAA,AAC9B,OAAS,CAAC,EACvB,CAAC,EAD2B,CAAU,CAAA,4DElJhC,OAAO,MAAwB,IAAQ,GAAkB,CAG7D,YAAY,CAAY,CAAA,CACtB,KAAK,EAAE,CAAA,AAHT,OAAA,cAAA,CAAA,IAAA,CAAA,UAAA,0DAIE,IAAI,CAAC,OAAA,CAAU,CACjB,CAAC,AAEQ,GAAG,CAAC,CAAW,CAAA,CACtB,IAAM,EAAQ,GAAH,EAAQ,CAAC,GAAG,CAAC,GAOxB,OALI,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,KAAc,IAAV,IACpB,CADuC,AAAd,EAAgB,CAAC,AACtC,CAAC,MAAM,CAAC,GAAG,AACf,CADgB,CAAA,GACX,CAAC,GAAG,CAAC,EAAK,CAAF,GAGR,CACT,AAJwB,CAAC,AAIxB,AAEQ,CANgB,EAGX,AAGF,CAHE,AAGD,CAAW,CAAE,CAAY,CAAA,CAEpC,GADA,KAAK,CAAC,GAAG,CAAC,EAAK,CAAF,EACT,EADgB,CAAC,CACb,AADa,CACZ,OAAO,EAAI,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,OAAO,CAAE,CAAC,AAC7C,IAAM,EAAW,IAAI,CAAC,CAAR,GAAY,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,CAAA,AACrC,GAAU,IAAI,CAAC,AAAP,MAAa,CAAC,EAC5B,CAAC,AACD,KAFoC,CAAC,CAAA,AAE9B,IAAI,AACb,CADa,AACZ,CDzBI,AC0BN,ID1BY,EAJE,AAIS,CAHtB,KAGmB,AAAS,GAHpB,CAAgB,CAAd,GAAkB,EAAwB,IAAI,AAAtB,CAAuB,CAA/C,AACX,CAE8B,AAF9B,CADwB,OAGc,CAAA,8EELvC,EAAqC,CAA9B,ACDA,CDC8B,CAAA,CAAA,ECDzB,ADCA,MAAM,ACDA,ADElB,EAAqC,CCD9B,ADCA,CAA8B,CAAA,CADb,AACa,ACFb,EACZ,ADCA,GCDG,GDCG,GCDG,EADgB,ADCA,CAAA,ACDA,ADEb,OCDO,CAAA,KDCM,CAAA,0BCyC/B,SAAU,EACd,CAAkC,CAClC,EAFoB,AAEM,CAAA,CAAE,EAE5B,GAAM,YAAE,CAAU,CAAE,CAAG,EACjB,KADwB,CAAA,EACtB,CAAM,GAAE,CAAC,GAAE,CAAC,CAAE,CAAG,EAGzB,EDnBI,CCoBF,CAAA,GAJgC,CAAA,GAKlB,AAAb,iBAAO,CAAC,CDjBG,CCiB2B,QAAQ,CAAC,CAAtB,GDjBK,CAAA,GCiBE,CAAC,CAClC,CAAC,GACc,CAAC,GAAZ,EACF,IADQ,EACR,CDlBa,GCkBH,EAAmB,QAC3B,EACA,CDlBK,AACF,EAFsB,GAEtB,ICiBQ,IAEf,MDhBQ,ACiBV,CADQ,AACP,AAGD,EDvBgC,CCuBhC,CACiB,ADxBiB,GAKH,CCkB/B,AACqB,ADnBW,GCoBrB,QARoC,EAAE,AAQ9C,OAAO,CAAC,EAAiB,KAAa,IAAb,EAC1B,CAAC,AACD,GAAI,CAF8C,CAAC,EAE/C,GAA2B,CAAC,GAAZ,EDpBF,ACqBhB,IADwB,EAClB,GDpBC,CCoBG,EAAmB,MDpBI,EAAE,ACqBjC,EACA,IADM,CACD,CAAE,IAAI,IAEf,MACF,CADQ,AACP,AAGD,MAAM,IAAI,EAAa,KANsB,EAAE,GAMzB,CAAG,CAAS,CAAE,CACtC,AADuC,CAmFjC,AAlFL,AADsC,KAAH,IAmFpB,EDXW,ACiBzB,CDjByB,ACiBG,CANV,CAOlB,IAAM,EAAY,CAAC,GAAG,EAAE,AACtB,CADa,EACT,EAAI,CAAD,CAAC,MAAQ,CAAC,GAAQ,EAAH,CAAC,IAAS,EAAQ,GACxC,EADuC,AAAM,CAAC,AAC1C,CAD0C,CACpC,GAAD,CAAC,IAAQ,CAAC,KAAK,CAAC,EAgEH,EAhEK,OAgEiB,AAhEV,EAAU,EAiEvC,EAAQ,CAjEoC,CAiEhC,CAAD,AAjE2B,CAiE1B,CAAL,MAAc,CAAC,GAjEuB,CAAA,AAElD,GAAM,EA+D8B,CAAC,CAAC,CAAA,GA/D9B,CAAM,GAAE,CAAC,GAAE,CAAC,CAAE,CAAG,KAAK,CAAA,EAC9B,AAAiB,QAAQ,EAArB,OAAO,CAAC,EAA8B,QAAQ,EAArB,AAC3B,OADkC,CAAC,CAC5B,CAAE,MAAM,CAAE,GAAU,GAAJ,CAAQ,AAAE,CAAC,CAAE,CAAC,EAAA,CAAE,CAAA,AAClC,QAAE,IAAQ,CAAC,CAAH,AAAK,CAAA,AACtB,CAAC,CAAC,EAIF,AAJI,CAAA,MAEJ,EAAO,GAEA,CACT,AAHQ,CAGP,AA+FK,IAlGY,CAAC,CAAA,CAEQ,CAAA,CAgGX,EAAQ,CAAkB,EACxC,EADqB,CAEE,GAAG,GAAxB,EAAU,MAAM,CAAP,CACY,GAAG,GAAxB,EAAU,MAAM,CAAP,CACY,EAAE,GAAvB,EAAU,MAAM,CAAP,AAET,MAAM,IAAI,EAA2B,WAAE,CAAS,CAAE,CAAC,CAAA,AAErD,GAAyB,EAFyB,CAEtB,EAAE,CAAC,AAFO,AAElC,EAAU,MAAM,CAGlB,AAHW,MAGJ,CACL,MAAM,CAAE,CAAC,CACT,CAAC,CAJO,MAAM,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAW,CAAC,CAAE,EAAE,CAAC,CAAC,CAAA,AAK3C,AALkC,CAKjC,CAJO,MAAM,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAW,EAAE,CAAE,EAAE,CAAC,CAAT,AAAU,CAAA,AAKpC,CAAA,AAGZ,EDnBI,CCmBqB,MAArB,EAAU,MAAA,CAAW,CACvB,IAAM,EAAS,EDhBH,ECgBA,GAAG,EAAA,KAAgB,CAAC,EAAW,CAAC,CAAE,CAAC,CAAC,CAAC,CAAA,OAI/C,MAAM,GACN,CAAC,CAJO,MAAM,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAW,CAAC,CAAE,EAAE,CAAC,CAAC,CAAT,AAAS,AAK3C,CAAC,CAJO,IDhBI,GCgBG,EAAA,KAAA,CAAA,EAAqB,EAAE,CAAE,EAAE,CAAC,CAAC,CAMhD,AANgD,CAM/C,AAID,MAAO,CACL,MAAM,CAHO,MAAM,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAW,CAAC,CAAE,CAAC,CAAC,CAAC,CAAA,AAI/C,CAJuC,AAItC,CAHO,MAAM,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAW,CAAC,CAAE,EAAE,CAAC,CAAC,CAInC,AACZ,AAL+C,AAAT,CAKrC,AA0BK,AA3BM,SA2BI,EACd,CAA6B,CAC7B,EAA2B,CAFN,AAEM,CAAE,EAE7B,OAAO,EAAA,OAAa,CAAC,EAAM,EAAW,GACxC,CAAC,AAqCK,ADlDgE,CAAC,CAAA,OCkDvD,EACd,CAA6B,CAC7B,CAFmB,CAEM,CAAA,CAAE,EAE3B,EAAO,GAEP,CAFM,EAEA,GAFU,CAAC,CAAA,GAET,CAAM,CAAE,GAAC,GAAE,CAAC,CAAE,CAAG,EACnB,OAD4B,CAAA,OAC1B,GAAgB,CAAI,CAAE,CAAG,EASjC,KATwC,AAAnB,CAAmB,CASjC,AAPY,EAAI,CAAD,CAAC,IAAM,CAC3B,CAMe,CANC,AAMD,EANK,CAAD,CAAC,OAAP,CAAC,AAAgB,CAAf,AAAgB,EAAQ,CAAE,GAAJ,CAAQ,CAAE,CAAC,CAAE,CAAC,CAAG,AAAF,CAAC,GAAK,CAC1D,EAAI,CAAD,CAAC,QAAU,CAAC,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAElB,CADb,OACqB,CAAC,CAAtB,AAAuB,OAAhB,CAAC,CAAgB,EAAI,CAAD,CAAC,QAAU,CAAC,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAAC,AAAE,CAAD,GAAK,CAIlE,AAHG,CAGF,AAiEK,AApEH,MAoEU,KAtEoD,KAsE/B,EAAR,AAAe,IAAD,CAAC,IAAS,CAGhD,YAAY,WAAE,CAAS,CAA0B,CAAA,CAC/C,KAAK,CAAC,CAAA,QAAA,EAAW,EAAK,EAAD,CAAC,MAAS,CAAC,GAAU,MAAD,CAAC,sBAAA,CAA+B,CAAE,CACzE,YAAY,CAAE,CACZ,0BAA0B,CAC1B,0CAA0C,CAC1C,kDAAkD,CACnD,CACF,CAAC,CAAA,AATc,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,wBAAwB,EAUjD,CAViD,AAUhD,CACF,AAGK,MAAO,UAIH,EAAO,IAAD,CAAC,CAAf,GAA+B,CAG/B,YAAY,QAAE,CAAM,OAAE,CAAK,CAAgD,CAAA,CACzE,KAAK,CAAC,CAAA,QAAA,EAAW,EAAM,IAAA,SAAA,CAAe,CAAE,OACtC,EACD,CAAC,CAAA,AALc,CAIT,MAJS,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,8BAA8B,EAMvD,CANuD,AAMtD,CACF,AAGK,MAAO,UAAqC,EAAO,IAAD,CAAC,IAAS,CAGhE,MAHwC,OAGxC,CACE,KAAK,CAAC,mDAAmD,CAAC,CAAA,AAH1C,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,wCAAwC,EAIjE,CAJiE,AAIhE,CACF,AAGK,MAAO,UAAuC,EAAO,IAAD,CAAC,IAAS,CAGlE,QAH0C,KAG1C,CACE,KAAK,CAAC,gDAAgD,CAAC,CAHvC,AAGuC,OAHvC,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,0CAA0C,EAInE,CAAC,AAJkE,CAKpE,AAGK,MAAO,UAAmC,EAAO,IAAD,CAAC,IAAS,CAG9D,IAHsC,QAG1B,WAAE,CAAS,CAAwC,CAAA,CAC7D,KAAK,CAAC,CAAA,QAAA,EAAW,EAAS,OAAA,0BAAA,CAAmC,CAAE,CAC7D,YAAY,CAAE,CACZ,wGAAwG,CACxG,CAAA,SAAA,EAAY,EAAI,CAAD,CAAC,EAAI,CAAC,EAAI,CAAD,CAAC,EAAI,CAAC,IAAW,KAAF,CAAC,CAAC,CAAS,CACnD,CACF,CAAC,CAAA,AARc,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,sCAAsC,EAS/D,CAT+D,AAS9D,CACF,yEDjgBD,IAAM,EAAe,UAAH,WAAwB,CAAA,AA0BpC,SAAU,ECoBF,ADnBZ,CAAa,CACb,EAFoB,AAEM,CAAA,CAAE,EAE5B,GAAM,CCiBJ,ODjBM,GAAS,CAAI,CAAE,CAAG,EAE1B,GAAI,CAAC,EAAa,IAAI,CAAC,GACrB,EAD0B,CAAC,GACrB,IAAA,EAAwB,CAC5B,CCgB4B,ODhBnB,CCiBD,CDhBR,GADc,GACP,ECiBA,EDjBI,EACZ,CAAC,CAAA,AAEJ,GAAA,EAAY,CAAC,AACX,GAAI,EAAM,GAAD,QAAY,EAAE,GAAK,EAAO,GAAF,IACjC,GAAI,EAAS,ICmBH,CDnByB,CAAvB,CACV,GADsC,GAChC,IAAI,EAAoB,CAC5B,ECoBM,GAFY,GDlBT,EACT,MAAO,IAAI,EACZ,CAAC,AACN,CACF,AAFQ,AACL,CACF,AA6BK,QCZ4B,CDYlB,EAAS,CAAe,EACtC,GADsB,AAClB,EAAO,IAAD,CAAC,GAAQ,CAAC,GAAG,CAAC,GAAU,IAAH,CAAC,EAAS,EAAO,IAAD,CAAC,GAAQ,CAAC,GAAG,CAAC,GAE7D,EAAO,EAF6D,AAEpD,CAAE,AAFoD,CAAA,AAEhE,GAAQ,EAAU,EAAE,CAAK,CAAE,CAAC,CAAA,AAElC,CAF+B,GAEzB,EAAa,EAAQ,KAAD,CAAV,GAAoB,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAA,AAC/C,EAAO,EAAK,AAAR,EAAO,CAAC,MAAS,CAAC,EAAM,GAAD,CAAC,MAAU,CAAC,GAAa,CAAE,EAAE,CAAE,GAAT,CAAC,GAAe,CAAE,CAAC,CAAA,AAEpE,EAAa,EAAW,KAAK,CAAC,AAApB,EAAsB,AAAT,CAAU,CAAA,AACvC,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAE,CAAE,CAAC,EAAI,CAAC,CAAE,AAC1B,CAD2B,AACvB,CAAC,CAAC,EAAI,CAAC,CAAE,EAAI,CAAC,EAAI,CAAC,EAAI,CAAU,CAAC,CAAC,CAAC,EAAE,CAAC,AAC7C,CAAU,CAAC,CAAC,CAAC,CAAG,CAAU,CAAC,CAAC,CAAE,CAAC,WAAW,EAAA,CAAE,CAAA,AAE1C,CAAC,AAAgB,IAAZ,CAAC,CAAC,EAAI,CAAC,CAAE,AAAG,CAAI,CAAC,CAAI,CAAC,EAAI,CAAU,CAAC,CAAC,CAAG,CAAC,CAAC,EAAE,CAAC,AACrD,CAAU,CAAC,CAAC,CAAG,CAAC,CAAC,CAAG,CAAU,CAAC,CAAC,CAAG,CAAC,CAAE,CAAC,WAAW,EAAA,CAAE,CAAA,AAIxD,IAAM,EAAS,CAAA,EAAA,EAAK,EAAW,ICcL,ADdS,CCcT,ADdU,EAAE,CAAR,AAAS,CAAA,CAAW,CAAA,AAElD,OADA,EAAM,IAAA,IAAS,CAAC,GAAG,CAAC,EAAS,GACtB,CACT,CAF6B,AA6CvB,AA3CL,CAFoC,ACe3B,CDf4B,CAAA,MA6CtB,EAAK,CAAe,CAAE,AAAlB,EAA0C,CAAA,CAAE,EAC9D,GAAM,CAAE,QAAQ,CAAE,GAAc,CAAK,CAAE,CAAG,KAAb,EAAoB,CAAA,AAEjD,CADA,EAAO,GACH,CADE,EACkB,CADV,CAAC,AACkB,CADlB,EAER,CACT,CAAC,AAoCK,CAtCW,AAAiB,CAAQ,CAAC,AAAxB,CAAwB,KAsC3B,EACd,CAA8B,CAC9B,EAAiC,CAAA,CAAE,EAEnC,GAJ2B,CAIrB,EAAU,EAAK,EAAD,CAAC,AAAR,MAAiB,CAC5B,CAAA,EAAA,EAAK,EAAgB,GAAP,AAAkB,CAAjB,IAAsB,CAAjB,AAAU,AAAQ,CAAP,AAAQ,CAAC,CAAA,CAAE,CAC3C,CAAC,SAAS,CAAC,EAAE,CAAC,CACf,AADe,OACR,EAAK,CAAA,CAAD,CAAC,EAAK,EAAO,CAAE,CAAE,EAC9B,CAAC,AA+CK,AAhDoB,IAAW,CAAC,CAAA,GAgDtB,EAAQ,CAAiB,CAAE,CAAiB,EAArC,AAGrB,OAFA,EAAO,EAAU,CAAE,CAAb,IAAS,CAAU,EAAE,CAAK,CAAE,CAAC,CAAA,AACnC,CADgC,CACzB,EAAU,CAAE,CAAb,IAAS,CAAU,EAAE,CAAK,CAAE,CAAC,CAAA,AAC5B,CADyB,CAChB,MAAD,KAAY,EAAE,GAAK,EAAS,MAAD,KAAY,EACxD,AAD0D,CA8BpD,AA7BL,AADyD,SA8B1C,CCmBD,CDlBb,CAAe,CACf,CCiB+B,CDjBH,CAAA,CAAE,EAE9B,GAAM,QAAE,GAAS,CAAI,CAAE,CAAG,CCgBH,EAAI,ADhBU,CCgBT,ADhBS,CAAE,CAAA,AACvC,CADiC,EAC7B,CAAC,AAEH,CCayC,MDdzC,EAAO,EAAS,QAAE,CAAM,CCgBJ,CAAC,EDfd,CADiB,AAE1B,CAAE,AAAD,EADY,CAAA,EACL,CAAC,AACP,OAAO,CACT,CAAC,AACH,CAAC,AAwBK,EA1BU,CAAA,GA0BH,UAIH,EAAO,IAAD,CAAC,EAAf,EAA+B,CAG/B,YAAY,SAAE,CAAO,OAAE,CAAK,CAAqC,CAAA,CAC/D,KAAK,CAAC,CAAA,SAAA,EAAY,EAAO,KAAA,QAAA,CAAe,CAAE,OACxC,EACD,CAAC,CAAA,AALc,CAIT,MAJS,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,6BAA6B,EAMtD,CANsD,AAMrD,CACF,AAGK,MAAO,UAA0B,EAAO,IAAD,CAAd,AAAe,IAAS,CAGrD,aAAA,CACE,KAAK,CAAC,8DAHU,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,2BAA2B,EAIpD,CAJoD,AAInD,CACF,AAGK,MAAO,UAA6B,EAAO,IAAD,CAAC,GAAf,CAAwB,CAGxD,aAAA,CACE,KAAK,CAAC,kDAAkD,CAAC,CAAA,AAHzC,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,8BAA8B,EAIvD,CAJuD,AAItD,CACF,iMEpVD,IAAA,ECIwC,CDJjC,ACIA,CAAiC,CAAA,CAAA,EAA5B,ADJA,OCIO,ADJA,MAAM,ACIA,ODFzB,EAFkC,ACKI,CDLJ,AAE3B,ACGA,CAA+B,CAAA,CAAA,EADE,AAC5B,ADHA,CCE4B,KACtB,ADHA,MAAM,ACGA,QDDxB,ECyaM,EAAA,CAAA,AD3a+B,CC2a/B,AAxagC,ADHD,CCGC,8BAwatB,EAAmB,CAAiB,EDza/B,AC0anB,GDzaK,CCyaD,GAAS,CDzaH,CC0aN,CD1ac,AADW,AC0anB,CAAO,AACH,AD3ae,CC0aZ,CADe,AAEhB,CAAA,AACZ,ED3aoB,AC0ab,AACC,CAAC,CACT,AADS,CAAJ,CACI,EAAE,CAAA,AACX,CADM,CACE,GAAH,AAET,EAFiB,CAAA,CAEZ,IAAI,CAAC,CAAG,CAAC,AD/aiC,CC+a/B,AD/a+B,CC+a9B,CAAG,EAAU,MAAM,CAAP,AAAS,CAAC,EAAE,CAAE,CAAC,AAC1C,IAAM,EAAO,CAAS,CAAZ,AAAa,CAAC,CAAE,CAAA,AAU1B,GAPI,CAOA,AAPC,GAAG,CAAE,GAAG,CAAE,GAAG,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,AAAE,GAAS,CAAA,CAAI,CAAP,AAAO,AAGpC,GAAG,GAAZ,GAAc,CAAV,GACK,CADU,EAAE,AACT,CADS,EACrB,GAAc,CAAV,GAGH,CAHkB,EAAE,AAMzB,CANyB,EAGd,AAGG,CAAC,CAHF,EAGT,EAAa,CAAC,AAChB,EADO,CACM,CAJM,EAIH,GAAZ,GAAgB,CAAC,AAAb,OAAoB,CAAE,UAAU,CAAE,OAAO,CAAE,EAAE,CAAC,CAAC,QAAQ,CAAC,GAC9D,EAAS,CAD2D,CACzD,AAD0D,CAC1D,CAAL,IAKN,GAHA,GAAU,EAGG,CAHP,CAAQ,CAAA,AAGE,GAAZ,EAAc,CAAC,AACjB,CADM,CACE,GAAH,AACL,CADY,CAAA,GAEd,CADO,AACN,AAGH,QACF,CADU,AACT,AAGD,GAAa,GAAG,GAAZ,EAAc,CAAC,AAEQ,CAFnB,EAEsB,AD9WI,CAAU,CAAA,CC8WtC,CAAS,CAAC,AD9WJ,CAAC,AC8WI,CAAG,CAAC,CAAA,EAAyB,GAAG,GAAf,GAA+B,IAAxB,AAA4B,EAAE,CAAlB,AAAmB,IACpE,EAAU,CAD8C,CAC5C,CAAA,AACZ,EADO,CACE,GAAH,AAER,EAFgB,CAAA,KAGlB,CAAC,AADS,AAGV,GAAU,EACV,CADM,CAAQ,CAAA,AACH,EACb,CAAC,AAED,CAHS,AAAQ,CAAA,CAGb,CAAC,EAAO,GAAF,GAAQ,IAAI,EAAO,IAAD,CAAC,IAAS,CAAC,gCAAgC,CAAC,CAAA,AAExE,OAAO,CACT,CAAC,AD9QK,IC6QS,CAAA,ID7QC,EAGd,CAOG,CAVe,AAWlB,EAAwB,CAAA,CAAE,EAE1B,GAAM,CAAE,OAAO,IAAG,CAAI,CAAE,CAAG,EACrB,EACJ,AAAI,EADI,CADwB,CAAA,CAEvB,AADE,CAAC,AACF,GADK,EAAE,EACA,CAAC,IACK,GADE,CAAC,EAAE,EACG,EAA3B,AACF,OADS,AACF,EAF0B,EAAQ,GACzB,AACF,CAAC,CAFyB,CAAC,MAAY,CAAC,GAGjD,EAET,EALiE,CAAC,CAAA,CAGlD,CAAA,AAET,CACL,GAAG,CAAI,CACP,GAAI,EAAU,CAAE,IAAL,AAAS,CAAR,AAAU,CAAT,CAA0B,EAAK,CAAE,CAAH,AAAI,AAAE,CAAA,AAAL,AAAI,CAAG,CAAC,AAC5C,AACZ,CAPiC,AAMrB,AACX,AA0FK,CAjG4B,KAKQ,EALQ,CAAC,AAiGnC,CAjGmC,CAwGjD,CAAuC,CACvC,CAAsD,CACtD,CAA0C,AATrB,EAWrB,IAqBI,EArBE,MAAE,EAAO,EAAH,AAAK,CAAE,CAqBoB,CAAA,KArBb,IAAG,CAAI,CAAE,CAAI,GACrC,CAAA,CAAE,CAA+B,AAE7B,CAF6B,AADW,CAG3B,EAAI,CAAD,CAAC,IAAP,EAAe,CAAC,EAAM,CAAE,CAAJ,KAAU,EAAE,CAAK,CAAE,CAAC,CAAA,AAClD,CAD+C,CACnC,EAAgB,CAAD,GAAnB,EAA0B,CAAC,AAAC,GACxC,AAAI,EACF,AAAI,AAAiB,EAFwB,EAAE,EAAE,CAEtC,CADC,EACmB,AADjB,CAAC,IACH,IAAI,EAAoC,OAAO,EACzD,CADiC,EAAQ,IAAI,CAAL,AACjC,EAAY,KAAa,EAAN,AAAU,CAAT,AAAQ,CAAjB,AAAkB,GAAK,CAAC,EAAM,CAAC,CAAH,AAAK,CAAC,CAAC,CAClC,AADkC,OAC3B,EAAE,CAA1B,EAAQ,IAAI,CAAL,CAA0B,EAAiB,KAAa,EAAN,AAGxD,CAHyD,CAAS,CAAA,GAG5D,CAH0C,EAGtC,GAAW,EAAQ,EAAZ,EAAgB,CAAL,EAAU,GAG/C,CAHmD,CAAA,CAG/C,AAAoB,CAAC,KAAZ,EAAD,IAAO,CAAQ,MAAM,IAAI,EAAc,CAAE,IAAI,CAAE,CAAc,CAAE,CAAC,CAAA,AAC5E,AADyE,CAAvB,EAC1B,CAAC,GAArB,EAAS,MAAD,AAAO,CACjB,MAAO,CACL,GAAG,CAAQ,CAAC,CAAC,CAAC,CACd,GAAI,EAAU,CAAE,IAAL,AAAS,CAAR,AAAU,CAAT,CAA0B,CAAQ,CAAC,CAAC,CAAE,CAAC,CAAE,CAAG,AAAF,CAAE,AAAD,CAAG,CAAC,AACpD,CAAA,AAGZ,GAJ0C,CAIrC,IAAM,KAAW,EAAJ,AAAc,CAAC,AAC/B,GAAM,CAAF,CADwB,AACvB,MAAS,GAAI,GAClB,GAAI,CADqB,AACpB,CADqB,EAAE,AACC,CAApB,AAAqB,GAAjB,EAAK,EAAD,CADmB,GACZ,CAAQ,CAC9B,AAD+B,GAC3B,CAAC,EAAQ,KAAD,CAAO,EAA8B,CAAC,GAA3B,EAAQ,KAAD,CAAO,CAAC,MAAM,CAC1C,MAAO,CACL,GAAG,CAAO,CACV,GAAI,EAAU,CAAE,IAAL,AAAS,CAAR,AAAU,CAAT,CAA0B,EAAQ,CAAE,CAAC,AAAE,CAAD,AAAC,CAAE,CAAR,AAAS,AAC/C,CAAA,AACZ,AAFmD,MAAT,EAG5C,CADU,AACT,AACD,GAAK,CAAD,CAAS,KAAD,CAAO,EAAE,AACS,CAAC,EAAE,CAA7B,EAAQ,GADiB,EAClB,CAAO,AAAuB,CAAtB,MAAM,EACrB,EAAQ,KAAD,CAAO,CAAC,MAAM,GAAK,EAAK,EAAD,IAAO,EAAE,AAC3B,EAAK,EAAD,GAAM,CAAC,CADwB,AACvB,EAAK,CAAF,IAAO,AACpC,EADsC,EAAE,AAClC,EAAe,QAAQ,EAAX,CAAe,GAAW,EAAQ,EAAZ,GAAW,CAAQ,CAAC,EAAM,CAAA,EAAD,IACjE,CAAI,CAAC,GCoHL,ADnHO,QAAQ,CAAC,ACmHN,ADpHO,ECqHrB,ADrHuB,CCqHX,CACZ,CAAqC,EAErC,EDxH8B,ECwHxB,AAJmB,EAIT,CDxHmB,CAAA,GCwHtB,EAAU,EACjB,CADoB,CAAA,AACD,EAAa,IAAI,CAAA,AAC1C,KADqC,EAAf,AACd,GACN,IAAK,SADiB,AACR,CACZ,CAFsB,CAAC,KAEhB,EAAQ,KAAD,CAAC,EAAQ,CAAC,EAAwB,CAAF,AAAI,MAAM,EAAE,CAAK,CAAE,CAAC,AACpE,CADoE,CAAH,GAC5D,MAAM,CACT,MAAmB,AAAZ,OAAO,EAAc,CAAA,GAC9B,KAAK,UAAU,CAEf,IAAK,QAAQ,CADX,MAAmB,QAAQ,CAAA,EAApB,CAGT,MAHgB,CAGT,CAAC,CACN,GAAyB,OAAO,GAA5B,GAAgC,YAAY,CAA5B,EAAgC,EAClD,OAAO,GADuD,GACjD,CAAC,MAAM,CAAC,EAAa,UAAU,AAAX,CAAY,CAAC,KAAK,CACjD,CAAC,EAAW,IACH,CADQ,CAEb,CAFM,AAAS,EAAE,GAEX,CAAC,EADS,IACH,CAAC,EAA2C,CAAD,AAAE,EAAM,CAChE,EAD+D,EAQvE,GACE,EAR0C,CACrC,CAAA,0HAOyH,CAAC,IAAI,CACjI,GAGF,MAAmB,OAHD,CACjB,AAE0B,GAApB,GAAoC,IAA7B,IAAqC,CAAA,EAApB,EAIjC,GAAI,EAJoC,oCAIE,CAAC,IAAI,CAAC,GAC9C,MAAmB,AAAZ,OAAO,AADgD,CACnC,AADoC,MAChC,GAAG,UAAY,UAAU,CAAA,AAI1D,GAAI,mCAAmC,CAAC,IAAI,CAAC,GAC3C,OAAO,KACA,CAFoD,AAEnD,CAFoD,EAAE,CAAC,GAEhD,CAAC,GAAG,CAAC,AAClB,EAAI,CAAD,IAAM,CAAC,AAAC,CAAU,EAAE,AACrB,CADuB,CACX,CAAC,CAAE,CACb,GAAG,CAAY,CAEf,CAHS,GAGL,CAAE,EAAiB,OAAO,CAAC,MAAT,YAA2B,CAAE,EAAE,CAAC,CAC5B,CAAC,CAC9B,CACF,AAGH,CAHG,MAGI,CAEX,CAAC,AACH,CAAC,CD7KiC,CC0KhB,CAAA,AD1KqB,CAAF,CACjC,CAD6B,AAC5B,CAAC,CAAA,AACW,CAAC,AAEZ,GACE,GAL2C,AAM3C,CAN4C,CAAA,MAMpC,GADM,AACF,GACZ,EAAe,MAAM,CACrB,CAAC,AACD,CAH0B,GACZ,AAER,ECuKR,ADvKyB,QAAQ,CCuKvB,ADvKwB,ECwKtC,CAAoD,ADxK1B,CCyK1B,CAAoD,CACpD,CAAiB,EAEjB,IAAK,IAAM,AALoB,KAKF,EAAkB,CAAC,AAC9C,IAAM,EADiB,AACC,CAAgB,CAAC,EAAgB,CAAA,AACnD,EAFqC,AAEnB,CAAgB,CAAC,EAAgB,CAAA,AAEzD,CAHqB,EAIM,AAAzB,CAJqD,IAClC,EAGa,CAHqB,IAGrC,GAAD,CAAK,EACK,OAAO,GAAhC,EAAgB,IAAI,EACpB,OADe,KACH,GAAI,GAChB,YAD+B,AACnB,GAAI,EAEhB,OAAO,EACL,EAAgB,EAHa,QAGH,CAC1B,EAFsB,AACP,AACC,UAAU,CACzB,CAAY,CADE,AACD,EAAe,CAC9B,CAAA,AAEH,IAAM,EAAQ,CAAC,EAAJ,AAAoB,CAHC,GAGG,CAAE,EAAgB,IAAI,CAAC,CAA5B,AAA4B,AAe1D,GAZE,AAAI,CAYF,CAZQ,EAHwC,CAGzC,KAYE,AAZO,CAAC,SAAS,CAAC,EAAI,EAAM,GAAD,KAAS,CAAC,SAAS,CAAC,EAAE,CACxD,EAAM,GAAD,CAD0D,IAAI,AACrD,CADqD,AACpD,SAAS,CAAC,EAAI,EAAM,GAAD,KAAS,CAAC,QAAQ,CAAC,EAIrD,AAHF,EAGQ,GAAD,KAAS,CAAC,SAAS,CAAC,EAAI,EAAM,GAAD,KAAS,CAAC,OAAO,CAAC,EACtD,CAJO,EAAQ,IAIR,CAJO,CAAC,EAAQ,CAAC,CAAI,CAId,AAJe,CAId,CAJgD,CAAE,CAC/D,MAAM,EAAE,EACT,AAF0C,CAEzC,CAAA,AAQS,CATI,MASG,CACxB,CAGF,AAHG,CAGF,CD9MS,CC0MqB,CD1Mb,AC0Ma,KD1Md,CAAO,CACd,EAAe,MAAM,ACmMA,CAAC,ADlMtB,GAEF,CCgM4B,ADlMA,CADZ,AAEf,ACiM4B,CDjM5B,AACG,EACF,MAAM,IAAI,CC+L+B,CDhMzB,AAEd,AC8L2D,EAAE,OD7L3D,EACA,CAHoB,GAGhB,CAAE,AADC,CACa,CAAC,CAAC,CAAE,CACzB,CACD,CACE,OAAO,CAAE,EACT,IAAI,CAAE,CAAc,CAAC,CAAC,CAAE,CACzB,CACF,AACL,CAJ+B,AAG1B,AACJ,AAED,EAAiB,CACnB,CAAC,CACH,CAAC,AAED,GAJ4B,CAItB,AAJsB,EAIZ,CAAC,CAJC,EAIE,CAAP,CAAS,AACpB,GAAI,EAAgB,OAAO,EAC3B,GADkB,AACZ,CAAC,EAAS,GAAG,EAAL,AAAe,CADY,AACT,CADS,CAEzC,IAD4B,EAAY,AACjC,CADiC,AAC/B,GAAG,CAAQ,WAAE,CAAS,CAAE,CAAA,AACnC,CAAC,CAAC,EAAE,AAEJ,CAFI,CAD6B,CAG7B,CAAC,EAAS,KAAF,CAAQ,IAAI,EAAc,CAAE,IAAI,CAAE,CAAc,CAAE,CAAC,CAAH,AAAG,AAC/D,CADqC,KAC9B,CACL,GAAG,CAAO,CACV,GAAI,EAAU,CAAE,IAAI,AAAT,CAAC,AAAU,CAAT,CAA0B,EAAQ,CAAE,CAAC,AAAE,CAAD,AAAC,CAAE,CAAR,AAAS,AAC/C,AACZ,CA6GM,AA9GM,AADuC,AAElD,MAFyC,GA+G1B,EACd,GAAG,CAEmB,EAEtB,GALyB,CAKnB,EAAU,CAAC,GAAG,CAAP,CAAS,AACpB,GAAI,KAAK,CAAC,OAAO,CAAC,CAAU,CAAC,CAAC,CAAC,CAAC,CAAE,CAAC,AACjC,GAAM,CAAC,EAAK,CAAF,CAAO,CAAG,CAAJ,CAChB,OAAO,CADiE,CAAA,AACzD,EAAK,CAAF,CACpB,CADgB,AACf,AACD,CAF0B,CAAC,CAAA,IAEpB,CAAU,CAAC,CAAC,CAAqB,CAAA,AAC1C,CAAC,CAAC,EAAE,AACJ,CADI,MACG,EAAI,CAAD,CAAC,GAAK,CAAC,EAAiB,GAAU,CAAC,CAAE,CAAC,CAAC,AACnD,AAD2C,CAAQ,AAClD,AAgIK,AAjIsC,MAAT,GAiInB,EACd,GAAG,CAEmB,EAEtB,IAAM,EAAU,CAAC,CALa,EAKV,CAAP,CAAS,AACpB,GAAI,KAAK,CAAC,OAAO,CAAC,CAAU,CAAC,CAAC,CAAC,CAAC,CAAE,CAChC,AADiC,GAC3B,CAAC,EAAK,CAAF,CAAO,CAAG,CAAJ,CAChB,OAAO,CADiE,CAAA,AACzD,EAAK,CAAF,CACpB,CAAC,AACD,AAFgB,CAAU,CAAC,CAAA,IAEpB,CAAU,CAAC,CAAC,CAAqB,AAC1C,CAD0C,AACzC,CAAC,EAAE,CAAA,MACJ,AAAuB,QAAQ,EAA3B,OAAO,GAAwB,IAAjB,EAAuB,GAAI,GAAW,EAAQ,EAAZ,EAAgB,CAAL,AACtD,CAAP,CAAe,IAAe,CAAhB,AAAgB,AACzB,EAAK,EAAD,CAAC,MAAS,CAAC,EAAI,CAAD,CAAC,QAAU,CAxFhC,AAwFiC,SAxFvB,AACd,GAuFiD,AAvF9C,CAEmB,EAEtB,IAAM,EAAU,AALU,CAKT,GAAG,CAAP,CAAS,AACpB,GAAI,KAAK,CAAC,OAAO,CAAC,CAAU,CAAC,CAAC,CAAC,CAAC,CAAE,CAAC,AACjC,GAAM,CAAC,EAAK,CAAF,CAAO,CAAG,CAAJ,CAChB,OAAO,CADiE,CAAA,AACzD,EAAK,CAAF,CACpB,CADgB,AACf,AACD,CAF0B,CAAC,CAAA,IAEpB,CAAU,CAAC,CAAC,CAAqB,CAAA,AAC1C,CAAC,CAAC,EAAE,AAKJ,CALI,MAKG,EAHL,AAAuB,MAGV,CAAC,CAHiB,EAA3B,AAA6B,OAAtB,AAGsB,EAHO,EACjC,EAAQ,CADG,CAGc,CAAU,AAHK,CAAA,AAGJ,CAAA,AAF7B,CAAC,OAAa,CAAC,GAGjC,CAAC,CAuEmD,EA1EZ,CAAC,CA2EzC,AA3EyC,CA2ExC,AAiDK,EAlDqD,CAAC,CAAC,CAAC,CAAA,AAkDjD,UAAuB,EAAO,EAAf,EAAc,CAAC,IAAS,CAElD,YACE,CAA6C,CAC7C,CAA6C,CAAA,CAE7C,KAAK,CAAC,gDAAgD,CAAE,CACtD,YAAY,CAAE,CAEZ,CAAA,EAAA,EAAK,CAAC,CAAC,IAAI,CAAA,QAAA,EAAW,EAA4B,EAAD,IAAnB,CAAC,AAA0B,CAAC,AAAT,OAAsB,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAA,OAAA,CAAS,CAC5F,CAAA,EAAA,EAAK,CAAC,CAAC,IAAI,CAAA,QAAA,EAAW,EAA4B,EAAQ,IAA5B,CAA2B,AAA1B,CAAkB,AAAS,OAAa,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAA,EAAA,CAAI,CACvF,EAAE,CACF,wEAAwE,CACxE,+CAA+C,CAChD,CACF,CAAC,CAAA,AAdc,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,wBAAwB,EAejD,CAfiD,AAehD,CACF,AAkCK,MAAO,UAAsB,EAAO,CAAf,GAAc,CAAC,IAAS,CAEjD,YAAY,MACV,CAAI,MACJ,CAAI,CACJ,IAAI,GAAG,MAAM,CAKd,CAAA,CAMC,KAAK,CAAC,CAAA,IAAA,EAAO,EAAI,EAJf,AAAI,AAIW,AAAG,EAJD,CAAA,CAAT,EAAE,EAIgB,OAJT,EAAe,EAAI,CAAA,CAAA,AAAG,CAAA,AACnC,EAAa,CAAA,CAAT,EAAE,SAAO,EAAe,EAAI,CAAA,CAAA,AAAG,CAChC,AADgC,EAC9B,CAEiB,AAFjB,WAEiB,CAAa,CAAC,CAAA,AAf1B,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,uBAAuB,EAgBhD,CAhBgD,AAgB/C,CACF,AAgCK,MAAO,UAAiC,EAAO,IAAD,CAAC,IAAS,CAE5D,EAFoC,UAExB,CAAE,MAAI,CAAqB,CAAA,CACrC,KAAK,CACH,CAAA,qDAAA,EAAwD,EAAI,CAAD,CAAC,EAAI,CAAC,GAAK,CAAD,CAAC,OAAA,EAAY,EAAI,EAAA,CAAA,CAAK,CAC5F,CAAA,AAJe,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,kCAAkC,EAK3D,CAL2D,AAK1D,CACF,mKEx0ByB,oBAAoB,CAAA,eAIpB,sCAAsC,CAAA,iBAK9D,gIAAgI,CAAA,gBAmGxG,CAAE,KAAI,CAAI,EAAG,CAAE,CAAA,qPC5GzC,EECsC,CFD/B,AECA,ADKA,CAA6C,CAAA,CAAA,EDNxC,ACMA,ACLA,ADKwC,CAAA,KCLlC,CFDC,KECK,CDKC,ADNA,MCMM,GDNG,CAAA,GECI,CAAA,MFEtC,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,sBCofM,SAAU,EAAO,CAAuC,EAE5D,CAFoB,GAEhB,EAAa,CAAC,CAAA,AAClB,IAAK,EADS,EACL,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAmB,MAAM,CAAE,CAAC,EAAE,CAAE,CAAC,AACnD,GAAM,CAD8B,AAC5B,SAAO,CAAE,SAAO,CAAE,CAAG,CAAkB,CAAC,CAAC,CAAE,CAAA,AAC/C,EAAS,GAAc,EAAhB,AAAkB,CAAA,AACxB,GAAc,CADI,CACA,CAAD,CAAC,EAAI,CAAC,AAAb,EACjB,CAAC,AAGD,IAJqC,AAI/B,CAJgC,CAAA,AAIF,EAAE,CAAA,AAChC,EAA+B,EAAE,CAAA,AACnC,EAAc,CAAC,CAAA,AACnB,EDzDI,ACsDkB,EAGjB,GADU,CADQ,AAEd,CAAC,CAAG,CAAC,CAAA,EAAM,EAAmB,MAAM,CAAE,CAAC,EAAE,CAAE,CAAC,YAC3C,CAAO,SAAE,CAAA,CAAS,CAAA,CAAA,CAAA,EAAyB,CAC/C,AAD+C,GAEjD,EAAiB,IAAI,AADV,CAET,AAFU,ADrDA,CAAC,CACiB,CCsDzB,CAAC,ADtDwB,QCsDd,CAAC,EAAa,EAAa,CAAE,IAAI,CAAtB,AAAwB,EAAE,CAAZ,AAAc,CAAC,CACvD,CACD,AADC,EACiB,IAAI,CAAC,GACvB,GAAe,EAAI,CAAD,CAAC,EAAI,ADvDD,CCuDE,ADvDF,CCuDX,GAEX,EAAiB,CAFc,CAAC,CAAA,CAEX,CAAC,EAE1B,CAAC,AAGD,IALiC,CAAC,CAAd,AAAc,CAK3B,EAAI,CAAD,CAAC,IAAM,CAAC,GAAG,KAAqB,EAC5C,CAAC,AAwPK,QAzPiC,CAyPvB,CAzPyB,CA0PvC,CAAY,EA1P+C,AA4P3D,CA5P4D,CAAA,EA4PtD,EAAU,EAAK,KAAK,CAAC,kBAAkB,CAAC,CAAA,AAC9C,OAAO,EAEH,CAAC,CAAO,CAAC,CAAC,CAAE,CAAC,AAAE,CAAD,KAAO,CAAC,CAAO,CAAC,CAAC,CAAE,CAAC,CAAC,AAAE,CAAD,GAAK,CAAE,CAAO,CAAC,CAAC,CAAE,CAAC,CACvD,OAIA,EAJS,CAAA,MAIC,EAAgB,CAA8B,EAC5D,GAAM,MAAE,CADqB,AACjB,CAAE,CAAG,EACjB,GADsB,AACT,CADS,OACD,GAAjB,GACS,CADL,MACY,EAAE,CAAlB,GACA,CADI,CACC,CADoB,CACrB,GADyB,CAAA,EAChB,CAAC,IAAI,CAAC,CAFA,CAEE,MAFK,CAEE,CAEhC,EAJkC,CAIrB,AAJqB,AAEE,CAAA,MAEhB,GAAhB,EAAkB,EAAd,KAAsB,EAAc,GAAD,OAAW,EAAE,IAAI,CAAC,GAE7D,IAAM,EAAkB,EAAmB,EAAM,EAF2B,CAE5B,AAF6B,CAAA,AAExB,CAAC,CAAA,GAAjC,KAAqB,CAExC,GACA,EAAgB,CACd,GAAG,CAAK,CACR,IAHa,AAGT,CAAE,CAAe,CAFR,AAES,CAAC,CAAC,EACE,CAKhC,AALiC,CAKhC,CAHG,OAAO,IAAI,AChwBT,CDgwBS,AAhyBR,ADNA,CEsCsB,CAC3B,GFvCU,AACL,ACMA,ADPkB,ACMb,AAAa,ECiClB,CAAE,CFtCG,ACMA,EC+BM,CACL,AFvCM,ACMA,EACF,ADNA,KADsB,CCMC,ADND,AAChB,ACMA,CADiB,CCiCjB,CACrB,CADuB,EFrClB,ACMA,KCgCG,ADhCE,ADNA,CEsCA,AFvCuB,CAAA,ACMC,CAAA,ECiCpB,MFtCQ,ACMA,ECgCA,CAAC,IAAI,MFtCQ,CAAA,ACMC,CAAA,GCgCE,CAAC,CAAC,CAAC,CAAC,CAC1C,GDhCK,ADNA,KCMK,ADNA,AEsCF,CAAE,CFtCG,AEsCF,ADhCE,CCiCb,GDhCK,ADNA,ECME,AADY,ADNA,GACT,OADmB,CAAA,ACMC,ADLZ,CCKY,ACiCb,ADhCE,CAAA,ICgCI,EDhCI,CCgCD,CAC1B,CAD4B,EFrCvB,KAAK,ICuDI,EAlD6B,ADL3B,CCK2B,GCiCzB,CAAA,EAClB,EDiBI,CDzDiD,CAAA,eEwCjC,EFtCI,EEuCxB,EAD0B,gBAExB,EAF0C,CAEtC,IAAA,CAAK,KFyBS,aAAA,EAAA,IEzBiB,CAAC,EDqBI,gBCrBc,CAAA,MAC9C,IAAI,CDqBK,CAAA,CCpBb,MAAA,IAAA,CAAA,kBAA8B,CDqBI,ACrBD,CAAC,AFiCM,CAAC,MEhClC,EFiCQ,CCZD,ADYE,CEjCL,CAAC,IFiCU,cEjCQ,EAEpC,CAAC,wBAEgB,CAAC,EAAI,CDyBH,CCzBW,IAAO,CAAC,CAAR,IAAa,CAAC,MAAM,CAAG,CAAC,CAAA,MAAA,IACxC,EAAyB,CACjC,CFiCmC,CAAC,CAAC,GEjC/B,AFkCE,CAAA,IElCI,CAAC,KAAA,CAAM,MAAM,UACzB,uBAGY,CAAM,EDwBoB,EAAO,CAAC,ADWlB,AElC5B,CDuB8C,ADWjB,CAAC,AElCrB,CAAC,CAAE,MAAM,CFoCX,GAAA,EEpCmC,QAAE,CAAM,CAAE,CAAC,CAAA,EAAH,EDyBJ,ECxBjC,IAAA,CAAA,QAAa,CAAA,MAC1B,CAAC,cAAc,CAAA,gBACN,CAAG,CAClB,CAAC,CFmCkB,AElCnB,IDuB2B,CCzBD,CAAA,OAEb,CAAQ,EDwBE,CAAC,MCvBf,CFoCC,GEpCG,CAAA,KDuB2B,YCvBT,CAAC,GAAG,CAAC,GAAY,IAAI,CAAR,AAAS,QAAQ,CAAC,EAAI,CAAC,AACnE,CAAC,AADkE,CAEnE,kBAAkB,CAAA,EAChB,GAAI,EAAS,CAAC,CAAA,ADuCF,ECvCF,IAAI,IAAY,EFmCT,QEnC+B,CAAM,CAAE,CAAC,CAAA,AACzD,IAAM,EAAW,ID2CH,AC3CO,CAAA,CAAP,OAAgB,CAAG,CD2CC,CC1ClC,IADuC,AACnC,CAAC,AADkC,ED4C9B,EDRE,UEnCQ,CAAC,GACpB,IAAI,CAAC,CD2CG,OC3CK,CAAG,CD2CY,EAAE,ACzChC,EDyCkC,SCzCvB,CAAC,CAAS,EACnB,IAAM,EDoDM,ACpDK,GAAa,GAAhB,CAAoB,CAAC,CAAT,OAAiB,CAE3C,AAF2C,OAC3C,IAAI,CAAC,cAAc,CAAA,GACZ,IAAI,CAAC,KAAK,CAAC,EAAU,CAAA,CAE9B,YAAY,CAAC,CAAM,CAAE,CAAS,EAC5B,IAAM,CD6DG,CC7DQ,GAAa,IAAI,CAAC,CAAT,OAAiB,CAAA,AAE3C,OADA,IAAI,CAAC,cAAc,CAAC,EAAW,EAAS,CAAC,CAAC,CAAA,AACnC,CAD8B,AAAT,GACjB,CAAA,KAAM,CAAC,ED6DE,CAAC,KC7DK,CAAC,EAAA,EAAqB,EAClD,CAAC,CACD,EAFwD,CAAC,CAAA,GD6DI,CAAC,CAAC,CAAA,GC3DlD,CAAS,CD8DT,KC7DL,EAAQ,ED6Dc,CC7DE,GAAhB,CAAoB,CAAC,KD8DK,CAAA,EC9DG,CAAA,OAC3C,IAAI,CAAC,cAAc,CAAC,OACT,CADiB,AAChB,CADiB,CAAA,GACZ,CAAA,EAAW,AAC9B,CAD8B,AAC7B,CACD,cAAc,CAAS,QACJ,CDgEC,EChEY,IAAI,CAAC,CDgEC,OAAA,aC/D/B,ODiEO,OCjEO,CAAC,EAAW,CAAC,CAAC,CAAA,AAC1B,GADqB,CACjB,CAAC,QAAQ,CAAC,SAAS,CAAC,EACjC,CAAC,CACD,IAFyC,CAAC,CAAA,QAE5B,CAAS,EACrB,IAAM,EAAW,GAAa,GAAhB,CAAoB,CAAC,CAAT,OAAiB,CAAA,AAE3C,OADA,IAAA,CAAK,KDiEG,SCjEW,CAAC,EAAW,CAAC,CAAC,CAE/B,AAF+B,ADiED,CC/D7B,IAAI,CAAC,CDgEK,OChEG,CAAC,GDgEO,MChEE,CAAC,IDgEgB,CAAA,CChEF,CAAC,AACxC,CD+DgD,AChEf,CAAC,EAC9B,CD+DqC,AC/DpC,QAAQ,CAAC,KDgEG,GChEK,CAAC,EAAW,CAAC,CAAC,AAExC,CADG,AACF,CADE,AAEH,EAHmC,YAGrB,CAAS,EACrB,IAAM,EAAW,GAAa,CD+DpB,EC/DI,CAAoB,CD+DX,AC/DY,CD+DZ,AC/DG,OAAiB,CAAA,AAE3C,CD+DC,MChED,IAAI,CAAC,ID+DE,UC/DY,CAAA,EAAY,CAAC,CAAC,CAAA,AAC1B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,EACjC,CAAC,CACD,IAFyC,CAAC,CAAA,GAEjC,CAAmB,ADgEpB,EC/DN,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAA,AAClC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAG,EAC5B,EADgC,CAAA,CAC5B,CAAC,QAAQ,CFqEK,aEnEV,CF8EI,GAAA,GE7ER,CAAC,cAAc,CAAC,CDiEG,CAAC,ECjEA,CAAC,IF8EI,IE9EI,CAAG,EAAM,GAAD,GAAO,CAAG,CAAC,CAAC,CACrD,AADqD,IACrD,CAAK,KAAK,CAAC,GAAG,CAAC,EAAO,CF8EN,GE9EU,CAAC,GF8EC,KE9EO,CAAC,MAC/B,QAAQ,EAAA,EAAA,MAAA,AACf,CAAC,WACS,CAAa,MACjB,CAAC,cAAc,CAAA,IAAK,CAAC,MF8EQ,CAAC,CE9ED,CAAC,CAAA,IAC9B,CAAC,KAAK,CAAC,GF6EwC,CE7ExC,CAAK,CDmEC,OCnEO,CAAC,CDmEC,ACnEE,OACvB,KF8EK,GE9EG,EAAE,AACjB,CADiB,AAChB,MF6E+C,ME5ErC,CAAa,EACtB,CDkEa,GClET,CAAC,CF8EG,aE9EW,CAAC,GDmED,CAAA,CAAA,QCnEc,CAAG,CAAC,CAAC,CAAA,IF8EO,CAAC,CAAA,OE7EjC,CAAC,SAAS,CAAA,IAAK,CAAC,QAAQ,CAAE,KAAK,CAAC,CAAA,SAChC,EAAI,CAAC,CAAA,CAEpB,WAAW,CAAa,MAClB,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAG,CAAC,CAAC,CAAA,IAClC,CAAC,CDoEC,OCpEO,CAAC,SAAS,CAAC,IAAI,CAAC,IDoEI,ICpEI,CDoEC,ACpEC,CDoEA,ECpES,CAAC,CAAL,AAAM,CAAA,IAC9C,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAG,CAAC,CAAU,CAAC,GAAT,GAC1C,EAD+C,EAC3C,AADyD,CACxD,AADyD,CAAA,OACjD,EAAI,CAAC,AACpB,CADoB,AACnB,YACU,CAAa,MAClB,CAAC,GDqEK,WCrES,CAAC,IAAI,CAAC,QAAQ,CAAG,CAAC,CAAC,CAAA,AACtC,IAAI,CAAC,EDqEI,MCrEI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAE,GACvC,EAD4C,CAAC,CAAA,AACzC,CAAA,QAAS,EAAI,CACnB,AADoB,CAAA,AACnB,CACD,EDmE0B,SClExB,IAAA,CAAK,aDqEW,EAAA,GCpEhB,CDqEC,CAAC,CAAA,CCrEE,CAAC,MAAM,EAAE,CAAA,AACb,IAAM,EDqEE,ACrEM,GAAH,CAAO,CAAC,EDqEE,CAAA,QCrES,EAAE,CAEhC,AAFgC,OAChC,IAAI,CAAC,QAAQ,EAAE,ADqEA,CAAC,ACrED,AACR,CDoES,EClElB,EAFc,CAAA,MAEL,CAAC,CAAM,CAAE,CAAI,EACpB,IAAI,CAAC,eAAA,OACD,CAAA,MAAO,SACG,IAAI,CAAA,YAAa,CAAC,GAEhC,OADA,IAAA,CAAK,QAAQ,EAAI,CFiGD,EAAA,EEhGT,CD+EK,AC9Ed,CAAC,CD+EG,EChFU,CAAA,EFiGC,OE9Fb,IAAI,CAAA,eAAgB,CFkGkB,MEjGlC,CAAC,MAAM,aACO,CAAC,YAAY,EAAE,CAAA,EDmFG,kBClFvB,EAAI,CAAC,CAAA,GFkGI,AE/FxB,aACE,IAAI,CAAC,KDsFK,UCtFU,EAAE,CAAA,AACtB,IAAA,CAAK,MAAM,EAAE,CAAA,AACb,IAAM,EAAQ,EDsFN,ECtFM,CAAK,aAAa,EAAE,aAC7B,GFoHG,KAAA,EEpHS,EACV,CACT,CAAC,CACD,iBACM,CAAC,CDwFC,cCxFc,EAAE,CAAA,KACjB,KDuF4B,CCvF5B,GACL,IAAM,EAAA,IAAY,CAAC,aAAA,GAEnB,YADK,EDyFI,CD6BD,KEtHK,CDyFG,CCzFC,CAAC,CAAA,AACX,CFqHa,AEpHtB,CDwFa,ACxFZ,CACD,iBACM,CAAC,eAAA,QACA,GDoGK,GCpGC,CFsHC,CEtHC,CACb,IAAA,EAAc,CDoGG,GAAA,CCpGE,aAAA,GAEnB,OADA,IAAA,CAAK,EDoGI,MCpGI,CFsHD,CClBM,CAAA,CCnGX,CACT,CAAC,CACD,IAAI,IDoGA,CAAC,MAAA,CCnGH,OAAA,IAAW,CAAA,KAAM,CAAC,MAAM,CAAG,CDoGH,GCpGO,CAAC,IDoGE,ICpGM,AAC1C,CAD0C,AACzC,CACD,YAAY,CAAA,MACJ,EAAc,IAAI,CAAC,CFuHX,OEvHmB,CAGjC,AAHiC,OACjC,IAAA,CAAK,GDiHO,WCjHO,CAAC,EFuHA,CEtHpB,IAAA,CAAK,QAAQ,CFuHD,AEvHI,EACT,CDgHgB,GChHhB,IAAA,CAAA,QAAoB,CAAG,YAG9B,GAAI,IAAA,CAAA,kBAAuB,GAAK,IAAwB,EAAlB,CAAC,QACjC,EAAQ,GAAH,ADuHQ,CCvHD,CAAC,EADqC,UACzB,EAAE,CAAA,IAC7B,CAAC,iBAAiB,CAAA,GAAI,CAAC,IAAI,CAAC,MFyHkB,CAAC,CEzHX,CAAE,EAAK,GAAA,EACnC,CAAC,CFyHC,CAAA,IEzHK,CAAC,kBAAA,IAEvB,CAAA,AAGK,SAAU,EAAM,CACR,CDyHa,CAAA,CC1HL,kBD0HK,ECxHF,IAAK,CAAA,CAAoB,CAAA,CAAE,EAElD,IAAM,EAAiB,CFsHX,MEtHkB,MAAA,CAAA,UAC9B,EAAO,KAAA,CAAQ,CDuHD,CCtHd,EAAO,QAAA,CAAA,IAAe,SACpB,EFoH2B,AEpHrB,CFoHsB,CAAA,CEpHvB,GAAO,CACZ,EAAM,GAAD,OAAW,CAChB,EAAM,UAAU,CACjB,CAAA,AACD,EAAO,iBAAiB,CAAG,IAAI,CDoHD,ECpHI,CAClC,EAAO,kBAAkB,CAAG,CDqHD,CCpHpB,CACT,CAAC,AAUK,MAAO,UAA4B,EAAO,IAAD,CAAC,IAAS,CAGvD,YAAA,QAAc,CAAM,CAAsB,CAAA,CACxC,CD0GkB,IC1GlB,CAAM,CAAA,SAAA,EAAY,EAAM,IAAA,kBAAA,CAAwB,CAAC,CAAA,AAHjC,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,gCAK1B,AAGK,MAAO,CDkHD,SClHkC,EAAA,SAAgB,CAG5D,YAAY,QAAE,CAAM,CAAA,GDgHH,MChHG,CAAU,CAAwC,CAAA,MAC/D,CAAA,CAAA,WAAA,EACW,ED+GM,AC/GE,YD+GiB,0BAAA,EC/GwB,EAAM,IAAA,CAAM,CAC5E,CAAA,AALe,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,qCAUrB,MAAO,UAAA,EAAA,SAAwD,aAGvD,OAAE,CAAK,OAAE,CAAK,CAAoC,CAAA,CAC5D,KAAK,CACH,CAAA,CDwHQ,yBAAA,ECxHqB,EAAK,GAAA,kCAAA,EAAwC,EAAK,GAAA,CAAA,CAAM,CACtF,CAAA,AALe,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,wCAAwC,EAMjE,CAAC,CACF,AFnLK,SAAU,EACd,CAAyB,CCLJ,ADMrB,CAA2B,CAC3B,EAGI,CAAA,CAAE,EAEN,GAAM,CAAE,EAAE,GAAG,OAAO,CAAE,eAAe,IAAG,CAAK,CAAE,CAAG,CEhCL,CFkCvC,EAAwB,GAF2B,CAAA,IAEnB,CAAC,CAAzB,AAA0B,GCZzB,ACrBJ,IFiCU,EAAoB,EAAA,OAAa,CAAC,GAAQ,CAAJ,CAAC,AACtD,CADuD,CAAC,AAAK,AACpD,CADoD,CEhCxD,AFiCkB,GAE7B,CCTC,EDSG,AAAsB,CAAC,KAAvB,IAAU,CAAC,IAAgB,CAAX,CAAC,AAAqB,MAAM,CAAG,CAAV,AAAW,CAClD,KCTO,CDSD,IAAI,EACZ,GAAI,EAAM,GAAD,CAAC,AAAI,CAAC,IAA8B,CAAzB,CAAC,AAA0B,CCT3B,ADSK,EAAK,ECTH,CDSG,CAAK,CAAC,GAClC,MAAM,IAAI,EElCE,AFkCoB,CAC9B,IAAI,CAAkB,QAAQ,CAAC,CAAzB,AAA0B,OAAnB,CCTC,CDSmB,CElCC,CFkCjB,AAAuB,EAAI,CAAD,CAAC,OAAS,CAAC,GACtD,CAD0D,CAAC,SAC3D,EACA,CCTK,IDSC,EAAA,IAAU,CAAC,GCTO,EDSF,AAG1B,CAH2B,AEhC1B,GAAA,EFmCc,CAAC,CAAA,AACV,EAAqB,UAAP,EEnCH,AFmCK,AAAe,EAAE,CAAC,AAAE,CAAD,AAAC,CAAE,CAAA,IACvC,IAAI,EAAI,EAAG,EAAI,EAAW,ECXE,CAAC,GDWG,CAAE,EAAE,CAAC,CAAE,CAAC,AAC3C,IAAM,EAAQ,CAAU,CAAC,CAAC,CAAc,ACXtB,CDWsB,EACjC,ECZyB,CCzBa,QFqC3B,CAAC,MACb,CAAA,EAAO,EAAU,CAAG,SCrCd,EACd,CAAqB,CDxDH,ACyDlB,CDzDuC,ACyDT,CCnBZ,AFtCqB,AC0DvC,CAA0E,MA6JjD,EDuET,ECnBhB,AD7B2B,ECvBmB,GAoDhB,AA/MxB,EDkO4C,CAAC,cClO3C,CAAe,CAAE,KCrBV,WDqBwB,CAAE,CAAG,CDIC,CCHvC,EAAkB,EAAmB,CADQ,CAAA,AACR,IAAU,CAAC,CAAA,GAClD,EAAiB,CACnB,GAAM,CAAA,EAAS,EAAA,CAAQ,EACvB,OAAO,AA0DL,SAAU,CACO,CACrB,CAA8B,ACtDC,CDuD/B,ACvD+B,CD2D9B,EAED,GAAM,iBAAE,CAAe,QAAE,CC5DG,IAAA,YD4DK,CAAc,CAAE,CAAG,EAIpD,GAAA,CAAK,CAJsD,CAAA,AAI9C,CAKX,AALY,IAKN,AClEQ,EAIJ,AD8DI,EAHC,EAAA,QAAc,CAAC,EAAM,EAGL,CChEI,CD6DC,IAGC,CAHS,AAGT,CAxCpB,AAqC8B,OAI3B,KAAK,CC9DC,CDiEnB,CAHqB,UAGrB,CAAY,GACnB,EADwB,CAAC,CAAA,AC/DC,ADgEpB,EAAS,EAAM,EAAT,CAAQ,CAAC,IAAQ,CAAC,EAAO,IAAD,KAAU,CA9C7B,AA8C8B,EA9C5B,CAAA,EDFD,ECmDG,EAAgB,GChEX,ADkEtB,AALuD,CAAC,CAK7C,AAF2B,AAHmB,CAK7C,AAL6C,CAK7C,AACV,EAAmB,EAAE,CAAA,AAC3B,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAQ,EAAE,CAAC,CAAL,AAAO,CAAC,EAGzB,WAAW,CAAC,GAAe,ECjER,ADiE2B,EAAE,CAAN,AAAO,CAAN,AAAO,CAAC,CAAA,CAAQ,CAAC,CAAlC,AAAmC,AACpE,CAD8C,AAAsB,CAArB,CAAC,AChE3C,ADiEC,CAAC,EAAM,EAAU,CAAG,EAAgB,EAAQ,EAAO,GAAF,gBAErD,cAAc,CAAE,IAElB,GAAY,IAFiB,AAGvB,IAAI,CAAC,UAIb,EAAO,EChED,SDgEY,CAAC,EAAiB,EAAE,CAAC,CAAA,AAChC,CAAC,EAAO,EAAE,CACnB,AADe,AAAK,CAMpB,AALC,CAFkC,EAOnC,EAAoB,GAAA,CAKlB,IClEO,CAAA,CDkEO,EAHF,EAAA,QAAA,CAAA,CAGgB,CAHS,EAGN,MAAM,CAHS,AAGT,CAHU,KAKzC,EAAmB,EAAE,CAAhB,AAAgB,EALgC,CAAC,CAAC,CAAA,GAMpD,EAAI,CAAC,CAAA,EAAM,EAAA,EAAU,CAAC,CAAE,CAAC,ACnED,ADqE/B,EDWI,ACXG,GDWY,QCXD,CAAC,EAAY,EAAE,CAAC,AAAV,AAAG,CAAO,AAAN,EAC5B,ECnEM,CDmEA,CAAC,EAAK,CAAG,EAAgB,EAAQ,EAAO,EAAT,CAAO,MAAd,QAC5B,EACA,eAAgB,IAElB,EAAM,CDUC,CAAA,CCVF,CAAK,CAAC,EACb,CAAC,CADgB,CAAC,CAAA,EClEV,IDsED,WAAW,CAAC,EAAiB,IAC7B,CAAC,EAAO,EAAE,CAAC,AACpB,CAAC,AAID,AALoB,IAKpB,EAAe,CAAC,CAAA,AACV,EAAmB,EAAE,CAC3B,IAAK,IAAA,EAAQ,CAAC,CAAE,EAAI,EAAQ,EAAE,CAAC,CAAE,CAAC,AAChC,GAAM,CAAC,EAAM,EAAF,AAAY,CAAG,EAAgB,EAAQ,EAAO,AAAnC,EAA0B,CAAO,MAAd,2BAEN,OAEvB,CAF+B,GAGrC,IAAI,CAAC,EACb,CAAC,MACM,CAAC,EAAO,EAAS,AAC1B,CADe,AAAW,AACzB,CAhJU,CD0KR,CCxKG,CAAE,CDU4B,ACmIX,CDnIY,CAAA,CCVrB,MAAE,CAAI,CAAE,CAClB,CADgB,gBACd,SAAiB,MAAF,AAAQ,WAAE,CAAc,CAAE,CAC5C,CAAA,GAEgB,OAH0B,AAGnB,CDSD,SAAA,CAAE,CAAA,KCRlB,AA8NL,SACJ,CAAqB,CAAA,CAAA,CAErB,CAA0E,EDGhB,ACD1D,GAAM,iBAAE,CAAA,gBAAiB,CAAc,CAAE,CAAG,EAMtC,EACwB,CAAC,GAA7B,EAAM,GAAD,OAAW,CAAC,MAAM,EAAU,EAAM,GAAD,OAAW,CAAC,IAAI,CAAC,CAAC,MAAE,CAAI,CAAE,EAAE,CAAG,CAAC,GAIlE,CAJsE,CAAC,AAIvE,CAJuE,CAIvE,EAAiC,CAAG,CAAA,CAAE,CAAA,AACxC,EAAW,CAAC,CAAA,AAIhB,CDLyC,AAC3B,CAD2B,AErHrC,CD0HA,EAAgB,GAAA,KAKZ,EAAQ,EAHR,CAGK,CAHL,QAAuB,CAAC,EAAO,EAGN,CCpHG,CDiHE,ACjHF,IDoHG,CAHS,AAGT,CAHU,SAK1C,GALsD,CAAC,AAKnD,CALoD,CAAA,AAKhD,CAAC,CAAE,CAAC,CAAG,EAAA,UAAgB,CAAC,KCrHO,CDqHD,CAAE,EAAE,CAAC,CAAE,CAAC,AACjD,ICrHS,CAAA,CDqHS,EAAM,GAAD,OAAW,CAAC,CAAC,CAAE,CAAA,AACtC,EAAO,WAAW,CAAC,CDJtB,CCI8B,ADJ9B,GCI2B,AACxB,GDvEuB,ACuEjB,CC7GI,AD6GJ,CAD6B,CAAC,AACvB,CADuB,CACd,CAAI,EDJ/B,ACI+C,EDvEnB,ACuE2B,EAA5B,AAAuC,EAAb,KAAW,EAAlB,QACvC,EACA,aADe,CC7GU,CD8GT,IAElB,CAFuB,EAEX,EACZ,CAAK,CAAC,EAAkB,CAAC,CAAC,AAAE,CAAD,EAAY,IAAK,CAAC,CAAR,AAAW,CAClD,CAIA,AAJC,EADqD,CChHH,ADgHG,IAItD,EAAO,WAAW,CAAC,EAAiB,EAAE,CCpHa,ADoHZ,CAAA,AAChC,CAAC,EAAO,EAAE,CAAJ,AAAK,CAAA,AAKpB,CANmC,CC5G/B,EDkHC,IAAA,EAAQ,CAAC,CAAE,CAAC,CAAG,EAAM,GAAD,IClHW,GDkHA,CAAC,MAAM,CAAE,EAAE,CAAC,AClHE,CAAC,CDkHA,AACjD,IAAM,EAAY,EAAM,GAAD,OAAW,CAAC,CAAC,CAAE,CAAA,AACtC,CAAO,EAAM,EAAF,AAAY,CAAG,EC/GF,AD+GkB,EAAQ,EAAW,EAAb,KAAW,UACzD,iBACA,EACD,CAAC,AACF,CADE,CACG,CAAC,EAAkB,CAAC,CAAC,AAAE,CAAD,EAAY,IAAK,CAAC,CAAR,AAAW,EAChD,EADoD,CAAA,AACxC,CACd,CAAC,AACD,CCpHC,KDoHM,CAFgB,AAEf,CAFe,CAER,EAAS,AAC1B,CAAC,ACpHA,ADmHyB,AAAX,CArRJ,EAAA,EAqRc,AArRkC,GDShB,CAAC,SEkJgB,uBDxJvD,CAAC,CAAA,AACJ,GAAI,AAAM,cAAA,IAAA,CAAA,OAAA,AA4BN,SACJ,AADc,CACO,CAAA,EACyB,CAAA,CAAA,QAExC,CAAE,YAAW,CAAK,CAAA,CAAK,EACvB,EAAQ,EAAO,IAAD,KAAU,CAAC,CC3CD,CAAC,AD2CE,CC3CF,AD2CG,CAAA,MAG3B,EAFO,EAED,EAAI,CAAD,CAAC,OAAS,CAAC,EAAM,GAAD,CAAC,CAAK,CAAC,EAAO,CAAC,EAAH,AAAK,CAAC,CAAC,CAAC,AADlD,EC5CwB,AD4Cb,CC5Ca,CD4CL,IAAX,CAAC,AAAS,CAAC,AAAT,EAAiB,CAAC,GAAW,GACa,CADjB,CAAC,AACkB,CADjB,AACkB,AAC3D,CAF0C,AAAQ,AACS,AAC1D,CAFiD,AAlCzB,EAAQ,CAAE,GAAJ,KAAY,CAAE,CAAe,CAAE,CAAC,CAAA,GAC1C,MAAM,EADiC,GAChD,EDUE,ECVE,EAAa,OAAO,CDWtB,CAAA,ECgIL,CAAC,EAAA,SAAA,CAAgB,EAAO,EDuBA,ECvBD,KAAU,CAAC,CC1ED,CAAC,AD0EE,CC1EF,AD0EG,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAAE,EAAE,CDhInD,ACgIoD,CAAA,KA1ItD,IAAI,CAAC,UAAU,CAAC,IDWI,KAAA,OCVrB,AAiJL,SAAU,AACd,CAAqB,CACrB,CAA8B,CAC9B,OAHyB,SAGvB,CAAc,CAA8B,MAEvC,CAAC,CCnFC,ADmFC,EAAA,CAAQ,EAAM,GAAD,CAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA,MAChC,CAAC,MAEK,EAAA,QAAc,CAAC,EAAO,SAAS,CAAC,EAAE,CAAC,CAAC,CAAA,AAGnD,EAAO,IAAD,CCpFM,CAAA,KDoFM,CAAC,EAAiB,GAEpC,GAF0C,CAAC,AAE3C,CAF2C,CAE5B,EAAA,CAFkB,OAEJ,CAAC,EAAO,IAAD,KAAU,CAAC,EAAE,CAAC,CAAC,CAAA,MAGjC,CAAC,SAEjB,EAAA,WAAkB,CAAA,EAAA,IACX,CAAC,QAAS,CAGnB,AAHmB,AD8BG,IC3BhB,EAAO,EAAH,AAAU,CD6BX,CAAC,IAAc,CAAC,CAAA,CC7BI,CAAC,MAAM,CAAC,CAAA,IAG9B,WAAW,CAAC,EAAiB,EAAE,CAAC,CAAA,AAChC,YAAc,CAAC,GAAO,CAAH,CAAC,AAAI,CACjC,AADkC,CAAA,AACjC,AAGD,MAAO,CADO,EAAA,SAAa,CAAC,EAAO,IAAD,KAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAM,EAAF,AAAI,CAAC,CAAE,EAAE,CAAC,CAAC,CAAA,GAC1D,AACpB,CADoB,AACnB,CAhLsB,AD2M0B,CAAA,CC3M1B,EAAA,iBAA+B,CAAE,CAAC,CAAA,AACvD,GAAA,EAAA,IAAc,CAAC,GCzBC,OAAA,CAAA,SAAA,EAAA,IDyB+B,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA,OA8L3D,EACA,EA/L2D,OD8MjD,EC9MiD,EA6L3D,EAAA,GA7L2D,GA6L5C,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA,EAC9B,OAAA,QAAe,CAAC,CDkBH,CClBS,IAAA,CAAK,KAAA,CAAM,MAAM,CAAC,CAAC,CAAC,CDkBH,CAAA,AClBO,KAAK,CAAE,EAAE,CAAC,CAAA,EAC/D,EAAA,SAAwB,CAAC,EAAE,CAAC,CAAA,AAC3B,CACL,EAAO,EAAH,CACA,EAAA,QAAc,CAAC,EAAO,CDkBN,EClBI,KAAI,CAAM,CAAE,CAAC,CDkBP,AClBO,EAAH,AAAG,QACnB,CAAC,EAAO,QAAE,CAAM,CAAE,CAAC,IAnM0B,AAqMhE,CAAA,AAnMD,GAAA,AAAmB,WAAnB,EAAU,IAAI,CAAe,OAAO,SAkRtB,AACd,CAAqB,CDvQH,ACwQlB,CApRgD,SAkRtB,MAExB,CAAc,CAA8B,EAG9C,CC7H2C,CAAc,CAAC,CD6HpD,EAAS,EAAM,GAAD,CAAC,IAAQ,CAAC,EAAO,IAAD,KAAU,CAAC,EAAE,CAAC,CAAC,CAAA,AAInD,EAAO,IAAD,OAAY,CADZ,AACa,EADY,GAG/B,IAAM,EAAS,EAAA,QAAc,CAAC,EAAO,IAAD,KAAU,CAAC,EAAE,CAAC,CAAC,CAAA,AAGnD,GAAA,AAAe,CAAC,EAAE,CAAlB,AAAmB,EAEjB,OADA,EAAO,IAAD,OAAY,CAAC,EAAiB,EAAE,CAAC,CAChC,AADgC,CAC/B,EAAE,CAAE,EAAE,CAAC,CAAA,AAGjB,AAJmC,IAI7B,EAAO,EAAO,AAAV,IAAS,KAAU,CAAC,EAAQ,EAAE,CAAC,CAAA,AACnC,AAD8B,EACtB,EAAM,CAAT,EAAQ,CAAC,IAAQ,CAAC,EAAM,GAAD,CAAC,IAAQ,CAAC,IAAI,AAKhD,CALiD,CAAC,CAAA,IAGlD,EAAO,IAAD,OAAY,CAAC,EAAiB,EAAE,CAAC,CAAA,AAEhC,CAAC,EAAO,EAAE,CACnB,AADoB,AAAL,CAAK,AACnB,CAHkC,AAzSe,EAAS,gBAAE,CAAc,CAAE,CAAC,CAAA,UAClE,AAD+D,ECvB7D,ADwB6B,EAAM,GAAD,CAAK,CAAC,AACtD,CAAC,AADqD,CDSC,EAAQ,EAAO,EAAT,CAAO,cAC9D,EACA,eAAA,IAEF,GAAY,EACR,AAAO,EAAL,ICEQ,CDHO,CAAA,IACD,EAAO,IAAI,AAAL,ACGZ,CDHkB,KACpB,EAAM,IAAI,EAAI,CAAC,CAAC,CAAG,EAEjC,CErC+C,MFqCxC,CACT,CAAC,AAwEK,SAAU,EAGd,CExEiB,AFwEK,CACtB,CAES,CACT,CAAwB,KAElB,CAAE,eAAe,IAAG,CAAK,CAAE,CAAG,GAAW,CAAA,CAAE,CAAA,AAEjD,CAF2C,EAEvC,EAAW,GE9EN,GF8EY,GAAK,EAAO,IAAD,EAAO,CACrC,MAAM,IAAI,EAAoB,CAC5B,ECde,aDcC,EAAW,MAAgB,CAC3C,YAAa,EAAO,CCbF,CAAC,CCjEC,GF8Ea,GAQrC,GCrBsC,CDqBhC,EAAO,ECsMT,AD3MuB,KAKE,CAAR,CAAC,ECsMR,AAEd,iBAF+B,AAG/B,CAAe,YACf,CAAU,CACV,QAAM,CAOP,EACC,IAAM,EAA0C,EAAE,CAAA,AAClD,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CADQ,AACP,CAAG,EAAW,MAAM,CAAE,CAAC,AAAV,EAAY,CAAE,AAC1C,CAD2C,CACxB,IAAI,CACrB,AAgBA,SAAU,EAEd,AAnBoB,KACA,SAgBU,GAG9B,GAAkB,CAAK,CACvB,SAAS,CADM,AACJ,CAAU,OACrB,CAAK,CAON,EAGC,IAAM,EAAkB,EAFN,AAEyB,EAAU,IAAI,CAAC,CAAA,AAC1D,CADoD,EAA/B,AACjB,EAAiB,CAAC,AACpB,EAFwC,CAElC,CAAC,EAAQ,EAAK,CAAG,CAAV,AAAM,CACnB,CAFiB,MAqHf,AAnHK,MAD+B,CAAA,EAoH1B,AACd,CAA0C,CAC1C,AArHoB,CAyHnB,EAED,GAAM,GARmB,cAQjB,CAAe,QAAE,CAAM,WAAE,CAAS,CAAE,CAAG,EAEzC,EAAqB,GAF2B,CAAA,AAEvB,CAAlB,AAAkB,EAAf,EAEhB,GAAI,CAFkB,AAEjB,KAAK,CAAC,OAAO,CAAC,GAAQ,EAAH,CAAC,GAAQ,IAAI,EAAgC,GACrE,EAD0E,CAAC,AACvE,CADuE,AACtE,GAAW,CADkC,CAAC,AAC7B,CAD8C,CACxD,CAAS,GAAO,GAAK,EAC/B,IADqC,EAC/B,IAAI,EAAuC,CAC/C,UADqB,CAAC,CAAwB,EAChC,CAAE,EAChB,IADuB,QACV,EAAM,GAAD,ADxEW,GCwEJ,CACzB,KAAA,CAAA,EAAS,EAAU,IAAI,CAAA,CAAA,EAAI,EAAM,CAAA,CAAG,GAGxC,IAAI,GAAe,CDpEH,CCqEV,EAA0C,EAAE,CAClD,AADkD,CDpEzB,CAAC,ECqErB,IAAI,CAAC,CAAA,EAAM,CAAC,CAAG,EAAM,CDpEL,KAAA,CCoEa,CAAC,CDpEL,ECoES,CAAC,AACtC,IAAM,EAAgB,EAAiB,SAApB,KAAmB,GACpC,EACA,aADe,KAER,CAAA,CAAM,CAAC,CAAC,CAChB,CAAC,AACF,CAAA,AADE,EACgB,OAAO,EAAA,CAAA,GAAiB,CAAA,CAAI,CAAA,EAC3B,IAAI,CAAC,GAG1B,GAAI,GAAW,EAAc,CAAC,AAC5B,CADS,AAH4B,CAAC,CAAA,CAIhC,CDxFsD,CCwF/C,EAAH,AAAU,CADK,EAEzB,CADmB,EACf,EAAS,CAAC,AACZ,IADS,AACH,EAAS,EAAI,CAFiB,AAElB,CAFmB,AAEzB,AAAO,CAFkB,OAER,CAAC,EAAmB,MAAM,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,AAArB,CAAsB,CAAA,AACtE,MAAO,CACL,OAAO,EAAE,EACT,EADa,KACN,CACL,EAAmB,MAAM,CAAG,CAAC,CAAC,AAAE,CAAD,CAAK,CAAD,CAAC,GAAlB,CAAwB,CAAC,EAAQ,GAAQ,CAAV,AAAM,CAAC,AAC3D,AACH,CAF+D,AAG/D,AAFG,AACF,CAF+D,EAG5D,AAHmE,EAGrD,MAAO,CAAE,GAAX,IAAkB,EAAE,EAAM,EAAF,KAAS,CAAE,CAAI,CACzD,AAD2D,CAC1D,AACD,AAF2D,CAAF,KAElD,CACL,OAAO,CAAE,GACT,EADc,KACP,CAAE,EAAI,CAAD,CAAC,IAAM,CAAC,GAAG,EAAmB,GAAG,CAAC,CAAC,SAAE,CAAO,CAAE,AAAjB,EAAmB,CAAG,CAAD,GAC/D,AACH,CADG,AACF,CAnKsB,CAiKmD,CAAC,AAjK7C,CAiK8C,EAjKhD,cACtB,SACA,EACA,IAFe,AACT,KACG,CAAE,CARwC,CAAA,GASjD,CACA,EADG,EACC,GACL,CACF,CACH,AADI,CAEJ,AADC,AADG,CAHc,EAKd,AAAmB,OAAO,EAAjB,AAAmB,CAAC,EAAnB,IAAI,CAChB,OAAO,AAwRL,SAAU,AAKd,CAA0C,CA7RtB,AA8RpB,CAGC,EAED,GAAM,GAXmB,cAWjB,CAAe,WAAE,CAAS,CAAE,CAAG,EAEnC,EAAU,GAFgC,AAGxC,CAHwC,CAEnC,AAAQ,AAC6B,CAD7B,CAC+B,CAAA,AAClD,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,AADO,CACJ,EAAU,OAAD,GAAW,CAAC,MAAM,CAAE,CAAC,EAAE,CAAE,CAAC,AACrD,IAAM,EAAS,EAAU,EAAb,KAAY,GAAW,CAAC,CAAC,CAAE,CAAA,AACjC,EAAQ,GAAH,EAAQ,CAAC,OAAO,CAAC,GAAS,CAAC,CAAG,AAAR,AAAM,CAAC,AAAN,CAAC,AAAa,CAAZ,GAAW,AAAK,CAAA,AAC9C,EAAgB,EAAiB,SAApB,KAAmB,GACpC,EACA,SAAS,CAAE,EACX,CAFe,GACE,CACZ,CAAG,CAAa,CAAC,EAA6B,CACpD,CAAC,CAD4B,AAC5B,AACF,EAAmB,IAAI,CAAC,GACpB,EAAc,MADA,CACO,CADY,CAAC,AACX,CADW,CACrB,EAAoB,CAAA,CAAI,AAC3C,CADoC,AAAO,AAC1C,AACD,MAAO,SACL,EACA,KADO,EACA,CAAE,EACL,EAAO,GADK,AAEZ,CADM,CACN,MAAU,CAAC,EDpJiB,CCoJd,EAAmB,CADR,CAAC,CACU,CAAC,CAAC,SAAE,CAAO,CAAE,EAAE,CAAG,CAAD,GAE7D,AADG,CACF,AADE,CAvToB,CAsT8C,CAAC,AAtTpB,CAsTqB,EAtTvB,cAC1C,EACA,SAAS,EAAE,CACZ,CAFgB,AAEf,CAAA,AAEJ,GAAuB,AAAnB,GAHyC,MAGhC,AAAmB,EAAE,CAAC,EAArB,IAAI,CAChB,OAAO,AA8EL,SAAU,AACd,CAAc,CACd,CAA8B,CAhFR,CAkFtB,GAAM,KAJqB,KAInB,GAAW,CAAK,CAAE,CAAG,EAAb,AAEhB,KAFoC,CAAA,CACpC,EAAQ,KAAD,CAAC,AAAM,CAAC,EAAO,CAAE,EAAJ,IAAU,CAAE,CAAQ,CAAE,CAAC,CACpC,AADoC,CAEzC,GAFsC,IAE/B,CAAE,GACT,EADc,KACP,CAAE,EAAI,CAAD,CAAC,KAAO,CAAC,EAAM,GAAD,QAAY,EAAa,CAAC,CACrD,AACH,CADG,AACF,CAxFwB,EAA6B,CAChD,EAD8C,MACtC,CAAE,EACX,CAAC,CAAA,AAEJ,GAAuB,MAAM,EAAE,AAHF,CAGzB,AAA4B,EAAlB,IAAI,CACT,EADI,GAmMe,EAlML,EAmMvB,CAD0C,EACrB,CAnMC,QAmMQ,EAA1B,OAAO,EACT,GADc,GACR,IAAI,EAAO,IAAD,CAAC,IAAS,CACxB,CAAA,wBAAA,EAA2B,EAAK,GAAA,MAAA,EAAY,OAAO,EAAK,GAAA,gCAAA,CAAqC,CAC9F,CAAA,AACH,MAAO,CAAE,OAAO,CAAE,GAAO,EAAF,KAAS,CAAE,EAAI,CAAD,CAAC,KAAO,CAAC,EAAI,CAAD,CAAC,SAAW,CAAC,GAAO,CAAE,AAvMrB,CAAC,AAEnD,AAqMuE,AAAJ,CAvMhB,AAuMiB,CAAC,CArMjE,EAAU,IAAI,CAAC,EAAN,QAAgB,CAAC,MAAM,CAAC,EAAI,EAAU,IAAI,CAAC,EAAN,QAAgB,CAAC,KAAK,CAAC,CAAE,CAAC,AAC1E,IAAM,EAAS,EAAU,EAAb,EAAiB,CAAC,EAAN,QAAgB,CAAC,KAAK,CAAC,CAAA,AACzC,CAAC,EAAC,AAAC,AAAE,EAAO,EAAH,GAAQ,CAAC,CAAG,EAAA,YAAY,CAAC,IAAI,CAAC,EAAU,IAAI,CAAC,EAAN,AAAU,EAAE,CAAA,AAClE,OAAO,AA8ML,SAAU,AACd,CAAa,CACb,CAhNqB,OAgNnB,CAAM,CAFkB,KAEhB,CAAI,CAAqC,EAEnD,GAAoB,QAAQ,EAAxB,OAAO,EAAmB,CAAC,AAC7B,CADa,GACP,GAAG,AAAG,CAAE,EAAK,EAAD,IAAO,EAAC,IAAS,AAAL,CAAC,EAAa,CAAE,AAAZ,CAAa,AAAE,CAAR,AAAO,AAAG,CAAT,AAAO,AAAG,CAAT,AAAU,GAAG,CAAE,CACpD,AADoD,EAC9C,CAAH,CAAY,CAAC,GAAJ,AAAO,AAAG,CAAT,AAAW,CAAV,AAAW,CAAC,AAAC,CAAE,CAAA,AACnC,GAAI,EAAQ,GAAH,AAAM,AAAI,EAAQ,EACzB,CADsB,AAAM,KACtB,IAAI,EAAI,CAAD,CAAC,oBAAsB,CAAC,CACnC,GAAG,CAAE,EAAI,CAAD,OAAS,EAAE,CACnB,GAAG,CAAE,EAAI,CAAD,OAAS,EAAE,QACnB,EACA,IADM,AACF,CAAE,EAAO,CAAC,CAAJ,AACV,KAAK,CAAE,EAAM,GAAD,KAAS,EAAE,CACxB,CAAC,AACN,CADM,AACL,AACD,MAAO,CACL,OAAO,EAAE,EACT,GADc,IACP,CAAE,EAAI,CAAD,CAAC,QAAU,CAAC,EAAO,CAC7B,EAD2B,EACvB,CAAE,EAAE,QACR,IAGN,AADG,CACF,AADE,CApOqB,EAA4B,GAAF,KAC5C,EACA,IADM,AACF,CAAE,MAAM,CAAC,GACd,CADkB,AACjB,AACJ,CAFsB,AAClB,AACH,AACD,GAAI,EAAU,IAAI,CAAC,EAAN,QAAgB,CAAC,OAAO,CAAC,CACpC,CADsC,CAAC,KAiJrC,AAhJK,SAgJK,AACd,CAAc,CAjJM,AAkJpB,MAAE,CAAI,CAAoB,CAFD,CAIzB,GAAM,CAAC,CAAE,EAAc,CAAG,EAAK,EAAD,GAAM,CAAC,EAAf,KAAsB,CAAC,CAAA,AACvC,EAAY,EAAI,CAAD,CAAC,EAAI,CAAX,AAAY,GAC3B,EADgC,CAAC,AAC7B,CAD6B,AAC5B,EAAe,CAAC,AACnB,IAAI,EAAS,EAKb,EALU,AADM,CACE,CAAA,GAGd,EAAY,EAAE,EAAK,CAAC,EAAX,CACX,EAAS,EDvFY,CCuFT,CAAC,CDvFQ,KCuFA,CAAC,EAAiD,AAAjD,GAAA,KAAa,IAAA,CAAK,CAAC,EAAM,GAAD,GAAO,EAAG,CAAC,CAAC,AAAG,CAAC,CAAG,EAAE,CAAC,CAAK,CAAC,CACrE,AADqE,CAE1E,SAAS,EACT,EADa,MACJ,EAAI,CAAD,CAAC,IAAM,CACjB,EAAA,OAAW,CAAA,EAAA,UAAe,CAAC,EAAW,CAAE,CDxFe,CAAC,CAAA,CCwFZ,CAAE,CAAV,CAAY,CAAE,CAAC,CAAC,CACpD,GAEH,AACH,CADG,AACF,AACD,EAJY,CAIR,AAHC,IAGa,MAAM,CAAC,QAAQ,CAAC,EAAe,EAAE,CAAC,CAClD,MAAM,CADuC,GACnC,EAAqC,CAC7C,YAAY,CAAE,MAAM,CAAC,QAAQ,CAAC,EAAe,EAAE,CAAC,CAChD,KAAK,EADsC,GAG/C,MAAO,CAAE,OAAO,EAAE,EAAO,GAAF,IAAS,CAAE,EAAI,CAAD,CAAC,MAAQ,CAAC,EAAM,CAAE,AACzD,CADyD,AACxD,CADqD,AAzK/B,CAyKgC,CAzKH,CAAE,EAAJ,EAAQ,CAAE,EAAU,IAAI,CAAE,CAAC,CAAA,AAE3E,AAFmE,GAE5C,QAAQ,EAAE,CAAC,AAA9B,EAAU,IAAI,CACT,EADI,GAqOc,EApOL,EAqOtB,CADwC,EApOnB,CAqOf,EAAW,EAAA,UAAc,CAAC,GAC1B,EAD+B,AACjB,CADkB,CAAA,EACd,CAAC,IAAI,CAAC,EAAI,CAAD,CAAC,EAAI,CAAC,GAAY,EAAE,CAAC,CAAA,ADnIW,ACoI3D,CADyC,ADnIkB,CCmIjB,AACvB,EAAE,CAAhB,AAAgB,IACtB,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAa,CAAC,EAAE,CAAE,AACpC,CADqC,CAC/B,GADuB,AACxB,CAAK,CAAC,EAAI,CAAD,CAAC,MAAQ,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAc,EAAE,CAAN,CAAC,CAAO,CAAV,AAAW,CAAC,EAAG,CAAC,CAAC,AAAG,EAAE,CAAC,CAAC,CAAC,CAAA,AAErE,MAAO,CACL,OAAO,EAAE,EACT,EADa,KACN,CAAE,EAAI,CAAD,CAAC,IAAM,CACjB,EAAI,CAAD,CAAC,MAAQ,CAAC,EAAI,CAAD,CAAC,QAAU,CAAC,EAAI,CAAD,CAAC,EAAI,CAAC,GAAW,CAAE,IAAL,AAAS,CAAR,AAAU,EAAE,CAAE,CAAC,CAAC,EAC9D,EAAG,GA/OyC,AAiP/C,CAAA,AAjPgD,AAEjD,CA6OY,AA/OqC,CAgP9C,IA9OG,IAAI,EAA+B,EAAU,GAAX,CAAe,CAAC,AAC1D,CAAC,AADyD,CAvEnC,AAuE6B,EAA3B,CAAC,cAtElB,EACA,SAAS,CAAE,CAAU,CAAC,CADP,AACQ,CAAE,CACzB,KAAK,CAAE,CAAM,CAAC,CAAC,CAAC,CACjB,CAAC,CACH,CAAA,AAEH,OAAO,CACT,CAAC,CDnOuD,eCkO7B,CAAA,GDhOvB,WAAY,EACZ,OAAQ,ECXA,UDcV,AAAoB,CAAC,EAAE,CAAnB,EAAA,ACXgB,MDWL,CAAe,IAAI,CAAA,AAC3B,CACT,CAAC,AAqCK,SAAU,EAEd,CEjGwB,AFiGH,CEjGG,AFiGD,CAA2C,EAClE,ECvBI,CAAA,EDuBM,MAAM,CEjGD,CAAA,CFiGM,CCvBG,CDuBI,MAAM,CAChC,MAAM,GCvBK,CDuBD,CEjGC,CFiGmB,gBACZ,CEjGG,CFiGG,KEjGO,CFiGS,CACtC,YAAa,EAAO,IAAD,EAAiB,OAGlC,EAAkB,CCfV,CDeY,CAAA,AAC1B,IAAA,IAAS,CAAC,CAAG,CAAC,CAAE,CAAC,CAAI,EAAoB,CElGjB,KFkGuB,CAAE,CAAC,EAAE,CAAE,CAAC,IAC/C,EAAO,CElGA,AFkGK,CAAC,AAAT,CAAU,CAAC,CAAA,EACP,CAAM,CAAC,CAAC,CAAC,CAAA,AACvB,EAAK,IAAI,CAAC,EAAa,MAAM,CAAC,EAAM,EAAF,CACpC,CAAC,AACD,CAF2C,AEhG1C,CFgG2C,CAAC,CAAA,GAEtC,EAAA,MAAU,CAAC,GAAG,EACvB,CCdwB,ADcvB,AA0MK,CCxNmB,ADaE,CAAC,CAAA,MA2MZ,EAAA,CAGqD,SAEnE,AAAI,ECoDkC,GDpD7B,CAAC,OAAO,CAAC,IAAA,AAAwC,QAAQ,EAAhD,OAAsB,CAAU,CAAC,EAAE,EAE3B,UACxB,AADE,OAAO,AACF,EAFA,ECqDI,EAAA,CDnDG,CAAC,EADI,GCqDD,CAGC,QDzDc,CAAC,GAG7B,CACT,CAAC,KAJ+C,CAAU,CAAA,sBA/LxC,AAfD,IAAA,AAgNoB,CAAC,CCuDD,CAAA,AAhMpB,CAAA,CAAA,CAAA,EDxDC,GAiM8B,CAAU,CAAA,CAjMlC,CAAtB,EAAsB,OAAN,EACd,CAAmB,CACnB,CAAA,CACA,GAAU,CAAK,CC7BoB,CAAK,AD+BxC,CC/ByC,CAAA,CD+BzC,AAAa,GC9BC,QD8BU,CAAxB,AAAyB,EAGvB,EEpHM,KFmHN,EAAA,MAAc,CADE,AACD,GACR,EAFiC,AAE7B,CAAD,AAF8B,CAE7B,KAAO,CAChB,EAAQ,KAAD,MAAY,EAAa,CACtB,EAAE,CAAC,CAAC,CAAd,AAAe,CAAC,CACE,CAAA,GAElB,CAHO,CAAC,CAAC,QAGT,EAAmB,OAAO,EAAA,UAAc,CAAC,GAC7C,EAD4D,CACxD,UAAA,EAAkB,OAAA,EACtB,GAAa,MAAM,GAAf,EACF,EErHM,AFoHA,ECnBI,GDoBH,EAAI,CAAD,CAAC,KAAO,CAAC,EAAI,CAAD,CAAC,SAAW,CAAC,GAAmB,EAAH,AAAa,CAAZ,CAAc,CAAC,AAAE,CAAD,AAAE,CAAT,AAAU,CAAT,AAAS,AAEzE,CAFiE,GAE3D,EAAY,EAAgB,CEtHZ,IFsHiB,CAAC,EAAA,YAAqB,CAAC,CAAA,AAC9D,GAAI,EAAU,CAAC,AACb,CCnBgB,EDmBV,CAAC,EAAO,EAAU,EClBM,ADkBC,KAAK,CAAA,CAAI,EAClC,CCnByC,CDmBlC,CEtHG,CAAA,IFsHG,CAAC,QAAQ,CAAC,EAAM,EAAF,AAAI,CAAC,CAAG,CAAC,CAAA,AAC1C,OAAO,CEtHG,CFsHC,AEtHD,CFsHA,CAAC,QAAU,CAAC,EAAiB,CACrC,CClBK,CDiB8B,EAC/B,CAAE,EAAU,EAAE,CAAC,AAAE,CAAD,CAAP,AACb,CEtHO,AFqHO,CAAC,AAAU,CCjBpB,IDkBgB,QAAb,GAEZ,CAAC,AAED,CCpBE,GDoBI,CEvHG,CFuHW,EAAgB,EAAD,GAAM,CAAC,EAAS,MAAD,CAAC,GAAU,CAAC,CAAA,AAC9D,GAAI,EAAY,CAAC,AEvHA,AFwHf,GAAM,CAAC,EAAO,EAAK,CAAP,AAAU,EEvHI,AFwH1B,CExH2B,CAAA,CFwHvB,KAD4B,CAAA,CACrB,QAAQ,CAAC,CEvHE,CFuHK,EAAE,IAAM,CAAE,EAAkB,MAAM,EAAG,CAAC,CAAC,AAAG,CAAC,CACpE,EEvHM,EAAE,CAAC,CFuHH,IAAI,EAAuB,CEvHK,AFwHpC,CExHoC,IDqHO,CAAA,MDG/B,CAAE,MAAM,CAAC,QAAQ,CAAC,EAAO,EAAF,AAAI,CAAC,CACxC,KAAK,CAAE,KAAgB,MAEpB,EAAI,CAAD,CAAC,MAAQ,CAAC,EAA4B,EAAE,CAAd,AAAe,CAAC,CAAd,AAAe,CAAC,CAAY,AACpE,CADoE,AACnE,AAED,IAH+C,AAGzC,CAH0C,CAAC,AAG7B,EAAgB,KAAK,CAAzB,AAA0B,EAAA,UAAmB,EAC7D,GAAI,GAAc,EEzHT,GFyHc,CAAC,OAAO,CAAC,GAAQ,CAAC,AACvC,CADmC,CAAC,CCC7B,ADAD,CAAC,EAAO,EAAU,CAAZ,AE1H0B,AF0HX,CCAU,CDC/B,EAAkB,ACDM,CAAC,CDCL,CAAA,AAC1B,IAAK,IAAI,CAAC,CAAG,CAAC,CAAE,CAAC,CAAG,EAAM,GAAD,GAAO,CAAE,CAAC,EAAE,CAAE,AACrC,CADsC,CACjC,IAAI,CAAC,EAAO,EAAW,CAAK,CAAC,AAAlB,CAAmB,CAAC,EAAE,CAAZ,GAAgB,CAAC,CAAC,CAAA,IAE9C,AAAoB,GAAG,CAAnB,EAAK,IEtHgB,EFsHV,CAAQ,KAChB,EAAA,MAAU,CAAC,GAAG,CErHK,CFsH5B,CAAC,AAED,CEnHI,CACA,IFkHE,IAAA,EAAqB,EAC7B,CAuLI,AAvLH,CAD0C,CAAC,CAAA,IAwLjC,UCwEI,ADxE0B,EAAO,IAAD,CAAC,IAAS,CAEzD,YAAY,MACV,CAAI,YACJ,CAAU,KCqEU,CDpEpB,CAAI,CAC8D,CAAA,CAClE,CCmEC,CAAC,CAAA,EDnEG,CAAC,CAAA,aAAA,EAAgB,EAAI,EAAA,uCAAA,CAA2C,CAAE,CACrE,QCoEY,KDpEE,CACZ,CCmEkB,ADnElB,CCmEkB,QDnElB,EAAY,EAAA,mBAA2B,CAAC,GAAmC,CAAA,CAAG,CAC9E,CAAA,GAD0E,CAAC,IAC3E,EAAW,ECoEQ,ADpEJ,EAAA,EAAK,EAAA,OAAA,CAAa,CAClC,CACF,CAAC,CAAA,AAXc,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,KCmFgB,kCDvEzC,CAAC,ACyEA,CDxEF,AA2BK,MAAO,KCuFD,KDvFuB,EAAM,GCuFP,CDvFO,KAAA,CAEvC,aAAA,CACE,KAAK,CAAC,KCsFG,kDDxFO,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,YCgGA,CAAC,gBDhG4B,EAGtD,CAHsD,AAGrD,CACF,AA4BK,ECgE4C,IDhErC,KCuHD,KDvHkC,EAAO,IAAD,CAAC,IAAS,CAE5D,EAFoC,UAExB,gBACV,CAAc,CACd,aAAW,CACX,MAAI,CAC0D,CAAA,CAC9D,KAAK,CACH,CAAA,iCAAA,EAAoC,EAAI,EAAA,cAAA,EAAmB,EAAc,YAAA,CAAA,EAAgB,EAAW,GAAA,CAAK,CAC1G,CAAA,AARe,GAOsF,IAPtF,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,ECmIR,wCD1HjB,CAAC,CACF,AA4BK,KCmJA,CDnJO,UAA+B,EAAO,IAAD,CAAC,IAAS,CAE1D,QCkJI,CAAC,GDlJO,CCkJH,aDjJP,CAAY,CACZ,OAAK,CACoC,CAAA,CACzC,GC8IoC,ED9I/B,CACH,CAAA,eAAA,EAAkB,EAAK,GAAA,KAAA,EAAW,EAAI,CAAD,CAAC,EAAI,CACxC,GACD,EADM,CACN,kCAAA,EAAwC,EAAY,EAAA,CAAI,CAC1D,CAAA,AATe,KAQuC,EARvC,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,sCAAsC,EAU/D,CAAC,CACF,AAyBK,MAAO,CCgIT,CAAC,QDhIoC,EAAO,IAAD,CAAC,EAAf,EAAwB,CAEvD,YAAY,gBACV,CAAc,aACd,CAAW,CACqC,CAAA,CAChD,KAAK,CACH;gCAEmC,cAAc,EAAE;yBACvB,GAC3B,CAAC,CAVY,GAUR,CAAC,EADgC,CATzB,CAS2B,AAC9B,CAAC,CACb,CAAA,UAXe,CAAA,IAAA,CAAA,OAAA,iDAAO,mCAAmC,EAY5D,CAZ4D,AAY3D,CACF,AAkBK,MAAO,UAA0B,EAAO,IAAD,CAAC,AAAf,IAAwB,CAErD,YAAY,CAAc,CAAA,CACxB,KAAK,CAAC,CAAA,QAAA,EAAW,EAAK,GAAA,qBAAA,CAA0B,CAAC,CAAA,AAFjC,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,iCAAiC,EAG1D,CAH0D,AAGzD,CACF,AAcK,MAAO,UAAyB,EAAO,IAAf,AAAc,CAAC,IAAS,CAEpD,YAAY,CAAY,CAAA,CACtB,KAAK,CAAC,CAAA,OAAA,EAAU,EAAI,EAAA,yBAAA,CAA6B,CAAC,CAFlC,AAEkC,OAFlC,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,gCAAgC,EAGzD,CAHyD,AAGxD,CACF,wGKlKK,SAAA,EACJ,EF1emB,CAAA,CEgfwC,EAE3D,GAAM,CAAC,EAAA,EAAoB,EAAA,CAAG,CAAG,CAAA,QAC3B,MAAM,EC/eF,KD+eS,CAAC,CAAU,CAAC,CC/eZ,AD+ea,CAAC,CAAC,CAAE,CAAC,AACjC,CC/eC,ED+eK,CAAC,CFjfkB,CAAA,AEifb,CAAF,CAAQ,EAAF,AAAO,CAAG,CAAJ,CAKtB,MAAO,CAAC,CADP,CAAA,AACe,EAAK,CAAF,CAAQ,CAAZ,CAAU,IAAI,CAAI,CAAE,CAAC,CAAH,AAAK,EAAK,CAAA,CAAD,EAEtC,CAAC,EFpfW,EEofO,CFpfC,AEofE,EAC5B,IADkB,AFpfA,EEqfX,EADoE,CAAA,AACtD,EAAK,CAAA,CAC3B,AAD0B,CACzB,EAAE,AAEE,CAFF,UAEI,CAAS,CAAE,CAAG,EFpfY,AEsf5B,CFtf4B,CEsfrB,EAAH,AACL,ECrfC,ADqfO,CAAC,CCtfG,CDmfgB,CAAA,EAGY,ACrf3B,EDqfqC,CAAE,EAAY,CAA7B,EAAE,CAAY,AAAmB,CAAE,IAAP,MAGhE,EAEE,EFpeI,AEoeO,EAAY,CFnepB,AACa,CAAC,EEkeU,CAAC,AAGhC,CAHgC,CAG3B,GFlec,GEkeR,CAAG,CAAC,CAAC,AAAE,CFleY,CAAA,AEkeE,MAAM,CAAC,EAAK,EAAb,AAAY,CAAX,GAAkB,CAAE,IAAI,CAAC,CAAC,CAAC,CAAC,SAAS,AAEhE,CAFgE,CAEzD,CFneJ,CEmeC,AAAO,CAAN,AAAK,AFneA,CEmeC,IAAM,CAAC,EAAU,GAAQ,CAAJ,AACzC,CAD0C,AACzC,AA8SK,CA/S6B,AAAQ,CAAC,IAAS,CAAA,EA+S/C,EAGJ,CAOG,CACH,EAAwB,CAAA,AFxiBG,CEwiBD,EAE1B,OAAO,EAAQ,IAAI,CAAL,AAAM,CAAL,CF1iB0B,EE2iB3C,CAAC,AAqFK,SAAU,EASd,CAAuC,CACvC,CAAsD,CACtD,CAXqB,AAgBpB,EAED,IAAM,EAAO,EAAH,AAAW,KAAD,CAAC,CAAO,CAAC,EAAK,CAAF,CAAQ,EAAF,CACtC,GAAkB,CADoC,CAAC,CAAA,OAC3B,GAAxB,EAAK,EAAD,EAAK,CACX,MAAM,IAAI,EAAQ,KAAD,CAAC,OAAa,CAAC,MAAE,EAAM,EAAF,EAAM,CAAE,UAAU,CAAE,CAAC,CAAA,AAC7D,OAAO,CACT,CAAC,AAoCK,EArCgB,CAAA,MAqCN,EAAY,CAA6B,EACvD,MADyB,CAClB,EAAQ,KAAD,CAAC,KAAW,CAAC,EAC7B,CAAC,IADmC,CAAC,CAAA,+FDlhCX,KCFK,CAAA,cFFe,CAAA,uBCIiC,CAAA,gBAEpD,oBCiIoB,wBDjIiC,CAAA,2BEczE,IAAM,EACX,EDwHwB,KAAN,CCzHG,6DAwEjB,SAAU,EAAO,CAAgB,EACrC,GAAI,CD0mB4B,CAAA,AC1mB5B,KAAS,CAAC,EAAS,CAAC,EAAE,CAAC,GAAK,EAAU,MAClC,EADkC,EAC9B,EAA6B,EAC3C,CD2mBmB,AC3mBlB,AAuCK,SAAU,EAAK,CAA4B,CAA7B,OAClB,AAAuB,QAAQ,EAA3B,AAA6B,OAAtB,EAA6B,EAAO,GAA7B,AACX,CADuC,AAEhD,CAAC,AAyBK,EA3BkD,CAAC,CAAA,CACzC,CAAA,GA0BA,EAAO,CAAgB,EACrC,CADoB,CACb,GAEP,CAFM,EAEA,CAAC,AAFO,CAAC,CAAA,AAEN,AAAE,EAAM,EAAF,AAAY,CAAG,EAAc,IAAlB,EAAwB,CAChD,EAAc,EAD2B,CAAC,CACxB,CAAC,MAAN,CAAC,gBAA4B,CAAC,CAC3C,GAGF,IAHS,CACR,CAAA,AAEM,MAAE,EAAM,EAAF,OAAW,MAAE,CAAE,CAAA,AAAE,AAChC,CAiCM,AAlC0B,AAC/B,SAiCe,EAAK,CAAgB,CAAjB,CAClB,GAAM,MAAE,CAAI,WAAE,CAAS,IAAE,CAAE,CAAE,CAAG,EAEhC,GAFqC,CAAA,GAE9B,EAAI,CAAD,CAAC,IAAM,CACf,EAAc,MAAM,CAAC,EAAc,EAAtB,CAAC,CAAyB,CAAC,MAAN,CAAC,gBAA4B,CAAC,CAAE,CAChE,EAAE,AACF,EACA,EADI,AAEL,CAAC,AHwDA,CGvDF,EAEJ,CAAC,AAwBK,EA5BS,OA4BC,EAAS,CAAgB,EACvC,CH+DgB,EGhEM,AAClB,CAAC,aAEI,EACP,EADW,CAAA,EACL,CAAC,GHiED,KG/DR,CAAC,AACH,CAAC,AAOK,MAAO,UAAqC,EAAO,IAAD,CAAC,IAAS,CAGhE,YAAA,CAAA,CAAA,CACE,KAAK,CAAC,CAAA,QAAA,EAAW,EAAO,GHyDA,EGzDA,uCHyDA,CGzD8C,CAAC,CAAA,AAHvD,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,iDAIzB,CAJwE,AAIvE,CACF,0HAjO6C,CAC5C,CACE,CHpBE,MGoBM,CACN,CACE,IDyHK,ACzHD,CD0HK,AC1HH,SAAS,iBAGjB,CACE,IAAI,CAAE,MDyHQ,CAAC,ACzHF,CACb,IAAI,CAAE,SAAS,EAEjB,CACE,CDkTK,IClTC,IDiTM,IAf2B,KCjSvC,KAAM,SAET,iBACgB,CD2ThB,WC3T4B,CAC7B,CD2TE,GC3TE,CAAE,uBAGE,CACN,CACE,CD0TI,AACC,IC3TC,CDyToD,CAAA,aCxTpD,WAER,CHHK,AGIH,CD0TO,IAAA,QCzTP,KAAM,EHFM,SGId,CACE,CHjByE,IGiBzE,aACA,CD+eK,IC/eC,kBAGD,CACP,MACQ,KDmfS,CCnfH,EAEf,CACD,gBAAiB,CDqfG,WCrfS,CAC7B,CDqfC,ICrfK,EHeM,CEseF,QCpfV,KAAM,EDqfE,AFreI,UGhBM,EAEM,CAAA,wCAlD1B,4yGAA4yG,CAAA,6GH9B9yG,IAAA,ECAM,EAAA,CAAA,CAAA,qBD+QA,SAAU,EGvDF,AHwDZ,CGvDC,AHuD2B,CGvD3B,AHwDD,EAA+B,CAFV,AAEU,CAAE,EAEjC,GAAM,IAAE,EAAE,AAAG,KAAK,CAAE,CAAG,EACvB,KAD8B,CAAA,CAnF1B,AAoFG,IAAI,KApFG,AACd,CAA4D,CAC5D,CAAyB,CAFP,CAIlB,GAAM,IAAE,CAAE,CAAE,CAAG,EAET,EAAY,AA+FpB,GAjGwB,CAAA,KAiGf,EACP,CAA4D,MAOpC,GARL,CAQsB,IACnC,EAEA,QAFU,KANZ,AAAJ,GAQsB,EARb,CAAC,OAAO,CAAC,KAAK,CAQE,AARD,EACtB,EAKiB,GALO,CAKH,CALd,AAAuB,GAAD,AAAI,CAAC,AAAC,CAAC,CAOE,CAPG,AAOF,AAPD,CAAE,CAAc,CAAC,CAAC,CAAC,CAAC,CAKpC,AALoC,EAAnC,CAO0B,CAAC,CAAA,AAPG,CAKzB,CAAC,CAAC,EAAK,CAAF,AAAG,EAAE,CAAG,CAAD,CAAO,CAAH,AAAI,CAAC,MAAM,CAAE,CAAC,CAAC,CAAA,CAQtD,CACL,OALA,AAAI,GAAc,EAAE,CAAS,CAAP,AAAQ,CAAG,EAC1B,CAAC,CAAG,EAAmB,CG/DhB,CAAC,AHoEf,CGpEe,CH8D4B,CAAA,GAMrC,CAAC,CAAqB,AALY,CAAA,CAetC,EAfyB,AG5Df,EH2EL,GAAM,CAAE,QAAM,CAAE,GATjB,GAAc,EAAE,CAClB,CADoB,CAAC,AACd,EADK,EACN,IAAS,CAAC,IAAO,AAAH,UAAa,CAAC,CAAA,EAEnB,CAAC,IAAI,AAAQ,GAAL,AACE,CAAC,CADD,EACrB,EAAwB,EAAO,IAAD,CADU,CAAC,CAAA,EACD,CAAC,GACf,CAAC,GAAtB,EAAwB,EAAO,UAAU,CAAC,CAA1B,EACK,CAAC,GAAtB,EAAwB,CAD4B,CAAC,AACtB,CADsB,GACvB,MAAW,CAAC,CAA1B,EACpB,EAAO,IAAD,CADkD,CAAC,CAAA,GACxC,CAAC,IAEA,GACvB,CAD2B,CACpB,AADsB,CAFI,CAKrC,AALsC,CG/DgC,AHoErE,AALqC,CAG5B,AAGX,CAAA,CAHkB,CAUb,AAVc,CAAA,CAUM,EAAgB,CAHpC,EACkB,EAEuB,CAHpC,KACqB,CAAC,CAEV,AAFW,AAAhC,AAEuC,OAFhC,AAFgB,EA/BA,GAiCU,EAjCE,AAiCI,CAjCH,CAAA,CAiCE,AAArB,AAFuC,CAEjB,GAAO,CAAC,GAAc,GAEf,IAFW,CAAC,CAAC,AAEP,CAAC,AAFkB,AAAX,CAAW,AAElB,AAOhD,CACL,MAAM,CANN,AAAqB,CAAC,GAAlB,EAAM,GAAD,GAAO,EAAU,CAAK,CAAC,CAAC,CAAE,CAAG,IAAa,AAAT,CAAU,CAChD,AADwC,AAAQ,EAC1C,GAAD,GAAO,EAAI,EAAE,CAAS,CAAP,AAAQ,CAAG,EAAM,GAAD,GAAO,CAAA,AACxC,CAAC,CAAG,EAAoB,EAAM,GAAD,GAAO,CAAA,AAK3C,MAL4B,AAKtB,CAAC,CAAqB,EACL,CAAC,GAAlB,EAAM,GAAD,GAAO,EAAU,CAAK,CAAC,CAAC,CAAE,CAAG,IAAI,EAAE,AAEjC,CAFkC,CAE5B,GAAD,GAAO,EAAI,EAAE,CAC3B,CAD6B,CAAC,AACvB,IAAD,IAAS,CAAC,IAAI,AAAG,EAAM,GAAD,GAAO,CAAC,CAAA,CAGpC,EAAO,IAAD,IAAS,CAAC,IAAI,AAAQ,GAAL,AACvB,AAA0B,CAAC,CADF,EACzB,EAA6B,EAAO,MADS,CAAC,CAAA,AE2iBN,CF1iBK,CAAA,EAAO,CE0iBH,CAAU,CAAA,GF1iBD,CAAC,CAAA,AAC5B,CAAC,GAAvB,EAAyB,EAAO,IAAD,MAAW,CAAC,EAAM,AAAhC,GAA+B,GAAO,CAAC,CAAA,AAClC,CAAC,GAAvB,EAAyB,EAAO,IAAD,MAAW,CAAC,EAAM,AAAhC,GAA+B,GAAO,CAAC,CAC5D,AAD4D,EACrD,IAAD,MAAW,CAAC,EAAM,GAAD,GAAO,CAAC,CAAA,EATpC,EAAO,IAAD,KAAU,CAAC,EAYrB,CAAC,CACF,CA1DH,AA0DG,AAb2B,CA7C7B,AA6C8B,CAlJE,AAkJF,GAjJvB,EAAA,AAD8B,CAAC,CAAA,AAC/B,MAAsB,CAAC,IAAI,OEskBO,CAAU,CAAA,CFtkBP,CAAC,EAAU,MAAM,CAAC,AAAR,CAAS,CAAA,MAG9D,CAFA,EAAU,MAAM,CAAP,AAAQ,GAEN,GAFY,CAAC,CAER,AAFQ,EAEN,CAAd,EAAE,CAAmB,EAAI,CAAD,CAAC,OAAS,CAAC,EAAO,IAAD,CAAM,CAAwB,CAAA,AACpE,EAAO,IAAD,CACf,AAD4C,CAC3C,AAD2C,CAyE9B,CGhHX,CHgHgB,CAAF,GAAI,CAAE,CAAE,AAAF,CAAY,AACnC,CAmFA,AApFmC,AAClC,SAmFQ,EAAgB,CAAc,EACrC,GAAI,EAAS,CAAC,GAAO,AAAX,CAAQ,AADI,CACH,KAAS,CAAC,CAAA,AAC7B,GAAI,EAAS,CAAC,GAAJ,CAAQ,CAAI,CAAF,MAAS,CAAC,CAAA,AAC9B,GAAI,EAAS,CAAC,GAAJ,CAAQ,EAAE,GAAE,OAAO,CAAC,CAAA,AAC9B,GAAI,EAAS,CAAC,GAAJ,CAAQ,EAAE,KAAE,OAAO,CAAC,AAC9B,CAD8B,MACxB,IAAI,EAAO,IAAD,CAAC,IAAS,CAAC,sBAAsB,CAAC,AACpD,CADoD,AACnD,uDI9WyB,EAAyB,CAAA,CAAA,CAAA,CAAA,MAChB,EAAA,CAAA,CAAA,OACnC,IAAA,EAAqC,CAA9B,CAA8B,CAAA,CAAA,EAAzB,MAAM,AAClB,EAA+B,CAAxB,CAAwB,CAAA,CADP,AACO,EAAnB,GAAG,GAEf,EAAiC,CAFZ,AAEd,CAA0B,CAHI,AAGJ,CAHI,AAGJ,EAArB,IAAI,CAFe,CAG/B,AAH+B,EAGU,CAAlC,CADe,AACmB,CAAA,CAAA,EAA7B,MA2DN,CA5D2B,CACb,AADa,MACP,CA2DV,EACd,CAAkC,CAClC,EAA0B,AAFN,CAEM,CAAE,EAE5B,GAAM,CA/DiC,CAAA,SA+D/B,CAAS,CAAE,CAAG,EACtB,IAAI,CADyB,CAAA,EACF,IAAhB,EAAU,CAAC,EAElB,EAFkC,EAAlB,CAEO,IAAhB,EAAU,CAAC,EAElB,EAFkC,CAErB,AAA6B,CAD5C,AADkB,KAEP,CADL,EACgB,EADZ,AACsB,AAAuB,EACvD,KAD+B,AAAQ,CACjC,AAJN,IAIU,EAJJ,IAAI,EAAuB,CAAE,CAEH,CAAC,OAFW,EAAA,CAAE,CAAC,AAIf,CAJe,AAId,AACnC,GAAI,EAAU,AALoB,CAKnB,EAAG,CAAE,EAAI,CAAX,CAAqB,CAAC,CAAG,EAAS,GAAd,GAAa,CAAC,GAAU,CACvD,MAAM,IAAI,EAAc,CAAE,KAAK,CAAE,EAAU,CAAC,CAArB,AAAuB,CAAC,CAAA,AACjD,GAAI,AADwC,EAC9B,CAAC,EAAG,CAAE,EAAI,CAAX,CAAqB,CAAC,CAAG,EAAS,GAAd,GAAa,CAAC,GAAU,CACvD,MAAM,IAAI,EAAc,CAAE,KAAK,CAAE,EAAU,CAAC,CAAE,AAAvB,CAAwB,CAAA,AACjD,GAC+B,AAFa,QAEL,EAArC,OAAO,EAAU,OAAD,AAAQ,EACF,CAAC,GAAvB,EAAU,OAAD,AAAQ,EACjB,AAAsB,CAAC,KAAb,GAAD,IAAQ,CAEjB,MAAM,IAAI,EAAoB,CAAE,KAAK,CAAE,EAAU,OAAO,AAAR,CAAU,AAA7B,CAA8B,AAC/D,CAD+D,AAC9D,AAqDK,SAAU,EAAQ,CAAkB,EACxC,EADqB,CACI,GAAG,GAAxB,EAAU,MAAM,CAAP,CAAwC,GAAG,GAAxB,EAAU,MAAM,CAAP,AACvC,MAAM,IAAI,EAA2B,WAAE,CAAS,CAAE,CAAC,CAAA,AAErD,IAAM,CAF4C,AAE3C,CAAG,GAF4B,GAEtB,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAW,CAAC,CAAE,EAAE,CAAC,CAAC,CAAA,AAAT,AAC9B,CAAC,CAAG,MAAM,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAW,EAAE,CAAE,EAAE,CAAC,CAAT,AAAU,CAAA,AAExC,EAAU,CAAC,GAAG,CAAP,CACX,AADoB,IACd,EAAU,KAAH,CAAS,CAAC,CAAA,EAAA,EAAK,EAAU,KAAK,CAAC,CAAP,EAAU,CAAC,CAAA,CAAE,CAAC,CACnD,AADmD,IAC/C,MAAM,CAAC,KAAK,CAAC,GACjB,GAAI,CADoB,AACnB,AACH,CAFuB,EAAE,IAElB,EAAW,CAFc,CAGlC,CAAC,AAAC,IADyB,CAAR,AACX,AADoB,CAAA,AACnB,AACP,CAJyC,CAAA,IAInC,IAAI,EAAoB,CAAE,KAAK,CAAE,CAAO,CAAE,CAClD,AADmD,CAAA,AAClD,CACH,CAAC,CAFiD,AAEhD,EAAE,CAF6B,AAE7B,MAEJ,AAAI,KAAmB,IAAZ,EACF,GACL,CAAC,CAFa,AAAgB,EAChC,AAEE,CAAC,CACO,CAAA,AACL,CACL,CAAC,KACD,CAAC,SACD,EACQ,AACZ,CADY,AACX,AAmCK,IArCK,KAqCK,EAAQ,CAAoB,EAC1C,EADqB,CACjB,KAAmB,IAAZ,EAAM,CAAC,EAAF,AACZ,EAD8B,EAAE,CACb,IAAZ,EADgC,AAC1B,CAAC,CAClB,CADgB,EAAkB,EAAE,EADgB,AAE7C,CAF6C,CAExC,EAAD,AACb,CAF6C,AAE5C,AAkEK,EAnEoB,CAAC,CAAA,KAD2B,AAoEtC,CApEsC,CA0EpD,CAIe,CAVG,CAYlB,IAAM,EAAa,AAAC,GAAG,EAAE,GAAT,EAkIM,SAKvB,CAtIG,GAAyB,QAAQ,EAA7B,OAAO,EAAwB,OAAf,AAAsB,EAAQ,GAClD,EADiD,CAC7C,GADuD,CAAC,CAAA,IAC/C,IAAY,UAAU,CAAE,OAAO,AAvKvC,EAAQ,EAAI,CAAD,CAAC,CAAL,EAuKyC,IAvK3B,CAuK4B,AAvK3B,SAuKoC,AAvK3B,CAuK4B,AAChE,AAA2B,AAxKU,CAuK2B,AAvK1B,CAAA,MAwKH,EAA/B,AAAiC,OAA1B,AAAiC,EAAvB,CAAC,IAA8B,AAAD,EAqI/C,AArIgB,EAqIN,CAAC,GAAG,CAAP,AArIkD,CAqIzC,AArI0C,AAsI9D,CAtI8D,GAsIxD,CAAC,CAAG,EAAU,CAAC,CAAC,AAAE,CAAD,IAAJ,CAAW,CAAC,EAAU,CAAC,CAAC,CAAC,CAAC,GAAL,CAAM,EAC1C,EAAU,EAAU,GAD+B,AAC5C,CAD4C,GAChC,AAAQ,CAAC,AAAE,CAAD,KAAO,CAAC,EAAU,OAAO,AAAR,CAAS,CAAC,CAAC,IAAC,EAG9D,GAFiB,IADsD,CAAA,GAC9C,EAArB,OAAO,CAAC,EAAiB,AAAmB,QAAQ,SAApB,IAClC,EAAU,CAD+B,CACpB,EAAC,CAAC,AAAhB,CAAgB,AACF,IADD,IACS,EAA3B,OAAO,EACT,KADgB,CACV,IAAI,EAAoB,CAAE,KAAK,CAAE,EAAU,OAAD,AAAQ,CAAE,AAA7B,CAA8B,CAAA,AAC7D,OAAO,EACT,CAAC,CAAC,EAAE,AAEG,CAHS,AACZ,AAGF,CAAC,AAJa,CAIX,MAAM,CAAC,EAAU,CAAC,CAAC,CACtB,CAAC,CAAE,EADgB,IACV,CAAC,EAAU,CAAC,CAAC,KAAH,IACnB,EACD,CAAA,CAlJK,EAAU,CAAC,AAiJR,CA/CF,CACL,AAnGiB,CAmGhB,CAAE,CAFoB,CAjGV,CAAsB,EAAX,CAmGX,CAAC,CACd,CADY,AACX,CAAE,AAHqC,EAjGI,AAoG/B,CApGgC,AAoG/B,CACd,AArG6C,CAAX,IAoGtB,EACL,CAAE,EAAW,EAAU,CAAC,CAAC,CACjC,CAAA,AArGQ,CACL,CAAC,AAmGgB,CAnGd,AAmGwB,EAnGd,CAAC,CACd,CAAC,CAAE,EAAU,CADD,AACE,CACd,GAAI,EADQ,GACqB,IAAtB,EAAU,KAAuB,EAAxB,AAAQ,CACxB,CAAE,OAAO,CAAE,EAAU,OAAO,AAAR,CAAU,CAC9B,CAAA,CAAE,CAAC,AACR,CAAA,AACH,CAAC,CAAC,EAEF,AAFI,CAAA,MACJ,EAAO,GACA,CADD,AAER,CAgKM,AAhKL,KAFkB,CAAC,CAAA,CACQ,CAAA,AAiKZ,EAAU,CAAY,EACpC,GAAM,CAAC,AADgB,EACP,CAAC,CAAE,CAAC,CAAC,CAAP,AAAU,EACxB,GAD6B,CAAA,GACtB,EAAK,CACV,CADS,AACR,CAAQ,IAAI,CAAC,CAAC,CAAZ,CAAC,EAAY,CAAE,CAAG,AAAF,CAAC,KAAO,CAAC,CAAC,CAAC,CAC9B,CAAC,CAAE,AAAM,CAAL,GAAS,CAAC,CAAC,GAAC,CAAE,CAAC,CAAC,AAAC,MAAM,CAAC,CAAC,CAAC,CAC9B,OAAO,CAAc,IAAI,CAAC,CAAC,CAAlB,EAAmB,CAAC,CAAC,AAAE,CAAD,EAAf,GAAsB,CAAC,GACxC,CACH,AADI,CAsDE,AArDL,AADG,EAD8C,CAAC,MAuDnC,EAAM,CAA6B,EAA9B,AACnB,EAAO,GAEP,CAFM,GAEA,CAAC,CAFS,AAEN,CAFO,CAAA,AAEG,CAAC,CACf,AADe,CACd,CAAG,EAAU,CADD,AACE,CAAA,AAWrB,KAXmB,EAEA,AASZ,EATgB,CAAD,CAAC,IAAM,CAC3B,CAQe,CAAA,AARX,CAAD,CAAC,QAAU,CAAC,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAC/B,EAAI,CAAD,CAAC,QAAU,CAAC,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAEF,CAD7B,OACqC,EAArC,OAAO,EAAU,OAAO,AAAR,CACZ,EAAI,CAAD,CAAC,QAAU,CAAC,AA8OjB,SAAU,AAAW,CA9OM,AA8OS,EACxC,GAAgB,CAAC,GAAb,AADoB,EACL,KAAR,EAAe,EAAE,CAAA,AAC5B,GAAI,AAAY,AAlP2D,CAkP1D,KAAE,CAAR,MAAe,EAAE,AAC5B,CAD4B,MACtB,IAAI,EAAoB,CAAE,KAAK,CAAE,CAAO,CAAE,CAClD,AADmD,CAClD,AADkD,CAjPjB,EAAU,AAiPI,GAAjB,IAjPY,AAAQ,CAAC,CAAE,CAAE,IAAI,CAAE,CAAC,CAAE,CAAC,CAC1D,IAAI,CACT,AAGH,CAHG,AAGF,AA4GK,SAAU,EAAM,CAAoB,EAArB,AACnB,GAAM,GAAE,CAAC,GAAE,CAAC,SAAE,CAAO,CAAE,CAAG,EAC1B,MAAO,CAD4B,AAEjC,CAFiC,AAEhC,CAAE,EAAI,CAAD,CAAC,QAAU,CAAC,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAClC,CAAC,CAAE,EAAI,CAAD,CAAC,QAAU,CAAC,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAClC,OAAO,CAAc,CAAC,CAAC,CAAC,CAAf,EAAgB,KAAK,AAAd,CAAe,AAAE,CAAD,IAAM,CACvC,AACH,CAAC,AAwBK,AAzBH,SAyBa,EAAQ,CAAoB,EAC1C,EADqB,CACf,GAAE,CAAC,GAAE,CAAC,SAAE,CAAO,CAAE,CAAG,EAE1B,MAAO,CAF4B,AAGjC,CAHiC,CAGvB,KAAH,CAAC,AAAQ,CAAP,AAAQ,AAAE,CAAD,GAAK,EACjB,CAAE,CAAC,CAAC,CAAV,CAAC,CAAU,IAAI,CAAG,AAAF,CAAC,CAAK,CAAD,CAAC,MAAQ,CAAC,EAAI,CAAD,CAAC,QAAU,CAAC,CAAE,CAAC,CAAC,EAC5C,CAAE,CAAC,CAAC,CAAV,CAAC,CAAU,IAAI,CAAC,AAAE,CAAD,CAAK,CAAD,CAAC,MAAQ,CAAC,EAAI,CAAD,CAAC,QAAU,CAAC,CAAE,CAAC,CAAC,CAC1C,AACZ,CADY,AACX,AA6DK,SAAU,EAAW,CAAS,EAClC,GAAU,CAAC,CADa,EACpB,CAAC,EAAgB,EAAE,GAAR,CAAC,CAAS,OAAO,CAAC,CACjC,AADiC,GACvB,CAAC,GAAP,CAAC,EAAgB,EAAE,GAAR,CAAC,CAAS,OAAO,CAAC,CAAA,AACjC,GAAI,CAAC,EAAI,EAAE,CAAE,QAAO,CAAC,CAAG,CAAC,GAAK,CAAC,AAC/B,CADgC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,AAChC,CADiC,CAAA,EAC7B,EAAc,CAAE,KAAK,CAAE,CAAC,CAAE,CAAC,AACvC,CADyB,AAgCnB,AA/BL,AADsC,MAgC1B,UAAmC,EAAO,IAAD,CAAC,IAAS,CAG9D,IAHsC,QAG1B,WAAE,CAAS,CAAwC,CAAA,CAC7D,KAAK,CAAC,CAAA,QAAA,EAAW,EAAS,OAAA,yBAAA,CAAkC,CAAE,CAC5D,YAAY,CAAE,CACZ,iCAAiC,CACjC,CAAA,SAAA,EAAY,EAAI,CAAD,CAAC,EAAI,CAAC,EAAI,CAAD,CAAC,EAAI,CAAC,IAAW,KAAF,CAAC,CAAC,CAAS,CACnD,CACF,CAAC,CAAA,AARc,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,sCAAsC,EAS/D,CAT+D,AAS9D,CACF,AAGK,MAAO,UAA+B,EAAO,IAAD,CAAC,IAAS,CAAxB,AAGlC,YAAY,WAAE,CAAS,CAA0B,CAAA,CAC/C,KAAK,CACH,CAAA,YAAA,EAAe,EAAK,EAAD,CAAC,MAAS,CAAC,GAAU,MAAD,CAAC,uDAAA,CAAgE,CACzG,CAAA,AALe,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,kCAAkC,EAM3D,CAAC,AAN0D,CAO5D,AAGK,MAAO,UAAsB,EAAO,CAAf,GAAc,CAAC,IAAS,CAGjD,YAAY,CAAE,OAAK,CAAsB,CAAA,CACvC,KAAK,CACH,CAAA,QAAA,EAAW,EAAK,GAAA,oEAAA,CAAyE,CAC1F,CAAA,AALe,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,yBAAyB,EAMlD,CANkD,AAMjD,CACF,AAGK,MAAO,UAAsB,EAAO,CAAf,GAAc,CAAC,IAAS,CAGjD,YAAY,OAAE,CAAK,CAAsB,CAAA,CACvC,KAAK,CACH,CAAA,QAAA,EAAW,EAAK,GAAA,oEAAA,CAAyE,CAC1F,CAAA,AALe,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,yBAAyB,EAMlD,CANkD,AAMjD,CACF,AAGK,MAAO,UAA4B,EAAO,IAAD,CAAC,EAAf,EAAwB,CAGvD,YAAY,OAAE,CAAK,CAAsB,CAAA,CACvC,KAAK,CACH,CAAA,QAAA,EAAW,EAAK,GAAA,sDAAA,CAA2D,CAC5E,CAAA,AALe,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,+BAA+B,EAMxD,CAAC,AANuD,CAOzD,AAGK,MAAO,UAAsB,EAAO,CAAf,GAAc,CAAC,IAAS,CAGjD,YAAY,OAAE,CAAK,CAAqB,CAAA,CACtC,KAAK,CAAC,CAAA,QAAA,EAAW,EAAK,GAAA,gDAAA,CAAqD,CAAC,CAAA,AAH5D,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,yBAAyB,EAIlD,CAJkD,AAIjD,CACF,0JCx0BD,IAAA,EAAiC,CAA1B,CAA0B,CAAA,CAAA,EAArB,IAAI,EAChB,EAA+B,CAAxB,CADe,AACS,CAAA,CAAA,EAAnB,GAAG,GAEf,CAHiC,CAGF,AAHE,CAG1B,AAFc,CAEU,CAAA,CAAA,EAAnB,GAAG,EAFgB,CAAA,AAG/B,EAA2C,CADtB,AACd,CAAoC,CAAA,CAAA,EAA/B,KADmB,CAiHzB,AAjHyB,GACV,MAgHL,AAhHW,EAoHzB,CAA4C,CAC5C,AALkB,EAKiB,CAAA,CAAE,QAErC,AAAqC,AAvHI,CAAA,OAuHI,EAAzC,AACF,OADS,EAAc,OAAO,CACvB,AAiDL,GAlDoB,IACR,EAiDF,AAAQ,CAAkB,EACxC,GAAM,CADe,QACb,CAAO,CAAE,SAAO,OAAE,CAAK,CAAE,CAAG,EAC9B,EAAY,EAAU,KAAb,EADkC,AACtB,AAAQ,CADc,AACrB,AAAQ,GAEpC,MAAO,IAF0C,CAAE,CAAA,GAGjD,EACA,KADO,EACA,CAAE,MAAM,CAAC,GAChB,IADuB,CAAC,AACnB,CAAE,MAAM,CAAC,GACd,EADmB,CAAC,AACjB,CAAS,CACb,AACH,CADG,AACF,CA3DkB,GACV,CAAE,GAAG,CAAa,CAAE,GAAG,CADA,CACQ,AADE,CAAA,IACH,IAAU,CACjD,AAD4D,CAC3D,AAD2D,AAqQtD,SAAU,EAAe,CAA4B,EACzD,OAAO,AA0BH,EA3BwB,EACjB,KA0BG,AACd,CAA4B,CAC5B,EAFkB,AAEM,CAAA,CAAE,EAE1B,GAAM,SAAE,CAAO,CAAE,CAAG,EACpB,KAD2B,CAAA,CACpB,EAAK,EAAD,CAAC,MAAS,CACnB,EAAI,CAAD,CAAC,IAAM,CACR,MAAM,CACN,EAAI,CAAD,CAAC,KAAO,CACT,AAmHF,OAnHS,EAmHC,AACd,CAA4B,EAE5B,GAAM,CAHe,QAGb,CAAO,SAAE,CAAO,OAAE,CAAK,CAAE,CAAG,EAC9B,EAAY,EAAU,KAAb,EADkC,AACtB,AAAQ,CADc,AACrB,AAAQ,GACpC,MAAO,CACL,EAAU,CAFqC,CAEjC,AAFkC,CAAA,AAEnC,CAAC,CAAP,CAAC,CAAC,KAAe,CAAC,GAAW,IAAJ,AAAQ,CAAP,AACjC,CADkC,CAAC,AAEnC,EAAQ,EAAI,CADL,AACF,AAAM,CAAC,AAAN,CAAC,OAAe,CAAC,GAAS,EAAJ,CAAC,CAAC,AAAM,CAAL,GAC3B,EAAY,EAAU,KAAb,CAAC,CAAC,AAAU,AAAQ,CAAP,AAAQ,GAAa,EAAE,CACzC,AAD0C,AAEtD,CAAC,AADW,CA5HF,CA2HqC,CA1HjC,AA0HkC,CAzHhC,AAyHiC,CAAC,GA3HjC,GAEM,CAAE,EAAc,OAAO,CAC9B,GADsB,IACf,CAAE,EAAc,OAAO,CAC9B,GADsB,EACjB,CAAE,EAAc,KAAK,CAC3B,CACD,IAFsB,CAOpC,CAAC,CA/Ca,EAAe,CAAE,GA0CJ,CAClB,CACF,CACF,CACF,AA9CmC,CA8CnC,CA9CqC,CAAb,AAAiB,CAAE,CAAC,AAC/C,CAD+C,AAC9C,AAD2C,6FEpY5C,EAAuC,CAAhC,CAAgC,CAAA,CAAA,EAA3B,IDCI,ECAhB,CADmB,CDEb,EAAA,CAAA,CAAA,CCFmB,MAGzB,EAAA,EAAA,CAAA,CAAA,EAHuC,CAAA,6BDDhB,CAAA,WCOvB,IAAA,EAA2B,CAApB,CAAoB,CAAA,CAAA,EAAf,MAmEN,GAnEe,MAmEL,AAnEW,EAoEzB,CAA6B,EAE7B,GAAM,IAHoB,QAGlB,CAAU,CAAE,CAAG,EACjB,EAAQ,EAAA,CADgB,AACnB,CADmB,OACP,CAAC,eAAe,CAAC,cAAc,CACpD,EAAI,CAAD,CAAC,EAAI,CAAC,GAAY,KAAK,CAAC,CAAC,AAAT,CAAU,AAAT,CACrB,CAAA,AACD,OAAO,EAAU,IAAI,CAAC,EAAN,AAClB,CADmB,AAClB,AA2FK,EA5FuB,CAAC,CAAA,KA4Fd,EACd,EAAwC,CAAA,CAAE,EAE1C,GAAM,IAAE,CAHsB,CAGpB,AAAG,KAAK,CAAE,CAAG,EACjB,EAAQ,EAAA,CADgB,AACnB,CADmB,OACP,CAAC,KAAK,CAAC,gBAAgB,EAAE,CAAA,MAChD,AAAW,KAAK,EAAE,CAAd,EAAE,AAAmB,EAAI,CAAD,CAAC,OAAS,CAAC,GAChC,CACT,CAF8C,AAE7C,AAoCK,CAtCkD,CAAA,CACjC,CAAA,KAqCP,EACd,CAA+B,EAE/B,OAAO,EAAQ,AAHa,KAGd,CAAC,OAAa,CAAC,AAqCzB,SAAU,AACd,CAAiC,EAEjC,GAAM,CAxCuC,QAwCrC,CAHsB,AAGf,CAAE,WAAS,CAAE,CAAG,EACzB,GAAE,CAAC,CAD6B,CAAA,CAC3B,CAAC,SAAE,CAAO,CAAE,CAAG,EAKpB,EAJa,AAIL,GAAH,CAJY,CADY,CAAA,AACZ,IAIC,KAJQ,CAAC,SAAS,CACxC,MAAM,CAAC,CAAC,CAAC,CACT,MAAM,CAAC,CAAC,CAAC,CACV,CAAC,cAAc,CAAC,GACQ,IADD,CAAC,CAAA,UACgB,CAAC,EAAI,CAAD,CAAC,EAAI,CAAC,GAAS,IAAF,CAAC,IAAU,CAAC,CAAC,CAAC,CAAC,CAAA,AACzE,OAAO,EAAU,IAAI,CAAC,EAAN,AAClB,CAAC,AADkB,CA/C6B,CA+CnB,CAAC,CA9C9B,AA8C8B,CA9C7B,AA+EK,GAhFiD,CAAC,CAAC,CAAA,GAgFzC,EAAK,CAAqB,CAAtB,CAClB,GAAM,CAAA,aACJ,ED7SmB,CAAA,CC6SgB,MACnC,CAAI,CADQ,IAAG,IAEf,CAAO,EAFe,CAAC,SAGvB,CAAU,CACX,CAAG,EACE,CAAE,GAAC,CADE,CAAA,CACA,CAAC,UAAE,CAAQ,CAAE,CAAG,EAAA,SAAS,CAAC,IAAI,CACvC,EAAM,GAAD,CAAC,AAAI,CAAC,GACX,EAAM,EADY,CACb,AADc,CACT,AAAJ,CAAK,GACX,CACE,MAFmB,CAAC,KAER,CACc,SAAS,EAAjC,OAAO,EACH,EACA,EAAI,CAAD,CAAC,EAAI,CAAC,CAFM,EACH,AACW,KAAK,CAAC,CAAC,CAAC,CAAV,AAC3B,CAD4B,GACxB,EAAE,EACN,EADU,CACN,EAAO,CAAE,CAAL,CAAC,CAAC,IAAU,CAAE,EAAI,CAAE,CAAF,AAAG,AAAE,CAAD,AAAC,CAAE,CAAC,AACnC,CACF,CAAA,AACD,MAAO,GACL,CAAC,GACD,CAAC,CACD,OAAO,CAAE,EACV,AACH,CADG,AACF,AAxToB,EAAA,GAsTA,MAtTS,CAAA,0MEN9B,EAA2B,CAApB,CAA0C,CAAA,CAAA,EAArC,MACZ,EAA2B,CADN,AACd,CAA0C,CAAA,CAAA,EAArC,CADe,KAqBpB,GApBc,CAoBR,EACX,GArByB,KAoBJ,4DACwD,CAAA,AAGlE,EAAmB,ECMS,IDNS,CAChD,ECKuC,mHDWnC,SAAU,EDEC,CAAA,ACFgC,KAC1B,QAAQ,EAAE,CAAC,YAC1B,EAAA,KAAS,CAAC,EAAO,ADK+C,CCL9C,ADK8C,ECL5C,AAAL,CAAM,GAAK,EAC5B,MAAM,EADgC,EAChC,EAAiC,EAAM,CAAA,EAAD,GACzC,EAAU,MAAM,CAAP,AAAQ,CAAP,CAAa,GAAD,UAAc,CAAC,AAC9C,CAD8C,AAC7C,AAuCK,SAAU,EAAK,CAA0B,CAA3B,OAClB,AAAqB,QAAQ,EAAzB,AAA2B,OAApB,EAA2B,EAAO,CAA7B,EACT,CACT,AAF8C,CAE7C,AAmBK,AArB8C,CAAC,CAAA,CACvC,CAAA,KAoBE,EAAO,CAAgB,EACrC,CADoB,CACb,GAEP,CAFM,GAAQ,AAER,CAFS,CAAA,AAEM,EAAI,CAAD,CAAC,MAAP,AAAe,CAAC,EAAI,CAAD,CAAC,GAAK,CAAC,EAAS,CAAC,EAAE,CAAE,CAAP,AAAQ,EAAE,CAAC,CAAC,CAAA,AACzD,EAAS,EAAI,CAAD,CAAN,AAAO,GAAK,CAAC,EAAS,CAAC,EAAe,EAAE,AAApB,CAAsB,CAAC,EAAE,CAAC,CAAA,AACpD,EAAY,AAD6B,EACzB,CAAD,CAAC,GAAP,AAAY,CAAC,EAAS,CAAC,CAAE,CAAC,EAAN,AAAqB,EAAE,CAAC,CAAA,AAErD,CAAC,EAAM,EAAE,AAAE,AAAN,CAF0C,CAE/B,CAAG,CAAJ,CAAkB,MAAM,CAAC,EAAkB,EAA1B,CAAC,AAWvC,GAXsE,CAAC,CAAA,CAWhE,CACL,IAZ4D,SAY/C,CAVO,EAAc,IAAI,CAAC,CACvC,KADiC,CAAC,CAC3B,CAAE,EAAK,EAAD,QAAW,CACxB,OAAO,CAAE,MAAM,CAAC,EAAK,EAAD,KAAQ,CAAC,CAC7B,KAAK,CAAE,EAAK,EAAD,GAAM,CACjB,OAAO,CAAE,EAAK,EAAD,KAAQ,CACrB,CAAC,CAAE,EAAK,CAAC,CAAF,AACP,CAAC,CAAE,EAAK,CAAC,CAAF,AACR,CAAC,CAAA,AAIA,SAAS,GACT,GAAI,GAAiB,CAAb,GAAiB,CAAC,CAAC,CAAf,EAAgB,EAAZ,IAAc,IAAI,CAAE,CAAE,CAAA,AAAE,CAAC,AAAE,CAAD,AAAC,CAAE,CAEjD,AADG,AAD+C,CAEjD,AA8BK,AA/BH,SA+Ba,EAAK,CAAgB,CAAjB,CAClB,GAAM,MAAE,CAAI,WAAE,CAAS,CAAE,CAAG,EAE5B,EAAO,CAF0B,CAAA,CAIjC,CAFM,CAAM,CAAC,CAEP,AAFO,EAEA,EAAH,AAAa,OAAD,CAAC,MAAc,CAAC,CACpC,OAAO,CAAE,EAAc,WAAD,CAAC,EAAc,CAAC,EAAM,GAAD,UAAc,CAAC,CAC1D,SAAS,CAAE,EAAU,IAAI,CAAC,EAAN,AAAY,CAAX,EAAU,UAAc,CAAC,CAC/C,CAAC,CAAA,AAEI,EAAS,EAAc,EAAjB,IAAuB,CAAC,EAAkB,CACpD,CACE,AAFwB,CAAC,EAEtB,EAAM,GAAD,IAFwC,MAE1B,CACtB,UAAU,CAAE,EAAM,GAAD,UAAc,CAAC,OAAO,CACvC,OAAO,CAAE,MAAM,CAAC,EAAM,GAAD,UAAc,CAAC,OAAO,CAAC,CAC7C,CACD,EAAM,EAAE,CAAH,CAAO,EACZ,EADgB,CACR,CAAJ,GAAQ,CACb,CAAC,CAAA,AACI,EAAe,EAAI,CAAD,CAAC,MAAP,EAAiB,CAAC,EAAI,CAAD,CAAC,EAAI,CAAC,GAAS,CAAE,EAAL,CAAC,CAAQ,CAAE,EAAE,CAAE,CAAC,CAAA,AACnE,OAAO,EAAI,CAAD,CAAC,IAAM,CAAC,EAAW,EAAQ,EAAc,EAAhB,AACrC,CAAC,AAoBK,AArBuB,OAAsB,AAAY,CAAC,CAAA,AAqBhD,EAAS,CAA0B,EACjD,GADsB,AAClB,CAAC,AAEH,OADA,EAAO,IAAD,AACC,CACT,AAFc,CAEb,AAAC,AAFa,CAAA,CACF,CAAA,EACL,CAAC,AACP,OAAO,CACT,CACF,AADG,CACF,AAOK,EATU,CAAA,GASH,UAAqC,EAAO,IAAD,CAAC,IAAS,CAGhE,MAHwC,MAG5B,CAAgB,CAAA,CAC1B,KAAK,CAAC,CAAA,QAAA,EAAW,EAAO,KAAA,uCAAA,CAA8C,CAAC,CAAA,AAHvD,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,+CAA+C,EAIxE,CAJwE,AAIvE,CACF,uRC/LqB,EAAoB,KDNb,ICO3B,CDP4C,AAAD,CAAC,ACQ5C,eAAa,WACb,CAAS,CACqB,EAC9B,MAAA,CAAA,EAAO,EAAA,cAAA,AAAc,EAAA,CAAA,EACnB,EAAA,UAAA,AAAU,EAAC,GACX,IADkB,CAAC,CACb,CAAA,EAAA,EAAA,0BDZ2G,CCY3G,AAA2B,ADXpC,CAAA,CCWqC,eAChC,EACA,SAAS,EADI,CAEd,CAAC,CACH,AACH,CADG,AACF,EFZE,uEA/BH,EEOO,CDTA,ACKA,AFHA,CAA4C,CEMjD,AFNO,AAA0C,CAAA,CAAA,CCFvC,ADEuC,MCFjC,ADkCZ,CAhCa,AEOsB,CAAA,CFPpB,GCFG,GDEG,AAgCX,EAA0C,CACxD,GAAC,GE3B0B,AF4B3B,CAAC,EE3BF,EF4BC,EAAE,AAAG,ACrCoC,CAAA,CDkCT,AEzB3B,GF4BK,GACV,CAAC,SACD,CAAO,CAC0B,EACjC,IAAM,EAAW,CAAC,GAAG,EAAP,AAAS,AACrB,GAAgB,CAAC,GAAb,GAAiB,AAAY,CAAC,GAAvB,EAAyB,CAAR,MAAe,EAC3C,GAAI,CAAC,CAD6C,CAAA,EACzC,CAAO,CAAG,GAAT,CAAC,IAAkB,CAAG,GAAT,CAAC,EAAY,CAAC,IAAI,CAAA,AAAG,CAAC,CAAE,QAAO,CAAC,EAAG,AAAE,IAAK,EAAA,AAAE,CAAC,AACpE,CADqE,CAAC,CAAC,CAAC,CAAC,CAAC,CACpE,AAAI,AADiE,CAAA,IAC5D,CAAC,gCAAgC,CAAC,CAAA,AACnD,CAAC,CAAC,EAAE,AACE,CADF,CACc,CAAA,EAAA,EAAK,IAAI,EAAA,SAAS,CAAC,SAAS,CAAA,CAAA,EAC5C,EAAA,WAAA,AAAW,EAAC,CAAC,CAAC,CAAA,CAAA,EACd,EAAA,WAAA,AAAW,EAAC,CAAC,CAAC,CACf,CAAC,YAAY,EAAE,CAAA,EAAgB,CAAC,CAAC,CAAC,CAAhB,EAAiB,IAAI,CAAC,AAAE,CAAhB,AAAe,GAAK,CAAA,CAAW,CAAA,MAE1D,AAAW,KCNK,ADMA,EAAE,CAAd,EAAqB,AAAnB,CCLI,CDMV,CAAA,EAAO,EAAA,UAAA,AAAU,EAAC,EACpB,CAAC,MAD4B,CAAqC,CAAA,iBCLtB,yCEjD5C,IAAA,EAA6C,CAAtC,CAAsC,CAAA,AAApC,CAAoC,QAC7C,EAA6C,CAAtC,CAAsC,CAApC,AAAoC,CAAA,CADpB,EAAE,KAK3B,CALiC,CAO/B,CAFK,CAIN,CAHC,AAC4B,AAE7B,CAAA,CARwB,AAOvB,EACK,AARoB,IADkB,CAU7C,CAJY,AALqB,CAW/B,CAFK,AAHL,CAMD,CAFC,AAED,CAAA,AALc,CAKR,EAJN,IAR4C,CAa7C,EAEE,CAFK,CAFa,AAKb,CAFL,AAEK,CARyB,AAQzB,CARyB,AAI/B,OAUD,CAPgC,CAUzB,CAHA,CANN,AASM,CADL,AACK,CAAA,CAAqC,CAAA,CAbP,AAEjB,CAFiB,AAFF,CAKjC,CAJA,EAeF,EAGO,AAb0B,CAU1B,AAV0B,CAa1B,CADL,AACK,CAAA,CALW,GACjB,CAI6C,CAAA,EAC9C,EAGO,AARA,CAKA,CAGmC,CADxC,AACwC,CAAA,GALtB,GACnB,EAKD,CAFY,CAKL,CAHA,CADN,AAIM,AARA,CAImC,AAGxC,AACK,CAJmC,AAInC,CAAuC,CAAA,EAJvC,IAKP,EAAoC,CAA7B,CAA6B,CAAA,AAFpB,AAEP,CAA2B,EADnC,MAAM,AAEP,EAAmD,CAA5C,CAAwE,CAA7C,AAA6C,CAAA,EADO,CAAA,CACP,AADnD,CACmD,CADjD,EACa,AAC3C,EAD6C,AACF,CAApC,CAA+D,AAFlC,CAEN,AAAwC,CAAA,EADnB,EAChB,EAAE,EACrC,EAA0B,CAAnB,CAAoD,AADhB,CAClC,AAAkD,CAAA,OAC3D,CADkB,CAMX,CANa,AAAuC,AACpD,CADoD,AAMpD,CAHL,AAGK,CAAA,GANmB,CAMY,CAAA,CACtC,EAA0B,CAAnB,AAJK,CAIwC,CAA3C,AAA2C,AAFlD,CAEkD,EAAA,CAAA,KAAlC,AAClB,EADoB,AAIb,AANM,CAGN,CAGA,CADL,AACK,AALN,CAKM,EAJmB,CAIsB,CAAA,CALzC,GAMP,EAGO,CAHA,CAGA,CALS,AAKT,AADL,CACK,EAJN,MAAM,AAKP,EAAyE,CADrB,AAC7C,CAD6C,AACqB,CAAvB,AAAuB,CAAA,GAAnB,AAFlC,EAEoC,CADvD,CAED,EAA6D,CAAtD,CADuD,AACD,CAAA,AAFtD,AAEyB,CAA6B,MAAtB,EACvC,AADyC,CADgC,CAAA,AAEhB,CAAlD,CAAqE,CAAvC,AAAuC,CAAA,AAD7B,QA+CxC,GA9C0C,EAAE,AA8CvC,CA/CiD,CAAA,IACJ,IA8CnC,EACpB,CAAgC,CAChC,CAAgC,EAEhC,GAJ8B,GAIxB,SACJ,CAAO,MACP,CAAI,CACJ,sBAAsB,CACpB,EAAkB,EAAW,QAAD,GAAb,sBAA+C,EAC9D,EAAO,IAAD,CAAM,EAAE,SAAS,EAAE,eAAe,EAAE,OAAO,CACnD,gBAAgB,GAAG,EAAW,QAAD,QAAiB,EAC5C,EAAO,IAAD,CAAM,EAAE,SAAS,EAAE,UAAU,EAAE,OAAO,CAC/C,CAAG,EAEE,GACE,EAAY,EAAW,CAHjB,CAAA,AAEC,GAAG,AACD,CADE,EACW,CAAU,AADlB,CAEpB,AADsC,AACtC,CAAA,AAFsB,EAElB,EAAA,KAAA,AAAK,EAAC,GAAmB,EACJ,IADN,CAAC,EAAE,AAAgB,CACL,AADK,EAClC,OAAO,GAA0B,GAAG,GAApB,AAAwB,GAAa,GAAG,GAAP,AAAW,EAC9D,CAAA,EAAO,EAAA,EADgE,EACvE,cAAO,AAAkB,EAAC,GAC5B,CAAA,EAAO,EAAA,CAD8B,CAAC,CAAA,OAC/B,AAAU,EAAC,IAGpB,GAAI,CAAC,AACH,CAJ2B,CAAC,CAAA,AAIxB,EAAA,gBAAgB,CAAC,QAAQ,CAAC,GAC5B,MADqC,CAAC,AAC/B,MAAM,EAAc,EAAQ,CACjC,GAD+B,AAC5B,CAAU,IADW,cAExB,YACA,EACD,CAAC,CAAA,AACJ,AAHoB,KACP,EAEN,MAAM,EAAc,EAAQ,CACjC,GAD+B,AAC5B,CAAU,IADW,aAExB,YACA,EACD,CAFgB,AAEf,AACJ,CADI,AACH,AAAC,KAFW,CAEJ,EAAO,CAAC,AAEf,EAFY,CAER,CAAC,AAKH,GAJc,CAIV,AAJU,EAAG,EAAA,IAIL,UAJmB,AAAd,EAAc,CAAA,EAC7B,EAAA,UAAA,AAAU,EAAC,GACX,IADkB,CAAC,CACnB,CAAA,EAAM,EAAA,cAAA,AAAc,EAAC,MAAE,IAAI,QAAE,CAAS,CAAE,CAAC,CAC1C,CAAA,AACa,IAF0B,GAEnB,CACvB,CAAC,AAAC,EADyB,CAAA,EACnB,CAAC,CAAC,AAEV,GAAI,KAAK,QAAY,EAInB,OAAO,CAGT,IAHc,CAAA,EAGR,AAPgC,CAQxC,CAAC,AACH,AAT4C,CAS3C,AAGM,AAZsC,EAO9B,CAAA,EAKH,UAAU,EACpB,CAAc,CACd,CAAoC,EAEpC,GAAM,GAJ2B,MAIzB,CAAO,aAAE,CAAW,UAAE,CAAQ,MAAE,CAAI,kBAAE,CAAgB,CAAE,CAAG,EAE7D,CACJ,OAH2E,CAAA,KAG9D,CAAE,CAAgB,CAC/B,IAAI,CAAE,CAAQ,WACd,CAAS,IACT,CAAE,CACH,CAAG,EAAA,gBAAgB,CAAC,MAAM,CAAC,EAAW,QAAD,CAAU,CAAC,CAUjD,AAViD,GAU7C,AAPS,IAOL,EAPK,CAAA,EAAM,EAAA,OAAA,AAAO,EAAC,EAAQ,IAAF,KAC/B,OAAO,OACP,WAAW,AACX,EACQ,CAAC,CAAA,EAGH,CAAA,CAJE,CAIG,EAAA,SAAA,AAAS,EAAC,CAAC,UAAU,CAAE,EAAiB,OAAO,CAAC,CAAC,CAC5D,IADkD,GAC3C,MAAM,EAAc,EAAQ,CACjC,GAD+B,IACxB,CADiB,cAExB,WAAW,AACX,OACA,CADQ,GACJ,QACJ,EACD,CAAC,CAAA,AAEJ,IAAM,CAHO,CAGS,CACpB,OAAO,CAAE,EADQ,AACS,OAAO,CACjC,MADyB,CAClB,CAAE,MAAM,CAAC,EAAiB,OAAO,CAAC,CACzC,KADgC,AAC3B,CAAE,MAAM,CAAC,EAAiB,KAAK,CAAC,CACrC,CAAC,CAAA,CAAA,EAAE,EAD2B,AAC3B,WAAA,AAAW,EAAC,EAAiB,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAChD,CAD+B,AAC9B,CAAA,CAAA,EAAE,EAAA,WAAA,AAAW,EAAC,EAAiB,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAChD,CAD+B,MACxB,CAAE,EAAiB,OAAO,CACzB,CAAA,AAMV,GAAI,CAAC,AAJS,CAHa,IAOjB,CAJI,CAAA,EAAM,EAAA,mBAAmB,AAAnB,EAAoB,SACtC,OAAO,SACP,EACD,CAAC,CACU,AADV,MACgB,GAFH,CAEO,EAGtB,IAAM,EAAU,KAAH,CAAG,CAAA,EAHuB,AAGjB,EAHmB,AAGnB,CAHmB,QAGnB,AAAS,EAC7B,EACA,EAAA,EADM,UACM,CACZ,cAAc,CACf,CAAC,CACA,GAAI,EACA,CAAE,OAAO,CAAE,CAAgB,CAAE,CAC7B,CAAE,CAFc,GAEV,CAAE,EAAA,KADmB,aACD,CAAE,CAAC,AACjC,iBAAiB,CAAE,CAAC,EAAc,CAClC,GAAG,CAAE,EAAA,IAD4B,SACf,aAClB,EACA,QAAQ,CADG,AACD,SAAS,CACnB,YAAY,CAAE,YAAY,CAC1B,IAAI,CAAE,CACJ,IACM,EACA,CACE,CACE,IAHI,QAGQ,EAAE,EACd,EADkB,IACZ,CAAE,EAAE,CAAI,EACd,KADqB,GACb,CAAE,EACX,CACF,CACD,EAAE,CAAC,AACP,CAJ0B,AAKxB,YAAY,EAAE,EACd,EADkB,IACZ,CAAE,EACR,KADe,GACP,CAAA,CAAA,EAAE,EAAA,kBAAA,AAAkB,EAAC,CAC3B,GAAG,CAAE,EAAA,UAAU,CACf,YAAY,CAAE,kBAAkB,CAChC,IAAI,CAAE,CAAC,EAAM,EAAF,AAAY,CACxB,CAAC,CACH,CACF,CACF,CACF,CAAC,AAL8B,CAK9B,AAEI,EAAO,CAAO,CAAV,AAAW,EAAQ,KAAD,CAAO,CAAG,CAAC,CAAC,EAAE,UAAU,CAAA,AAEpD,GAAI,GAAM,CAAF,SAAY,CAAC,YAAY,CAAC,CAAE,OAAO,CAC3C,GAD+C,CAAA,GACzC,IAAI,CACZ,CAAC,AAiBD,KAAK,UAAU,AAlBc,EAmB3B,AAnB6B,CAmBf,AAnBe,CAoB7B,CAAoC,EAEpC,GAAM,GAJoB,MAKxB,CAAO,SACP,CAAO,aACP,CAAW,MACX,CAAI,WACJ,CAAS,iBACT,CAAe,CACf,GAAG,EACJ,CAAG,CADK,CAGH,EAAmB,MAFX,AAEiB,CAAC,AAFlB,KAEuB,EAAf,EAAmB,AAGvC,AAAI,CAAC,CAHoC,EAGzB,CAAC,GAAL,AAGR,EAAA,MAHwB,EAAE,QAGV,CAAC,QAAQ,CAAC,GAHO,EAO9B,EAAA,EAJgC,CAAC,EAHM,AAGJ,CAHI,MAGG,IAI1B,CAAC,IAAI,AAJ8B,CAI7B,AAJ6B,CAKxD,IAAI,CAAE,WAAY,CAClB,EACA,EAAE,CAAE,EACL,CACH,AADI,CACH,AAHY,AAET,CACF,EAFc,AAEZ,AAEE,CAFF,CAES,EAAH,AACL,CACC,EAAE,CAAE,EACJ,IAAI,CAAA,CAAA,CAHkB,CAGhB,EAAA,GADa,eACb,AAAkB,EAAC,CACvB,GAAG,CAAE,EAAA,4BAA4B,CACjC,YAAY,CAAE,YAAY,CAC1B,IAAI,CAAE,CAAC,EAAS,EAAM,EAAiB,AAAnB,CACrB,AADe,CACd,CACF,GAAG,CAAI,CACsB,CAC9B,CACC,IAAI,AALoC,CAKpC,CAAA,EAAE,EAAA,gBAAA,AAAgB,EAAC,CACrB,GAAG,CAAE,EAAA,4BAA4B,CACjC,IAAI,CAAE,CAAC,EAAS,EAAM,EAAF,AAAmB,CAAzB,AACd,QAAQ,CAAE,EAAA,EAD4B,+BACK,CAC5C,CAAC,CACF,GAAG,CAAI,CACsB,CAAA,AAE7B,MAAE,CAAI,CAAE,CAAG,MAAA,CAAA,EAAM,EAAA,SAAS,AAAT,EACrB,EACA,EAAA,EADM,EACF,CACJ,MAAM,CACP,CAAC,GAAM,CAAF,CAAC,GAAM,CAAC,AAAC,IACb,CADkB,EAAE,AAChB,EADkB,GACb,QAAY,EAAA,kBAAkB,CAAE,MAAM,IAAI,CACnD,OAAM,CACR,CAAC,CAAC,CAAA,AAEF,CAHa,CAAA,CAGb,CAAA,CAJsE,CAIlE,CAJoE,CAIpE,AAJoE,SAIpE,AAAS,EAAC,GAAQ,CAAJ,IAAS,CAAC,CAAE,OAAO,CACrC,GADyC,CAAA,GACnC,IAAI,CACZ,CAAC,AAgBM,KAAK,UAjBiB,AAiBP,EAjBS,AAkB7B,CAlB6B,AAkBf,CACd,CAAoC,EAEpC,GAAM,CAAE,EAJyB,OAIlB,aAAE,CAAW,UAAE,CAAQ,MAAE,CAAI,WAAE,CAAS,CAAE,CAAG,EAmB5D,GAAI,CAjBW,IAFuD,CAAA,AAmB5D,CAjBK,CAAA,EAAM,EAAA,SAAA,AAAS,EAC5B,EACA,EAAA,EADM,UACM,CACZ,cAAc,CACf,CAAC,SACA,EACA,GAAG,CAAE,CADE,CACF,UAAU,CACf,IAAI,CAAE,CAAC,EAAM,EAAF,AAAY,OAAD,MACtB,WACA,AADW,EAEX,MADQ,MACI,CAAE,kBAAkB,CACjC,CAAC,CAAC,KAAK,CAAC,AAAC,IACR,CADa,EAAE,AACX,EADa,GACR,QAAY,EAAA,8BAA8B,CACjD,MAAM,IAAI,CACZ,OAAM,CACR,EAAC,CAAC,CAAA,AAES,AAHE,CAAA,GADkB,EAAE,CAAA,GAIZ,CAAC,YAAY,CAAC,CAAE,OAAO,CAC5C,GADgD,CAAA,GAC1C,IAAI,CACZ,CAAC,AAaD,MAAM,SAduB,CAcG,CAdD,CAAA,GAcM,EAAb,AAAgB,sGC9XjC,EGEE,ADAyB,ADFzB,AGEA,EJFI,EAAuB,CCAC,ECEM,ACAzB,ACAqB,EFAM,ACAzB,MDA+B,ACAzB,CDA+C,CAAA,ACAxB,CFFpB,AEEoB,EFFlB,AGEA,EAAE,AJFA,GIEwB,CAAA,OHFQ,CAAA,EDAG,CAAA,6FCkBpD,EIL2B,AJKT,CAAyB,CILd,CDAJ,AAAgB,AHMvD,CGNuD,EAClD,ACAA,CJKC,CIN2C,ADCf,ACElC,CJI0B,CGLK,EAAE,KHIjB,CAAC,CGL8B,AHMzC,EETU,AFQI,KACP,EGLoB,AAAd,CAAc,EHKU,EAAA,CAAtB,EIoBM,QJpBgB,AAAW,EAAC,GACzB,MGDU,CAAA,CHCF,EAAhC,AAAkC,GI8B7B,IJ9BE,CGDK,CHCI,GAAG,CAAsB,CGDvB,ACgCV,CJ/BO,AAAmC,GAAG,CAAA,EGQ3B,CHPvB,EAAA,UAAA,AAAU,EAAC,EAAS,GAAA,EAEvB,EAAA,CAAA,EAAS,CEGD,CAAA,WAAA,AFHY,EAAC,CAAA,EAAG,EAAoB,EAAG,CAAA,EAAA,EAAA,IAAA,AAAI,EAAC,GAAQ,CAAE,CAAC,AAAnB,CAAmB,CAAJ,CAAC,CEGK,MFFhE,EAAA,MAAA,AAAM,EAAC,CAAC,IAAgB,CEGb,ACiBA,AHnBpB,CADuB,AACtB,SCbe,CGFC,CHGf,CERA,AFQwB,CACxB,CCP8B,AFJM,AAAjB,CAAiB,CIOf,IDNH,AFQO,KAIlB,EGL0B,CAAA,QAAA,AHKjB,EAAA,EAAmB,EDP9B,CCOwC,CEL4B,CCAV,ADAU,CCAV,AHKf,CAAN,AAAO,CAAA,AAAN,SDPhB,CAAA,qVEFhB,EEGE,AJPA,QAAA,EAAA,SEIkC,CAC/C,ECHuB,CHDlB,AIOA,ADAA,CALL,CHAA,AIK4B,ADAI,OAAA,CAAA,OAAA,CDHZ,CAAA,CAAA,CAClB,CCGyB,ACAK,CDNV,GACvB,ADEQ,CAAC,CAAA,ICFH,YDEG,EAAA,CAAA,EAAA,EAAA,KCFqB,CAAA,GDErB,EAA6B,GAAO,EEG2B,AFH3B,CEG2B,AFHvB,AAAL,CAAO,AAAN,CACxC,KFQS,QAAA,CERM,CCGkC,ICE9B,EAEvB,2BFPqD,UAQ1C,MEAW,CAAA,GFAX,EAAA,SAAA,CACX,YAAY,CAAA,YAAA,CAAA,CAEV,GFA0B,IEArB,CAAA,CAAA,MAEA,CACH,CAAA,QCee,eAAA,EDfW,ECkB5B,ADlBuC,ECkBrC,ODlBqC,WAAA,EAAuB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,IAAO,CAAF,CAAC,CAAC,CAAK,CACnG,CACE,SAAU,wDACV,aAAc,oDAAoD,EAGxE,CAAC,CAMG,AALL,MAKY,MEwBE,IFxB6B,EAAA,SAAS,CACnD,AADkC,YACtB,MAAE,CCWD,ADXK,CCWL,ADXyB,CAAA,CACpC,KAAK,CAAC,CAAA,aAAA,EAAgB,EAAI,EAAA,WAAA,CAAe,CAAE,CACzC,GEyBO,CDbC,SDZM,4CAA4C,MACpD,0BAEV,CAAC,CACF,wICfK,SAAU,EAGd,CDbmC,KCc7B,CACJ,OAAQ,CCmBK,CAAA,QAAA,CDlBI,CACjB,aAAW,OACX,CAAK,CACN,CAAG,EAEE,EAAgB,CACpB,EACA,GAJ8C,CAAA,AAGT,CAGrC,IAAM,EHpBI,AGoBG,CAAE,CAAL,EAAQ,CAAA,EAClB,IAAK,IAAA,KAAe,EAAQ,CHpBE,AGoBD,AAC3B,GHrB0B,AGoBF,AAClB,MAAE,CCYK,ADZD,MAAE,CAAI,CAAE,CAAG,CACnB,CAAS,GAAL,AADoB,CAAA,KACN,OAAE,CAAI,CAAC,EAAK,CAAI,CAAL,AAAS,CAAC,EAAgB,CAAC,CAAb,UAAwB,EAAA,CAAE,CAAA,OAEpE,KAIF,CCaG,CDbG,CDZL,KCWQ,GAAG,CDZH,CCYK,CACI,EAClB,AADoB,CCcpB,CDZE,EAAc,CCcX,CDdiB,CADf,EACc,MAAN,GAAmB,CAAE,GCYpC,CAAA,CF1B2B,CCiB5B,CAH4C,CAAC,AAGnC,CAAC,AAHkC,ACoB5C,GDjBa,EAAE,AACpB,GCiBY,ADjBZ,AAAoB,cAAc,GAAlC,EACA,IAD2C,GACpC,CCkBQ,CACN,ADnBY,CAAK,CAAC,EADyB,AACb,CADa,AACX,GAC3C,CAAC,CAAC,GADsC,AAAW,CAAC,CAAA,2BAGjC,UAAQ,ECoBE,CAAC,CAAC,CAAA,EDpBG,OAAE,QAAa,CAAK,CAAE,CAAC,AAAV,CAAU,CAAH,UAatD,CAAuD,KACjD,CAAE,QAAM,SAAE,CCkBC,ADlBM,aAAE,CAAW,OAAE,CAAK,CAAE,CAC3C,EAEI,ECgBA,ADhBe,CACnB,EACA,GAJ4C,CAAA,AAGP,AACR,EAC7B,EAAE,CACG,IAAA,KAAe,EAAQ,CAAC,AAC3B,CCaG,EDdqB,AAClB,MAAE,CAAI,MAAE,CAAI,CAAE,CAAG,EACjB,EAAQ,CADc,AACV,CADU,AACT,CAAR,CAAa,CAElB,AAFkB,CAAD,CAEF,EAAK,EAAD,GAAM,CAAC,EAAA,AAAd,YAA0B,CAAC,CAAA,AAC7C,GAAA,GAEE,CAAA,AAAkB,QAAQ,EAA1B,EAAA,KAAQ,GAAuC,EAAlC,CCyBO,ODzBU,OAAO,CAAU,CAAQ,CAAC,AACxD,CAAC,AACD,CAF0C,EAEpC,CAAC,EAAO,EAAM,CAAR,CAAM,AAAQ,CAAG,EAAJ,GAGzB,EAAA,KAHyC,CAAA,KAGzC,AAAW,EAAC,EAAO,GAAF,KACE,KAAK,KACtB,IAAI,CAAE,MAAM,CAAC,QAAQ,CAAC,EAAO,EAAE,CAAJ,AAAK,CAAG,CAAC,EAExC,CAAC,AAED,GAAa,MCqCC,MDrCV,GAAS,AAA8B,CAAnC,ACsCmD,GAA5C,MDtCF,OAAoB,GAAsB,CAAA,ACsCH,CDtCd,AAAiB,EAAC,EAAA,SAAA,AAAS,EAAC,GAChE,EADqE,CAAC,CCwC5D,EDvCJ,IAAI,EAAA,mBAAA,CAAoB,CAAE,OAAO,CAAE,CAAK,CAAE,CAAC,CAAA,AAEnD,CAFgD,GAE1C,CCsCG,CDtCU,EAAK,EAAD,GAAC,CAAA,EAAA,UAAgB,CAAC,CAAA,GACrC,CCsCC,CDtCW,CAAC,GACT,CAAA,EAAQ,CADF,CACQ,CAAG,EAAJ,GACf,GCsCK,ADtCI,CAAA,CADoB,CAAA,AACpB,EAAA,IAAA,AAAI,EAAC,KAAY,AAAM,CAAL,KAAW,CAAC,QAAQ,CAAC,EAAO,EAAE,CAAJ,AAAK,CAC5D,MAAM,GCsCO,CAAA,EAAA,sBDtCmB,CAAC,CAC/B,YAAY,CAAE,MAAM,CAAC,QAAQ,CAAC,EAAO,EAAE,CAAJ,AAAK,CACxC,UAAA,CAAA,EAAW,EAAA,IAAI,AAAJ,EAAK,IAEtB,CAFkC,AAEjC,AAED,CAJmC,GAI7B,EAAS,CAAK,CAAC,EAAT,AAAc,CAAA,AACtB,CADqB,GA2D/B,ACrByC,ADpCjC,CC6CS,CD9CD,EAAE,CAAC,IA0DV,AAAkB,CCkFH,EDhFtB,GACW,YAAT,GACA,SAAA,GACA,WAAA,GAAA,EACK,UAAU,CAAC,OAAO,CAAC,EAAA,EACnB,UAAU,CAAC,MAAM,CAAC,EACvB,EAAK,UAAU,CAAC,KCmFG,ADnFE,EAErB,MAAM,IAAI,EAAA,MAAyB,CAAI,CAAE,CAC7C,AAD8C,CAC7C,AAD0C,AAAG,CAnEpB,GAClB,CCsJgB,CDtJH,EAAQ,GAEzB,CAAC,AACH,CCgDqB,ADnDsC,AAG1D,CAH2D,AAG3D,ACsDG,CDzDwD,ACmDpB,ED7CpC,EAAM,QC2DQ,ID3DI,EAAI,EAAQ,CAAC,AACjC,GAAsB,AADQ,GC2DS,EACV,CAAC,CAAA,CD3DA,EAA1B,IC2DM,GD3DC,EAAqB,EC6DxB,IAAA,ID7DkC,EAAmB,KC6DtC,EAAE,CD7DsC,CAAM,CAAE,CAAC,CAAA,AACxE,EAAa,EC4DsC,AD5DhC,CC4DiC,WD5DrB,CAAE,EACnC,CAAC,AAGD,GAJyC,AAIrC,CAJsC,CAAA,cAIN,CAAhC,AAAiC,EACnC,GAAI,CAAK,CAAC,EAAY,CAAE,EAAa,CAAK,CAAC,CC8DhC,CAAA,AD9D4C,CAAE,CAApC,IAAe,EAA4B,CAAV,AAAW,AAC5D,CAD4D,KACtD,IAAI,EAAwB,KCkEd,QDlEgB,QAAa,GAE1D,CAAC,AAIK,SAAA,EAAkC,CAAA,OAAA,CAChC,CAGP,ECoEkD,ADnEjD,MAAO,CACmB,QAAQ,EAAhC,OAAO,GAAQ,GAAF,CAAM,EAAiB,CAAE,IAAI,CAAE,MAAM,CAAE,IAAI,CAAE,QAAQ,CAAE,CACpE,GCqEK,SAAA,MDrEsB,SAAS,CAAE,IAAI,CAAE,QAAQ,CAAE,CACtD,CAA4B,AAA5B,KCsEmC,KDtEnC,OAAQ,GAAM,CCsEA,EDtEA,MACe,GCsEK,ODtEhC,OAAO,GAAQ,CCsEG,EDtEL,ICsEmB,CDtEG,CAAC,CCsEG,ADtEC,CACxC,IAAI,CAAE,SAAS,CACf,IAAI,CAAA,WAEN,GAAQ,IC6EQ,eD7Ea,CAC3B,KAAA,oBACA,KAAM,SAAS,CAChB,CACD,GAAQ,IAAI,EAAI,CAAE,IAAI,CAAA,OAAU,KAAA,SAAe,CAAE,CAClD,CAAC,ACsFiD,MDtF3C,CAAC,OAAO,CAAyB,AAC3C,CAD2C,AAC1C,AAOK,SAAU,EAAgB,QAAE,CAAM,CAA+B,EACrE,OAAO,EAAW,iBAGd,YAAY,CAAE,EAAwB,QAAE,CAAM,CAAE,CAAC,EAEpD,CAFiD,AAEhD,AACJ,CADI,AACH,MAH0C,GChI3B,EAId,CAA2D,CD7BpB,CC+BvC,CFjCC,ECGI,AC8BC,ED5BN,MAHmD,ACgCjD,CDhCiD,CCgCxC,CAAA,CAAE,EAAL,OACN,CAAO,ED7BJ,WC8BH,CAAW,CACZ,CAAG,EJ9B2D,AI+BzD,CJ/B0D,CAAA,AI+B1D,CACJ,EDjCiC,CAAA,EC+BM,CAAA,OAEzB,EAAwB,GJ/Be,KI+Bb,CAAM,CAAE,CAAC,CACjD,GAAG,EAAW,KAAA,EAKhB,EAAkB,QAChB,EACA,OAAO,uBAEP,KAAK,GAGD,EAAe,CAAC,SAAS,CAAA,OAC/B,GACE,CFzBC,CAAC,AEyBI,CFzBJ,GEyBQ,CACR,EAAW,QACT,EACA,KAAK,CAAE,KAIO,AFlCyC,cEkC3B,GAA9B,CDlBA,ECmBF,EAAM,GDjBK,CCiBD,CACR,CAFW,CAEA,MACH,KDlBK,ECkBE,OACb,EACA,MAAO,KAA8C,GAIpD,CDvBe,CCuBf,SAAA,AAAS,EAAA,CAAA,EAAC,EAAA,MAAA,AAAM,EAAC,CDpBC,ECqB3B,CDpBC,ACoBA,AAIK,SAAU,EAAW,QAAD,AACxB,CAAM,GDhByB,ICiB/B,CAAK,CAIN,EACC,OAAO,EAAW,CAChB,KAAM,EACN,IADY,EDhBI,MCiBH,GDbG,kBCchB,EACD,CAAC,AACJ,CADI,AACH,AAOK,SAAU,EAAW,CDjBP,KCkBlB,CAAI,CADoB,YAExB,CAAW,OACX,CAAK,CAKN,EACC,IAAM,EAAU,AAclB,SAAS,EAAW,MAClB,CAAI,aACJ,CAAW,OACX,CAAK,CAKN,EACC,IAAM,EAA+B,CAAC,CAAE,IAAI,CAAE,SAAS,CAAE,CAAC,CACpD,AADoD,EACzB,CAsBnC,AAtBoC,ODtCR,CCsCgB,CAsBnC,AAAS,aAChB,CAAW,OACX,CAAK,CD/CwB,ACmD9B,EACC,IAAM,EAAA,CAAA,EAAA,EAAA,KAAA,AAAuB,EAAC,AAM1B,CDzDqB,QCyDX,AAAW,UAAD,GACxB,CAAW,OACX,CAAK,CAIN,EACC,IAAI,EAAS,EAAE,CAAA,AACT,CADI,CACW,AAevB,CD1EW,QC0EF,EACP,CACE,WAAW,CAAE,CAAY,OACzB,CAAK,CAIN,CDzE8D,AC0E/D,CD1EgE,CC0EzC,IAAI,GAAG,AAAE,EAEhC,CD3EC,GC2EK,EAAQ,EAAa,CAAhB,IAAqB,CAAC,IAAP,GAAc,CAAC,CAAA,AACnC,EAAc,GAAO,CAAC,CAAH,AAAI,CAAE,CAAA,AAC/B,EDxEI,ACuEa,CACb,EAAQ,GAAG,CAAC,CAAL,QAA4C,EAA5B,CAAC,CAAI,CAAK,CAAC,CDxED,CCwEa,CAAc,AAC9D,EADgE,CAAC,IAC1D,EAKT,IAAK,CALW,CAAA,EAKL,KAFX,EAAQ,EDrEA,CCqEG,CAAC,GAEQ,CAAK,CAAC,CDtED,CADR,ACuEqB,EACpC,EAAqB,CAAE,GDtEC,SCsEY,EAAM,IAAI,OAAE,CAAK,CAAE,CAAE,EAAJ,CAEvD,IAFkE,CAAC,CAAA,CAE5D,CACT,CAAC,CArC2C,aAAE,QAAa,CAAK,CAAE,CAAT,AAAU,CAAA,AAIjE,CAJ8D,GAIzD,IAAM,IAAI,CAHf,AD1Dc,EC0DD,CAGM,GD7DC,EC0DD,AAGM,CAAC,AAHN,CD3DD,EC6DN,CAAC,KAAgB,KAAK,CAAC,IAAI,CAAC,GAAc,CD7DgB,GC6DZ,EAAE,CAAC,CAAA,CAE5D,GAAU,CAAA,EAAJ,AAAO,EAAI,CAAA,CAAA,CAAI,CAAK,CAAC,EAAK,CAC7B,CAD4B,EACzB,CAAC,CAAC,MAAE,CAAI,CAAE,KAAM,CAAC,CAAE,EAAE,CAAG,CAAD,EAAI,CAAC,CAAA,CAAA,EAAI,EAAI,CAAE,CAAF,AAAG,CAC1C,IAAI,CAAC,CD5DK,EC4DF,CAAC,CAAA,CAAA,CAAG,CAAA,AAGjB,OAAO,CACT,CAAC,CAzB0C,EDvCP,WCuCS,QAAa,CAAK,CAAE,CAAT,AAAU,CAAC,CAAJ,AAAI,AACjE,MAAO,CAAA,EAAA,EAAA,SAAA,AAAS,EAAC,EACnB,CAAC,CA/B4C,WA8BX,CAAC,CAAA,AA9BY,QAAa,CAAK,CAAE,CAAC,CAAC,CAAA,AAEnE,EDxCuD,ECwClD,IAAM,KAAS,CAAK,CAAC,EAAY,CAAE,CACtC,GAAM,CAAC,EAAM,CADsB,CAChB,CDtCD,ACsCI,AAqF1B,EArFsB,OAqFb,EAAY,GD7EX,IC8ER,CAAK,CACL,GD/E2B,GC+EvB,MACJ,CAAI,OACJ,CAAK,CAMN,EACC,QAAoB,IAAhB,CAAK,CAAC,EDvFF,ACuFO,CAAc,AAC3B,EAD6B,CAAC,CDvFH,ECwFpB,CDvFD,ACwFJ,CAAE,IAAI,CAAE,SAAS,CAAE,CACnB,CAAA,ADvFI,EAAA,EAAA,SAAA,ACuFK,EAAC,EAAW,CAAE,GDvFK,CCuFD,CAAE,EAAO,CDvFF,MAAW,KCuFI,IAAI,IAAE,CAAK,CAAE,CAAC,CAAC,CAAJ,AAC7D,CAAA,AAGH,EDlFI,CCkFS,OAAO,GAAhB,EAAkB,CAAC,AACrB,CADM,GDlFqB,ACmFrB,EAAU,EAAM,GDlFP,ACkFM,AAAR,GAAe,CAAG,CAAC,CAAC,AAAE,CAAD,EAAI,CAAC,AAAE,CAAD,CAAG,CAE3C,AAF2C,KDhFtC,ECiFL,EAAQ,CAAA,EAAH,AAAG,CDlFF,CCkFO,EAAU,EAAM,GAAT,AAAQ,EAAM,CAAC,CAAC,CAAC,CAAA,CAAE,CAAA,ADjFlC,CCkFG,CAAE,IAAI,CAAE,SAAS,CAAE,IAAE,EAAA,SAAS,AAAT,EAAU,GAAO,AAChD,CADgD,AAC/C,AAED,CAH8C,CAAC,CAGlC,QAAQ,GAAjB,CDnFD,CCmFoB,EAAf,IAAsB,CAAC,CAAE,IAAI,CAAE,SAAS,CAAE,IAAE,EAAA,SAAA,AAAS,EAAA,CAAA,EAAC,EAAA,KAAA,AAAK,EAAC,IAAQ,CAAH,AAAG,AAE5E,CAF0E,CAAC,CAEvE,EAAK,EAAD,SAAY,CAAC,GAAG,CAAC,GAAK,EAAK,EAAD,IAAO,CAAG,CAAC,CAAE,CAC7C,AAD8C,IACxC,EDlFM,ACkFO,EAAK,EAAD,GAAM,CAAb,AAAc,CAAC,CAAE,EAAK,EAAD,SAAY,CAAC,GAAG,CAAC,CAAC,CAAA,AACjD,EAAkB,EAAgC,GAAD,AAAI,CAAC,AAAC,GAC3D,CAD+D,AAAI,ADlF/C,CCmFR,CADqD,KAE/D,EACA,CAFS,CACL,EACA,CAAE,QDlFQ,ACmFd,EADgB,AAEhB,MAAO,IAAI,EDlFE,KCqFV,CACL,CAAE,IAAI,CAAE,cACR,EAAA,SAAA,AAAS,EACP,CAAA,EAAA,EDnF4B,YAAA,OAAA,ECoF1B,EAAe,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,CAC9B,EAAe,GAAG,CAAC,CAAC,CAAC,CAAE,CAAC,CAAC,EAAE,CAAb,AAAgB,CAAC,AAAF,CAAG,CACjC,CACF,CACF,AACH,CADG,AACF,AAED,MAAO,CAAC,MAAE,CAAI,CAAE,CAAE,CAAJ,CAAU,AAC1B,CAD0B,AACzB,CArIyB,CAoID,MAnInB,EACA,KAAM,EAAM,IAAI,CAChB,KAAM,EAAM,CDtCD,GCsCK,CAChB,KAAK,CAAE,CAAI,CAAC,EAAA,IAAU,CAAC,CACxB,CAAC,CAAA,AACF,EAAa,IAAI,CAAC,GAClB,CADsB,CAAV,AAAW,AACvB,CADuB,CDtCN,ECuCC,CAAC,EACrB,CAAC,AAED,EAH0B,CAAC,CAAA,EAG3B,CAAA,EAAO,EAAA,mBAAmB,AAAnB,EAAoB,EAAc,EAC3C,CAAC,CAtC4B,MACzB,GAoCoD,CApChD,AAoCiD,CAAA,SAnCrD,QACA,EACD,CAAC,CACF,AADE,CADK,KAEP,CAAA,EAAO,EAAA,SAAA,AAAS,EAAC,EACnB,CAAC,EDzBe,wBE/FhB,IAAA,EAGO,CAHA,CAGsC,CAD3C,AAC2C,CAAA,QAG7C,EAGO,CAPO,AAIP,CAGyB,CAF9B,AAE8B,CAN/B,AAM+B,MANzB,EAeP,EAA+B,CAAxB,CAAwB,CATC,AASvB,AAAsB,CATC,AASsC,CAAA,IAXhD,GAErB,AAWD,EAA0B,CAAnB,CAA6C,CAA3C,AAA2C,AAF7B,CAThB,AAW6C,CAF3B,CAE2B,CAAA,IAFrB,CAEb,AAClB,EAA2B,AADP,CACb,CAA6C,CAAA,AAA3C,CAA2C,EAD1B,AAC0B,CAAA,KACpD,CADmB,CACiB,CADf,AACd,CAA6B,CAA3B,AAA2B,CAAkC,CAAA,EAD3C,KAiEpB,KAAK,KAhEgB,EAAE,GAgER,EAIpB,CAAyC,AApEP,CAqElC,CAAmD,EAEnD,GAAM,CAAE,OAAO,CAAE,CAPuB,CAOZ,EAAO,IAAD,AAAT,GAAiB,SAAE,CAAO,OAAE,CAAK,CAAE,CAAG,EAE/D,GAAI,CAAC,EACH,EAHuE,CAAA,GAGjE,AADK,IACD,EAAA,oBAAoB,CAAC,CAC7B,QAAQ,CAAE,oCAAoC,CAC/C,CAAC,CAAA,AACJ,IAAM,EAAO,CAAA,EAAG,EAAA,AAAH,YAAG,AAAY,EAAC,GAEvB,EAAW,CAAC,EAFmB,CAAC,AAEjB,CAFiB,CAExB,AAAS,AACrB,GAAK,CAAD,CAAY,QAAD,AAAS,EAAE,KAC1B,AAA4B,EADK,IACC,EAAE,CAAhC,EADsC,AAC3B,CAD2B,OAC5B,AAAS,CAAoB,EAAW,QAAD,AAAS,CAAA,AAC9D,CAAA,EAAO,EAAA,YAAA,AAAY,EAAC,EAAW,QAAD,AAAS,CAAC,CAAA,AAC1C,CAAC,CAAC,EAAE,AAEE,CAFF,CAEkB,CACpB,OAAO,CAAE,EADQ,AACG,QAAD,OAAgB,EAAI,EAAW,OAAO,CAAR,QACjD,OAAO,CACP,EACgB,CAAA,AAuBlB,EAxBO,KAGH,KAAiC,IAA1B,EAAc,KAAuB,EAAhB,GAC9B,CADsB,CACR,OAAO,CACnB,EAAO,CADI,GACL,CAAM,EAAE,EAAE,EACf,MAAA,CAAA,EAAM,EAAA,SAAA,AAAS,EAAC,EAAQ,EAAA,EAAF,QAAY,CAAE,YAAY,CAAC,CAAC,CAAA,EAAE,CAAC,CAAC,CAAA,IAExB,IAAxB,EAAc,KAAqB,AAAhB,EAAkB,CAAC,AAC/C,EAAc,CADQ,IACH,CAAG,KAAT,CAAS,CAAA,EAAM,EAAA,SAAA,AAAS,EACnC,EACA,EAAA,EADM,iBACa,CACnB,qBAAqB,CACtB,CAAC,CACA,OAAO,CAAE,EAAQ,KAAD,EAAQ,CACxB,QAAQ,CAAE,SAAS,CACpB,CAAC,CAAA,AAEA,CAAa,MAAM,CAAX,KACP,GAAU,KAAF,EAAS,EAAA,CAAA,EAAI,EAAA,cAAA,AAAc,EAAC,EAAS,MAAD,CAAQ,CAAE,EAAQ,KAAD,GAAQ,CAAC,CAAC,EAExE,EAAc,KAAK,GAAI,CAAC,CAAA,CAAX,AAGV,CACT,CAAC,WADqB,CAAA","ignoreList":[2,3,4,5,7,8,10,11,12,13,14,15,17,18,19,20,21,22,23,26,27,28,29,30,32,33,34,35,36,37]}