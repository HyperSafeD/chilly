{"version":3,"sources":["turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getBalance.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/multicall.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/createPendingTransactionFilter.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/abi/parseEventLogs.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getFilterChanges.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/abi/decodeEventLog.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/filters/createFilterRequestScope.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/uninstallFilter.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/watchPendingTransactions.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getLogs.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/errors/log.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getContractEvents.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/createContractEventFilter.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/watchContractEvent.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/abi/encodeEventTopics.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetBalanceParameters = {\n  /** The address of the account. */\n  address: Address\n} & (\n  | {\n      /** The balance of the account at a block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /** The balance of the account at a block tag. */\n      blockTag?: BlockTag | undefined\n    }\n)\n\nexport type GetBalanceReturnType = bigint\n\nexport type GetBalanceErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the balance of an address in wei.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBalance\n * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)\n *\n * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther).\n *\n * ```ts\n * const balance = await getBalance(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   blockTag: 'safe'\n * })\n * const balanceAsEther = formatEther(balance)\n * // \"6.942\"\n * ```\n *\n * @param client - Client to use\n * @param parameters - {@link GetBalanceParameters}\n * @returns The balance of the address in wei. {@link GetBalanceReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBalance } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const balance = await getBalance(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n * // 10000000000000000000000n (wei)\n */\nexport async function getBalance<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    blockNumber,\n    blockTag = client.experimental_blockTag ?? 'latest',\n  }: GetBalanceParameters,\n): Promise<GetBalanceReturnType> {\n  const blockNumberHex =\n    typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n\n  const balance = await client.request({\n    method: 'eth_getBalance',\n    params: [address, blockNumberHex || blockTag],\n  })\n  return BigInt(balance)\n}\n","import type { AbiStateMutability, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { multicall3Bytecode } from '../../constants/contracts.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ContractFunctionParameters } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  MulticallContracts,\n  MulticallResults,\n} from '../../types/multicall.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { CallParameters } from './call.js'\nimport { type ReadContractErrorType, readContract } from './readContract.js'\n\nexport type MulticallParameters<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  options extends {\n    optional?: boolean\n    properties?: Record<string, any>\n  } = {},\n> = Pick<\n  CallParameters,\n  | 'authorizationList'\n  | 'blockNumber'\n  | 'blockOverrides'\n  | 'blockTag'\n  | 'stateOverride'\n> & {\n  /** The account to use for the multicall. */\n  account?: Address | undefined\n  /** Whether to allow failures. */\n  allowFailure?: allowFailure | boolean | undefined\n  /** The size of each batch of calls. */\n  batchSize?: number | undefined\n  /** Enable deployless multicall. */\n  deployless?: boolean | undefined\n  /** The contracts to call. */\n  contracts: MulticallContracts<\n    Narrow<contracts>,\n    { mutability: AbiStateMutability } & options\n  >\n  /** The address of the multicall3 contract to use. */\n  multicallAddress?: Address | undefined\n}\n\nexport type MulticallReturnType<\n  contracts extends readonly unknown[] = readonly ContractFunctionParameters[],\n  allowFailure extends boolean = true,\n  options extends {\n    error?: Error\n  } = { error: Error },\n> = MulticallResults<\n  Narrow<contracts>,\n  allowFailure,\n  { mutability: AbiStateMutability } & options\n>\n\nexport type MulticallErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | GetContractErrorReturnType<\n      EncodeFunctionDataErrorType | DecodeFunctionResultErrorType\n    >\n  | ErrorType\n\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall<\n  const contracts extends readonly unknown[],\n  chain extends Chain | undefined,\n  allowFailure extends boolean = true,\n>(\n  client: Client<Transport, chain>,\n  parameters: MulticallParameters<contracts, allowFailure>,\n): Promise<MulticallReturnType<contracts, allowFailure>> {\n  const {\n    account,\n    authorizationList,\n    allowFailure = true,\n    blockNumber,\n    blockOverrides,\n    blockTag,\n    stateOverride,\n  } = parameters\n  const contracts = parameters.contracts as ContractFunctionParameters[]\n\n  const {\n    batchSize = parameters.batchSize ?? 1024,\n    deployless = parameters.deployless ?? false,\n  } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {}\n\n  const multicallAddress = (() => {\n    if (parameters.multicallAddress) return parameters.multicallAddress\n    if (deployless) return null\n    if (client.chain) {\n      return getChainContractAddress({\n        blockNumber,\n        chain: client.chain,\n        contract: 'multicall3',\n      })\n    }\n    throw new Error(\n      'client chain not configured. multicallAddress is required.',\n    )\n  })()\n\n  type Aggregate3Calls = {\n    allowFailure: boolean\n    callData: Hex\n    target: Address\n  }[]\n\n  const chunkedCalls: Aggregate3Calls[] = [[]]\n  let currentChunk = 0\n  let currentChunkSize = 0\n  for (let i = 0; i < contracts.length; i++) {\n    const { abi, address, args, functionName } = contracts[i]\n    try {\n      const callData = encodeFunctionData({ abi, args, functionName })\n\n      currentChunkSize += (callData.length - 2) / 2\n      // Check to see if we need to create a new chunk.\n      if (\n        // Check if batching is enabled.\n        batchSize > 0 &&\n        // Check if the current size of the batch exceeds the size limit.\n        currentChunkSize > batchSize &&\n        // Check if the current chunk is not already empty.\n        chunkedCalls[currentChunk].length > 0\n      ) {\n        currentChunk++\n        currentChunkSize = (callData.length - 2) / 2\n        chunkedCalls[currentChunk] = []\n      }\n\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData,\n          target: address,\n        },\n      ]\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n        sender: account,\n      })\n      if (!allowFailure) throw error\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData: '0x' as Hex,\n          target: address,\n        },\n      ]\n    }\n  }\n\n  const aggregate3Results = await Promise.allSettled(\n    chunkedCalls.map((calls) =>\n      getAction(\n        client,\n        readContract,\n        'readContract',\n      )({\n        ...(multicallAddress === null\n          ? { code: multicall3Bytecode }\n          : { address: multicallAddress }),\n        abi: multicall3Abi,\n        account,\n        args: [calls],\n        authorizationList,\n        blockNumber,\n        blockOverrides,\n        blockTag,\n        functionName: 'aggregate3',\n        stateOverride,\n      }),\n    ),\n  )\n\n  const results = []\n  for (let i = 0; i < aggregate3Results.length; i++) {\n    const result = aggregate3Results[i]\n\n    // If an error occurred in a `readContract` invocation (ie. network error),\n    // then append the failure reason to each contract result.\n    if (result.status === 'rejected') {\n      if (!allowFailure) throw result.reason\n      for (let j = 0; j < chunkedCalls[i].length; j++) {\n        results.push({\n          status: 'failure',\n          error: result.reason,\n          result: undefined,\n        })\n      }\n      continue\n    }\n\n    // If the `readContract` call was successful, then decode the results.\n    const aggregate3Result = result.value\n    for (let j = 0; j < aggregate3Result.length; j++) {\n      // Extract the response from `readContract`\n      const { returnData, success } = aggregate3Result[j]\n\n      // Extract the request call data from the original call.\n      const { callData } = chunkedCalls[i][j]\n\n      // Extract the contract config for this call from the `contracts` argument\n      // for decoding.\n      const { abi, address, functionName, args } = contracts[\n        results.length\n      ] as ContractFunctionParameters\n\n      try {\n        if (callData === '0x') throw new AbiDecodingZeroDataError()\n        if (!success) throw new RawContractError({ data: returnData })\n        const result = decodeFunctionResult({\n          abi,\n          args,\n          data: returnData,\n          functionName,\n        })\n        results.push(allowFailure ? { result, status: 'success' } : result)\n      } catch (err) {\n        const error = getContractError(err as BaseError, {\n          abi,\n          address,\n          args,\n          docsPath: '/docs/contract/multicall',\n          functionName,\n        })\n        if (!allowFailure) throw error\n        results.push({ error, result: undefined, status: 'failure' })\n      }\n    }\n  }\n\n  if (results.length !== contracts.length)\n    throw new BaseError('multicall results mismatch')\n  return results as MulticallReturnType<contracts, allowFailure>\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreatePendingTransactionFilterReturnType = Filter<'transaction'>\n\nexport type CreatePendingTransactionFilterErrorType =\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter\n * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)\n *\n * @param client - Client to use\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createPendingTransactionFilter(client)\n * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'transaction' }\n */\nexport async function createPendingTransactionFilter<\n  transport extends Transport,\n  chain extends Chain | undefined,\n>(\n  client: Client<transport, chain>,\n): Promise<CreatePendingTransactionFilterReturnType> {\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newPendingTransactionFilter',\n  })\n  const id = await client.request({\n    method: 'eth_newPendingTransactionFilter',\n  })\n  return { id, request: getRequest(id), type: 'transaction' }\n}\n","// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      try {\n        const abiItem = (abi as Abi).find(\n          (abiItem) =>\n            abiItem.type === 'event' &&\n            log.topics[0] === toEventSelector(abiItem),\n        ) as AbiEvent\n        if (!abiItem) return null\n\n        const event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict,\n        })\n\n        // Check that the decoded event name matches the provided event name.\n        if (eventName && !eventName.includes(event.eventName)) return null\n\n        // Check that the decoded event args match the provided args.\n        if (\n          !includesArgs({\n            args: event.args,\n            inputs: abiItem.inputs,\n            matchArgs: args,\n          })\n        )\n          return null\n\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (value === null || value === undefined) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n","import type { Abi, AbiEvent, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcLog } from '../../index.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter, FilterType } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { DecodeEventLogErrorType } from '../../utils/abi/decodeEventLog.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type FormatLogErrorType,\n  formatLog,\n} from '../../utils/formatters/log.js'\n\nexport type GetFilterChangesParameters<\n  filterType extends FilterType = FilterType,\n  abi extends Abi | readonly unknown[] | undefined = undefined,\n  eventName extends string | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  filter: Filter<filterType, abi, eventName, any, strict, fromBlock, toBlock>\n}\n\nexport type GetFilterChangesReturnType<\n  filterType extends FilterType = FilterType,\n  abi extends Abi | readonly unknown[] | undefined = undefined,\n  eventName extends string | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _AbiEvent extends AbiEvent | undefined = abi extends Abi\n    ? eventName extends string\n      ? ExtractAbiEvent<abi, eventName>\n      : undefined\n    : undefined,\n  _Pending extends boolean =\n    | (fromBlock extends 'pending' ? true : false)\n    | (toBlock extends 'pending' ? true : false),\n> = filterType extends 'event'\n  ? Log<bigint, number, _Pending, _AbiEvent, strict, abi, eventName>[]\n  : Hash[]\n\nexport type GetFilterChangesErrorType =\n  | RequestErrorType\n  | DecodeEventLogErrorType\n  | FormatLogErrorType\n  | ErrorType\n\n/**\n * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterChanges\n * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)\n *\n * A Filter can be created from the following actions:\n *\n * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)\n * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter)\n * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)\n * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)\n *\n * Depending on the type of filter, the return value will be different:\n *\n * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.\n * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.\n * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterChangesParameters}\n * @returns Logs or hashes. {@link GetFilterChangesReturnType}\n *\n * @example\n * // Blocks\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createBlockFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createBlockFilter(client)\n * const hashes = await getFilterChanges(client, { filter })\n *\n * @example\n * // Contract Events\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createContractEventFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createContractEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n *   eventName: 'Transfer',\n * })\n * const logs = await getFilterChanges(client, { filter })\n *\n * @example\n * // Raw Events\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterChanges(client, { filter })\n *\n * @example\n * // Transactions\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createPendingTransactionFilter(client)\n * const hashes = await getFilterChanges(client, { filter })\n */\nexport async function getFilterChanges<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  filterType extends FilterType,\n  const abi extends Abi | readonly unknown[] | undefined,\n  eventName extends string | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  _client: Client<transport, chain>,\n  {\n    filter,\n  }: GetFilterChangesParameters<\n    filterType,\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >,\n): Promise<\n  GetFilterChangesReturnType<\n    filterType,\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >\n> {\n  const strict = 'strict' in filter && filter.strict\n\n  const logs = await filter.request({\n    method: 'eth_getFilterChanges',\n    params: [filter.id],\n  })\n\n  if (typeof logs[0] === 'string')\n    return logs as GetFilterChangesReturnType<\n      filterType,\n      abi,\n      eventName,\n      strict,\n      fromBlock,\n      toBlock\n    >\n\n  const formattedLogs = logs.map((log) => formatLog(log as RpcLog))\n  if (!('abi' in filter) || !filter.abi)\n    return formattedLogs as GetFilterChangesReturnType<\n      filterType,\n      abi,\n      eventName,\n      strict,\n      fromBlock,\n      toBlock\n    >\n  return parseEventLogs({\n    abi: filter.abi,\n    logs: formattedLogs,\n    strict,\n  }) as unknown as GetFilterChangesReturnType<\n    filterType,\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n","import type { Abi, AbiParameter } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  Prettify,\n  UnionEvaluate,\n} from '../../types/utils.js'\nimport { size } from '../data/size.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n> = {\n  abi: abi\n  data?: data | undefined\n  eventName?: eventName | ContractEventName<abi> | undefined\n  strict?: strict | boolean | undefined\n  topics: [signature: Hex, ...args: topics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n  ///\n  allEventNames extends\n    ContractEventName<abi> = eventName extends ContractEventName<abi>\n    ? eventName\n    : ContractEventName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? {\n      [name in allEventNames]: Prettify<\n        {\n          eventName: name\n        } & UnionEvaluate<\n          ContractEventArgsFromTopics<abi, name, strict> extends infer allArgs\n            ? topics extends readonly []\n              ? data extends undefined\n                ? { args?: undefined }\n                : { args?: allArgs | undefined }\n              : { args: allArgs }\n            : never\n        >\n      >\n    }[allEventNames]\n  : {\n      eventName: eventName\n      args: readonly unknown[] | undefined\n    }\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n>(\n  parameters: DecodeEventLogParameters<abi, eventName, topics, data, strict>,\n): DecodeEventLogReturnType<abi, eventName, topics, data, strict> {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics,\n  } = parameters as DecodeEventLogParameters\n\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({ docsPath })\n\n  const abiItem = abi.find(\n    (x) =>\n      x.type === 'event' &&\n      signature === toEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, { docsPath })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  const args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs\n    .map((x, i) => [x, i] as const)\n    .filter(([x]) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const [param, argIndex] = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      })\n    args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({\n      param,\n      value: topic,\n    })\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed)\n            for (let i = 0; i < inputs.length; i++)\n              args[i] = args[i] ?? decodedData.shift()\n          else\n            for (let i = 0; i < nonIndexedInputs.length; i++)\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n        }\n      } catch (err) {\n        if (strict) {\n          if (\n            err instanceof AbiDecodingDataSizeTooSmallError ||\n            err instanceof PositionOutOfBoundsError\n          )\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: data,\n              params: nonIndexedInputs,\n              size: size(data),\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<abi, eventName, topics, data, strict>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { OnResponseFn } from '../../clients/transports/fallback.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { EIP1193RequestFn, PublicRpcSchema } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Filter } from '../../types/utils.js'\n\ntype CreateFilterRequestScopeParameters = {\n  method:\n    | 'eth_newFilter'\n    | 'eth_newPendingTransactionFilter'\n    | 'eth_newBlockFilter'\n}\n\ntype FilterRpcSchema = Filter<\n  PublicRpcSchema,\n  { Method: 'eth_getFilterLogs' | 'eth_getFilterChanges' }\n>\n\ntype CreateFilterRequestScopeReturnType = (\n  id: Hex,\n) => EIP1193RequestFn<FilterRpcSchema>\n\n/**\n * Scopes `request` to the filter ID. If the client is a fallback, it will\n * listen for responses and scope the child transport `request` function\n * to the successful filter ID.\n */\nexport function createFilterRequestScope<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { method }: CreateFilterRequestScopeParameters,\n): CreateFilterRequestScopeReturnType {\n  const requestMap: Record<Hex, EIP1193RequestFn> = {}\n\n  if (client.transport.type === 'fallback')\n    client.transport.onResponse?.(\n      ({\n        method: method_,\n        response: id,\n        status,\n        transport,\n      }: Parameters<OnResponseFn>[0]) => {\n        if (status === 'success' && method === method_)\n          requestMap[id as Hex] = transport.request\n      },\n    )\n\n  return ((id) =>\n    requestMap[id] || client.request) as CreateFilterRequestScopeReturnType\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type UninstallFilterParameters = {\n  filter: Filter<any>\n}\nexport type UninstallFilterReturnType = boolean\n\nexport type UninstallFilterErrorType = RequestErrorType | ErrorType\n\n/**\n * Destroys a [`Filter`](https://viem.sh/docs/glossary/types#filter).\n *\n * - Docs: https://viem.sh/docs/actions/public/uninstallFilter\n * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)\n *\n * Destroys a Filter that was created from one of the following Actions:\n * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)\n * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)\n * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)\n *\n * @param client - Client to use\n * @param parameters - {@link UninstallFilterParameters}\n * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'\n *\n * const filter = await createPendingTransactionFilter(client)\n * const uninstalled = await uninstallFilter(client, { filter })\n * // true\n */\nexport async function uninstallFilter<\n  transport extends Transport,\n  chain extends Chain | undefined,\n>(\n  _client: Client<transport, chain>,\n  { filter }: UninstallFilterParameters,\n): Promise<UninstallFilterReturnType> {\n  return filter.request({\n    method: 'eth_uninstallFilter',\n    params: [filter.id],\n  })\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { GetPollOptions } from '../../types/transport.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\n\nimport { createPendingTransactionFilter } from './createPendingTransactionFilter.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type OnTransactionsParameter = Hash[]\nexport type OnTransactionsFn = (transactions: OnTransactionsParameter) => void\n\nexport type WatchPendingTransactionsParameters<\n  transport extends Transport = Transport,\n> = {\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n  /** The callback to call when new transactions are received. */\n  onTransactions: OnTransactionsFn\n} & GetPollOptions<transport>\n\nexport type WatchPendingTransactionsReturnType = () => void\n\nexport type WatchPendingTransactionsErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns pending transaction hashes.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions\n * - JSON-RPC Methods:\n *   - When `poll: true`\n *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.\n *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newPendingTransactions\"` event.\n *\n * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions#ontransactions).\n *\n * @param client - Client to use\n * @param parameters - {@link WatchPendingTransactionsParameters}\n * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchPendingTransactions } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = await watchPendingTransactions(client, {\n *   onTransactions: (hashes) => console.log(hashes),\n * })\n */\nexport function watchPendingTransactions<\n  transport extends Transport,\n  chain extends Chain | undefined,\n>(\n  client: Client<transport, chain>,\n  {\n    batch = true,\n    onError,\n    onTransactions,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchPendingTransactionsParameters<transport>,\n) {\n  const enablePolling =\n    typeof poll_ !== 'undefined'\n      ? poll_\n      : client.transport.type !== 'webSocket' && client.transport.type !== 'ipc'\n\n  const pollPendingTransactions = () => {\n    const observerId = stringify([\n      'watchPendingTransactions',\n      client.uid,\n      batch,\n      pollingInterval,\n    ])\n    return observe(observerId, { onTransactions, onError }, (emit) => {\n      let filter: Filter<'transaction'>\n\n      const unwatch = poll(\n        async () => {\n          try {\n            if (!filter) {\n              try {\n                filter = await getAction(\n                  client,\n                  createPendingTransactionFilter,\n                  'createPendingTransactionFilter',\n                )({})\n                return\n              } catch (err) {\n                unwatch()\n                throw err\n              }\n            }\n\n            const hashes = await getAction(\n              client,\n              getFilterChanges,\n              'getFilterChanges',\n            )({ filter })\n            if (hashes.length === 0) return\n            if (batch) emit.onTransactions(hashes)\n            else for (const hash of hashes) emit.onTransactions([hash])\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribePendingTransactions = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['newPendingTransactions'],\n          onData(data: any) {\n            if (!active) return\n            const transaction = data.result\n            onTransactions([transaction])\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return () => unsubscribe()\n  }\n\n  return enablePolling\n    ? pollPendingTransactions()\n    : subscribePendingTransactions()\n}\n","import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash, LogTopic } from '../../types/misc.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport type { DecodeEventLogErrorType } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormatLogErrorType,\n  formatLog,\n} from '../../utils/formatters/log.js'\n\nexport type GetLogsParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = {\n  /** Address or list of addresses from which logs originated */\n  address?: Address | Address[] | undefined\n} & (\n  | {\n      event: abiEvent\n      events?: undefined\n      args?: MaybeExtractEventArgsFromAbi<abiEvents, _eventName> | undefined\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: strict | undefined\n    }\n  | {\n      event?: undefined\n      events: abiEvents\n      args?: undefined\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: strict | undefined\n    }\n  | {\n      event?: undefined\n      events?: undefined\n      args?: undefined\n      strict?: undefined\n    }\n) &\n  (\n    | {\n        /** Block number or tag after which to include logs */\n        fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n        /** Block number or tag before which to include logs */\n        toBlock?: toBlock | BlockNumber | BlockTag | undefined\n        blockHash?: undefined\n      }\n    | {\n        fromBlock?: undefined\n        toBlock?: undefined\n        /** Hash of block to include logs from */\n        blockHash?: Hash | undefined\n      }\n  )\n\nexport type GetLogsReturnType<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _pending extends boolean =\n    | (fromBlock extends 'pending' ? true : false)\n    | (toBlock extends 'pending' ? true : false),\n> = Log<bigint, number, _pending, abiEvent, strict, abiEvents, _eventName>[]\n\nexport type GetLogsErrorType =\n  | DecodeEventLogErrorType\n  | EncodeEventTopicsErrorType\n  | FormatLogErrorType\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    blockHash,\n    fromBlock,\n    toBlock,\n    event,\n    events: events_,\n    args,\n    strict: strict_,\n  }: GetLogsParameters<abiEvent, abiEvents, strict, fromBlock, toBlock> = {},\n): Promise<GetLogsReturnType<abiEvent, abiEvents, strict, fromBlock, toBlock>> {\n  const strict = strict_ ?? false\n  const events = events_ ?? (event ? [event] : undefined)\n\n  let topics: LogTopic[] = []\n  if (events) {\n    const encoded = (events as AbiEvent[]).flatMap((event) =>\n      encodeEventTopics({\n        abi: [event],\n        eventName: (event as AbiEvent).name,\n        args: events_ ? undefined : args,\n      } as EncodeEventTopicsParameters),\n    )\n    // TODO: Clean up type casting\n    topics = [encoded as LogTopic]\n    if (event) topics = topics[0] as LogTopic[]\n  }\n\n  let logs: RpcLog[]\n  if (blockHash) {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{ address, topics, blockHash }],\n    })\n  } else {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [\n        {\n          address,\n          topics,\n          fromBlock:\n            typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n          toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        },\n      ],\n    })\n  }\n\n  const formattedLogs = logs.map((log) => formatLog(log))\n  if (!events)\n    return formattedLogs as GetLogsReturnType<\n      abiEvent,\n      abiEvents,\n      strict,\n      fromBlock,\n      toBlock\n    >\n  return parseEventLogs({\n    abi: events,\n    args: args as any,\n    logs: formattedLogs,\n    strict,\n  }) as unknown as GetLogsReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n","import { BaseError } from './base.js'\n\nexport type FilterTypeNotSupportedErrorType = FilterTypeNotSupportedError & {\n  name: 'FilterTypeNotSupportedError'\n}\nexport class FilterTypeNotSupportedError extends BaseError {\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`, {\n      name: 'FilterTypeNotSupportedError',\n    })\n  }\n}\n","import type { Abi, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n} from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash } from '../../types/misc.js'\nimport {\n  type GetAbiItemErrorType,\n  type GetAbiItemParameters,\n  getAbiItem,\n} from '../../utils/abi/getAbiItem.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type GetLogsErrorType,\n  type GetLogsParameters,\n  getLogs,\n} from './getLogs.js'\n\nexport type GetContractEventsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined =\n    | ContractEventName<abi>\n    | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[] | undefined\n  /** Contract ABI. */\n  abi: abi\n  args?:\n    | ContractEventArgs<\n        abi,\n        eventName extends ContractEventName<abi>\n          ? eventName\n          : ContractEventName<abi>\n      >\n    | undefined\n  /** Contract event. */\n  eventName?: eventName | ContractEventName<abi> | undefined\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n   * @default false\n   */\n  strict?: strict | boolean | undefined\n} & (\n  | {\n      /** Block number or tag after which to include logs */\n      fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n      /** Block number or tag before which to include logs */\n      toBlock?: toBlock | BlockNumber | BlockTag | undefined\n      blockHash?: undefined\n    }\n  | {\n      fromBlock?: undefined\n      toBlock?: undefined\n      /** Hash of block to include logs from */\n      blockHash?: Hash | undefined\n    }\n)\n\nexport type GetContractEventsReturnType<\n  abi extends Abi | readonly unknown[] = readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined =\n    | ContractEventName<abi>\n    | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  ///\n  isPending extends boolean =\n    | (fromBlock extends 'pending' ? true : false)\n    | (toBlock extends 'pending' ? true : false),\n> = Log<bigint, number, isPending, undefined, strict, abi, eventName>[]\n\nexport type GetContractEventsErrorType =\n  | GetAbiItemErrorType\n  | GetLogsErrorType\n  | ErrorType\n\n/**\n * Returns a list of event logs emitted by a contract.\n *\n * - Docs: https://viem.sh/docs/contract/getContractEvents#getcontractevents\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetContractEventsParameters}\n * @returns A list of event logs. {@link GetContractEventsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getContractEvents } from 'viem/public'\n * import { wagmiAbi } from './abi'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getContractEvents(client, {\n *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *  abi: wagmiAbi,\n *  eventName: 'Transfer'\n * })\n */\nexport async function getContractEvents<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: GetContractEventsParameters<\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >,\n): Promise<\n  GetContractEventsReturnType<abi, eventName, strict, fromBlock, toBlock>\n> {\n  const {\n    abi,\n    address,\n    args,\n    blockHash,\n    eventName,\n    fromBlock,\n    toBlock,\n    strict,\n  } = parameters\n  const event = eventName\n    ? getAbiItem({ abi, name: eventName } as GetAbiItemParameters)\n    : undefined\n  const events = !event\n    ? (abi as Abi).filter((x) => x.type === 'event')\n    : undefined\n  return getAction(\n    client,\n    getLogs,\n    'getLogs',\n  )({\n    address,\n    args,\n    blockHash,\n    event,\n    events,\n    fromBlock,\n    toBlock,\n    strict,\n  } as {} as GetLogsParameters) as unknown as GetContractEventsReturnType<\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n","import type { Abi, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateContractEventFilterParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  args extends\n    | MaybeExtractEventArgsFromAbi<abi, eventName>\n    | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  address?: Address | Address[] | undefined\n  abi: abi\n  eventName?: eventName | ContractEventName<abi> | undefined\n  fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments in the event ABI item.\n   * @default false\n   */\n  strict?: strict | boolean | undefined\n  toBlock?: toBlock | BlockNumber | BlockTag | undefined\n} & (undefined extends eventName\n  ? {\n      args?: undefined\n    }\n  : MaybeExtractEventArgsFromAbi<abi, eventName> extends infer eventFilterArgs\n    ? {\n        args?:\n          | eventFilterArgs\n          | (args extends eventFilterArgs ? args : never)\n          | undefined\n      }\n    : {\n        args?: undefined\n      })\n\nexport type CreateContractEventFilterReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  args extends\n    | MaybeExtractEventArgsFromAbi<abi, eventName>\n    | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = Filter<'event', abi, eventName, args, strict, fromBlock, toBlock>\n\nexport type CreateContractEventFilterErrorType =\n  | EncodeEventTopicsErrorType\n  | RequestErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).\n *\n * - Docs: https://viem.sh/docs/contract/createContractEventFilter\n *\n * @param client - Client to use\n * @param parameters - {@link CreateContractEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateContractEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createContractEventFilter } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createContractEventFilter(client, {\n *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n * })\n */\nexport async function createContractEventFilter<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined,\n  args extends MaybeExtractEventArgsFromAbi<abi, eventName> | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: CreateContractEventFilterParameters<\n    abi,\n    eventName,\n    args,\n    strict,\n    fromBlock,\n    toBlock\n  >,\n): Promise<\n  CreateContractEventFilterReturnType<\n    abi,\n    eventName,\n    args,\n    strict,\n    fromBlock,\n    toBlock\n  >\n> {\n  const { address, abi, args, eventName, fromBlock, strict, toBlock } =\n    parameters as CreateContractEventFilterParameters\n\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newFilter',\n  })\n\n  const topics = eventName\n    ? encodeEventTopics({\n        abi,\n        args,\n        eventName,\n      } as unknown as EncodeEventTopicsParameters)\n    : undefined\n  const id: Hex = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        topics,\n      },\n    ],\n  })\n\n  return {\n    abi,\n    args,\n    eventName,\n    id,\n    request: getRequest(id),\n    strict: Boolean(strict),\n    type: 'event',\n  } as unknown as CreateContractEventFilterReturnType<\n    abi,\n    eventName,\n    args,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n","import type { Abi, Address, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport { InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { LogTopic } from '../../types/misc.js'\nimport type { GetPollOptions } from '../../types/transport.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\nimport { createContractEventFilter } from './createContractEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport {\n  type GetContractEventsParameters,\n  getContractEvents,\n} from './getContractEvents.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type WatchContractEventOnLogsParameter<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n> = abi extends Abi\n  ? Abi extends abi\n    ? Log[]\n    : Log<bigint, number, false, ExtractAbiEvent<abi, eventName>, strict>[]\n  : Log[]\n\nexport type WatchContractEventOnLogsFn<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n> = (logs: WatchContractEventOnLogsParameter<abi, eventName, strict>) => void\n\nexport type WatchContractEventParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[] | undefined\n  /** Contract ABI. */\n  abi: abi\n  args?:\n    | ContractEventArgs<\n        abi,\n        eventName extends ContractEventName<abi>\n          ? eventName\n          : ContractEventName<abi>\n      >\n    | undefined\n  /** Contract event. */\n  eventName?: eventName | ContractEventName<abi> | undefined\n  /** Block to start listening from. */\n  fromBlock?: BlockNumber<bigint> | undefined\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchContractEventOnLogsFn<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    strict\n  >\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n   * @default false\n   */\n  strict?: strict | boolean | undefined\n} & GetPollOptions<transport>\n\nexport type WatchContractEventReturnType = () => void\n\nexport type WatchContractEventErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n>(\n  client: Client<transport, chain>,\n  parameters: WatchContractEventParameters<abi, eventName, strict, transport>,\n): WatchContractEventReturnType {\n  const {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    fromBlock,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  } = parameters\n\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (typeof fromBlock === 'bigint') return true\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n\n  const pollContractEvent = () => {\n    const strict = strict_ ?? false\n    const observerId = stringify([\n      'watchContractEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      eventName,\n      pollingInterval,\n      strict,\n      fromBlock,\n    ])\n\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      let previousBlockNumber: bigint\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n\n      let filter: Filter<'event', abi, eventName> | undefined\n      let initialized = false\n\n      const unwatch = poll(\n        async () => {\n          if (!initialized) {\n            try {\n              filter = (await getAction(\n                client,\n                createContractEventFilter,\n                'createContractEventFilter',\n              )({\n                abi,\n                address,\n                args: args as any,\n                eventName: eventName as any,\n                strict: strict as any,\n                fromBlock,\n              })) as Filter<'event', abi, eventName>\n            } catch {}\n            initialized = true\n            return\n          }\n\n          try {\n            let logs: Log[]\n            if (filter) {\n              logs = await getAction(\n                client,\n                getFilterChanges,\n                'getFilterChanges',\n              )({ filter })\n            } else {\n              // If the filter doesn't exist, we will fall back to use `getLogs`.\n              // The fall back exists because some RPC Providers do not support filters.\n\n              // Fetch the block number to use for `getLogs`.\n              const blockNumber = await getAction(\n                client,\n                getBlockNumber,\n                'getBlockNumber',\n              )({})\n\n              // If the block number has changed, we will need to fetch the logs.\n              // If the block number doesn't exist, we are yet to reach the first poll interval,\n              // so do not emit any logs.\n              if (previousBlockNumber && previousBlockNumber < blockNumber) {\n                logs = await getAction(\n                  client,\n                  getContractEvents,\n                  'getContractEvents',\n                )({\n                  abi,\n                  address,\n                  args,\n                  eventName,\n                  fromBlock: previousBlockNumber + 1n,\n                  toBlock: blockNumber,\n                  strict,\n                } as {} as GetContractEventsParameters)\n              } else {\n                logs = []\n              }\n              previousBlockNumber = blockNumber\n            }\n\n            if (logs.length === 0) return\n            if (batch) emit.onLogs(logs as any)\n            else for (const log of logs) emit.onLogs([log] as any)\n          } catch (err) {\n            // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n            // Reinitialize the filter when this occurs\n            if (filter && err instanceof InvalidInputRpcError)\n              initialized = false\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribeContractEvent = () => {\n    const strict = strict_ ?? false\n    const observerId = stringify([\n      'watchContractEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      eventName,\n      pollingInterval,\n      strict,\n    ])\n\n    let active = true\n    let unsubscribe = () => (active = false)\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      ;(async () => {\n        try {\n          const transport = (() => {\n            if (client.transport.type === 'fallback') {\n              const transport = client.transport.transports.find(\n                (transport: ReturnType<Transport>) =>\n                  transport.config.type === 'webSocket' ||\n                  transport.config.type === 'ipc',\n              )\n              if (!transport) return client.transport\n              return transport.value\n            }\n            return client.transport\n          })()\n\n          const topics: LogTopic[] = eventName\n            ? encodeEventTopics({\n                abi: abi,\n                eventName: eventName,\n                args,\n              } as EncodeEventTopicsParameters)\n            : []\n\n          const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n            params: ['logs', { address, topics }],\n            onData(data: any) {\n              if (!active) return\n              const log = data.result\n              try {\n                const { eventName, args } = decodeEventLog({\n                  abi: abi,\n                  data: log.data,\n                  topics: log.topics as any,\n                  strict: strict_,\n                })\n                const formatted = formatLog(log, {\n                  args,\n                  eventName: eventName as string,\n                })\n                emit.onLogs([formatted] as any)\n              } catch (err) {\n                let eventName: string | undefined\n                let isUnnamed: boolean | undefined\n                if (\n                  err instanceof DecodeLogDataMismatch ||\n                  err instanceof DecodeLogTopicsMismatch\n                ) {\n                  // If strict mode is on, and log data/topics do not match event definition, skip.\n                  if (strict_) return\n                  eventName = err.abiItem.name\n                  isUnnamed = err.abiItem.inputs?.some(\n                    (x) => !('name' in x && x.name),\n                  )\n                }\n\n                // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n                const formatted = formatLog(log, {\n                  args: isUnnamed ? [] : {},\n                  eventName,\n                })\n                emit.onLogs([formatted] as any)\n              }\n            },\n            onError(error: Error) {\n              emit.onError?.(error)\n            },\n          })\n          unsubscribe = unsubscribe_\n          if (!active) unsubscribe()\n        } catch (err) {\n          onError?.(err as Error)\n        }\n      })()\n      return () => unsubscribe()\n    })\n  }\n\n  return enablePolling ? pollContractEvent() : subscribeContractEvent()\n}\n","import type {\n  Abi,\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  ExtractAbiEvents,\n} from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n} from '../../errors/abi.js'\nimport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from '../../errors/log.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeEventTopics'\n\nexport type EncodeEventTopicsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  ///\n  hasEvents = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiEvents<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>\n  >,\n  allErrorNames = ContractEventName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { eventName?: eventName | allErrorNames | undefined }\n      : { eventName: eventName | allErrorNames }\n    : { eventName?: eventName | allErrorNames | undefined }\n> &\n  (hasEvents extends true ? unknown : never)\n\nexport type EncodeEventTopicsReturnType = [Hex, ...(Hex | Hex[] | null)[]]\n\nexport type EncodeEventTopicsErrorType =\n  | AbiEventNotFoundErrorType\n  | EncodeArgErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nexport function encodeEventTopics<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n>(\n  parameters: EncodeEventTopicsParameters<abi, eventName>,\n): EncodeEventTopicsReturnType {\n  const { abi, eventName, args } = parameters as EncodeEventTopicsParameters\n\n  let abiItem = abi[0]\n  if (eventName) {\n    const item = getAbiItem({ abi, name: eventName })\n    if (!item) throw new AbiEventNotFoundError(eventName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toEventSelector(definition as EventDefinition)\n\n  let topics: (Hex | Hex[] | null)[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? (indexedInputs?.map((x: any) => (args as any)[x.name]) ?? [])\n        : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) => {\n          if (Array.isArray(args_[i]))\n            return args_[i].map((_: any, j: number) =>\n              encodeArg({ param, value: args_[i][j] }),\n            )\n          return typeof args_[i] !== 'undefined' && args_[i] !== null\n            ? encodeArg({ param, value: args_[i] })\n            : null\n        }) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nexport type EncodeArgErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | EncodeAbiParametersErrorType\n  | FilterTypeNotSupportedErrorType\n  | ErrorType\n\nfunction encodeArg({\n  param,\n  value,\n}: {\n  param: AbiParameter\n  value: AbiParameterToPrimitiveType<AbiParameter>\n}) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,3,4,5,6,7,9,10,11,12,13,14]}