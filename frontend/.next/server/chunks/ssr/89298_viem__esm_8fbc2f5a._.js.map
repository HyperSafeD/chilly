{"version":3,"sources":["turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/createBlockFilter.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/ens/encodeLabelhash.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/ens/namehash.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/errors/ens.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/ens/errors.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/ens/avatar/utils.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/ens/avatar/parseAvatarRecord.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/createAccessList.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/ens/encodedLabelToLabelhash.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/ens/labelhash.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/ens/packetToBytes.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/ens/getEnsText.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/ens/getEnsAvatar.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/createEventFilter.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/ens/getEnsAddress.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/ens/getEnsResolver.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/ens/getEnsName.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/estimateContractGas.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/formatters/feeHistory.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getTransactionConfirmations.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/ox/core/AbiConstructor.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getFeeHistory.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getBlockTransactionCount.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/formatters/proof.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getProof.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getStorageAt.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getFilterLogs.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/simulateBlocks.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/simulateCalls.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/getBlobBaseFee.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/simulateContract.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/clients/createPublicClient.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/verifyTypedData.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/watchBlocks.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/watchEvent.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/siwe/validateSiweMessage.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/siwe/verifySiweMessage.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/public/verifyMessage.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/actions/wallet/sendRawTransactionSync.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/clients/decorators/public.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/siwe/parseSiweMessage.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/signature/parseSignature.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/nonceManager.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/constants/bytes.ts","turbopack:///[project]/Desktop/walletconnect/chilly/node_modules/viem/utils/signature/serializeErc6492Signature.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateBlockFilterReturnType = Filter<'block'>\n\nexport type CreateBlockFilterErrorType = RequestErrorType | ErrorType\n\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createBlockFilter\n * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)\n *\n * @param client - Client to use\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createBlockFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createBlockFilter(client)\n * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'block' }\n */\nexport async function createBlockFilter<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n): Promise<CreateBlockFilterReturnType> {\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newBlockFilter',\n  })\n  const id = await client.request({\n    method: 'eth_newBlockFilter',\n  })\n  return { id, request: getRequest(id), type: 'block' }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type EncodeLabelhashErrorType = ErrorType\n\nexport function encodeLabelhash(hash: Hex): `[${string}]` {\n  return `[${hash.slice(2)}]`\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n  type ToBytesErrorType,\n  toBytes,\n} from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type EncodedLabelToLabelhashErrorType,\n  encodedLabelToLabelhash,\n} from './encodedLabelToLabelhash.js'\n\nexport type NamehashErrorType =\n  | BytesToHexErrorType\n  | EncodedLabelToLabelhashErrorType\n  | ToBytesErrorType\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ConcatErrorType\n  | ErrorType\n\n/**\n * @description Hashes ENS name\n *\n * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @example\n * namehash('wevm.eth')\n * '0x08c85f2f4059e930c45a6aeff9dcd3bd95dc3c5c1cddef6a0626b31152248560'\n *\n * @link https://eips.ethereum.org/EIPS/eip-137\n */\nexport function namehash(name: string) {\n  let result = new Uint8Array(32).fill(0) as ByteArray\n  if (!name) return bytesToHex(result)\n\n  const labels = name.split('.')\n  // Iterate in reverse order building up hash\n  for (let i = labels.length - 1; i >= 0; i -= 1) {\n    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i])\n    const hashed = hashFromEncodedLabel\n      ? toBytes(hashFromEncodedLabel)\n      : keccak256(stringToBytes(labels[i]), 'bytes')\n    result = keccak256(concat([result, hashed]), 'bytes')\n  }\n\n  return bytesToHex(result)\n}\n","import { BaseError } from './base.js'\n\nexport type EnsAvatarInvalidMetadataErrorType =\n  EnsAvatarInvalidMetadataError & {\n    name: 'EnsAvatarInvalidMetadataError'\n  }\nexport class EnsAvatarInvalidMetadataError extends BaseError {\n  constructor({ data }: { data: any }) {\n    super(\n      'Unable to extract image from metadata. The metadata may be malformed or invalid.',\n      {\n        metaMessages: [\n          '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',\n          '',\n          `Provided data: ${JSON.stringify(data)}`,\n        ],\n        name: 'EnsAvatarInvalidMetadataError',\n      },\n    )\n  }\n}\n\nexport type EnsAvatarInvalidNftUriErrorType = EnsAvatarInvalidNftUriError & {\n  name: 'EnsAvatarInvalidNftUriError'\n}\nexport class EnsAvatarInvalidNftUriError extends BaseError {\n  constructor({ reason }: { reason: string }) {\n    super(`ENS NFT avatar URI is invalid. ${reason}`, {\n      name: 'EnsAvatarInvalidNftUriError',\n    })\n  }\n}\n\nexport type EnsAvatarUriResolutionErrorType = EnsAvatarUriResolutionError & {\n  name: 'EnsAvatarUriResolutionError'\n}\nexport class EnsAvatarUriResolutionError extends BaseError {\n  constructor({ uri }: { uri: string }) {\n    super(\n      `Unable to resolve ENS avatar URI \"${uri}\". The URI may be malformed, invalid, or does not respond with a valid image.`,\n      { name: 'EnsAvatarUriResolutionError' },\n    )\n  }\n}\n\nexport type EnsAvatarUnsupportedNamespaceErrorType =\n  EnsAvatarUnsupportedNamespaceError & {\n    name: 'EnsAvatarUnsupportedNamespaceError'\n  }\nexport class EnsAvatarUnsupportedNamespaceError extends BaseError {\n  constructor({ namespace }: { namespace: string }) {\n    super(\n      `ENS NFT avatar namespace \"${namespace}\" is not supported. Must be \"erc721\" or \"erc1155\".`,\n      { name: 'EnsAvatarUnsupportedNamespaceError' },\n    )\n  }\n}\n\nexport type EnsInvalidChainIdErrorType = EnsInvalidChainIdError & {\n  name: 'EnsInvalidChainIdError'\n}\nexport class EnsInvalidChainIdError extends BaseError {\n  constructor({ chainId }: { chainId: number }) {\n    super(\n      `Invalid ENSIP-11 chainId: ${chainId}. Must be between 0 and 0x7fffffff, or 1.`,\n      {\n        name: 'EnsInvalidChainIdError',\n      },\n    )\n  }\n}\n","import { BaseError } from '../../errors/base.js'\nimport { ContractFunctionRevertedError } from '../../errors/contract.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\n/** @internal */\nexport type IsNullUniversalResolverErrorErrorType = ErrorType\n\n/*\n * @description Checks if error is a valid null result UniversalResolver error\n */\nexport function isNullUniversalResolverError(err: unknown): boolean {\n  if (!(err instanceof BaseError)) return false\n  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError)\n  if (!(cause instanceof ContractFunctionRevertedError)) return false\n\n  if (cause.data?.errorName === 'HttpError') return true\n  if (cause.data?.errorName === 'ResolverError') return true\n  if (cause.data?.errorName === 'ResolverNotContract') return true\n  if (cause.data?.errorName === 'ResolverNotFound') return true\n  if (cause.data?.errorName === 'ReverseAddressMismatch') return true\n  if (cause.data?.errorName === 'UnsupportedResolverProfile') return true\n\n  return false\n}\n","import type { Address } from 'abitype'\n\nimport {\n  type ReadContractErrorType,\n  readContract,\n} from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport {\n  EnsAvatarInvalidMetadataError,\n  type EnsAvatarInvalidMetadataErrorType,\n  EnsAvatarInvalidNftUriError,\n  type EnsAvatarInvalidNftUriErrorType,\n  EnsAvatarUnsupportedNamespaceError,\n  type EnsAvatarUnsupportedNamespaceErrorType,\n  EnsAvatarUriResolutionError,\n  type EnsAvatarUriResolutionErrorType,\n} from '../../../errors/ens.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\ntype UriItem = {\n  uri: string\n  isOnChain: boolean\n  isEncoded: boolean\n}\n\nconst networkRegex =\n  /(?<protocol>https?:\\/\\/[^/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/\nconst ipfsHashRegex =\n  /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/\n\ntype IsImageUriErrorType = ErrorType\n\n/** @internal */\nexport async function isImageUri(uri: string) {\n  try {\n    const res = await fetch(uri, { method: 'HEAD' })\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type')\n      return contentType?.startsWith('image/')\n    }\n    return false\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    if (!Object.hasOwn(globalThis, 'Image')) return false\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image()\n      img.onload = () => {\n        resolve(true)\n      }\n      img.onerror = () => {\n        resolve(false)\n      }\n      img.src = uri\n    })\n  }\n}\n\ntype GetGatewayErrorType = ErrorType\n\n/** @internal */\nexport function getGateway(custom: string | undefined, defaultGateway: string) {\n  if (!custom) return defaultGateway\n  if (custom.endsWith('/')) return custom.slice(0, -1)\n  return custom\n}\n\nexport type ResolveAvatarUriErrorType =\n  | GetGatewayErrorType\n  | EnsAvatarUriResolutionErrorType\n  | ErrorType\n\nexport function resolveAvatarUri({\n  uri,\n  gatewayUrls,\n}: {\n  uri: string\n  gatewayUrls?: AssetGatewayUrls | undefined\n}): UriItem {\n  const isEncoded = base64Regex.test(uri)\n  if (isEncoded) return { uri, isOnChain: true, isEncoded }\n\n  const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io')\n  const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net')\n\n  const networkRegexMatch = uri.match(networkRegex)\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = '',\n  } = networkRegexMatch?.groups || {}\n\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/'\n  const isIPFS =\n    protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri)\n\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri\n    if (gatewayUrls?.arweave)\n      replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave)\n    return { uri: replacedUri, isOnChain: false, isEncoded: false }\n  }\n\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  if (protocol === 'ar:/' && target) {\n    return {\n      uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  let parsedUri = uri.replace(dataURIRegex, '')\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`\n  }\n\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false,\n    }\n  }\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\nexport type GetJsonImageErrorType =\n  | EnsAvatarInvalidMetadataErrorType\n  | ErrorType\n\nexport function getJsonImage(data: any) {\n  // validation check for json data, must include one of theses properties\n  if (\n    typeof data !== 'object' ||\n    (!('image' in data) && !('image_url' in data) && !('image_data' in data))\n  ) {\n    throw new EnsAvatarInvalidMetadataError({ data })\n  }\n\n  return data.image || data.image_url || data.image_data\n}\n\nexport type GetMetadataAvatarUriErrorType =\n  | EnsAvatarUriResolutionErrorType\n  | ParseAvatarUriErrorType\n  | GetJsonImageErrorType\n  | ErrorType\n\nexport async function getMetadataAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  try {\n    const res = await fetch(uri).then((res) => res.json())\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res),\n    })\n    return image\n  } catch {\n    throw new EnsAvatarUriResolutionError({ uri })\n  }\n}\n\nexport type ParseAvatarUriErrorType =\n  | ResolveAvatarUriErrorType\n  | IsImageUriErrorType\n  | EnsAvatarUriResolutionErrorType\n  | ErrorType\n\nexport async function parseAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls })\n  if (isOnChain) return resolvedURI\n\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI)\n  if (isImage) return resolvedURI\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\ntype ParsedNft = {\n  chainID: number\n  namespace: string\n  contractAddress: Address\n  tokenID: string\n}\n\nexport type ParseNftUriErrorType = EnsAvatarInvalidNftUriErrorType | ErrorType\n\nexport function parseNftUri(uri_: string): ParsedNft {\n  let uri = uri_\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/')\n  }\n\n  const [reference, asset_namespace, tokenID] = uri.split('/')\n  const [eip_namespace, chainID] = reference.split(':')\n  const [erc_namespace, contractAddress] = asset_namespace.split(':')\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' })\n  if (!chainID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' })\n  if (!contractAddress)\n    throw new EnsAvatarInvalidNftUriError({\n      reason: 'Contract address not found',\n    })\n  if (!tokenID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' })\n  if (!erc_namespace)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' })\n\n  return {\n    chainID: Number.parseInt(chainID, 10),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress as Address,\n    tokenID,\n  }\n}\n\nexport type GetNftTokenUriErrorType =\n  | ReadContractErrorType\n  | EnsAvatarUnsupportedNamespaceErrorType\n  | ErrorType\n\nexport async function getNftTokenUri<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { nft }: { nft: ParsedNft },\n) {\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'tokenURI',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: 'tokenId', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'uri',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: '_id', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace })\n}\n","import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\nimport {\n  type GetJsonImageErrorType,\n  type GetMetadataAvatarUriErrorType,\n  type GetNftTokenUriErrorType,\n  getJsonImage,\n  getMetadataAvatarUri,\n  getNftTokenUri,\n  type ParseAvatarUriErrorType,\n  type ParseNftUriErrorType,\n  parseAvatarUri,\n  parseNftUri,\n  type ResolveAvatarUriErrorType,\n  resolveAvatarUri,\n} from './utils.js'\n\nexport type ParseAvatarRecordErrorType =\n  | ParseNftAvatarUriErrorType\n  | ParseAvatarUriErrorType\n  | ErrorType\n\n/*\n * @description Parses an ENS avatar record.\n *\n * @example\n * parseAvatarRecord('eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063')\n * 'https://ipfs.io/ipfs/QmSP4nq9fnN9dAiCj42ug9Wa79rqmQerZXZch82VqpiH7U/image.gif'\n *\n * @see https://docs.ens.domains/web/avatars\n *\n */\nexport async function parseAvatarRecord<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls | undefined\n    record: string\n  },\n): Promise<string> {\n  if (/eip155:/i.test(record))\n    return parseNftAvatarUri(client, { gatewayUrls, record })\n  return parseAvatarUri({ uri: record, gatewayUrls })\n}\n\ntype ParseNftAvatarUriErrorType =\n  | ParseNftUriErrorType\n  | GetNftTokenUriErrorType\n  | ResolveAvatarUriErrorType\n  | ParseAvatarUriErrorType\n  | GetJsonImageErrorType\n  | GetMetadataAvatarUriErrorType\n  | ErrorType\n\nasync function parseNftAvatarUri<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls | undefined\n    record: string\n  },\n): Promise<string> {\n  // parse NFT URI into properties\n  const nft = parseNftUri(record)\n  // fetch tokenURI from the NFT contract\n  const nftUri = await getNftTokenUri(client, { nft })\n  // resolve the URI from the fetched tokenURI\n  const {\n    uri: resolvedNftUri,\n    isOnChain,\n    isEncoded,\n  } = resolveAvatarUri({ uri: nftUri, gatewayUrls })\n\n  // if the resolved URI is on chain, return the data\n  if (\n    isOnChain &&\n    (resolvedNftUri.includes('data:application/json;base64,') ||\n      resolvedNftUri.startsWith('{'))\n  ) {\n    const encodedJson = isEncoded\n      ? // if it is encoded, decode it\n        atob(resolvedNftUri.replace('data:application/json;base64,', ''))\n      : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)\n        resolvedNftUri\n\n    const decoded = JSON.parse(encodedJson)\n    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls })\n  }\n\n  let uriTokenId = nft.tokenID\n  if (nft.namespace === 'erc1155')\n    uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0')\n\n  return getMetadataAvatarUri({\n    gatewayUrls,\n    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { AccessList, TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, Prettify, UnionOmit } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type GetCallErrorReturnType,\n  getCallError,\n} from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport type {\n  AssertRequestErrorType,\n  AssertRequestParameters,\n} from '../../utils/transaction/assertRequest.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\n\nexport type CreateAccessListParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<\n  FormattedTransactionRequest<chain>,\n  'from' | 'nonce' | 'accessList'\n> & {\n  /** Account attached to the call (msg.sender). */\n  account?: Account | Address | undefined\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: undefined\n      }\n    | {\n        blockNumber?: undefined\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag | undefined\n      }\n  )\n\nexport type CreateAccessListReturnType = Prettify<{\n  accessList: AccessList\n  gasUsed: bigint\n}>\n\nexport type CreateAccessListErrorType = GetCallErrorReturnType<\n  | ParseAccountErrorType\n  | AssertRequestErrorType\n  | NumberToHexErrorType\n  | FormatTransactionRequestErrorType\n  | RequestErrorType\n>\n\n/**\n * Creates an EIP-2930 access list.\n *\n * - Docs: https://viem.sh/docs/actions/public/createAccessList\n * - JSON-RPC Methods: `eth_createAccessList`\n *\n * @param client - Client to use\n * @param parameters - {@link CreateAccessListParameters}\n * @returns The access list. {@link CreateAccessListReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createAccessList } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await createAccessList(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function createAccessList<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  args: CreateAccessListParameters<chain>,\n): Promise<CreateAccessListReturnType> {\n  const {\n    account: account_ = client.account,\n    blockNumber,\n    blockTag = 'latest',\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    to,\n    value,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  try {\n    assertRequest(args as AssertRequestParameters)\n\n    const blockNumberHex =\n      typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format(\n      {\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        account,\n        blobs,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        to,\n        value,\n      } as TransactionRequest,\n      'createAccessList',\n    ) as TransactionRequest\n\n    const response = await client.request({\n      method: 'eth_createAccessList',\n      params: [request as ExactPartial<RpcTransactionRequest>, block],\n    })\n    return {\n      accessList: response.accessList,\n      gasUsed: BigInt(response.gasUsed),\n    }\n  } catch (err) {\n    throw getCallError(err as ErrorType, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\n\nexport type EncodedLabelToLabelhashErrorType = IsHexErrorType | ErrorType\n\nexport function encodedLabelToLabelhash(label: string): Hex | null {\n  if (label.length !== 66) return null\n  if (label.indexOf('[') !== 0) return null\n  if (label.indexOf(']') !== 65) return null\n  const hash = `0x${label.slice(1, 65)}`\n  if (!isHex(hash)) return null\n  return hash\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type EncodedLabelToLabelhashErrorType,\n  encodedLabelToLabelhash,\n} from './encodedLabelToLabelhash.js'\n\nexport type LabelhashErrorType =\n  | BytesToHexErrorType\n  | EncodedLabelToLabelhashErrorType\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\n/**\n * @description Hashes ENS label\n *\n * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @example\n * labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n */\nexport function labelhash(label: string) {\n  const result = new Uint8Array(32).fill(0)\n  if (!label) return bytesToHex(result)\n  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label))\n}\n","// Adapted from https://github.com/mafintosh/dns-packet\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray } from '../../types/misc.js'\nimport {\n  type StringToBytesErrorType,\n  stringToBytes,\n} from '../encoding/toBytes.js'\nimport {\n  type EncodeLabelhashErrorType,\n  encodeLabelhash,\n} from './encodeLabelhash.js'\nimport { type LabelhashErrorType, labelhash } from './labelhash.js'\n\nexport type PacketToBytesErrorType =\n  | EncodeLabelhashErrorType\n  | LabelhashErrorType\n  | StringToBytesErrorType\n  | ErrorType\n\n/*\n * @description Encodes a DNS packet into a ByteArray containing a UDP payload.\n *\n * @example\n * packetToBytes('awkweb.eth')\n * '0x0661776b7765620365746800'\n *\n * @see https://docs.ens.domains/resolution/names#dns\n *\n */\nexport function packetToBytes(packet: string): ByteArray {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, '')\n  if (value.length === 0) return new Uint8Array(1)\n\n  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2)\n\n  let offset = 0\n  const list = value.split('.')\n  for (let i = 0; i < list.length; i++) {\n    let encoded = stringToBytes(list[i])\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255)\n      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])))\n    bytes[offset] = encoded.length\n    bytes.set(encoded, offset + 1)\n    offset += encoded.length + 1\n  }\n\n  if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1)\n\n  return bytes\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  textResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsTextParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENS name to get Text for. */\n    name: string\n    /** Universal Resolver gateway URLs to use for resolving CCIP-read requests. */\n    gatewayUrls?: string[] | undefined\n    /** Text record to retrieve. */\n    key: string\n    /** Whether or not to throw errors propagated from the ENS Universal Resolver Contract. */\n    strict?: boolean | undefined\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsTextReturnType = string | null\n\nexport type GetEnsTextErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | DecodeFunctionResultErrorType\n\n/**\n * Gets a text record for specified ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsTextParameters}\n * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsText, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const twitterRecord = await getEnsText(client, {\n *   name: normalize('wevm.eth'),\n *   key: 'com.twitter',\n * })\n * // 'wevm_dev'\n */\nexport async function getEnsText<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsTextParameters,\n): Promise<GetEnsTextReturnType> {\n  const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null\n\n  try {\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      args: [\n        toHex(packetToBytes(name)),\n        encodeFunctionData({\n          abi: textResolverAbi,\n          functionName: 'text',\n          args: [namehash(name), key],\n        }),\n        gatewayUrls ?? [localBatchGatewayUrl],\n      ],\n      functionName: 'resolveWithGateways',\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const res = await readContractAction(readContractParameters)\n\n    if (res[0] === '0x') return null\n\n    const record = decodeFunctionResult({\n      abi: textResolverAbi,\n      functionName: 'text',\n      data: res[0],\n    })\n\n    return record === '' ? null : record\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../types/ens.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type ParseAvatarRecordErrorType,\n  parseAvatarRecord,\n} from '../../utils/ens/avatar/parseAvatarRecord.js'\nimport { getAction } from '../../utils/getAction.js'\n\nimport {\n  type GetEnsTextErrorType,\n  type GetEnsTextParameters,\n  getEnsText,\n} from './getEnsText.js'\n\nexport type GetEnsAvatarParameters = Prettify<\n  Omit<GetEnsTextParameters, 'key'> & {\n    /** Gateway urls to resolve IPFS and/or Arweave assets. */\n    assetGatewayUrls?: AssetGatewayUrls | undefined\n  }\n>\n\nexport type GetEnsAvatarReturnType = string | null\n\nexport type GetEnsAvatarErrorType =\n  | GetEnsTextErrorType\n  | ParseAvatarRecordErrorType\n  | ErrorType\n\n/**\n * Gets the avatar of an ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAvatarParameters}\n * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAvatar, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAvatar = await getEnsAvatar(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'\n */\nexport async function getEnsAvatar<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    assetGatewayUrls,\n    name,\n    gatewayUrls,\n    strict,\n    universalResolverAddress,\n  }: GetEnsAvatarParameters,\n): Promise<GetEnsAvatarReturnType> {\n  const record = await getAction(\n    client,\n    getEnsText,\n    'getEnsText',\n  )({\n    blockNumber,\n    blockTag,\n    key: 'avatar',\n    name,\n    universalResolverAddress,\n    gatewayUrls,\n    strict,\n  })\n  if (!record) return null\n  try {\n    return await parseAvatarRecord(client, {\n      record,\n      gatewayUrls: assetGatewayUrls,\n    })\n  } catch {\n    return null\n  }\n}\n","import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hex, LogTopic } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type EncodeEventTopicsErrorType,\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateEventFilterParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n> = {\n  address?: Address | Address[] | undefined\n  fromBlock?: fromBlock | BlockNumber | BlockTag | undefined\n  toBlock?: toBlock | BlockNumber | BlockTag | undefined\n} & (MaybeExtractEventArgsFromAbi<\n  abiEvents,\n  _eventName\n> extends infer eventFilterArgs\n  ?\n      | {\n          args:\n            | eventFilterArgs\n            | (_args extends eventFilterArgs ? _args : never)\n          event: abiEvent\n          events?: undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: abiEvent | undefined\n          events?: undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: undefined\n          events: abiEvents | undefined\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: strict | undefined\n        }\n      | {\n          args?: undefined\n          event?: undefined\n          events?: undefined\n          strict?: undefined\n        }\n  : {\n      args?: undefined\n      event?: undefined\n      events?: undefined\n      strict?: undefined\n    })\n\nexport type CreateEventFilterReturnType<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n> = Prettify<\n  Filter<'event', abiEvents, _eventName, _args, strict, fromBlock, toBlock>\n>\n\nexport type CreateEventFilterErrorType =\n  | EncodeEventTopicsErrorType\n  | RequestErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n *\n * - Docs: https://viem.sh/docs/actions/public/createEventFilter\n * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n *\n * @param client - Client to use\n * @param parameters - {@link CreateEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * })\n */\nexport async function createEventFilter<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber<bigint> | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber<bigint> | BlockTag | undefined = undefined,\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n  _args extends\n    | MaybeExtractEventArgsFromAbi<abiEvents, _eventName>\n    | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    args,\n    event,\n    events: events_,\n    fromBlock,\n    strict,\n    toBlock,\n  }: CreateEventFilterParameters<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  > = {} as any,\n): Promise<\n  CreateEventFilterReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  >\n> {\n  const events = events_ ?? (event ? [event] : undefined)\n\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newFilter',\n  })\n\n  let topics: LogTopic[] = []\n  if (events) {\n    const encoded = (events as AbiEvent[]).flatMap((event) =>\n      encodeEventTopics({\n        abi: [event],\n        eventName: (event as AbiEvent).name,\n        args,\n      } as EncodeEventTopicsParameters),\n    )\n    // TODO: Clean up type casting\n    topics = [encoded as LogTopic]\n    if (event) topics = topics[0] as LogTopic[]\n  }\n\n  const id: Hex = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        ...(topics.length ? { topics } : {}),\n      },\n    ],\n  })\n\n  return {\n    abi: events,\n    args,\n    eventName: event ? (event as AbiEvent).name : undefined,\n    fromBlock,\n    id,\n    request: getRequest(id),\n    strict: Boolean(strict),\n    toBlock,\n    type: 'event',\n  } as unknown as CreateEventFilterReturnType<\n    abiEvent,\n    abiEvents,\n    strict,\n    fromBlock,\n    toBlock,\n    _eventName,\n    _args\n  >\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  addressResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type TrimErrorType, trim } from '../../utils/data/trim.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsAddressParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /**\n     * ENSIP-9 compliant coinType (chain) to get ENS address for.\n     *\n     * To get the `coinType` for a chain id, use the `toCoinType` function:\n     * ```ts\n     * import { toCoinType } from 'viem'\n     * import { base } from 'viem/chains'\n     *\n     * const coinType = toCoinType(base.id)\n     * ```\n     *\n     * @default 60n\n     */\n    coinType?: bigint | undefined\n    /**\n     * Universal Resolver gateway URLs to use for resolving CCIP-read requests.\n     */\n    gatewayUrls?: string[] | undefined\n    /**\n     * Name to get the address for.\n     */\n    name: string\n    /**\n     * Whether or not to throw errors propagated from the ENS Universal Resolver Contract.\n     */\n    strict?: boolean | undefined\n    /**\n     * Address of ENS Universal Resolver Contract.\n     */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsAddressReturnType = Address | null\n\nexport type GetEnsAddressErrorType =\n  | GetChainContractAddressErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | DecodeFunctionResultErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsAddressParameters,\n): Promise<GetEnsAddressReturnType> {\n  const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } =\n    parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld))) return null\n\n  const args = (() => {\n    if (coinType != null) return [namehash(name), BigInt(coinType)] as const\n    return [namehash(name)] as const\n  })()\n\n  try {\n    const functionData = encodeFunctionData({\n      abi: addressResolverAbi,\n      functionName: 'addr',\n      args,\n    })\n\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolveWithGateways',\n      args: [\n        toHex(packetToBytes(name)),\n        functionData,\n        gatewayUrls ?? [localBatchGatewayUrl],\n      ],\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const res = await readContractAction(readContractParameters)\n\n    if (res[0] === '0x') return null\n\n    const address = decodeFunctionResult({\n      abi: addressResolverAbi,\n      args,\n      functionName: 'addr',\n      data: res[0],\n    })\n\n    if (address === '0x') return null\n    if (trim(address) === '0x00') return null\n    return address\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsResolverParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsResolverReturnType = Address\n\nexport type GetEnsResolverErrorType =\n  | GetChainContractAddressErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | ErrorType\n\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wevm.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsResolverParameters,\n): Promise<GetEnsResolverReturnType> {\n  const { blockNumber, blockTag, name } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  const tlds = chain?.ensTlds\n  if (tlds && !tlds.some((tld) => name.endsWith(tld)))\n    throw new Error(\n      `${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain \"${chain.name}\" (id: ${chain.id}).`,\n    )\n\n  const [resolverAddress] = await getAction(\n    client,\n    readContract,\n    'readContract',\n  )({\n    address: universalResolverAddress,\n    abi: [\n      {\n        inputs: [{ type: 'bytes' }],\n        name: 'findResolver',\n        outputs: [\n          { type: 'address' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n        ],\n        stateMutability: 'view',\n        type: 'function',\n      },\n    ],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag,\n  })\n  return resolverAddress\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalResolverReverseAbi } from '../../constants/abis.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { localBatchGatewayUrl } from '../../utils/ens/localBatchGatewayRequest.js'\nimport type { PacketToBytesErrorType } from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsNameParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /**\n     * Address to get ENS name for.\n     */\n    address: Address\n    /**\n     * ENSIP-9 compliant coinType (chain) to get ENS name for.\n     *\n     * To get the `coinType` for a chain id, use the `toCoinType` function:\n     * ```ts\n     * import { toCoinType } from 'viem'\n     * import { base } from 'viem/chains'\n     *\n     * const coinType = toCoinType(base.id)\n     * ```\n     *\n     * @default 60n\n     */\n    coinType?: bigint | undefined\n    /**\n     * Universal Resolver gateway URLs to use for resolving CCIP-read requests.\n     */\n    gatewayUrls?: string[] | undefined\n    /**\n     * Whether or not to throw errors propagated from the ENS Universal Resolver Contract.\n     */\n    strict?: boolean | undefined\n    /**\n     * Address of ENS Universal Resolver Contract.\n     */\n    universalResolverAddress?: Address | undefined\n  }\n>\n\nexport type GetEnsNameReturnType = string | null\n\nexport type GetEnsNameErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | PacketToBytesErrorType\n  | ErrorType\n\n/**\n * Gets primary name for specified address.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsName\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `reverse(bytes)` on ENS Universal Resolver Contract to \"reverse resolve\" the address to the primary ENS name.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsNameParameters}\n * @returns Name or `null` if not found. {@link GetEnsNameReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsName } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensName = await getEnsName(client, {\n *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',\n * })\n * // 'wevm.eth'\n */\nexport async function getEnsName<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: GetEnsNameParameters,\n): Promise<GetEnsNameReturnType> {\n  const {\n    address,\n    blockNumber,\n    blockTag,\n    coinType = 60n,\n    gatewayUrls,\n    strict,\n  } = parameters\n  const { chain } = client\n\n  const universalResolverAddress = (() => {\n    if (parameters.universalResolverAddress)\n      return parameters.universalResolverAddress\n    if (!chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n    return getChainContractAddress({\n      blockNumber,\n      chain,\n      contract: 'ensUniversalResolver',\n    })\n  })()\n\n  try {\n    const readContractParameters = {\n      address: universalResolverAddress,\n      abi: universalResolverReverseAbi,\n      args: [address, coinType, gatewayUrls ?? [localBatchGatewayUrl]],\n      functionName: 'reverseWithGateways',\n      blockNumber,\n      blockTag,\n    } as const\n\n    const readContractAction = getAction(client, readContract, 'readContract')\n\n    const [name] = await readContractAction(readContractParameters)\n\n    return name || null\n  } catch (err) {\n    if (strict) throw err\n    if (isNullUniversalResolverError(err)) return null\n    throw err\n  }\n}\n","import type { Abi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  GetValue,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type EstimateGasErrorType,\n  type EstimateGasParameters,\n  estimateGas,\n} from './estimateGas.js'\n\nexport type EstimateContractGasParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n> = ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<EstimateGasParameters<chain>, 'data' | 'to' | 'value'> &\n  GetValue<\n    abi,\n    functionName,\n    EstimateGasParameters<chain> extends EstimateGasParameters\n      ? EstimateGasParameters<chain>['value']\n      : EstimateGasParameters['value']\n  > & {\n    /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n    dataSuffix?: Hex | undefined\n  }\n\nexport type EstimateContractGasReturnType = bigint\n\nexport type EstimateContractGasErrorType = GetContractErrorReturnType<\n  EncodeFunctionDataErrorType | EstimateGasErrorType | ParseAccountErrorType\n>\n\n/**\n * Estimates the gas required to successfully execute a contract write function call.\n *\n * - Docs: https://viem.sh/docs/contract/estimateContractGas\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateContractGas } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gas = await estimateContractGas(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractGas<\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: EstimateContractGasParameters<abi, functionName, args, chain>,\n): Promise<EstimateContractGasReturnType> {\n  const { abi, address, args, functionName, dataSuffix, ...request } =\n    parameters as EstimateContractGasParameters\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as EncodeFunctionDataParameters)\n  try {\n    const gas = await getAction(\n      client,\n      estimateGas,\n      'estimateGas',\n    )({\n      data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...request,\n    } as unknown as EstimateGasParameters)\n    return gas\n  } catch (error) {\n    const account = request.account ? parseAccount(request.account) : undefined\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/estimateContractGas',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { FeeHistory } from '../../types/fee.js'\nimport type { RpcFeeHistory } from '../../types/rpc.js'\n\nexport type FormatFeeHistoryErrorType = ErrorType\n\nexport function formatFeeHistory(feeHistory: RpcFeeHistory): FeeHistory {\n  return {\n    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),\n    gasUsedRatio: feeHistory.gasUsedRatio,\n    oldestBlock: BigInt(feeHistory.oldestBlock),\n    reward: feeHistory.reward?.map((reward) =>\n      reward.map((value) => BigInt(value)),\n    ),\n  }\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { FormattedTransactionReceipt } from '../../utils/formatters/transactionReceipt.js'\nimport { getAction } from '../../utils/getAction.js'\n\nimport {\n  type GetBlockNumberErrorType,\n  getBlockNumber,\n} from './getBlockNumber.js'\nimport {\n  type GetTransactionErrorType,\n  getTransaction,\n} from './getTransaction.js'\n\nexport type GetTransactionConfirmationsParameters<\n  chain extends Chain | undefined = Chain,\n> =\n  | {\n      /** The transaction hash. */\n      hash: Hash\n      transactionReceipt?: undefined\n    }\n  | {\n      hash?: undefined\n      /** The transaction receipt. */\n      transactionReceipt: FormattedTransactionReceipt<chain>\n    }\n\nexport type GetTransactionConfirmationsReturnType = bigint\n\nexport type GetTransactionConfirmationsErrorType =\n  | GetBlockNumberErrorType\n  | GetTransactionErrorType\n  | ErrorType\n\n/**\n * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionConfirmationsParameters}\n * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionConfirmations } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const confirmations = await getTransactionConfirmations(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransactionConfirmations<\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  { hash, transactionReceipt }: GetTransactionConfirmationsParameters<chain>,\n): Promise<GetTransactionConfirmationsReturnType> {\n  const [blockNumber, transaction] = await Promise.all([\n    getAction(client, getBlockNumber, 'getBlockNumber')({}),\n    hash\n      ? getAction(client, getTransaction, 'getTransaction')({ hash })\n      : undefined,\n  ])\n  const transactionBlockNumber =\n    transactionReceipt?.blockNumber || transaction?.blockNumber\n  if (!transactionBlockNumber) return 0n\n  return blockNumber - transactionBlockNumber! + 1n\n}\n","import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiConstructor.js'\nimport type { IsNarrowable } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with a `constructor` type. */\nexport type AbiConstructor = abitype.AbiConstructor\n\n/**\n * ABI-decodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const bytecode = '0x...'\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode,\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * const decoded = AbiConstructor.decode(constructor, { // [!code focus]\n *   bytecode, // [!code focus]\n *   data, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object as a parameter to `AbiConstructor.decode`.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiConstructor.encode(abi, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * const decoded = AbiConstructor.decode(abi, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   data, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param abiConstructor - The ABI Constructor to decode.\n * @param options - Decoding options.\n * @returns The decoded constructor inputs.\n */\nexport function decode<\n  const abi extends Abi.Abi | readonly unknown[],\n  abiConstructor extends\n    AbiConstructor = fromAbi.ReturnType<abi> extends AbiConstructor\n    ? fromAbi.ReturnType<abi>\n    : never,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  options: decode.Options,\n): decode.ReturnType<abiConstructor>\nexport function decode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor | AbiConstructor,\n  options: decode.Options,\n): decode.ReturnType<abiConstructor>\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function decode(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], options: decode.Options]\n    | [abiConstructor: AbiConstructor, options: decode.Options]\n): decode.ReturnType {\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        decode.Options,\n      ]\n      return [fromAbi(abi), options] as [AbiConstructor, decode.Options]\n    }\n    return parameters as [AbiConstructor, decode.Options]\n  })()\n\n  const { bytecode } = options\n  if (abiConstructor.inputs.length === 0) return undefined\n  const data = options.data.replace(bytecode, '0x') as Hex.Hex\n  return AbiParameters.decode(abiConstructor.inputs, data)\n}\n\nexport declare namespace decode {\n  interface Options {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The encoded constructor. */\n    data: Hex.Hex\n  }\n\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    | (abiConstructor['inputs']['length'] extends 0\n        ? undefined\n        : abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>)\n    | (IsNarrowable<abiConstructor, AbiConstructor> extends true\n        ? never\n        : undefined)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### ABI-shorthand\n *\n * You can also specify an entire ABI object as a parameter to `AbiConstructor.encode`.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([...])\n *\n * const data = AbiConstructor.encode(abi, { // [!code focus]\n *   bytecode: '0x...', // [!code focus]\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n], // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nexport function encode<\n  const abi extends Abi.Abi | readonly unknown[],\n  abiConstructor extends\n    AbiConstructor = fromAbi.ReturnType<abi> extends AbiConstructor\n    ? fromAbi.ReturnType<abi>\n    : never,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  options: encode.Options<abiConstructor>,\n): encode.ReturnType\nexport function encode<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor | AbiConstructor,\n  options: encode.Options<abiConstructor>,\n): encode.ReturnType\n// eslint-disable-next-line jsdoc/require-jsdoc\nexport function encode(\n  ...parameters:\n    | [abi: Abi.Abi | readonly unknown[], options: encode.Options]\n    | [abiConstructor: AbiConstructor, options: encode.Options]\n): encode.ReturnType {\n  const [abiConstructor, options] = (() => {\n    if (Array.isArray(parameters[0])) {\n      const [abi, options] = parameters as [\n        Abi.Abi | readonly unknown[],\n        encode.Options,\n      ]\n      return [fromAbi(abi), options] as [AbiConstructor, encode.Options]\n    }\n\n    return parameters as [AbiConstructor, encode.Options]\n  })()\n\n  const { bytecode, args } = options\n  return Hex.concat(\n    bytecode,\n    abiConstructor.inputs?.length && args?.length\n      ? AbiParameters.encode(abiConstructor.inputs, args as readonly unknown[])\n      : '0x',\n  )\n}\n\nexport declare namespace encode {\n  type Options<\n    abiConstructor extends AbiConstructor = AbiConstructor,\n    ///\n    args extends abitype.AbiParametersToPrimitiveTypes<\n      abiConstructor['inputs']\n    > = abitype.AbiParametersToPrimitiveTypes<abiConstructor['inputs']>,\n  > = {\n    /** The bytecode of the contract. */\n    bytecode: Hex.Hex\n    /** The constructor arguments to encode. */\n    args?: args | undefined\n  } & (readonly [] extends args\n    ? {}\n    : {\n        /** The constructor arguments to encode. */\n        args: args\n      })\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | AbiParameters.encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function format<const abiConstructor extends AbiConstructor>(\n  abiConstructor: abiConstructor,\n): format.ReturnType<abiConstructor>\n/**\n * Formats an {@link ox#AbiConstructor.AbiConstructor} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const formatted = AbiConstructor.format({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiConstructor - The ABI Constructor to format.\n * @returns The formatted ABI Constructor.\n */\nexport function format(abiConstructor: AbiConstructor): string\n/** @internal */\nexport function format(abiConstructor: AbiConstructor): format.ReturnType {\n  return abitype.formatAbiItem(abiConstructor)\n}\n\nexport declare namespace format {\n  type ReturnType<abiConstructor extends AbiConstructor = AbiConstructor> =\n    abitype.FormatAbiItem<abiConstructor>\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function from<\n  const abiConstructor extends AbiConstructor | string | readonly string[],\n>(\n  abiConstructor: (abiConstructor | string | readonly string[]) &\n    (\n      | (abiConstructor extends string\n          ? internal.Signature<abiConstructor>\n          : never)\n      | (abiConstructor extends readonly string[]\n          ? internal.Signatures<abiConstructor>\n          : never)\n      | AbiConstructor\n    ),\n): from.ReturnType<abiConstructor>\n/**\n * Parses an arbitrary **JSON ABI Constructor** or **Human Readable ABI Constructor** into a typed {@link ox#AbiConstructor.AbiConstructor}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from({\n *   inputs: [\n *     { name: 'owner', type: 'address' },\n *   ],\n *   payable: false,\n *   stateMutability: 'nonpayable',\n *   type: 'constructor',\n * })\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner)' // [!code hl]\n * )\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from([\n *   'struct Foo { address owner; uint256 amount; }', // [!code hl]\n *   'constructor(Foo foo)',\n * ])\n *\n * constructor\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiConstructor - The ABI Constructor to parse.\n * @returns Typed ABI Constructor.\n */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): AbiConstructor\n/** @internal */\nexport function from(\n  abiConstructor: AbiConstructor | string | readonly string[],\n): from.ReturnType {\n  return AbiItem.from(abiConstructor as AbiConstructor)\n}\n\nexport declare namespace from {\n  type ReturnType<\n    abiConstructor extends\n      | AbiConstructor\n      | string\n      | readonly string[] = AbiConstructor,\n  > = AbiItem.from.ReturnType<abiConstructor>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function fromAbi<const abi extends Abi.Abi | readonly unknown[]>(\n  abi: abi | Abi.Abi | readonly unknown[],\n): fromAbi.ReturnType<abi>\n/**\n * Extracts an {@link ox#AbiConstructor.AbiConstructor} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Events can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiConstructor } from 'ox'\n *\n * const abi = Abi.from([\n *   'constructor(address owner)',\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiConstructor.fromAbi(abi) // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @returns The ABI constructor.\n */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): AbiConstructor\n/** @internal */\nexport function fromAbi(abi: Abi.Abi | readonly unknown[]): fromAbi.ReturnType {\n  const item = (abi as Abi.Abi).find((item) => item.type === 'constructor')\n  if (!item) throw new AbiItem.NotFoundError({ name: 'constructor' })\n  return item\n}\n\nexport declare namespace fromAbi {\n  type ReturnType<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> = Extract<\n    abi[number],\n    { type: 'constructor' }\n  >\n\n  type ErrorType = AbiItem.NotFoundError | Errors.GlobalErrorType\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { FeeHistory } from '../../types/fee.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormatFeeHistoryErrorType,\n  formatFeeHistory,\n} from '../../utils/formatters/feeHistory.js'\n\nexport type GetFeeHistoryParameters = {\n  /**\n   * Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.\n   */\n  blockCount: number\n  /**\n   * A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.\n   */\n  rewardPercentiles: number[]\n} & (\n  | {\n      blockNumber?: undefined\n      /**\n       * Highest number block of the requested range.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag | undefined\n    }\n  | {\n      /** Highest number block of the requested range. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n)\nexport type GetFeeHistoryReturnType = FeeHistory\n\nexport type GetFeeHistoryErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | FormatFeeHistoryErrorType\n\n/**\n * Returns a collection of historical gas information.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFeeHistory\n * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)\n *\n * @param client - Client to use\n * @param parameters - {@link GetFeeHistoryParameters}\n * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getFeeHistory } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const feeHistory = await getFeeHistory(client, {\n *   blockCount: 4,\n *   rewardPercentiles: [25, 75],\n * })\n */\nexport async function getFeeHistory<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockCount,\n    blockNumber,\n    blockTag = 'latest',\n    rewardPercentiles,\n  }: GetFeeHistoryParameters,\n): Promise<GetFeeHistoryReturnType> {\n  const blockNumberHex =\n    typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n  const feeHistory = await client.request(\n    {\n      method: 'eth_feeHistory',\n      params: [\n        numberToHex(blockCount),\n        blockNumberHex || blockTag,\n        rewardPercentiles,\n      ],\n    },\n    { dedupe: Boolean(blockNumberHex) },\n  )\n  return formatFeeHistory(feeHistory)\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Quantity } from '../../types/rpc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type HexToNumberErrorType,\n  hexToNumber,\n} from '../../utils/encoding/fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetBlockTransactionCountParameters =\n  | {\n      /** Hash of the block. */\n      blockHash?: Hash | undefined\n      blockNumber?: undefined\n      blockTag?: undefined\n    }\n  | {\n      blockHash?: undefined\n      /** The block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockHash?: undefined\n      blockNumber?: undefined\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag | undefined\n    }\n\nexport type GetBlockTransactionCountReturnType = number\n\nexport type GetBlockTransactionCountErrorType =\n  | NumberToHexErrorType\n  | HexToNumberErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the number of Transactions at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockTransactionCountParameters}\n * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlockTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const count = await getBlockTransactionCount(client)\n */\nexport async function getBlockTransactionCount<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag = 'latest',\n  }: GetBlockTransactionCountParameters = {},\n): Promise<GetBlockTransactionCountReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let count: Quantity\n  if (blockHash) {\n    count = await client.request(\n      {\n        method: 'eth_getBlockTransactionCountByHash',\n        params: [blockHash],\n      },\n      { dedupe: true },\n    )\n  } else {\n    count = await client.request(\n      {\n        method: 'eth_getBlockTransactionCountByNumber',\n        params: [blockNumberHex || blockTag],\n      },\n      { dedupe: Boolean(blockNumberHex) },\n    )\n  }\n\n  return hexToNumber(count)\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Proof } from '../../types/proof.js'\nimport type { RpcProof } from '../../types/rpc.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { hexToNumber } from '../index.js'\n\nexport type FormatProofErrorType = ErrorType\n\nfunction formatStorageProof(storageProof: RpcProof['storageProof']) {\n  return storageProof.map((proof) => ({\n    ...proof,\n    value: BigInt(proof.value),\n  }))\n}\n\nexport function formatProof(proof: ExactPartial<RpcProof>) {\n  return {\n    ...proof,\n    balance: proof.balance ? BigInt(proof.balance) : undefined,\n    nonce: proof.nonce ? hexToNumber(proof.nonce) : undefined,\n    storageProof: proof.storageProof\n      ? formatStorageProof(proof.storageProof)\n      : undefined,\n  } as Proof\n}\n","import type { Address } from 'abitype'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Proof } from '../../types/proof.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type FormatProofErrorType,\n  formatProof,\n} from '../../utils/formatters/proof.js'\n\nexport type GetProofParameters = {\n  /** Account address. */\n  address: Address\n  /** Array of storage-keys that should be proofed and included. */\n  storageKeys: Hash[]\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /**\n       * The block tag.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag | undefined\n    }\n)\n\nexport type GetProofReturnType = Proof\n\nexport type GetProofErrorType =\n  | NumberToHexErrorType\n  | FormatProofErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the account and storage values of the specified account including the Merkle-proof.\n *\n * - Docs: https://viem.sh/docs/actions/public/getProof\n * - JSON-RPC Methods:\n *   - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186)\n *\n * @param client - Client to use\n * @param parameters - {@link GetProofParameters}\n * @returns Proof data. {@link GetProofReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getProof } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const block = await getProof(client, {\n *  address: '0x...',\n *  storageKeys: ['0x...'],\n * })\n */\nexport async function getProof<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    blockNumber,\n    blockTag: blockTag_,\n    storageKeys,\n  }: GetProofParameters,\n): Promise<GetProofReturnType> {\n  const blockTag = blockTag_ ?? 'latest'\n\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  const proof = await client.request({\n    method: 'eth_getProof',\n    params: [address, storageKeys, blockNumberHex || blockTag],\n  })\n\n  return formatProof(proof)\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type GetStorageAtParameters = {\n  address: Address\n  slot: Hex\n} & (\n  | {\n      blockNumber?: undefined\n      blockTag?: BlockTag | undefined\n    }\n  | {\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n)\n\nexport type GetStorageAtReturnType = Hex | undefined\n\nexport type GetStorageAtErrorType =\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns the value from a storage slot at a given address.\n *\n * - Docs: https://viem.sh/docs/contract/getStorageAt\n * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)\n *\n * @param client - Client to use\n * @param parameters - {@link GetStorageAtParameters}\n * @returns The value of the storage slot. {@link GetStorageAtReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getStorageAt } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getStorageAt(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   slot: toHex(0),\n * })\n */\nexport async function getStorageAt<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  { address, blockNumber, blockTag = 'latest', slot }: GetStorageAtParameters,\n): Promise<GetStorageAtReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n  const data = await client.request({\n    method: 'eth_getStorageAt',\n    params: [address, slot, blockNumberHex || blockTag],\n  })\n  return data\n}\n","import type { Abi, AbiEvent, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { DecodeEventLogErrorType } from '../../utils/abi/decodeEventLog.js'\nimport { parseEventLogs } from '../../utils/abi/parseEventLogs.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type FormatLogErrorType,\n  formatLog,\n} from '../../utils/formatters/log.js'\n\nexport type GetFilterLogsParameters<\n  abi extends Abi | readonly unknown[] | undefined = undefined,\n  eventName extends string | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  filter: Filter<'event', abi, eventName, any, strict, fromBlock, toBlock>\n}\nexport type GetFilterLogsReturnType<\n  abi extends Abi | readonly unknown[] | undefined = undefined,\n  eventName extends string | undefined = undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _AbiEvent extends AbiEvent | undefined = abi extends Abi\n    ? eventName extends string\n      ? ExtractAbiEvent<abi, eventName>\n      : undefined\n    : undefined,\n  _Pending extends boolean =\n    | (fromBlock extends 'pending' ? true : false)\n    | (toBlock extends 'pending' ? true : false),\n> = Log<bigint, number, _Pending, _AbiEvent, strict, abi, eventName>[]\n\nexport type GetFilterLogsErrorType =\n  | RequestErrorType\n  | DecodeEventLogErrorType\n  | FormatLogErrorType\n  | ErrorType\n\n/**\n * Returns a list of event logs since the filter was created.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterLogs\n * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n *\n * `getFilterLogs` is only compatible with **event filters**.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterLogsParameters}\n * @returns A list of event logs. {@link GetFilterLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterLogs(client, { filter })\n */\nexport async function getFilterLogs<\n  chain extends Chain | undefined,\n  const abi extends Abi | readonly unknown[] | undefined,\n  eventName extends string | undefined,\n  strict extends boolean | undefined = undefined,\n  fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  toBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  _client: Client<Transport, chain>,\n  {\n    filter,\n  }: GetFilterLogsParameters<abi, eventName, strict, fromBlock, toBlock>,\n): Promise<\n  GetFilterLogsReturnType<abi, eventName, strict, fromBlock, toBlock>\n> {\n  const strict = filter.strict ?? false\n\n  const logs = await filter.request({\n    method: 'eth_getFilterLogs',\n    params: [filter.id],\n  })\n\n  const formattedLogs = logs.map((log) => formatLog(log))\n  if (!filter.abi)\n    return formattedLogs as GetFilterLogsReturnType<\n      abi,\n      eventName,\n      strict,\n      fromBlock,\n      toBlock\n    >\n  return parseEventLogs({\n    abi: filter.abi,\n    logs: formattedLogs,\n    strict,\n  }) as unknown as GetFilterLogsReturnType<\n    abi,\n    eventName,\n    strict,\n    fromBlock,\n    toBlock\n  >\n}\n","import type { Abi, AbiStateMutability, Address, Narrow } from 'abitype'\nimport * as BlockOverrides from 'ox/BlockOverrides'\n\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { MulticallResults } from '../../types/multicall.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, UnionOmit } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { concat } from '../../utils/data/concat.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\nimport {\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from '../../utils/errors/getNodeError.js'\nimport {\n  type FormatBlockErrorType,\n  formatBlock,\n} from '../../utils/formatters/block.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport {\n  type SerializeStateOverrideErrorType,\n  serializeStateOverride,\n} from '../../utils/stateOverride.js'\nimport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\n\ntype CallExtraProperties = ExactPartial<\n  UnionOmit<\n    TransactionRequest,\n    'blobs' | 'data' | 'kzg' | 'to' | 'sidecars' | 'value'\n  >\n> & {\n  /** Account attached to the call (msg.sender). */\n  account?: Account | Address | undefined\n  /** Recipient. `null` if contract deployment. */\n  to?: Address | null | undefined\n}\n\nexport type SimulateBlocksParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Blocks to simulate. */\n  blocks: readonly {\n    /** Block overrides. */\n    blockOverrides?: BlockOverrides.BlockOverrides | undefined\n    /** Calls to execute. */\n    calls: Calls<Narrow<calls>, CallExtraProperties>\n    /** State overrides. */\n    stateOverrides?: StateOverride | undefined\n  }[]\n  /** Whether to return the full transactions. */\n  returnFullTransactions?: boolean | undefined\n  /** Whether to trace transfers. */\n  traceTransfers?: boolean | undefined\n  /** Whether to enable validation mode. */\n  validation?: boolean | undefined\n} & (\n  | {\n      /** The balance of the account at a block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /**\n       * The balance of the account at a block tag.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag | undefined\n    }\n)\n\nexport type SimulateBlocksReturnType<\n  calls extends readonly unknown[] = readonly unknown[],\n> = readonly (Block & {\n  calls: MulticallResults<\n    Narrow<calls>,\n    true,\n    {\n      extraProperties: {\n        data: Hex\n        gasUsed: bigint\n        logs?: Log[] | undefined\n      }\n      error: Error\n      mutability: AbiStateMutability\n    }\n  >\n})[]\n\nexport type SimulateBlocksErrorType =\n  | AssertRequestErrorType\n  | DecodeFunctionResultErrorType\n  | EncodeFunctionDataErrorType\n  | FormatBlockErrorType\n  | FormatTransactionRequestErrorType\n  | GetNodeErrorReturnType\n  | ParseAccountErrorType\n  | SerializeStateOverrideErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Simulates a set of calls on block(s) with optional block and state overrides.\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { simulate } from 'viem/actions'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulate(client, {\n *   blocks: [{\n *     blockOverrides: {\n *       number: 69420n,\n *     },\n *     calls: [{\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         data: '0xdeadbeef',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       },\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         value: parseEther('1'),\n *       },\n *     }],\n *     stateOverrides: [{\n *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *       balance: parseEther('10'),\n *     }],\n *   }]\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SimulateBlocksParameters}\n * @returns Simulated blocks. {@link SimulateBlocksReturnType}\n */\nexport async function simulateBlocks<\n  chain extends Chain | undefined,\n  const calls extends readonly unknown[],\n>(\n  client: Client<Transport, chain>,\n  parameters: SimulateBlocksParameters<calls>,\n): Promise<SimulateBlocksReturnType<calls>> {\n  const {\n    blockNumber,\n    blockTag = client.experimental_blockTag ?? 'latest',\n    blocks,\n    returnFullTransactions,\n    traceTransfers,\n    validation,\n  } = parameters\n\n  try {\n    const blockStateCalls = []\n    for (const block of blocks) {\n      const blockOverrides = block.blockOverrides\n        ? BlockOverrides.toRpc(block.blockOverrides)\n        : undefined\n      const calls = block.calls.map((call_) => {\n        const call = call_ as Call<unknown, CallExtraProperties>\n        const account = call.account ? parseAccount(call.account) : undefined\n        const data = call.abi ? encodeFunctionData(call) : call.data\n        const request = {\n          ...call,\n          account,\n          data: call.dataSuffix\n            ? concat([data || '0x', call.dataSuffix])\n            : data,\n          from: call.from ?? account?.address,\n        } as const\n        assertRequest(request)\n        return formatTransactionRequest(request)\n      })\n      const stateOverrides = block.stateOverrides\n        ? serializeStateOverride(block.stateOverrides)\n        : undefined\n\n      blockStateCalls.push({\n        blockOverrides,\n        calls,\n        stateOverrides,\n      })\n    }\n\n    const blockNumberHex =\n      typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const result = await client.request({\n      method: 'eth_simulateV1',\n      params: [\n        { blockStateCalls, returnFullTransactions, traceTransfers, validation },\n        block,\n      ],\n    })\n\n    return result.map((block, i) => ({\n      ...formatBlock(block),\n      calls: block.calls.map((call, j) => {\n        const { abi, args, functionName, to } = blocks[i].calls[j] as Call<\n          unknown,\n          CallExtraProperties\n        >\n\n        const data = call.error?.data ?? call.returnData\n        const gasUsed = BigInt(call.gasUsed)\n        const logs = call.logs?.map((log) => formatLog(log))\n        const status = call.status === '0x1' ? 'success' : 'failure'\n\n        const result =\n          abi && status === 'success' && data !== '0x'\n            ? decodeFunctionResult({\n                abi,\n                data,\n                functionName,\n              })\n            : null\n\n        const error = (() => {\n          if (status === 'success') return undefined\n\n          let error: Error | undefined\n          if (call.error?.data === '0x') error = new AbiDecodingZeroDataError()\n          else if (call.error) error = new RawContractError(call.error)\n\n          if (!error) return undefined\n          return getContractError(error, {\n            abi: (abi ?? []) as Abi,\n            address: to ?? '0x',\n            args,\n            functionName: functionName ?? '<unknown>',\n          })\n        })()\n\n        return {\n          data,\n          gasUsed,\n          logs,\n          status,\n          ...(status === 'success'\n            ? {\n                result,\n              }\n            : {\n                error,\n              }),\n        }\n      }),\n    })) as unknown as SimulateBlocksReturnType<calls>\n  } catch (e) {\n    const cause = e as BaseError\n    const error = getNodeError(cause, {})\n    if (error instanceof UnknownNodeError) throw cause\n    throw error\n  }\n}\n","import type { AbiStateMutability, Address, Narrow } from 'abitype'\nimport * as AbiConstructor from 'ox/AbiConstructor'\nimport * as AbiFunction from 'ox/AbiFunction'\n\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { ethAddress, zeroAddress } from '../../constants/address.js'\nimport { deploylessCallViaBytecodeBytecode } from '../../constants/contracts.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block } from '../../types/block.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { MulticallResults } from '../../types/multicall.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { Mutable } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { hexToBigInt } from '../../utils/index.js'\nimport {\n  type CreateAccessListErrorType,\n  createAccessList,\n} from './createAccessList.js'\nimport {\n  type SimulateBlocksErrorType,\n  type SimulateBlocksParameters,\n  simulateBlocks,\n} from './simulateBlocks.js'\n\nconst getBalanceCode =\n  '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033'\n\nexport type SimulateCallsParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n  account extends Account | Address | undefined = Account | Address | undefined,\n> = Omit<SimulateBlocksParameters, 'blocks' | 'returnFullTransactions'> & {\n  /** Account attached to the calls (msg.sender). */\n  account?: account | undefined\n  /** Calls to simulate. */\n  calls: Calls<Narrow<calls>>\n  /** State overrides. */\n  stateOverrides?: StateOverride | undefined\n  /** Whether to trace asset changes. */\n  traceAssetChanges?: boolean | undefined\n}\n\nexport type SimulateCallsReturnType<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Asset changes. */\n  assetChanges: readonly {\n    token: {\n      address: Address\n      decimals?: number | undefined\n      symbol?: string | undefined\n    }\n    value: { pre: bigint; post: bigint; diff: bigint }\n  }[]\n  /** Block results. */\n  block: Block\n  /** Call results. */\n  results: MulticallResults<\n    Narrow<calls>,\n    true,\n    {\n      extraProperties: {\n        data: Hex\n        gasUsed: bigint\n        logs?: Log[] | undefined\n      }\n      error: Error\n      mutability: AbiStateMutability\n    }\n  >\n}\n\nexport type SimulateCallsErrorType =\n  | AbiFunction.encodeData.ErrorType\n  | AbiFunction.from.ErrorType\n  | CreateAccessListErrorType\n  | EncodeFunctionDataErrorType\n  | SimulateBlocksErrorType\n  | ErrorType\n\n/**\n * Simulates execution of a batch of calls.\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateCallsParameters}\n * @returns Results. {@link SimulateCallsReturnType}\n *\n * @example\n * ```ts\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateCalls } from 'viem/actions'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulateCalls(client, {\n *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *   calls: [{\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: parseEther('1'),\n *     },\n *   ]\n * })\n * ```\n */\nexport async function simulateCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | Address | undefined = undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: SimulateCallsParameters<calls, account>,\n): Promise<SimulateCallsReturnType<calls>> {\n  const {\n    blockNumber,\n    blockTag,\n    calls,\n    stateOverrides,\n    traceAssetChanges,\n    traceTransfers,\n    validation,\n  } = parameters\n\n  const account = parameters.account\n    ? parseAccount(parameters.account)\n    : undefined\n\n  if (traceAssetChanges && !account)\n    throw new BaseError(\n      '`account` is required when `traceAssetChanges` is true',\n    )\n\n  // Derive bytecode to extract ETH balance via a contract call.\n  const getBalanceData = account\n    ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {\n        bytecode: deploylessCallViaBytecodeBytecode,\n        args: [\n          getBalanceCode,\n          AbiFunction.encodeData(\n            AbiFunction.from('function getBalance(address)'),\n            [account.address],\n          ),\n        ],\n      })\n    : undefined\n\n  // Fetch ERC20/721 addresses that were \"touched\" from the calls.\n  const assetAddresses = traceAssetChanges\n    ? await Promise.all(\n        parameters.calls.map(async (call: any) => {\n          if (!call.data && !call.abi) return\n          const { accessList } = await createAccessList(client, {\n            account: account!.address,\n            ...call,\n            data: call.abi ? encodeFunctionData(call) : call.data,\n          })\n          return accessList.map(({ address, storageKeys }) =>\n            storageKeys.length > 0 ? address : null,\n          )\n        }),\n      ).then((x) => x.flat().filter(Boolean))\n    : []\n\n  const blocks = await simulateBlocks(client, {\n    blockNumber,\n    blockTag: blockTag as undefined,\n    blocks: [\n      ...(traceAssetChanges\n        ? [\n            // ETH pre balances\n            {\n              calls: [{ data: getBalanceData }],\n              stateOverrides,\n            },\n\n            // Asset pre balances\n            {\n              calls: assetAddresses.map((address, i) => ({\n                abi: [\n                  AbiFunction.from(\n                    'function balanceOf(address) returns (uint256)',\n                  ),\n                ],\n                functionName: 'balanceOf',\n                args: [account!.address],\n                to: address,\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n          ]\n        : []),\n\n      {\n        calls: [...calls, {}].map((call) => ({\n          ...(call as Call),\n          from: account?.address,\n        })) as any,\n        stateOverrides,\n      },\n\n      ...(traceAssetChanges\n        ? [\n            // ETH post balances\n            {\n              calls: [{ data: getBalanceData }],\n            },\n\n            // Asset post balances\n            {\n              calls: assetAddresses.map((address, i) => ({\n                abi: [\n                  AbiFunction.from(\n                    'function balanceOf(address) returns (uint256)',\n                  ),\n                ],\n                functionName: 'balanceOf',\n                args: [account!.address],\n                to: address,\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Decimals\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [\n                  AbiFunction.from('function decimals() returns (uint256)'),\n                ],\n                functionName: 'decimals',\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Token URI\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [\n                  AbiFunction.from(\n                    'function tokenURI(uint256) returns (string)',\n                  ),\n                ],\n                functionName: 'tokenURI',\n                args: [0n],\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n\n            // Symbols\n            {\n              calls: assetAddresses.map((address, i) => ({\n                to: address,\n                abi: [AbiFunction.from('function symbol() returns (string)')],\n                functionName: 'symbol',\n                from: zeroAddress,\n                nonce: i,\n              })),\n              stateOverrides: [\n                {\n                  address: zeroAddress,\n                  nonce: 0,\n                },\n              ],\n            },\n          ]\n        : []),\n    ],\n    traceTransfers,\n    validation,\n  })\n\n  const block_results = traceAssetChanges ? blocks[2] : blocks[0]\n  const [\n    block_ethPre,\n    block_assetsPre,\n    ,\n    block_ethPost,\n    block_assetsPost,\n    block_decimals,\n    block_tokenURI,\n    block_symbols,\n  ] = traceAssetChanges ? blocks : []\n\n  // Extract call results from the simulation.\n  const { calls: block_calls, ...block } = block_results\n  const results = block_calls.slice(0, -1) ?? []\n\n  // Extract pre-execution ETH and asset balances.\n  const ethPre = block_ethPre?.calls ?? []\n  const assetsPre = block_assetsPre?.calls ?? []\n  const balancesPre = [...ethPre, ...assetsPre].map((call) =>\n    call.status === 'success' ? hexToBigInt(call.data) : null,\n  )\n\n  // Extract post-execution ETH and asset balances.\n  const ethPost = block_ethPost?.calls ?? []\n  const assetsPost = block_assetsPost?.calls ?? []\n  const balancesPost = [...ethPost, ...assetsPost].map((call) =>\n    call.status === 'success' ? hexToBigInt(call.data) : null,\n  )\n\n  // Extract asset symbols & decimals.\n  const decimals = (block_decimals?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (number | null)[]\n  const symbols = (block_symbols?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (string | null)[]\n  const tokenURI = (block_tokenURI?.calls ?? []).map((x) =>\n    x.status === 'success' ? x.result : null,\n  ) as (string | null)[]\n\n  const changes: Mutable<SimulateCallsReturnType<calls>['assetChanges']> = []\n  for (const [i, balancePost] of balancesPost.entries()) {\n    const balancePre = balancesPre[i]\n\n    if (typeof balancePost !== 'bigint') continue\n    if (typeof balancePre !== 'bigint') continue\n\n    const decimals_ = decimals[i - 1]\n    const symbol_ = symbols[i - 1]\n    const tokenURI_ = tokenURI[i - 1]\n\n    const token = (() => {\n      if (i === 0)\n        return {\n          address: ethAddress,\n          decimals: 18,\n          symbol: 'ETH',\n        }\n\n      return {\n        address: assetAddresses[i - 1]! as Address,\n        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,\n        symbol: symbol_ ?? undefined,\n      }\n    })()\n\n    if (changes.some((change) => change.token.address === token.address))\n      continue\n\n    changes.push({\n      token,\n      value: {\n        pre: balancePre,\n        post: balancePost,\n        diff: balancePost - balancePre,\n      },\n    })\n  }\n\n  return {\n    assetChanges: changes,\n    block,\n    results,\n  } as unknown as SimulateCallsReturnType<calls>\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetBlobBaseFeeReturnType = bigint\n\nexport type GetBlobBaseFeeErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the base fee per blob gas in wei.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlobBaseFee\n * - JSON-RPC Methods: [`eth_blobBaseFee`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blobBaseFee)\n *\n * @param client - Client to use\n * @returns The blob base fee (in wei). {@link GetBlobBaseFeeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlobBaseFee } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const blobBaseFee = await getBlobBaseFee(client)\n */\nexport async function getBlobBaseFee<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n): Promise<GetBlobBaseFeeReturnType> {\n  const baseFee = await client.request({\n    method: 'eth_blobBaseFee',\n  })\n  return BigInt(baseFee)\n}\n","import type { Abi, AbiFunction, AbiStateMutability, Address } from 'abitype'\n\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, ParseAccount } from '../../types/account.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n  ContractFunctionParameters,\n  ContractFunctionReturnType,\n  ExtractAbiFunctionForArgs,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type {\n  IsNarrowable,\n  NoInfer,\n  Prettify,\n  UnionEvaluate,\n  UnionOmit,\n} from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetContractErrorReturnType,\n  getContractError,\n} from '../../utils/errors/getContractError.js'\nimport { getAction } from '../../utils/getAction.js'\nimport type { WriteContractParameters } from '../wallet/writeContract.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type GetMutabilityAwareValue<\n  abi extends Abi | readonly unknown[],\n  mutability extends AbiStateMutability = AbiStateMutability,\n  functionName extends ContractFunctionName<\n    abi,\n    mutability\n  > = ContractFunctionName<abi, mutability>,\n  valueType = TransactionRequest['value'],\n  args extends ContractFunctionArgs<\n    abi,\n    mutability,\n    functionName\n  > = ContractFunctionArgs<abi, mutability, functionName>,\n  abiFunction extends AbiFunction = abi extends Abi\n    ? ExtractAbiFunctionForArgs<abi, mutability, functionName, args>\n    : AbiFunction,\n  _Narrowable extends boolean = IsNarrowable<abi, Abi>,\n> = _Narrowable extends true\n  ? abiFunction['stateMutability'] extends 'payable'\n    ? { value?: NoInfer<valueType> | undefined }\n    : abiFunction['payable'] extends true\n      ? { value?: NoInfer<valueType> | undefined }\n      : { value?: undefined }\n  : { value?: NoInfer<valueType> | undefined }\n\nexport type SimulateContractParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  accountOverride extends Account | Address | null | undefined = undefined,\n  ///\n  derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  account?: accountOverride | null | undefined\n  chain?: chainOverride | undefined\n  /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n  dataSuffix?: Hex | undefined\n} & ContractFunctionParameters<\n  abi,\n  'nonpayable' | 'payable',\n  functionName,\n  args\n> &\n  UnionOmit<\n    CallParameters<derivedChain>,\n    | 'account'\n    | 'batch'\n    | 'code'\n    | 'to'\n    | 'data'\n    | 'factory'\n    | 'factoryData'\n    | 'value'\n  > &\n  GetMutabilityAwareValue<\n    abi,\n    'nonpayable' | 'payable',\n    functionName,\n    CallParameters<derivedChain> extends CallParameters\n      ? CallParameters<derivedChain>['value']\n      : CallParameters['value'],\n    args\n  >\n\nexport type SimulateContractReturnType<\n  out abi extends Abi | readonly unknown[] = Abi,\n  in out functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  in out args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  /** @ts-expect-error cast variance */\n  out chain extends Chain | undefined = Chain | undefined,\n  out account extends Account | undefined = Account | undefined,\n  out chainOverride extends Chain | undefined = Chain | undefined,\n  out accountOverride extends Account | Address | null | undefined =\n    | Account\n    | Address\n    | null\n    | undefined,\n  ///\n  in out minimizedAbi extends Abi = readonly [\n    ExtractAbiFunctionForArgs<\n      abi extends Abi ? abi : Abi,\n      'nonpayable' | 'payable',\n      functionName,\n      args\n    >,\n  ],\n  out resolvedAccount extends\n    | Account\n    | null\n    | undefined = accountOverride extends Account | Address | null\n    ? ParseAccount<accountOverride>\n    : account,\n> = {\n  result: ContractFunctionReturnType<\n    minimizedAbi,\n    'nonpayable' | 'payable',\n    functionName,\n    args\n  >\n  request: Prettify<\n    UnionEvaluate<\n      UnionOmit<\n        WriteContractParameters<\n          minimizedAbi,\n          functionName,\n          args,\n          chain,\n          undefined,\n          chainOverride\n        >,\n        'account' | 'abi' | 'args' | 'chain' | 'functionName'\n      >\n    > &\n      ContractFunctionParameters<\n        minimizedAbi,\n        'nonpayable' | 'payable',\n        functionName,\n        args\n      > & {\n        chain: DeriveChain<chain, chainOverride>\n      } & (resolvedAccount extends Account | null\n        ? { account: resolvedAccount }\n        : { account?: undefined })\n  >\n}\n\nexport type SimulateContractErrorType =\n  | ParseAccountErrorType\n  | EncodeFunctionDataErrorType\n  | GetContractErrorReturnType<CallErrorType | DecodeFunctionResultErrorType>\n  | ErrorType\n\n/**\n * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n *\n * - Docs: https://viem.sh/docs/contract/simulateContract\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n *\n * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateContractParameters}\n * @returns The simulation result and write request. {@link SimulateContractReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n *   functionName: 'mint',\n *   args: ['69420'],\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function simulateContract<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  const args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined = undefined,\n  accountOverride extends Account | Address | null | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SimulateContractParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    chainOverride,\n    accountOverride\n  >,\n): Promise<\n  SimulateContractReturnType<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride,\n    accountOverride\n  >\n> {\n  const { abi, address, args, dataSuffix, functionName, ...callRequest } =\n    parameters as SimulateContractParameters\n\n  const account = callRequest.account\n    ? parseAccount(callRequest.account)\n    : client.account\n  const calldata = encodeFunctionData({ abi, args, functionName })\n  try {\n    const { data } = await getAction(\n      client,\n      call,\n      'call',\n    )({\n      batch: false,\n      data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...callRequest,\n      account,\n    })\n    const result = decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    })\n    const minimizedAbi = abi.filter(\n      (abiItem) =>\n        'name' in abiItem && abiItem.name === parameters.functionName,\n    )\n    return {\n      result,\n      request: {\n        abi: minimizedAbi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...callRequest,\n        account,\n      },\n    } as unknown as SimulateContractReturnType<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >\n  } catch (error) {\n    throw getContractError(error as BaseError, {\n      abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n","import type { Address } from 'abitype'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { Account, ParseAccount } from '../types/account.js'\nimport type { Chain } from '../types/chain.js'\nimport type { PublicRpcSchema, RpcSchema } from '../types/eip1193.js'\nimport type { Prettify } from '../types/utils.js'\nimport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from './createClient.js'\nimport { type PublicActions, publicActions } from './decorators/public.js'\nimport type { Transport } from './transports/createTransport.js'\n\nexport type PublicClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  accountOrAddress extends Account | Address | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, accountOrAddress, rpcSchema>,\n    | 'batch'\n    | 'cacheTime'\n    | 'ccipRead'\n    | 'chain'\n    | 'experimental_blockTag'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'rpcSchema'\n    | 'transport'\n  >\n>\n\nexport type PublicClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  accountOrAddress extends Account | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain,\n    accountOrAddress,\n    rpcSchema extends RpcSchema\n      ? [...PublicRpcSchema, ...rpcSchema]\n      : PublicRpcSchema,\n    PublicActions<transport, chain>\n  >\n>\n\nexport type CreatePublicClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * Creates a Public Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/docs/clients/public\n *\n * A Public Client is an interface to \"public\" [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) methods such as retrieving block numbers, transactions, reading from smart contracts, etc through [Public Actions](/docs/actions/public/introduction).\n *\n * @param config - {@link PublicClientConfig}\n * @returns A Public Client. {@link PublicClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n */\nexport function createPublicClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  accountOrAddress extends Account | Address | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: PublicClientConfig<transport, chain, accountOrAddress, rpcSchema>,\n): PublicClient<transport, chain, ParseAccount<accountOrAddress>, rpcSchema> {\n  const { key = 'public', name = 'Public Client' } = parameters\n  const client = createClient({\n    ...parameters,\n    key,\n    name,\n    type: 'publicClient',\n  })\n  return client.extend(publicActions) as any\n}\n","import type { Address, TypedData } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type HashTypedDataErrorType,\n  hashTypedData,\n} from '../../utils/signature/hashTypedData.js'\nimport {\n  type VerifyHashErrorType,\n  type VerifyHashParameters,\n  verifyHash,\n} from './verifyHash.js'\n\nexport type VerifyTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = Omit<VerifyHashParameters, 'hash'> &\n  TypedDataDefinition<typedData, primaryType> & {\n    /** The address to verify the typed data for. */\n    address: Address\n    /** The signature to verify */\n    signature: Hex | ByteArray | Signature\n  }\n\nexport type VerifyTypedDataReturnType = boolean\n\nexport type VerifyTypedDataErrorType =\n  | HashTypedDataErrorType\n  | VerifyHashErrorType\n  | ErrorType\n\n/**\n * Verify that typed data was signed by the provided address.\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  parameters: VerifyTypedDataParameters<typedData, primaryType>,\n): Promise<VerifyTypedDataReturnType> {\n  const {\n    address,\n    factory,\n    factoryData,\n    signature,\n    message,\n    primaryType,\n    types,\n    domain,\n    ...callRequest\n  } = parameters as VerifyTypedDataParameters\n  const hash = hashTypedData({ message, primaryType, types, domain })\n  return verifyHash(client, {\n    address,\n    factory: factory!,\n    factoryData: factoryData!,\n    hash,\n    signature,\n    ...callRequest,\n  })\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { HasTransportType } from '../../types/transport.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockReturnType, getBlock } from './getBlock.js'\n\nexport type OnBlockParameter<\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = GetBlockReturnType<chain, includeTransactions, blockTag>\n\nexport type OnBlock<\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = (\n  block: OnBlockParameter<chain, includeTransactions, blockTag>,\n  prevBlock: OnBlockParameter<chain, includeTransactions, blockTag> | undefined,\n) => void\n\nexport type WatchBlocksParameters<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n> = {\n  /** The callback to call when a new block is received. */\n  onBlock: OnBlock<chain, includeTransactions, blockTag>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n} & (\n  | (HasTransportType<transport, 'webSocket' | 'ipc'> extends true\n      ? {\n          blockTag?: undefined\n          emitMissed?: undefined\n          emitOnBegin?: undefined\n          includeTransactions?: undefined\n          /** Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`. */\n          poll?: false | undefined\n          pollingInterval?: undefined\n        }\n      : never)\n  | {\n      /** The block tag. Defaults to \"latest\". */\n      blockTag?: blockTag | BlockTag | undefined\n      /** Whether or not to emit the missed blocks to the callback. */\n      emitMissed?: boolean | undefined\n      /** Whether or not to emit the block to the callback when the subscription opens. */\n      emitOnBegin?: boolean | undefined\n      /** Whether or not to include transaction data in the response. */\n      includeTransactions?: includeTransactions | undefined\n      poll?: true | undefined\n      /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */\n      pollingInterval?: number | undefined\n    }\n)\n\nexport type WatchBlocksReturnType = () => void\n\nexport type WatchBlocksErrorType =\n  | StringifyErrorType\n  | PollErrorType\n  | ErrorType\n\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks<\n  transport extends Transport,\n  chain extends Chain | undefined,\n  includeTransactions extends boolean = false,\n  blockTag extends BlockTag = 'latest',\n>(\n  client: Client<transport, chain>,\n  {\n    blockTag = client.experimental_blockTag ?? 'latest',\n    emitMissed = false,\n    emitOnBegin = false,\n    onBlock,\n    onError,\n    includeTransactions: includeTransactions_,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlocksParameters<transport, chain, includeTransactions, blockTag>,\n): WatchBlocksReturnType {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n  const includeTransactions = includeTransactions_ ?? false\n\n  let prevBlock:\n    | GetBlockReturnType<chain, false | includeTransactions, 'latest'>\n    | undefined\n\n  const pollBlocks = () => {\n    const observerId = stringify([\n      'watchBlocks',\n      client.uid,\n      blockTag,\n      emitMissed,\n      emitOnBegin,\n      includeTransactions,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onBlock, onError }, (emit) =>\n      poll(\n        async () => {\n          try {\n            const block = await getAction(\n              client,\n              getBlock,\n              'getBlock',\n            )({\n              blockTag,\n              includeTransactions,\n            })\n            if (block.number !== null && prevBlock?.number != null) {\n              // If the current block number is the same as the previous,\n              // we can skip.\n              if (block.number === prevBlock.number) return\n\n              // If we have missed out on some previous blocks, and the\n              // `emitMissed` flag is truthy, let's emit those blocks.\n              if (block.number - prevBlock.number > 1 && emitMissed) {\n                for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n                  const block = (await getAction(\n                    client,\n                    getBlock,\n                    'getBlock',\n                  )({\n                    blockNumber: i,\n                    includeTransactions,\n                  })) as GetBlockReturnType<chain>\n                  emit.onBlock(block as any, prevBlock as any)\n                  prevBlock = block\n                }\n              }\n            }\n\n            if (\n              // If no previous block exists, emit.\n              prevBlock?.number == null ||\n              // If the block tag is \"pending\" with no block number, emit.\n              (blockTag === 'pending' && block?.number == null) ||\n              // If the next block number is greater than the previous block number, emit.\n              // We don't want to emit blocks in the past.\n              (block.number !== null && block.number > prevBlock.number)\n            ) {\n              emit.onBlock(block as any, prevBlock as any)\n              prevBlock = block as any\n            }\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin,\n          interval: pollingInterval,\n        },\n      ),\n    )\n  }\n\n  const subscribeBlocks = () => {\n    let active = true\n    let emitFetched = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        if (emitOnBegin) {\n          getAction(\n            client,\n            getBlock,\n            'getBlock',\n          )({\n            blockTag,\n            includeTransactions,\n          })\n            .then((block) => {\n              if (!active) return\n              if (!emitFetched) return\n              onBlock(block as any, undefined)\n              emitFetched = false\n            })\n            .catch(onError)\n        }\n\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(\n              (transport: ReturnType<Transport>) =>\n                transport.config.type === 'webSocket' ||\n                transport.config.type === 'ipc',\n            )\n            if (!transport) return client.transport\n            return transport.value\n          }\n          return client.transport\n        })()\n\n        const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n          params: ['newHeads'],\n          async onData(data: any) {\n            if (!active) return\n            const block = (await getAction(\n              client,\n              getBlock,\n              'getBlock',\n            )({\n              blockNumber: data.result?.number,\n              includeTransactions,\n            }).catch(() => {})) as GetBlockReturnType<chain>\n            if (!active) return\n            onBlock(block as any, prevBlock as any)\n            emitFetched = false\n            prevBlock = block\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return () => unsubscribe()\n  }\n\n  return enablePolling ? pollBlocks() : subscribeBlocks()\n}\n","import type { AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport { InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockNumber } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { LogTopic } from '../../types/misc.js'\nimport type { GetPollOptions } from '../../types/transport.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\nimport {\n  type CreateEventFilterParameters,\n  createEventFilter,\n} from './createEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { type GetLogsParameters, getLogs } from './getLogs.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type WatchEventOnLogsParameter<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = Log<bigint, number, false, abiEvent, strict, abiEvents, eventName>[]\nexport type WatchEventOnLogsFn<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = (\n  logs: WatchEventOnLogsParameter<abiEvent, abiEvents, strict, _eventName>,\n) => void\n\nexport type WatchEventParameters<\n  abiEvent extends AbiEvent | undefined = undefined,\n  abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n  //\n  _eventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[] | undefined\n  /** Block to start listening from. */\n  fromBlock?: BlockNumber<bigint> | undefined\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: ((error: Error) => void) | undefined\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchEventOnLogsFn<abiEvent, abiEvents, strict, _eventName>\n} & GetPollOptions<transport> &\n  (\n    | {\n        event: abiEvent\n        events?: undefined\n        args?: MaybeExtractEventArgsFromAbi<abiEvents, _eventName> | undefined\n        /**\n         * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n         * @default false\n         */\n        strict?: strict | undefined\n      }\n    | {\n        event?: undefined\n        events?: abiEvents | undefined\n        args?: undefined\n        /**\n         * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n         * @default false\n         */\n        strict?: strict | undefined\n      }\n    | {\n        event?: undefined\n        events?: undefined\n        args?: undefined\n        strict?: undefined\n      }\n  )\n\nexport type WatchEventReturnType = () => void\n\nexport type WatchEventErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent<\n  chain extends Chain | undefined,\n  const abiEvent extends AbiEvent | undefined = undefined,\n  const abiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n  strict extends boolean | undefined = undefined,\n  transport extends Transport = Transport,\n  _eventName extends string | undefined = undefined,\n>(\n  client: Client<transport, chain>,\n  {\n    address,\n    args,\n    batch = true,\n    event,\n    events,\n    fromBlock,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  }: WatchEventParameters<abiEvent, abiEvents, strict, transport>,\n): WatchEventReturnType {\n  const enablePolling = (() => {\n    if (typeof poll_ !== 'undefined') return poll_\n    if (typeof fromBlock === 'bigint') return true\n    if (\n      client.transport.type === 'webSocket' ||\n      client.transport.type === 'ipc'\n    )\n      return false\n    if (\n      client.transport.type === 'fallback' &&\n      (client.transport.transports[0].config.type === 'webSocket' ||\n        client.transport.transports[0].config.type === 'ipc')\n    )\n      return false\n    return true\n  })()\n  const strict = strict_ ?? false\n\n  const pollEvent = () => {\n    const observerId = stringify([\n      'watchEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      event,\n      pollingInterval,\n      fromBlock,\n    ])\n\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      let previousBlockNumber: bigint\n      if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n\n      let filter: Filter<'event', abiEvents, _eventName, any>\n      let initialized = false\n\n      const unwatch = poll(\n        async () => {\n          if (!initialized) {\n            try {\n              filter = (await getAction(\n                client,\n                createEventFilter as any,\n                'createEventFilter',\n              )({\n                address,\n                args,\n                event: event!,\n                events,\n                strict,\n                fromBlock,\n              } as unknown as CreateEventFilterParameters)) as unknown as Filter<\n                'event',\n                abiEvents,\n                _eventName\n              >\n            } catch {}\n            initialized = true\n            return\n          }\n\n          try {\n            let logs: Log[]\n            if (filter) {\n              logs = await getAction(\n                client,\n                getFilterChanges,\n                'getFilterChanges',\n              )({ filter })\n            } else {\n              // If the filter doesn't exist, we will fall back to use `getLogs`.\n              // The fall back exists because some RPC Providers do not support filters.\n\n              // Fetch the block number to use for `getLogs`.\n              const blockNumber = await getAction(\n                client,\n                getBlockNumber,\n                'getBlockNumber',\n              )({})\n\n              // If the block number has changed, we will need to fetch the logs.\n              // If the block number doesn't exist, we are yet to reach the first poll interval,\n              // so do not emit any logs.\n              if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n                logs = await getAction(\n                  client,\n                  getLogs,\n                  'getLogs',\n                )({\n                  address,\n                  args,\n                  event: event!,\n                  events,\n                  fromBlock: previousBlockNumber + 1n,\n                  toBlock: blockNumber,\n                } as unknown as GetLogsParameters)\n              } else {\n                logs = []\n              }\n              previousBlockNumber = blockNumber\n            }\n\n            if (logs.length === 0) return\n            if (batch) emit.onLogs(logs as any)\n            else for (const log of logs) emit.onLogs([log] as any)\n          } catch (err) {\n            // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n            // Reinitialize the filter when this occurs\n            if (filter && err instanceof InvalidInputRpcError)\n              initialized = false\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribeEvent = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const transport = (() => {\n          if (client.transport.type === 'fallback') {\n            const transport = client.transport.transports.find(\n              (transport: ReturnType<Transport>) =>\n                transport.config.type === 'webSocket' ||\n                transport.config.type === 'ipc',\n            )\n            if (!transport) return client.transport\n            return transport.value\n          }\n          return client.transport\n        })()\n\n        const events_ = events ?? (event ? [event] : undefined)\n        let topics: LogTopic[] = []\n        if (events_) {\n          const encoded = (events_ as AbiEvent[]).flatMap((event) =>\n            encodeEventTopics({\n              abi: [event],\n              eventName: (event as AbiEvent).name,\n              args,\n            } as EncodeEventTopicsParameters),\n          )\n          // TODO: Clean up type casting\n          topics = [encoded as LogTopic]\n          if (event) topics = topics[0] as LogTopic[]\n        }\n\n        const { unsubscribe: unsubscribe_ } = await transport.subscribe({\n          params: ['logs', { address, topics }],\n          onData(data: any) {\n            if (!active) return\n            const log = data.result\n            try {\n              const { eventName, args } = decodeEventLog({\n                abi: events_ ?? [],\n                data: log.data,\n                topics: log.topics,\n                strict,\n              })\n              const formatted = formatLog(log, { args, eventName })\n              onLogs([formatted] as any)\n            } catch (err) {\n              let eventName: string | undefined\n              let isUnnamed: boolean | undefined\n              if (\n                err instanceof DecodeLogDataMismatch ||\n                err instanceof DecodeLogTopicsMismatch\n              ) {\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict_) return\n                eventName = err.abiItem.name\n                isUnnamed = err.abiItem.inputs?.some(\n                  (x) => !('name' in x && x.name),\n                )\n              }\n\n              // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n              const formatted = formatLog(log, {\n                args: isUnnamed ? [] : {},\n                eventName,\n              })\n              onLogs([formatted] as any)\n            }\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return () => unsubscribe()\n  }\n\n  return enablePolling ? pollEvent() : subscribeEvent()\n}\n","import type { Address } from 'abitype'\n\nimport type { ExactPartial } from '../../types/utils.js'\nimport { isAddress } from '../address/isAddress.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport type { SiweMessage } from './types.js'\n\nexport type ValidateSiweMessageParameters = {\n  /**\n   * Ethereum address to check against.\n   */\n  address?: Address | undefined\n  /**\n   * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986) authority to check against.\n   */\n  domain?: string | undefined\n  /**\n   * EIP-4361 message fields.\n   */\n  message: ExactPartial<SiweMessage>\n  /**\n   * Random string to check against.\n   */\n  nonce?: string | undefined\n  /**\n   * [RFC 3986](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) URI scheme to check against.\n   */\n  scheme?: string | undefined\n  /**\n   * Current time to check optional `expirationTime` and `notBefore` fields.\n   *\n   * @default new Date()\n   */\n  time?: Date | undefined\n}\n\nexport type ValidateSiweMessageReturnType = boolean\n\n/**\n * @description Validates EIP-4361 message.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4361\n */\nexport function validateSiweMessage(\n  parameters: ValidateSiweMessageParameters,\n): ValidateSiweMessageReturnType {\n  const {\n    address,\n    domain,\n    message,\n    nonce,\n    scheme,\n    time = new Date(),\n  } = parameters\n\n  if (domain && message.domain !== domain) return false\n  if (nonce && message.nonce !== nonce) return false\n  if (scheme && message.scheme !== scheme) return false\n\n  if (message.expirationTime && time >= message.expirationTime) return false\n  if (message.notBefore && time < message.notBefore) return false\n\n  try {\n    if (!message.address) return false\n    if (!isAddress(message.address, { strict: false })) return false\n    if (address && !isAddressEqual(message.address, address)) return false\n  } catch {\n    return false\n  }\n\n  return true\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { HashMessageErrorType } from '../../utils/signature/hashMessage.js'\nimport { hashMessage } from '../../utils/signature/hashMessage.js'\nimport { parseSiweMessage } from '../../utils/siwe/parseSiweMessage.js'\nimport {\n  type ValidateSiweMessageParameters,\n  validateSiweMessage,\n} from '../../utils/siwe/validateSiweMessage.js'\nimport {\n  type VerifyHashErrorType,\n  type VerifyHashParameters,\n  verifyHash,\n} from '../public/verifyHash.js'\n\nexport type VerifySiweMessageParameters = Prettify<\n  Pick<VerifyHashParameters, 'blockNumber' | 'blockTag'> &\n    Pick<\n      ValidateSiweMessageParameters,\n      'address' | 'domain' | 'nonce' | 'scheme' | 'time'\n    > & {\n      /**\n       * EIP-4361 formatted message.\n       */\n      message: string\n      /**\n       * Signature to check against.\n       */\n      signature: Hex\n    }\n>\n\nexport type VerifySiweMessageReturnType = boolean\n\nexport type VerifySiweMessageErrorType =\n  | HashMessageErrorType\n  | VerifyHashErrorType\n  | ErrorType\n\n/**\n * Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/siwe/actions/verifySiweMessage}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifySiweMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifySiweMessageReturnType}\n */\nexport async function verifySiweMessage<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: VerifySiweMessageParameters,\n): Promise<VerifySiweMessageReturnType> {\n  const {\n    address,\n    domain,\n    message,\n    nonce,\n    scheme,\n    signature,\n    time = new Date(),\n    ...callRequest\n  } = parameters\n\n  const parsed = parseSiweMessage(message)\n  if (!parsed.address) return false\n\n  const isValid = validateSiweMessage({\n    address,\n    domain,\n    message: parsed,\n    nonce,\n    scheme,\n    time,\n  })\n  if (!isValid) return false\n\n  const hash = hashMessage(message)\n  return verifyHash(client, {\n    address: parsed.address,\n    hash,\n    signature,\n    ...callRequest,\n  })\n}\n","import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ByteArray,\n  Hex,\n  SignableMessage,\n  Signature,\n} from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { HashMessageErrorType } from '../../utils/signature/hashMessage.js'\nimport { hashMessage } from '../../utils/signature/hashMessage.js'\nimport {\n  type VerifyHashErrorType,\n  type VerifyHashParameters,\n  verifyHash,\n} from './verifyHash.js'\n\nexport type VerifyMessageParameters = Prettify<\n  Omit<VerifyHashParameters, 'hash'> & {\n    /** The address that signed the original message. */\n    address: Address\n    /** The message to be verified. */\n    message: SignableMessage\n    /** The signature that was generated by signing the message with the address's private key. */\n    signature: Hex | ByteArray | Signature\n  }\n>\n\nexport type VerifyMessageReturnType = boolean\n\nexport type VerifyMessageErrorType =\n  | HashMessageErrorType\n  | VerifyHashErrorType\n  | ErrorType\n\n/**\n * Verify that a message was signed by the provided address.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n */\nexport async function verifyMessage<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    address,\n    message,\n    factory,\n    factoryData,\n    signature,\n    ...callRequest\n  }: VerifyMessageParameters,\n): Promise<VerifyMessageReturnType> {\n  const hash = hashMessage(message)\n  return verifyHash(client, {\n    address,\n    factory: factory!,\n    factoryData: factoryData!,\n    hash,\n    signature,\n    ...callRequest,\n  })\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { TransactionReceiptRevertedError } from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { TransactionSerializedGeneric } from '../../types/transaction.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { formatTransactionReceipt } from '../../utils/formatters/transactionReceipt.js'\nimport {\n  type FormattedTransactionReceipt,\n  numberToHex,\n} from '../../utils/index.js'\n\nexport type SendRawTransactionSyncParameters = {\n  /** The signed serialized transaction. */\n  serializedTransaction: TransactionSerializedGeneric\n  /** Whether to throw an error if the transaction was detected as reverted. @default true */\n  throwOnReceiptRevert?: boolean | undefined\n  /** The timeout for the transaction. */\n  timeout?: number | undefined\n}\n\nexport type SendRawTransactionSyncReturnType<\n  chain extends Chain | undefined = undefined,\n> = FormattedTransactionReceipt<chain>\n\nexport type SendRawTransactionSyncErrorType = RequestErrorType | ErrorType\n\n/**\n * Sends a **signed** transaction to the network synchronously,\n * and waits for the transaction to be included in a block.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransactionSync\n * - JSON-RPC Method: [`eth_sendRawTransactionSync`](https://eips.ethereum.org/EIPS/eip-7966)\n *\n * @param client - Client to use\n * @param parameters - {@link SendRawTransactionParameters}\n * @returns The transaction receipt. {@link SendRawTransactionSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendRawTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const receipt = await sendRawTransactionSync(client, {\n *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n * })\n */\nexport async function sendRawTransactionSync<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    serializedTransaction,\n    throwOnReceiptRevert,\n    timeout,\n  }: SendRawTransactionSyncParameters,\n): Promise<SendRawTransactionSyncReturnType<chain>> {\n  const receipt = await client.request(\n    {\n      method: 'eth_sendRawTransactionSync',\n      params: timeout\n        ? [serializedTransaction, numberToHex(timeout)]\n        : [serializedTransaction],\n    },\n    { retryCount: 0 },\n  )\n  const format =\n    client.chain?.formatters?.transactionReceipt?.format ||\n    formatTransactionReceipt\n\n  const formatted = format(receipt) as SendRawTransactionSyncReturnType<chain>\n  if (formatted.status === 'reverted' && throwOnReceiptRevert)\n    throw new TransactionReceiptRevertedError({ receipt: formatted })\n  return formatted\n}\n","import type { Abi, AbiEvent, Address } from 'abitype'\n\nimport {\n  type GetEnsAddressParameters,\n  type GetEnsAddressReturnType,\n  getEnsAddress,\n} from '../../actions/ens/getEnsAddress.js'\nimport {\n  type GetEnsAvatarParameters,\n  type GetEnsAvatarReturnType,\n  getEnsAvatar,\n} from '../../actions/ens/getEnsAvatar.js'\nimport {\n  type GetEnsNameParameters,\n  type GetEnsNameReturnType,\n  getEnsName,\n} from '../../actions/ens/getEnsName.js'\nimport {\n  type GetEnsResolverParameters,\n  type GetEnsResolverReturnType,\n  getEnsResolver,\n} from '../../actions/ens/getEnsResolver.js'\nimport {\n  type GetEnsTextParameters,\n  type GetEnsTextReturnType,\n  getEnsText,\n} from '../../actions/ens/getEnsText.js'\nimport {\n  type CallParameters,\n  type CallReturnType,\n  call,\n} from '../../actions/public/call.js'\nimport {\n  type CreateAccessListParameters,\n  type CreateAccessListReturnType,\n  createAccessList,\n} from '../../actions/public/createAccessList.js'\nimport {\n  type CreateBlockFilterReturnType,\n  createBlockFilter,\n} from '../../actions/public/createBlockFilter.js'\nimport {\n  type CreateContractEventFilterParameters,\n  type CreateContractEventFilterReturnType,\n  createContractEventFilter,\n} from '../../actions/public/createContractEventFilter.js'\nimport {\n  type CreateEventFilterParameters,\n  type CreateEventFilterReturnType,\n  createEventFilter,\n} from '../../actions/public/createEventFilter.js'\nimport {\n  type CreatePendingTransactionFilterReturnType,\n  createPendingTransactionFilter,\n} from '../../actions/public/createPendingTransactionFilter.js'\nimport {\n  type EstimateContractGasParameters,\n  type EstimateContractGasReturnType,\n  estimateContractGas,\n} from '../../actions/public/estimateContractGas.js'\nimport {\n  type EstimateFeesPerGasParameters,\n  type EstimateFeesPerGasReturnType,\n  estimateFeesPerGas,\n} from '../../actions/public/estimateFeesPerGas.js'\nimport {\n  type EstimateGasParameters,\n  type EstimateGasReturnType,\n  estimateGas,\n} from '../../actions/public/estimateGas.js'\nimport {\n  type EstimateMaxPriorityFeePerGasParameters,\n  type EstimateMaxPriorityFeePerGasReturnType,\n  estimateMaxPriorityFeePerGas,\n} from '../../actions/public/estimateMaxPriorityFeePerGas.js'\nimport {\n  type GetBalanceParameters,\n  type GetBalanceReturnType,\n  getBalance,\n} from '../../actions/public/getBalance.js'\nimport {\n  type GetBlobBaseFeeReturnType,\n  getBlobBaseFee,\n} from '../../actions/public/getBlobBaseFee.js'\nimport {\n  type GetBlockParameters,\n  type GetBlockReturnType,\n  getBlock,\n} from '../../actions/public/getBlock.js'\nimport {\n  type GetBlockNumberParameters,\n  type GetBlockNumberReturnType,\n  getBlockNumber,\n} from '../../actions/public/getBlockNumber.js'\nimport {\n  type GetBlockTransactionCountParameters,\n  type GetBlockTransactionCountReturnType,\n  getBlockTransactionCount,\n} from '../../actions/public/getBlockTransactionCount.js'\nimport {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../actions/public/getChainId.js'\nimport {\n  type GetCodeParameters,\n  type GetCodeReturnType,\n  getCode,\n} from '../../actions/public/getCode.js'\nimport {\n  type GetContractEventsParameters,\n  type GetContractEventsReturnType,\n  getContractEvents,\n} from '../../actions/public/getContractEvents.js'\nimport {\n  type GetEip712DomainParameters,\n  type GetEip712DomainReturnType,\n  getEip712Domain,\n} from '../../actions/public/getEip712Domain.js'\nimport {\n  type GetFeeHistoryParameters,\n  type GetFeeHistoryReturnType,\n  getFeeHistory,\n} from '../../actions/public/getFeeHistory.js'\nimport {\n  type GetFilterChangesParameters,\n  type GetFilterChangesReturnType,\n  getFilterChanges,\n} from '../../actions/public/getFilterChanges.js'\nimport {\n  type GetFilterLogsParameters,\n  type GetFilterLogsReturnType,\n  getFilterLogs,\n} from '../../actions/public/getFilterLogs.js'\nimport {\n  type GetGasPriceReturnType,\n  getGasPrice,\n} from '../../actions/public/getGasPrice.js'\nimport {\n  type GetLogsParameters,\n  type GetLogsReturnType,\n  getLogs,\n} from '../../actions/public/getLogs.js'\nimport {\n  type GetProofParameters,\n  type GetProofReturnType,\n  getProof,\n} from '../../actions/public/getProof.js'\nimport {\n  type GetStorageAtParameters,\n  type GetStorageAtReturnType,\n  getStorageAt,\n} from '../../actions/public/getStorageAt.js'\nimport {\n  type GetTransactionParameters,\n  type GetTransactionReturnType,\n  getTransaction,\n} from '../../actions/public/getTransaction.js'\nimport {\n  type GetTransactionConfirmationsParameters,\n  type GetTransactionConfirmationsReturnType,\n  getTransactionConfirmations,\n} from '../../actions/public/getTransactionConfirmations.js'\nimport {\n  type GetTransactionCountParameters,\n  type GetTransactionCountReturnType,\n  getTransactionCount,\n} from '../../actions/public/getTransactionCount.js'\nimport {\n  type GetTransactionReceiptParameters,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from '../../actions/public/getTransactionReceipt.js'\nimport {\n  type MulticallParameters,\n  type MulticallReturnType,\n  multicall,\n} from '../../actions/public/multicall.js'\nimport {\n  type ReadContractParameters,\n  type ReadContractReturnType,\n  readContract,\n} from '../../actions/public/readContract.js'\nimport {\n  type SimulateBlocksParameters,\n  type SimulateBlocksReturnType,\n  simulateBlocks,\n} from '../../actions/public/simulateBlocks.js'\nimport {\n  type SimulateCallsParameters,\n  type SimulateCallsReturnType,\n  simulateCalls,\n} from '../../actions/public/simulateCalls.js'\nimport {\n  type SimulateContractParameters,\n  type SimulateContractReturnType,\n  simulateContract,\n} from '../../actions/public/simulateContract.js'\nimport {\n  type UninstallFilterParameters,\n  type UninstallFilterReturnType,\n  uninstallFilter,\n} from '../../actions/public/uninstallFilter.js'\nimport {\n  type VerifyHashParameters,\n  type VerifyHashReturnType,\n  verifyHash,\n} from '../../actions/public/verifyHash.js'\nimport {\n  type VerifyMessageParameters,\n  type VerifyMessageReturnType,\n  verifyMessage,\n} from '../../actions/public/verifyMessage.js'\nimport {\n  type VerifyTypedDataParameters,\n  type VerifyTypedDataReturnType,\n  verifyTypedData,\n} from '../../actions/public/verifyTypedData.js'\nimport {\n  type WaitForTransactionReceiptParameters,\n  type WaitForTransactionReceiptReturnType,\n  waitForTransactionReceipt,\n} from '../../actions/public/waitForTransactionReceipt.js'\nimport {\n  type WatchBlockNumberParameters,\n  type WatchBlockNumberReturnType,\n  watchBlockNumber,\n} from '../../actions/public/watchBlockNumber.js'\nimport {\n  type WatchBlocksParameters,\n  type WatchBlocksReturnType,\n  watchBlocks,\n} from '../../actions/public/watchBlocks.js'\nimport {\n  type WatchContractEventParameters,\n  type WatchContractEventReturnType,\n  watchContractEvent,\n} from '../../actions/public/watchContractEvent.js'\nimport {\n  type WatchEventParameters,\n  type WatchEventReturnType,\n  watchEvent,\n} from '../../actions/public/watchEvent.js'\nimport {\n  type WatchPendingTransactionsParameters,\n  type WatchPendingTransactionsReturnType,\n  watchPendingTransactions,\n} from '../../actions/public/watchPendingTransactions.js'\nimport {\n  type VerifySiweMessageParameters,\n  type VerifySiweMessageReturnType,\n  verifySiweMessage,\n} from '../../actions/siwe/verifySiweMessage.js'\nimport {\n  type PrepareTransactionRequestParameters,\n  type PrepareTransactionRequestRequest,\n  type PrepareTransactionRequestReturnType,\n  prepareTransactionRequest,\n} from '../../actions/wallet/prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionParameters,\n  type SendRawTransactionReturnType,\n  sendRawTransaction,\n} from '../../actions/wallet/sendRawTransaction.js'\nimport {\n  type SendRawTransactionSyncParameters,\n  type SendRawTransactionSyncReturnType,\n  sendRawTransactionSync,\n} from '../../actions/wallet/sendRawTransactionSync.js'\nimport type { Account } from '../../types/account.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractEventName,\n  ContractFunctionArgs,\n  ContractFunctionName,\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { FeeValuesType } from '../../types/fee.js'\nimport type { FilterType } from '../../types/filter.js'\nimport type { Client } from '../createClient.js'\nimport type { Transport } from '../transports/createTransport.js'\n\nexport type PublicActions<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Executes a new message call immediately without submitting a transaction to the network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/call\n   * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n   *\n   * @param args - {@link CallParameters}\n   * @returns The call data. {@link CallReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const data = await client.call({\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   * })\n   */\n  call: (parameters: CallParameters<chain>) => Promise<CallReturnType>\n  /**\n   * Creates an EIP-2930 access list that you can include in a transaction.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/createAccessList\n   * - JSON-RPC Methods: `eth_createAccessList`\n   *\n   * @param args - {@link CreateAccessListParameters}\n   * @returns The call data. {@link CreateAccessListReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const data = await client.createAccessList({\n   *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   * })\n   */\n  createAccessList: (\n    parameters: CreateAccessListParameters<chain>,\n  ) => Promise<CreateAccessListReturnType>\n  /**\n   * Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/createBlockFilter\n   * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)\n   *\n   * @returns Filter. {@link CreateBlockFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, createBlockFilter, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await createBlockFilter(client)\n   * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'block' }\n   */\n  createBlockFilter: () => Promise<CreateBlockFilterReturnType>\n  /**\n   * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).\n   *\n   * - Docs: https://viem.sh/docs/contract/createContractEventFilter\n   *\n   * @param args - {@link CreateContractEventFilterParameters}\n   * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateContractEventFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createContractEventFilter({\n   *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n   * })\n   */\n  createContractEventFilter: <\n    const abi extends Abi | readonly unknown[],\n    eventName extends ContractEventName<abi> | undefined,\n    args extends MaybeExtractEventArgsFromAbi<abi, eventName> | undefined,\n    strict extends boolean | undefined = undefined,\n    fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args: CreateContractEventFilterParameters<\n      abi,\n      eventName,\n      args,\n      strict,\n      fromBlock,\n      toBlock\n    >,\n  ) => Promise<\n    CreateContractEventFilterReturnType<\n      abi,\n      eventName,\n      args,\n      strict,\n      fromBlock,\n      toBlock\n    >\n  >\n  /**\n   * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/createEventFilter\n   * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n   *\n   * @param args - {@link CreateEventFilterParameters}\n   * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createEventFilter({\n   *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n   * })\n   */\n  createEventFilter: <\n    const abiEvent extends AbiEvent | undefined = undefined,\n    const abiEvents extends\n      | readonly AbiEvent[]\n      | readonly unknown[]\n      | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n    strict extends boolean | undefined = undefined,\n    fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    toBlock extends BlockNumber | BlockTag | undefined = undefined,\n    _EventName extends string | undefined = MaybeAbiEventName<abiEvent>,\n    _Args extends\n      | MaybeExtractEventArgsFromAbi<abiEvents, _EventName>\n      | undefined = undefined,\n  >(\n    args?:\n      | CreateEventFilterParameters<\n          abiEvent,\n          abiEvents,\n          strict,\n          fromBlock,\n          toBlock,\n          _EventName,\n          _Args\n        >\n      | undefined,\n  ) => Promise<\n    CreateEventFilterReturnType<\n      abiEvent,\n      abiEvents,\n      strict,\n      fromBlock,\n      toBlock,\n      _EventName,\n      _Args\n    >\n  >\n  /**\n   * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter\n   * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)\n   *\n   * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createPendingTransactionFilter()\n   * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'transaction' }\n   */\n  createPendingTransactionFilter: () => Promise<CreatePendingTransactionFilterReturnType>\n  /**\n   * Estimates the gas required to successfully execute a contract write function call.\n   *\n   * - Docs: https://viem.sh/docs/contract/estimateContractGas\n   *\n   * @remarks\n   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n   *\n   * @param args - {@link EstimateContractGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const gas = await client.estimateContractGas({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint() public']),\n   *   functionName: 'mint',\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   * })\n   */\n  estimateContractGas: <\n    chain extends Chain | undefined,\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'nonpayable' | 'payable',\n      functionName\n    >,\n  >(\n    args: EstimateContractGasParameters<abi, functionName, args, chain>,\n  ) => Promise<EstimateContractGasReturnType>\n  /**\n   * Estimates the gas necessary to complete a transaction without submitting it to the network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/estimateGas\n   * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n   *\n   * @param args - {@link EstimateGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const gasEstimate = await client.estimateGas({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: parseEther('1'),\n   * })\n   */\n  estimateGas: (\n    args: EstimateGasParameters<chain>,\n  ) => Promise<EstimateGasReturnType>\n  /**\n   * Returns the balance of an address in wei.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBalance\n   * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)\n   *\n   * @remarks\n   * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther).\n   *\n   * ```ts\n   * const balance = await getBalance(client, {\n   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   blockTag: 'safe'\n   * })\n   * const balanceAsEther = formatEther(balance)\n   * // \"6.942\"\n   * ```\n   *\n   * @param args - {@link GetBalanceParameters}\n   * @returns The balance of the address in wei. {@link GetBalanceReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const balance = await client.getBalance({\n   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   * // 10000000000000000000000n (wei)\n   */\n  getBalance: (args: GetBalanceParameters) => Promise<GetBalanceReturnType>\n  /**\n   * Returns the base fee per blob gas in wei.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBlobBaseFee\n   * - JSON-RPC Methods: [`eth_blobBaseFee`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blobBaseFee)\n   *\n   * @param client - Client to use\n   * @returns The blob base fee (in wei). {@link GetBlobBaseFeeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { getBlobBaseFee } from 'viem/public'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const blobBaseFee = await client.getBlobBaseFee()\n   */\n  getBlobBaseFee: () => Promise<GetBlobBaseFeeReturnType>\n  /**\n   * Returns information about a block at a block number, hash, or tag.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBlock\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks\n   * - JSON-RPC Methods:\n   *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.\n   *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.\n   *\n   * @param args - {@link GetBlockParameters}\n   * @returns Information about the block. {@link GetBlockReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const block = await client.getBlock()\n   */\n  getBlock: <\n    includeTransactions extends boolean = false,\n    blockTag extends BlockTag = 'latest',\n  >(\n    args?: GetBlockParameters<includeTransactions, blockTag> | undefined,\n  ) => Promise<GetBlockReturnType<chain, includeTransactions, blockTag>>\n  /**\n   * Returns the number of the most recent block seen.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBlockNumber\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks\n   * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)\n   *\n   * @param args - {@link GetBlockNumberParameters}\n   * @returns The number of the block. {@link GetBlockNumberReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const blockNumber = await client.getBlockNumber()\n   * // 69420n\n   */\n  getBlockNumber: (\n    args?: GetBlockNumberParameters | undefined,\n  ) => Promise<GetBlockNumberReturnType>\n  /**\n   * Returns the number of Transactions at a block number, hash, or tag.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount\n   * - JSON-RPC Methods:\n   *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.\n   *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.\n   *\n   * @param args - {@link GetBlockTransactionCountParameters}\n   * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const count = await client.getBlockTransactionCount()\n   */\n  getBlockTransactionCount: (\n    args?: GetBlockTransactionCountParameters | undefined,\n  ) => Promise<GetBlockTransactionCountReturnType>\n  /** @deprecated Use `getCode` instead. */\n  getBytecode: (args: GetCodeParameters) => Promise<GetCodeReturnType>\n  /**\n   * Returns the chain ID associated with the current network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Retrieves the bytecode at an address.\n   *\n   * - Docs: https://viem.sh/docs/contract/getCode\n   * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)\n   *\n   * @param args - {@link GetBytecodeParameters}\n   * @returns The contract's bytecode. {@link GetBytecodeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const code = await client.getCode({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   * })\n   */\n  getCode: (args: GetCodeParameters) => Promise<GetCodeReturnType>\n  /**\n   * Returns a list of event logs emitted by a contract.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getContractEvents\n   * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetContractEventsParameters}\n   * @returns A list of event logs. {@link GetContractEventsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { wagmiAbi } from './abi'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const logs = await client.getContractEvents(client, {\n   *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *  abi: wagmiAbi,\n   *  eventName: 'Transfer'\n   * })\n   */\n  getContractEvents: <\n    const abi extends Abi | readonly unknown[],\n    eventName extends ContractEventName<abi> | undefined = undefined,\n    strict extends boolean | undefined = undefined,\n    fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args: GetContractEventsParameters<\n      abi,\n      eventName,\n      strict,\n      fromBlock,\n      toBlock\n    >,\n  ) => Promise<\n    GetContractEventsReturnType<abi, eventName, strict, fromBlock, toBlock>\n  >\n  /**\n   * Reads the EIP-712 domain from a contract, based on the ERC-5267 specification.\n   *\n   * @param client - A {@link Client} instance.\n   * @param parameters - The parameters of the action. {@link GetEip712DomainParameters}\n   * @returns The EIP-712 domain, fields, and extensions. {@link GetEip712DomainReturnType}\n   *\n   * @example\n   * ```ts\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const domain = await client.getEip712Domain({\n   *   address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n   * })\n   * // {\n   * //   domain: {\n   * //     name: 'ExampleContract',\n   * //     version: '1',\n   * //     chainId: 1,\n   * //     verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n   * //   },\n   * //   fields: '0x0f',\n   * //   extensions: [],\n   * // }\n   * ```\n   */\n  getEip712Domain: (\n    args: GetEip712DomainParameters,\n  ) => Promise<GetEip712DomainReturnType>\n  /**\n   * Gets address for ENS name.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n   *\n   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n   *\n   * @param args - {@link GetEnsAddressParameters}\n   * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { normalize } from 'viem/ens'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const ensAddress = await client.getEnsAddress({\n   *   name: normalize('wevm.eth'),\n   * })\n   * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n   */\n  getEnsAddress: (\n    args: GetEnsAddressParameters,\n  ) => Promise<GetEnsAddressReturnType>\n  /**\n   * Gets the avatar of an ENS name.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.\n   *\n   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n   *\n   * @param args - {@link GetEnsAvatarParameters}\n   * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { normalize } from 'viem/ens'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const ensAvatar = await client.getEnsAvatar({\n   *   name: normalize('wevm.eth'),\n   * })\n   * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'\n   */\n  getEnsAvatar: (\n    args: GetEnsAvatarParameters,\n  ) => Promise<GetEnsAvatarReturnType>\n  /**\n   * Gets primary name for specified address.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsName\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls `reverse(bytes)` on ENS Universal Resolver Contract to \"reverse resolve\" the address to the primary ENS name.\n   *\n   * @param args - {@link GetEnsNameParameters}\n   * @returns Name or `null` if not found. {@link GetEnsNameReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const ensName = await client.getEnsName({\n   *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',\n   * })\n   * // 'wevm.eth'\n   */\n  getEnsName: (args: GetEnsNameParameters) => Promise<GetEnsNameReturnType>\n  /**\n   * Gets resolver for ENS name.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n   *\n   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n   *\n   * @param args - {@link GetEnsResolverParameters}\n   * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { normalize } from 'viem/ens'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const resolverAddress = await client.getEnsResolver({\n   *   name: normalize('wevm.eth'),\n   * })\n   * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n   */\n  getEnsResolver: (\n    args: GetEnsResolverParameters,\n  ) => Promise<GetEnsResolverReturnType>\n  /**\n   * Gets a text record for specified ENS name.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n   *\n   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.\n   *\n   * @param args - {@link GetEnsTextParameters}\n   * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { normalize } from 'viem/ens'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const twitterRecord = await client.getEnsText({\n   *   name: normalize('wevm.eth'),\n   *   key: 'com.twitter',\n   * })\n   * // 'wevm_dev'\n   */\n  getEnsText: (args: GetEnsTextParameters) => Promise<GetEnsTextReturnType>\n  /**\n   * Returns a collection of historical gas information.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getFeeHistory\n   * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)\n   *\n   * @param args - {@link GetFeeHistoryParameters}\n   * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const feeHistory = await client.getFeeHistory({\n   *   blockCount: 4,\n   *   rewardPercentiles: [25, 75],\n   * })\n   */\n  getFeeHistory: (\n    args: GetFeeHistoryParameters,\n  ) => Promise<GetFeeHistoryReturnType>\n  /**\n   * Returns an estimate for the fees per gas for a transaction to be included\n   * in the next block.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateFeesPerGasParameters}\n   * @returns An estimate (in wei) for the fees per gas. {@link EstimateFeesPerGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const maxPriorityFeePerGas = await client.estimateFeesPerGas()\n   * // { maxFeePerGas: ..., maxPriorityFeePerGas: ... }\n   */\n  estimateFeesPerGas: <\n    chainOverride extends Chain | undefined = undefined,\n    type extends FeeValuesType = 'eip1559',\n  >(\n    args?: EstimateFeesPerGasParameters<chain, chainOverride, type> | undefined,\n  ) => Promise<EstimateFeesPerGasReturnType<type>>\n  /**\n   * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getFilterChanges\n   * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)\n   *\n   * @remarks\n   * A Filter can be created from the following actions:\n   *\n   * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)\n   * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter)\n   * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)\n   * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)\n   *\n   * Depending on the type of filter, the return value will be different:\n   *\n   * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.\n   * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.\n   * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.\n   *\n   * @param args - {@link GetFilterChangesParameters}\n   * @returns Logs or hashes. {@link GetFilterChangesReturnType}\n   *\n   * @example\n   * // Blocks\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createBlockFilter()\n   * const hashes = await client.getFilterChanges({ filter })\n   *\n   * @example\n   * // Contract Events\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createContractEventFilter({\n   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n   *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n   *   eventName: 'Transfer',\n   * })\n   * const logs = await client.getFilterChanges({ filter })\n   *\n   * @example\n   * // Raw Events\n   * import { createPublicClient, http, parseAbiItem } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createEventFilter({\n   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n   *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n   * })\n   * const logs = await client.getFilterChanges({ filter })\n   *\n   * @example\n   * // Transactions\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createPendingTransactionFilter()\n   * const hashes = await client.getFilterChanges({ filter })\n   */\n  getFilterChanges: <\n    filterType extends FilterType,\n    const abi extends Abi | readonly unknown[] | undefined,\n    eventName extends string | undefined,\n    strict extends boolean | undefined = undefined,\n    fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args: GetFilterChangesParameters<\n      filterType,\n      abi,\n      eventName,\n      strict,\n      fromBlock,\n      toBlock\n    >,\n  ) => Promise<\n    GetFilterChangesReturnType<\n      filterType,\n      abi,\n      eventName,\n      strict,\n      fromBlock,\n      toBlock\n    >\n  >\n  /**\n   * Returns a list of event logs since the filter was created.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getFilterLogs\n   * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n   *\n   * @remarks\n   * `getFilterLogs` is only compatible with **event filters**.\n   *\n   * @param args - {@link GetFilterLogsParameters}\n   * @returns A list of event logs. {@link GetFilterLogsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbiItem } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createEventFilter({\n   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n   *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n   * })\n   * const logs = await client.getFilterLogs({ filter })\n   */\n  getFilterLogs: <\n    const abi extends Abi | readonly unknown[] | undefined,\n    eventName extends string | undefined,\n    strict extends boolean | undefined = undefined,\n    fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args: GetFilterLogsParameters<abi, eventName, strict, fromBlock, toBlock>,\n  ) => Promise<\n    GetFilterLogsReturnType<abi, eventName, strict, fromBlock, toBlock>\n  >\n  /**\n   * Returns the current price of gas (in wei).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getGasPrice\n   * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)\n   *\n   * @returns The gas price (in wei). {@link GetGasPriceReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const gasPrice = await client.getGasPrice()\n   */\n  getGasPrice: () => Promise<GetGasPriceReturnType>\n  /**\n   * Returns a list of event logs matching the provided parameters.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getLogs\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs\n   * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n   *\n   * @param args - {@link GetLogsParameters}\n   * @returns A list of event logs. {@link GetLogsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbiItem } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const logs = await client.getLogs()\n   */\n  getLogs: <\n    const abiEvent extends AbiEvent | undefined = undefined,\n    const abiEvents extends\n      | readonly AbiEvent[]\n      | readonly unknown[]\n      | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n    strict extends boolean | undefined = undefined,\n    fromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    toBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args?:\n      | GetLogsParameters<abiEvent, abiEvents, strict, fromBlock, toBlock>\n      | undefined,\n  ) => Promise<\n    GetLogsReturnType<abiEvent, abiEvents, strict, fromBlock, toBlock>\n  >\n  /**\n   * Returns the account and storage values of the specified account including the Merkle-proof.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getProof\n   * - JSON-RPC Methods:\n   *   - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetProofParameters}\n   * @returns Proof data. {@link GetProofReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const block = await client.getProof({\n   *  address: '0x...',\n   *  storageKeys: ['0x...'],\n   * })\n   */\n  getProof: (args: GetProofParameters) => Promise<GetProofReturnType>\n  /**\n   * Returns an estimate for the max priority fee per gas (in wei) for a transaction\n   * to be included in the next block.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas\n   *\n   * @param client - Client to use\n   * @returns An estimate (in wei) for the max priority fee per gas. {@link EstimateMaxPriorityFeePerGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const maxPriorityFeePerGas = await client.estimateMaxPriorityFeePerGas()\n   * // 10000000n\n   */\n  estimateMaxPriorityFeePerGas: <\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args?:\n      | EstimateMaxPriorityFeePerGasParameters<chain, chainOverride>\n      | undefined,\n  ) => Promise<EstimateMaxPriorityFeePerGasReturnType>\n  /**\n   * Returns the value from a storage slot at a given address.\n   *\n   * - Docs: https://viem.sh/docs/contract/getStorageAt\n   * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)\n   *\n   * @param args - {@link GetStorageAtParameters}\n   * @returns The value of the storage slot. {@link GetStorageAtReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { getStorageAt } from 'viem/contract'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const code = await client.getStorageAt({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   slot: toHex(0),\n   * })\n   */\n  getStorageAt: (\n    args: GetStorageAtParameters,\n  ) => Promise<GetStorageAtReturnType>\n  /**\n   * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms#transaction) given a hash or block identifier.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getTransaction\n   * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n   * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)\n   *\n   * @param args - {@link GetTransactionParameters}\n   * @returns The transaction information. {@link GetTransactionReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const transaction = await client.getTransaction({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getTransaction: <blockTag extends BlockTag = 'latest'>(\n    args: GetTransactionParameters<blockTag>,\n  ) => Promise<GetTransactionReturnType<chain, blockTag>>\n  /**\n   * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations\n   * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n   * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)\n   *\n   * @param args - {@link GetTransactionConfirmationsParameters}\n   * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const confirmations = await client.getTransactionConfirmations({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getTransactionConfirmations: (\n    args: GetTransactionConfirmationsParameters<chain>,\n  ) => Promise<GetTransactionConfirmationsReturnType>\n  /**\n   * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms#transaction) an Account has broadcast / sent.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getTransactionCount\n   * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)\n   *\n   * @param args - {@link GetTransactionCountParameters}\n   * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const transactionCount = await client.getTransactionCount({\n   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  getTransactionCount: (\n    args: GetTransactionCountParameters,\n  ) => Promise<GetTransactionCountReturnType>\n  /**\n   * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt\n   * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions\n   * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt)\n   *\n   * @param args - {@link GetTransactionReceiptParameters}\n   * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const transactionReceipt = await client.getTransactionReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getTransactionReceipt: (\n    args: GetTransactionReceiptParameters,\n  ) => Promise<GetTransactionReceiptReturnType<chain>>\n  /**\n   * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n   *\n   * - Docs: https://viem.sh/docs/contract/multicall\n   *\n   * @param args - {@link MulticallParameters}\n   * @returns An array of results with accompanying status. {@link MulticallReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const abi = parseAbi([\n   *   'function balanceOf(address) view returns (uint256)',\n   *   'function totalSupply() view returns (uint256)',\n   * ])\n   * const result = await client.multicall({\n   *   contracts: [\n   *     {\n   *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *       abi,\n   *       functionName: 'balanceOf',\n   *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n   *     },\n   *     {\n   *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *       abi,\n   *       functionName: 'totalSupply',\n   *     },\n   *   ],\n   * })\n   * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n   */\n  multicall: <\n    const contracts extends readonly unknown[],\n    allowFailure extends boolean = true,\n  >(\n    args: MulticallParameters<contracts, allowFailure>,\n  ) => Promise<MulticallReturnType<contracts, allowFailure>>\n  /**\n   * Prepares a transaction request for signing.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest\n   *\n   * @param args - {@link PrepareTransactionRequestParameters}\n   * @returns The transaction request. {@link PrepareTransactionRequestReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   */\n  prepareTransactionRequest: <\n    const request extends PrepareTransactionRequestRequest<\n      chain,\n      chainOverride\n    >,\n    chainOverride extends Chain | undefined = undefined,\n    accountOverride extends Account | Address | undefined = undefined,\n  >(\n    args: PrepareTransactionRequestParameters<\n      chain,\n      account,\n      chainOverride,\n      accountOverride,\n      request\n    >,\n  ) => Promise<\n    PrepareTransactionRequestReturnType<\n      chain,\n      account,\n      chainOverride,\n      accountOverride,\n      request\n    >\n  >\n  /**\n   * Calls a read-only function on a contract, and returns the response.\n   *\n   * - Docs: https://viem.sh/docs/contract/readContract\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_reading-contracts\n   *\n   * @remarks\n   * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n   *\n   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n   *\n   * @param args - {@link ReadContractParameters}\n   * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { readContract } from 'viem/contract'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const result = await client.readContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n   *   functionName: 'balanceOf',\n   *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n   * })\n   * // 424122n\n   */\n  readContract: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'pure' | 'view'>,\n    const args extends ContractFunctionArgs<abi, 'pure' | 'view', functionName>,\n  >(\n    args: ReadContractParameters<abi, functionName, args>,\n  ) => Promise<ReadContractReturnType<abi, functionName, args>>\n  /**\n   * Sends a **signed** transaction to the network\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction\n   * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendRawTransactionParameters}\n   * @returns The transaction hash. {@link SendRawTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { sendRawTransaction } from 'viem/wallet'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const hash = await client.sendRawTransaction({\n   *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n   * })\n   */\n  sendRawTransaction: (\n    args: SendRawTransactionParameters,\n  ) => Promise<SendRawTransactionReturnType>\n  /**\n   * Sends a **signed** transaction to the network\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransactionSync\n   * - JSON-RPC Method: [`eth_sendRawTransactionSync`](https://eips.ethereum.org/EIPS/eip-7966)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendRawTransactionSyncParameters}\n   * @returns The transaction receipt. {@link SendRawTransactionSyncReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { sendRawTransactionSync } from 'viem/wallet'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const receipt = await client.sendRawTransactionSync({\n   *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n   * })\n   */\n  sendRawTransactionSync: (\n    args: SendRawTransactionSyncParameters,\n  ) => Promise<SendRawTransactionSyncReturnType<chain>>\n  /**\n   * @deprecated Use `simulateBlocks` instead.\n   */\n  simulate: <const calls extends readonly unknown[]>(\n    args: SimulateBlocksParameters<calls>,\n  ) => Promise<SimulateBlocksReturnType<calls>>\n  /**\n   * Simulates a set of calls on block(s) with optional block and state overrides.\n   *\n   * @example\n   * ```ts\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.simulateBlocks({\n   *   blocks: [{\n   *     blockOverrides: {\n   *       number: 69420n,\n   *     },\n   *     calls: [{\n   *       {\n   *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n   *         data: '0xdeadbeef',\n   *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *       },\n   *       {\n   *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n   *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *         value: parseEther('1'),\n   *       },\n   *     }],\n   *     stateOverrides: [{\n   *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n   *       balance: parseEther('10'),\n   *     }],\n   *   }]\n   * })\n   * ```\n   *\n   * @param client - Client to use.\n   * @param parameters - {@link SimulateParameters}\n   * @returns Simulated blocks. {@link SimulateReturnType}\n   */\n  simulateBlocks: <const calls extends readonly unknown[]>(\n    args: SimulateBlocksParameters<calls>,\n  ) => Promise<SimulateBlocksReturnType<calls>>\n  /**\n   * Simulates a set of calls.\n   *\n   * @example\n   * ```ts\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const result = await client.simulateCalls({\n   *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n   *   calls: [{\n   *     {\n   *       data: '0xdeadbeef',\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     },\n   *     {\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *       value: parseEther('1'),\n   *     },\n   *   ]\n   * })\n   * ```\n   *\n   * @param client - Client to use.\n   * @param parameters - {@link SimulateCallsParameters}\n   * @returns Results. {@link SimulateCallsReturnType}\n   */\n  simulateCalls: <const calls extends readonly unknown[]>(\n    args: SimulateCallsParameters<calls>,\n  ) => Promise<SimulateCallsReturnType<calls>>\n  /**\n   * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n   *\n   * - Docs: https://viem.sh/docs/contract/simulateContract\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n   *\n   * @remarks\n   * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.\n   *\n   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n   *\n   * @param args - {@link SimulateContractParameters}\n   * @returns The simulation result and write request. {@link SimulateContractReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const result = await client.simulateContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n   *   functionName: 'mint',\n   *   args: ['69420'],\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  simulateContract: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n    const args extends ContractFunctionArgs<\n      abi,\n      'nonpayable' | 'payable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined,\n    accountOverride extends Account | Address | undefined = undefined,\n  >(\n    args: SimulateContractParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      chainOverride,\n      accountOverride\n    >,\n  ) => Promise<\n    SimulateContractReturnType<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride,\n      accountOverride\n    >\n  >\n  /**\n   * Verify that a hash was signed by the provided address.\n   *\n   * - Docs {@link https://viem.sh/docs/actions/public/verifyHash}\n   *\n   * @param parameters - {@link VerifyHashParameters}\n   * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n   */\n  verifyHash: (args: VerifyHashParameters) => Promise<VerifyHashReturnType>\n  /**\n   * Verify that a message was signed by the provided address.\n   *\n   * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n   *\n   * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage}\n   *\n   * @param parameters - {@link VerifyMessageParameters}\n   * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n   */\n  verifyMessage: (\n    args: VerifyMessageParameters,\n  ) => Promise<VerifyMessageReturnType>\n  /**\n   * Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.\n   *\n   * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n   *\n   * - Docs {@link https://viem.sh/docs/siwe/actions/verifySiweMessage}\n   *\n   * @param parameters - {@link VerifySiweMessageParameters}\n   * @returns Whether or not the signature is valid. {@link VerifySiweMessageReturnType}\n   */\n  verifySiweMessage: (\n    args: VerifySiweMessageParameters,\n  ) => Promise<VerifySiweMessageReturnType>\n  /**\n   * Verify that typed data was signed by the provided address.\n   *\n   * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData}\n   *\n   * @param parameters - {@link VerifyTypedDataParameters}\n   * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n   */\n  verifyTypedData: (\n    args: VerifyTypedDataParameters,\n  ) => Promise<VerifyTypedDataReturnType>\n  /**\n   * Destroys a Filter that was created from one of the following Actions:\n   *\n   * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)\n   * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)\n   * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)\n   *\n   * - Docs: https://viem.sh/docs/actions/public/uninstallFilter\n   * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)\n   *\n   * @param args - {@link UninstallFilterParameters}\n   * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'\n   *\n   * const filter = await client.createPendingTransactionFilter()\n   * const uninstalled = await client.uninstallFilter({ filter })\n   * // true\n   */\n  uninstallFilter: (\n    args: UninstallFilterParameters,\n  ) => Promise<UninstallFilterReturnType>\n  /**\n   * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt). If the Transaction reverts, then the action will throw an error.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n   * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n   * - JSON-RPC Methods:\n   *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n   *   - If a Transaction has been replaced:\n   *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n   *     - Checks if one of the Transactions is a replacement\n   *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n   *\n   * @remarks\n   * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n   *\n   * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n   *\n   * There are 3 types of Transaction Replacement reasons:\n   *\n   * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n   * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n   * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n   *\n   * @param args - {@link WaitForTransactionReceiptParameters}\n   * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const transactionReceipt = await client.waitForTransactionReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  waitForTransactionReceipt: (\n    args: WaitForTransactionReceiptParameters<chain>,\n  ) => Promise<WaitForTransactionReceiptReturnType<chain>>\n  /**\n   * Watches and returns incoming block numbers.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n   * - JSON-RPC Methods:\n   *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n   *\n   * @param args - {@link WatchBlockNumberParameters}\n   * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = await client.watchBlockNumber({\n   *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n   * })\n   */\n  watchBlockNumber: (\n    args: WatchBlockNumberParameters,\n  ) => WatchBlockNumberReturnType\n  /**\n   * Watches and returns information for incoming blocks.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/watchBlocks\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks\n   * - JSON-RPC Methods:\n   *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n   *\n   * @param args - {@link WatchBlocksParameters}\n   * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = await client.watchBlocks({\n   *   onBlock: (block) => console.log(block),\n   * })\n   */\n  watchBlocks: <\n    includeTransactions extends boolean = false,\n    blockTag extends BlockTag = 'latest',\n  >(\n    args: WatchBlocksParameters<\n      transport,\n      chain,\n      includeTransactions,\n      blockTag\n    >,\n  ) => WatchBlocksReturnType\n  /**\n   * Watches and returns emitted contract event logs.\n   *\n   * - Docs: https://viem.sh/docs/contract/watchContractEvent\n   *\n   * @remarks\n   * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).\n   *\n   * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n   *\n   * @param args - {@link WatchContractEventParameters}\n   * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = client.watchContractEvent({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n   *   eventName: 'Transfer',\n   *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n   *   onLogs: (logs) => console.log(logs),\n   * })\n   */\n  watchContractEvent: <\n    const abi extends Abi | readonly unknown[],\n    eventName extends ContractEventName<abi>,\n    strict extends boolean | undefined = undefined,\n  >(\n    args: WatchContractEventParameters<abi, eventName, strict, transport>,\n  ) => WatchContractEventReturnType\n  /**\n   * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/watchEvent\n   * - JSON-RPC Methods:\n   *   - **RPC Provider supports `eth_newFilter`:**\n   *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n   *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n   *   - **RPC Provider does not support `eth_newFilter`:**\n   *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n   *\n   * @remarks\n   * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).\n   *\n   * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n   *\n   * @param args - {@link WatchEventParameters}\n   * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = client.watchEvent({\n   *   onLogs: (logs) => console.log(logs),\n   * })\n   */\n  watchEvent: <\n    const abiEvent extends AbiEvent | undefined = undefined,\n    const abiEvents extends\n      | readonly AbiEvent[]\n      | readonly unknown[]\n      | undefined = abiEvent extends AbiEvent ? [abiEvent] : undefined,\n    strict extends boolean | undefined = undefined,\n  >(\n    args: WatchEventParameters<abiEvent, abiEvents, strict, transport>,\n  ) => WatchEventReturnType\n  /**\n   * Watches and returns pending transaction hashes.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions\n   * - JSON-RPC Methods:\n   *   - When `poll: true`\n   *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.\n   *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.\n   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newPendingTransactions\"` event.\n   *\n   * @remarks\n   * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions#ontransactions).\n   *\n   * @param args - {@link WatchPendingTransactionsParameters}\n   * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = await client.watchPendingTransactions({\n   *   onTransactions: (hashes) => console.log(hashes),\n   * })\n   */\n  watchPendingTransactions: (\n    args: WatchPendingTransactionsParameters<transport>,\n  ) => WatchPendingTransactionsReturnType\n}\n\nexport function publicActions<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>(\n  client: Client<transport, chain, account>,\n): PublicActions<transport, chain, account> {\n  return {\n    call: (args) => call(client, args),\n    createAccessList: (args) => createAccessList(client, args),\n    createBlockFilter: () => createBlockFilter(client),\n    createContractEventFilter: (args) =>\n      createContractEventFilter(client, args),\n    createEventFilter: (args) => createEventFilter(client, args),\n    createPendingTransactionFilter: () =>\n      createPendingTransactionFilter(client),\n    estimateContractGas: (args) => estimateContractGas(client, args as any),\n    estimateGas: (args) => estimateGas(client, args),\n    getBalance: (args) => getBalance(client, args),\n    getBlobBaseFee: () => getBlobBaseFee(client),\n    getBlock: (args) => getBlock(client, args),\n    getBlockNumber: (args) => getBlockNumber(client, args),\n    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),\n    getBytecode: (args) => getCode(client, args),\n    getChainId: () => getChainId(client),\n    getCode: (args) => getCode(client, args),\n    getContractEvents: (args) => getContractEvents(client, args),\n    getEip712Domain: (args) => getEip712Domain(client, args),\n    getEnsAddress: (args) => getEnsAddress(client, args),\n    getEnsAvatar: (args) => getEnsAvatar(client, args),\n    getEnsName: (args) => getEnsName(client, args),\n    getEnsResolver: (args) => getEnsResolver(client, args),\n    getEnsText: (args) => getEnsText(client, args),\n    getFeeHistory: (args) => getFeeHistory(client, args),\n    estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),\n    getFilterChanges: (args) => getFilterChanges(client, args),\n    getFilterLogs: (args) => getFilterLogs(client, args),\n    getGasPrice: () => getGasPrice(client),\n    getLogs: (args) => getLogs(client, args as any),\n    getProof: (args) => getProof(client, args),\n    estimateMaxPriorityFeePerGas: (args) =>\n      estimateMaxPriorityFeePerGas(client, args),\n    getStorageAt: (args) => getStorageAt(client, args),\n    getTransaction: (args) => getTransaction(client, args),\n    getTransactionConfirmations: (args) =>\n      getTransactionConfirmations(client, args),\n    getTransactionCount: (args) => getTransactionCount(client, args),\n    getTransactionReceipt: (args) => getTransactionReceipt(client, args),\n    multicall: (args) => multicall(client, args),\n    prepareTransactionRequest: (args) =>\n      prepareTransactionRequest(client as any, args as any) as any,\n    readContract: (args) => readContract(client, args),\n    sendRawTransaction: (args) => sendRawTransaction(client, args),\n    sendRawTransactionSync: (args) => sendRawTransactionSync(client, args),\n    simulate: (args) => simulateBlocks(client, args),\n    simulateBlocks: (args) => simulateBlocks(client, args),\n    simulateCalls: (args) => simulateCalls(client, args),\n    simulateContract: (args) => simulateContract(client, args),\n    verifyHash: (args) => verifyHash(client, args),\n    verifyMessage: (args) => verifyMessage(client, args),\n    verifySiweMessage: (args) => verifySiweMessage(client, args),\n    verifyTypedData: (args) => verifyTypedData(client, args),\n    uninstallFilter: (args) => uninstallFilter(client, args),\n    waitForTransactionReceipt: (args) =>\n      waitForTransactionReceipt(client, args),\n    watchBlocks: (args) => watchBlocks(client, args),\n    watchBlockNumber: (args) => watchBlockNumber(client, args),\n    watchContractEvent: (args) => watchContractEvent(client, args),\n    watchEvent: (args) => watchEvent(client, args),\n    watchPendingTransactions: (args) => watchPendingTransactions(client, args),\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { ExactPartial, Prettify } from '../../types/utils.js'\nimport type { SiweMessage } from './types.js'\n\n/**\n * @description Parses EIP-4361 formatted message into message fields object.\n *\n * @see https://eips.ethereum.org/EIPS/eip-4361\n *\n * @returns EIP-4361 fields object\n */\nexport function parseSiweMessage(\n  message: string,\n): Prettify<ExactPartial<SiweMessage>> {\n  const { scheme, statement, ...prefix } = (message.match(prefixRegex)\n    ?.groups ?? {}) as {\n    address: Address\n    domain: string\n    scheme?: string\n    statement?: string\n  }\n  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } =\n    (message.match(suffixRegex)?.groups ?? {}) as {\n      chainId: string\n      expirationTime?: string\n      issuedAt?: string\n      nonce: string\n      notBefore?: string\n      requestId?: string\n      uri: string\n      version: '1'\n    }\n  const resources = message.split('Resources:')[1]?.split('\\n- ').slice(1)\n  return {\n    ...prefix,\n    ...suffix,\n    ...(chainId ? { chainId: Number(chainId) } : {}),\n    ...(expirationTime ? { expirationTime: new Date(expirationTime) } : {}),\n    ...(issuedAt ? { issuedAt: new Date(issuedAt) } : {}),\n    ...(notBefore ? { notBefore: new Date(notBefore) } : {}),\n    ...(requestId ? { requestId } : {}),\n    ...(resources ? { resources } : {}),\n    ...(scheme ? { scheme } : {}),\n    ...(statement ? { statement } : {}),\n  }\n}\n\n// https://regexr.com/80gdj\nconst prefixRegex =\n  /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?<address>0x[a-fA-F0-9]{40})\\n\\n(?:(?<statement>.*)\\n\\n)?/\n\n// https://regexr.com/80gf9\nconst suffixRegex =\n  /(?:URI: (?<uri>.+))\\n(?:Version: (?<version>.+))\\n(?:Chain ID: (?<chainId>\\d+))\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\n(?:Issued At: (?<issuedAt>.+))(?:\\nExpiration Time: (?<expirationTime>.+))?(?:\\nNot Before: (?<notBefore>.+))?(?:\\nRequest ID: (?<requestId>.+))?/\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type ParseSignatureErrorType = NumberToHexErrorType | ErrorType\n\n/**\n * @description Parses a hex formatted signature into a structured signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', s: '0x...', v: 28n }\n */\nexport function parseSignature(signatureHex: Hex) {\n  const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130))\n  const yParityOrV = Number(`0x${signatureHex.slice(130)}`)\n  const [v, yParity] = (() => {\n    if (yParityOrV === 0 || yParityOrV === 1) return [undefined, yParityOrV]\n    if (yParityOrV === 27) return [BigInt(yParityOrV), 0]\n    if (yParityOrV === 28) return [BigInt(yParityOrV), 1]\n    throw new Error('Invalid yParityOrV value')\n  })()\n\n  if (typeof v !== 'undefined')\n    return {\n      r: numberToHex(r, { size: 32 }),\n      s: numberToHex(s, { size: 32 }),\n      v,\n      yParity,\n    } satisfies Signature\n  return {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    yParity,\n  } satisfies Signature\n}\n","import type { Address } from 'abitype'\n\nimport { getTransactionCount } from '../actions/public/getTransactionCount.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { MaybePromise } from '../types/utils.js'\nimport { LruMap } from './lru.js'\n\nexport type CreateNonceManagerParameters = {\n  source: NonceManagerSource\n}\n\ntype FunctionParameters = {\n  address: Address\n  chainId: number\n}\n\nexport type NonceManager = {\n  /** Get and increment a nonce. */\n  consume: (\n    parameters: FunctionParameters & { client: Client },\n  ) => Promise<number>\n  /** Increment a nonce. */\n  increment: (chainId: FunctionParameters) => void\n  /** Get a nonce. */\n  get: (chainId: FunctionParameters & { client: Client }) => Promise<number>\n  /** Reset a nonce. */\n  reset: (chainId: FunctionParameters) => void\n}\n\n/**\n * Creates a nonce manager for auto-incrementing transaction nonces.\n *\n * - Docs: https://viem.sh/docs/accounts/createNonceManager\n *\n * @example\n * ```ts\n * const nonceManager = createNonceManager({\n *   source: jsonRpc(),\n * })\n * ```\n */\nexport function createNonceManager(\n  parameters: CreateNonceManagerParameters,\n): NonceManager {\n  const { source } = parameters\n\n  const deltaMap = new Map()\n  const nonceMap = new LruMap<number>(8192)\n  const promiseMap = new Map<string, Promise<number>>()\n\n  const getKey = ({ address, chainId }: FunctionParameters) =>\n    `${address}.${chainId}`\n\n  return {\n    async consume({ address, chainId, client }) {\n      const key = getKey({ address, chainId })\n      const promise = this.get({ address, chainId, client })\n\n      this.increment({ address, chainId })\n      const nonce = await promise\n\n      await source.set({ address, chainId }, nonce)\n      nonceMap.set(key, nonce)\n\n      return nonce\n    },\n    async increment({ address, chainId }) {\n      const key = getKey({ address, chainId })\n      const delta = deltaMap.get(key) ?? 0\n      deltaMap.set(key, delta + 1)\n    },\n    async get({ address, chainId, client }) {\n      const key = getKey({ address, chainId })\n\n      let promise = promiseMap.get(key)\n      if (!promise) {\n        promise = (async () => {\n          try {\n            const nonce = await source.get({ address, chainId, client })\n            const previousNonce = nonceMap.get(key) ?? 0\n            if (previousNonce > 0 && nonce <= previousNonce)\n              return previousNonce + 1\n            nonceMap.delete(key)\n            return nonce\n          } finally {\n            this.reset({ address, chainId })\n          }\n        })()\n        promiseMap.set(key, promise)\n      }\n\n      const delta = deltaMap.get(key) ?? 0\n      return delta + (await promise)\n    },\n    reset({ address, chainId }) {\n      const key = getKey({ address, chainId })\n      deltaMap.delete(key)\n      promiseMap.delete(key)\n    },\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Sources\n\nexport type NonceManagerSource = {\n  /** Get a nonce. */\n  get(parameters: FunctionParameters & { client: Client }): MaybePromise<number>\n  /** Set a nonce. */\n  set(parameters: FunctionParameters, nonce: number): MaybePromise<void>\n}\n\n/** JSON-RPC source for a nonce manager. */\nexport function jsonRpc(): NonceManagerSource {\n  return {\n    async get(parameters) {\n      const { address, client } = parameters\n      return getTransactionCount(client, {\n        address,\n        blockTag: 'pending',\n      })\n    },\n    set() {},\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Default\n\n/** Default Nonce Manager with a JSON-RPC source. */\nexport const nonceManager = /*#__PURE__*/ createNonceManager({\n  source: jsonRpc(),\n})\n","export const erc6492MagicBytes =\n  '0x6492649264926492649264926492649264926492649264926492649264926492' as const\n\nexport const zeroHash =\n  '0x0000000000000000000000000000000000000000000000000000000000000000' as const\n","import type { Address } from 'abitype'\nimport { erc6492MagicBytes } from '../../constants/bytes.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js'\nimport { concatHex } from '../data/concat.js'\nimport { hexToBytes } from '../encoding/toBytes.js'\n\ntype To = 'bytes' | 'hex'\n\nexport type SerializeErc6492SignatureParameters<to extends To = 'hex'> = {\n  /** The ERC-4337 Account Factory address to use for counterfactual verification. */\n  address: Address\n  /** Calldata to pass to deploy account (if not deployed) for counterfactual verification. */\n  data: Hex\n  /** The original signature. */\n  signature: Hex\n  to?: to | To | undefined\n}\n\nexport type SerializeErc6492SignatureReturnType<to extends To = 'hex'> =\n  | (to extends 'hex' ? Hex : never)\n  | (to extends 'bytes' ? ByteArray : never)\n\nexport type SerializeErc6492SignatureErrorType = ErrorType\n\n/**\n * @description Serializes a ERC-6492 flavoured signature into hex format.\n *\n * @param signature ERC-6492 signature in object format.\n * @returns ERC-6492 signature in hex format.\n *\n * @example\n * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })\n * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n */\nexport function serializeErc6492Signature<to extends To = 'hex'>(\n  parameters: SerializeErc6492SignatureParameters<to>,\n): SerializeErc6492SignatureReturnType<to> {\n  const { address, data, signature, to = 'hex' } = parameters\n  const signature_ = concatHex([\n    encodeAbiParameters(\n      [{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }],\n      [address, data, signature],\n    ),\n    erc6492MagicBytes,\n  ])\n\n  if (to === 'hex') return signature_ as SerializeErc6492SignatureReturnType<to>\n  return hexToBytes(signature_) as SerializeErc6492SignatureReturnType<to>\n}\n"],"names":[],"mappings":"0OIU6C,CAAY,KUciB,CAAA,CVblE,EYS0B,CZTvB,AIFA,AQWuB,QXagC,CAAA,CGxBvD,EAAA,EGc6D,AJWA,CAAA,AIXA,MPZxC,AIFrB,CJEsB,CUcI,EAAE,IAAA,CAAA,CAAM,aVbrB,CAAC,AAAC,CAAC,EAAE,AOiBtB,QRjBqG,EWapC,CAAA,EVb3B,EOiBJ,KGFqC,AHHI,CAAA,AGGJ,UHErC,CAAA,YPjBiC,CAAC,CAAA,OACnE,aAAiB,EC2BE,ESTpB,ATSoB,2BD3B2B,CAAC,AC2BH,IDzBxC,CC2BD,AG9BE,GMmB4B,AVhBzB,CUgByB,CVhBvB,CUoBJ,WVpBkB,KEqBO,QGRjC,ELZM,IAAI,CADoC,CAClC,KKYO,OLZO,iBAAiB,CC6B5C,MD7BmD,aACxB,UMcU,oBNdoB,CAC5C,YAAA,4BACA,IC8BE,QAAA,0BD9BsC,AACpD,EAAA,IAAA,CAD2D,CEsDnD,AJjCA,AEpBR,YAA0B,qCAAqC,4EIdrD,EPAC,AWIC,CXJD,AQD4B,ADCQ,CJLP,CIM5C,ECFyE,CDEpD,ACFoD,KDErE,CCD4B,AKWhC,AJNgC,AKGhC,AbLiC,ASOjC,AJMA,AKPA,ACSO,AGZA,CRLG,GAAD,GAAO,EACZ,AAAuB,CGcC,ATT5B,AaMA,AbNuB,AMLK,AMeD,APK3B,ASbO,CTaiB,CCpBM,CNM/B,AcKC,ALIO,AJWA,AOVqB,CPK7B,CCrBW,CMeuB,CHDE,CGEF,ATQlB,CWjBC,ARPqB,ANMhC,CKeA,ESdW,CAAA,EFQiD,CAAA,GNd/C,CQMgC,CLOsB,AKPtB,CLOsB,EHbpE,COW4B,CAAA,APXtB,CHuB+C,CAAA,EGvBnB,GAArB,CAAC,KAFO,ANOU,CAJH,AaMzB,AbF4B,AcD5B,APJP,AKYA,APGO,AIJP,MHbgC,CDiBlB,EQRE,ARQA,ALdyB,CGoBxB,AGvBmB,COSlB,AbNyB,AMHP,KDsBe,CAAA,YCnBtB,CAAA,EAAI,EAAE,CAAC,CAAA,CAAE,CAAA,gBAC5B,EAAC,CLKD,CEwBC,CG5BJ,EH4BI,KHJP,SAAA,EAAA,CAA+B,GIwBL,AG9BM,KPOvB,IAAI,QEnBQ,AMcoB,GAAA,IAAA,IAAA,CRKR,CAAC,CAAc,CAAA,IAC/C,EAAA,MAAa,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,iBAEH,EQHE,CAAC,ARGA,CAAC,AQHD,CRGC,IIiCK,AJ/B9B,IAAI,EAAA,EAAW,MAAM,CAAA,EAAM,CAAC,EFTI,EAAA,GAAA,EESW,KACxC,EErBI,AC+BC,CD/BD,CFqB2C,CGU1C,AHVgD,CAAC,CAAC,CAAC,CAAC,CAAA,EAChD,CGSsC,CHTlB,AGSkB,AHTlB,CAAA,EAC/B,EQHO,GAAA,GVLiB,CUKjB,ARGA,EAAC,CIuCG,EAAA,CAAA,AJxCoB,EAE/B,EAAA,SAAA,AAAS,EAAC,CAAA,CIuCE,AD9BE,CAAA,EAAA,aAAA,EAAA,CHTgB,CAAC,EAAE,EAAA,cAC5B,EAAA,SAAA,EAAA,CAAA,EAAU,EAAA,MAAA,EAAO,KAAgB,CAAC,CAAE,ACKL,gCDFxB,CGQL,EI9BT,SAAA,EAAoB,CAAa,ELZZ,AMaE,IDArB,EAAS,CLb2C,GKavC,WAAW,EAAE,EAAE,CHmBC,GGnBG,CAAC,CAAC,CAAC,CAAA,MHmBO,CGlB3C,EACE,ELbE,AKasB,IAAA,CAAA,EAAU,ELbO,KAAA,IAAA,AKaE,EAAA,CAAA,EAAC,EAAA,aAAA,AAAa,EAAC,IAD5D,CACiE,AADjE,CACkE,CAAC,AADnE,CACmE,CADnE,UAAA,EAAA,EAEP,CAAC,WCH6B,CAAc,EAE1C,CJgBiC,CHtBM,EOMjC,EAAQ,EAAO,INdI,GMcG,CAAC,YAAa,IAC1C,CLeC,ACaE,CJxBC,CAAA,AAAkB,IAAlB,EQJM,MAAM,CRIM,GAAA,IQJS,CLeZ,GKfgB,WAAW,CRKnB,AQLoB,QAEjC,CNhB+C,CAAA,EMgB3C,KJqCK,MAAA,CAAA,EIrCM,CJqCC,CAAC,CAAA,YAAA,AIrCW,EAAC,GAAO,UAAU,CAAG,CAAC,CAAC,CAAA,EAEpD,IACA,EAAM,KAAK,CAAA,SACnB,IAAI,EAAI,EAAG,EAAI,EAAA,MAAW,CAAE,CAAC,EAAE,CAAE,CAAC,MACrC,IAAA,EAAA,CAAA,EAAA,EAAA,aAAA,AAA2B,EAAA,CAAA,CAAA,EAAQ,CAG/B,GAAQ,UAAU,CAAA,KAAA,CAAA,EAAA,CAAA,EAAA,EAAA,aAAA,GTrCM,CDCC,CUqCa,CElCvC,AGCN,AfJkC,AaY5B,CZbkC,ASsCe,CP3CnB,AO2CuB,CMvCtB,AbJD,AO2CwB,CAAC,CFzCD,AEyCE,CFzCF,ARIpB,AeIlC,CbRyD,ADIvD,CCJuD,AIS1C,ALLb,CeFmC,AfEnC,CKMP,CLNW,EAAA,AGNmC,CAAA,IHMzB,AUAM,CVAN,CQFQ,ACEA,CDFA,AKEF,AJAE,ACC9B,CVDsB,CAAA,CAAM,AKMb,AQLf,CEGwB,ALGxB,AVP4B,AaQ5B,CRCC,AI4B6D,AAjCxD,CCHA,ATCN,CcGA,CNiCQ,CIrCF,AJqCE,CN3C6B,AUa/B,AHDA,ANJwB,CGHQ,AEsC9B,CHtCoC,AGsCpC,CMxC4D,ATExB,CSFwB,ANwCzC,CLvCoB,CAAA,CQaH,CAAA,CPH7B,CI6BY,CJ5B1B,AI6BE,EAAM,CLYD,AOhD2C,CAAA,CFoCvC,CAAC,EAAS,AG6IL,CRjII,CKZU,ACtCA,AIGqB,CJHrB,AIGqB,ATMxC,ADyCW,AKZS,CAAC,CJ3BhC,ANZwF,AcC1D,AJsCE,CVvCwD,AcC1D,AJsCH,EACf,EJ0CwB,AAC1B,AI3CU,ELYF,AHRM,CAAC,AGQN,CAAA,AHRM,CWyIA,CH7IC,CAAG,IJ5Bb,GACjB,MAAM,QI8Be,GAAA,CJ9BH,CI8BG,AJ9BH,EI8BG,EAAA,KAAmC,CAAC,CAAC,AJ4CnC,CAAA,EAAA,GI1Cf,CACT,CAAC,iHI8DiC,CAChC,CAAmC,IRZQ,GAAY,CAAC,iCQcjB,CCtCmC,CACrE,CAAA,GDqCoC,CAAI,aAAE,CAAW,CAAE,QAAA,CAAQ,CAClE,KHtB0E,CAAA,IGsBhE,CAAA,yCAKR,EDmFI,KAAA,ECnFc,wBAAwB,CHtBA,AGsBA,AAC5C,CELG,ADjCD,EAAA,CAAA,EAAA,MAAA,MAAA,+ED0CK,EAAA,uBAAA,EAAA,qGAQoC,CAAA,IAAA,OAAe,KAE5D,IAAM,CPYF,COXc,MADJ,EACiB,MAAiB,OAAO,EHrBlB,CGqBqC,CAAA,CAChE,EAAS,CAD4C,CAAC,APc7C,AMsEE,CCnFa,CAAA,CT9BoB,AAC3B,SSiCJ,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CIWD,CAAA,WAAA,AJXY,EAAC,EACrB,CAAC,AD7BM,CKuCgB,CJXG,CAAC,CAAA,WD5BL,ECMA,AGbA,AJQpB,CAAgC,ADgJuB,CC/IvD,AD+IuD,AKvJ1C,AHaA,YDJX,CAAU,CACV,IIVyB,AHaA,CAAC,AGbA,CHaC,AGbA,OJUhB,UACX,ECEsD,KAAH,AGbA,CAAC,AJW5C,ACE4C,CAAC,AGbA,CAAC,AHaA,ADFnC,CIX6C,AHaA,kBAAA,CDD/C,CACO,cAGjB,UAAP,EIfuB,KJehB,EAAA,CAAA,EAAA,EAAA,WAAA,AAAsC,EAAA,QAAgB,QHzExD,CGqFA,AD1FG,AQAA,AVMR,CUJK,ADKA,ARKP,KOCS,CNbQ,CIaN,AFDA,CIEZ,ACXa,ECHS,AJctB,AFDA,AHLe,CQJf,CPJwB,ACUP,CFEhB,AAHD,CDLgC,AKEN,AGQpB,CNhB2B,CAAA,ACiFb,AAWK,MExFe,AF6Ed,CE7Ec,AC6Eb,CN3E8B,AM2E9B,OAAA,CGhFuB,ACAA,APiF/C,CF5EgD,AQLD,ACAA,CTKC,OMMd,ADAA,AHHA,CGGA,ACAA,AJHA,CCEE,CAAA,GIA0B,CAAA,gBLyEpD,yBAEY,EAClB,EKQE,CADqB,CLJ3B,CGF6B,CHFC,OAIpB,CDoME,ACpMM,CDoML,IDhRf,aDNyC,CAAC,GAAG,CAAC,GAAW,IUJQ,CAAA,CVIF,CAAC,KAAK,CAAC,CAAC,UACvD,EEJa,COMN,EAAE,IPNI,CQEC,AVEJ,AEJG,IFIU,CACrC,CSEK,ACJA,ILGA,OLDQ,CSC0C,CAAA,KTDnC,EAAW,CUHiC,CAAA,CAC1B,EAAE,GRkEG,GFhED,CAAC,CAC3C,CSeF,ACjBO,EDG8C,CAAA,ETD7C,CAAA,EAAa,ESeD,GACrB,CThB4B,EAAE,IAAI,AAAC,GUFY,CVEF,CACjC,CAD6B,CUHsC,CAAA,AVGpC,AUFI,AVGhC,CAAJ,AAAK,AAAC,GAAU,CAAD,CAAJ,EAAE,ESeuB,ATfd,CSec,wHDiDzC,eAAA,EAAA,CAAA,CASL,CDlBwC,AL0JxB,OK1JwB,CAAA,CCoB8B,EPlBlB,AOsBpD,ADxBoD,CACnD,CAAC,CAAA,CAAA,ECuBa,EAAO,MAAM,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EIQ,SGzBU,IAAI,ILqBM,AKrBF,AJ8BE,CI9BF,IAAe,CAAA,CAAE,CAAC,ADiDhB,KChDrB,WAAa,IAAI,IAAI,CAAC,EAAU,CAAE,CAAC,AAAE,CAAD,AAAC,CAAE,CAAC,EAAT,CAAC,AAC5C,EAAY,GDoD2B,CAAA,OCpDzB,GAAc,CAAA,CAAE,CAAC,CDwDb,ECxDK,EACX,WAAE,CAAS,CAAE,CAAC,AJ8BG,CI9BF,AJ8BE,CI9BC,CAAC,KACtB,QAAE,CLoBmB,AKpBb,CDgElB,AJ5C+B,AKpBX,CAAC,AAAC,CAAA,CAAG,CAAP,AAAQ,ED2DU,CAAA,EC1DvB,GDsDqC,CAAA,eC3DlD,GJ+BL,GGmBK,CAAA,EHnBO,GCLC,CFLkD,GAAA,ECoB3D,CARY,AAQX,GE3BK,MF2BI,ADrCA,AACd,CIqGA,AJrGyC,IDhBtB,EEoDE,EGiEb,ADpFK,AP4BA,CQlDI,GAClB,GC5B+B,ALmCrB,QACP,CAAM,IDnByC,IKWD,CAAA,AJS9C,CAAO,CIJV,MJKG,CKnCkC,CAAA,OAAA,CLoC5B,CDtBmE,KAAA,EAAA,ICuB9D,IAAI,AAAE,CKrCgD,ALsClE,CAAG,EAEJ,GDzBK,AKgBA,GJSS,EAFA,AAEA,CAFA,KAEc,EIV4B,CAAA,AAKnD,ALjBA,ACsB4B,GAC7B,CDrBG,AKuBP,EJFa,AAD0B,EKtBxB,KAAA,GAAA,GHiBX,GFOU,CADwB,CIOtC,AL3B+B,AKgCpB,MJZkC,AACjB,CDrBU,EAAE,ACqBP,GAE7B,AHKgC,COcpC,CJnBY,GImBF,ACzCG,ALoB4B,CKpB3B,ADoCd,MJhBgD,IAEtB,CKtBD,CLsBK,GAAQ,CAAJ,CKtBD,AJiBI,ADKC,cAAA,IAC1B,SAAA,EAAa,EKrBE,CR6BA,CGRE,AKrBF,SLqBsB,CALR,CIFzC,ALnBO,MCqByC,CAKU,CAE1D,GIgCK,EL7DwB,CAAA,EC8BtB,EIsCG,EH7BG,ACLF,EEkCD,GAAA,MJrCH,CIdyC,AHwBxC,CGxBwC,ARgCrC,CAAA,SAAA,AIlBK,EAAA,EAAS,CJkBG,MAAA,CAAA,cIlB0B,AAChD,CCWC,EADE,ADVQ,CJkBL,AIlBK,CAAA,EAAJ,AAAK,CIyDnB,EAAM,IAAA,UAAA,AJzD2B,EAAC,EAAQ,OAAO,CAAE,GIoCxC,IJpC+C,CAAC,EAF3B,AAE6B,CAC5D,AKvBc,CLuBb,ACWO,EG6CoC,CAAA,EJxDpC,AAD2D,CAC1D,CJqBH,GItBkE,CI6DxD,AJ7DwD,EAE/D,CIyEF,AH5DK,CI3BG,EDwFhB,KJvEQ,GGPG,AFS0B,AAU1B,CDZC,mBCKT,CGyCF,OHzCW,4BDfoD,OCUnC,EJAjB,GIAsB,CAAA,AI7BlB,AJyCT,CIzCU,CJyCV,AIzCW,AJyCX,CAAA,EAAO,EHeY,EMqDb,GACb,GNtD0B,GAAA,AGfD,EAAC,CGqEpB,EHpEL,GGqEK,GAAA,CAAA,EHrEE,EEnBG,CAAA,SAAA,AFmBO,EAAC,CGwEJ,ANxCK,AKnDA,CAAA,CFoBjB,CG4EF,OH5EW,EAAO,OAAO,KG4EE,AD/FG,CFoB5B,CGgFF,aH9EE,CGwFF,EHxFK,CAAW,GEhBR,ACqLV,IAAA,GAAO,AAIL,EAAA,CAAA,CAAA,QAEF,GAAO,EAAA,CAAA,CAAA,kED7Me,GCwFf,ADvFL,CAAgC,CAChC,iBAF0C,MAGxC,CAAqB,ECqFe,CAAA,mBDpFpC,CAAoB,SACpB,CAAO,CAC0B,MAE7B,EAAU,CFmBU,KEnBJ,EAAO,IAAD,CP4BM,CAAQ,CAAA,CO3BxC,CACE,CCuFJ,MDvFY,6BACR,CC2FJ,MD3FY,EACJ,MAAwB,CCgGjC,CN7CmC,CM6C7B,IAAA,OAAA,ADhGsC,EAAC,GAAS,CAC7C,CAAC,EAD0C,CAAC,aAGpC,CAAC,CAAE,CAClB,CAAA,AAKK,EAJA,AAIY,CAJZ,ACmHQ,EDlHL,CCyGJ,AAUN,IDnHe,EAAA,GC0F4C,CAAA,QD1F9B,iBCyGY,CDzGM,ACyGN,EDzGQ,MAAM,EACpD,CC4GF,EAAA,CC9HuQ,CAAA,sBFkB7O,AC4G1B,CD5G0B,CAED,GCgHpB,AD/GL,GCgHK,AAIN,aDpHK,CCmHJ,CDnHc,CLiDH,KKjDS,CCoHrB,CDpHwC,EACrC,CCuHF,EAd2C,CAAA,EDzGnC,IAAI,GLiDA,CAAA,8BKjD+B,CAAC,CAAE,QAAS,CAAS,CAAE,CAAC,CAAA,AACnE,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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,19,20,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37,38,39,40]}