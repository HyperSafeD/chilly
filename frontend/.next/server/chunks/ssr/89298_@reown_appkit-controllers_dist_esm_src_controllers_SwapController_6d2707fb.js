module.exports=[903158,a=>{"use strict";var b=a.i(511854),c=a.i(791477),d=a.i(840800),e=a.i(50516),f=a.i(230158),g=a.i(936785),h=a.i(358765),i=a.i(325163),j=a.i(203479),k=a.i(231483);let l={getGasPriceInEther:(a,b)=>Number(b*a)/1e18,getGasPriceInUSD(a,b,c){let e=l.getGasPriceInEther(b,c);return d.NumberUtil.bigNumber(a).times(e).toNumber()},getPriceImpact({sourceTokenAmount:a,sourceTokenPriceInUSD:b,toTokenPriceInUSD:c,toTokenAmount:e}){let f=d.NumberUtil.bigNumber(a).times(b),g=d.NumberUtil.bigNumber(e).times(c);return f.minus(g).div(f).times(100).toNumber()},getMaxSlippage(a,b){let c=d.NumberUtil.bigNumber(a).div(100);return d.NumberUtil.multiply(b,c).toNumber()},getProviderFee:(a,b=.0085)=>d.NumberUtil.bigNumber(a).times(b).toString(),isInsufficientNetworkTokenForGas:(a,b)=>!!d.NumberUtil.bigNumber(a).eq(0)||d.NumberUtil.bigNumber(d.NumberUtil.bigNumber(b||"0")).gt(a),isInsufficientSourceTokenForSwap(a,b,c){let e=c?.find(a=>a.address===b)?.quantity?.numeric;return d.NumberUtil.bigNumber(e||"0").lt(a)}};var m=a.i(196283),n=a.i(993167),o=a.i(175787),p=a.i(490610),q=a.i(739741),r=a.i(832557),s=a.i(881791),t=a.i(802320),u=a.i(848800);let v={initializing:!1,initialized:!1,loadingPrices:!1,loadingQuote:!1,loadingApprovalTransaction:!1,loadingBuildTransaction:!1,loadingTransaction:!1,switchingTokens:!1,fetchError:!1,approvalTransaction:void 0,swapTransaction:void 0,transactionError:void 0,sourceToken:void 0,sourceTokenAmount:"",sourceTokenPriceInUSD:0,toToken:void 0,toTokenAmount:"",toTokenPriceInUSD:0,networkPrice:"0",networkBalanceInUSD:"0",networkTokenSymbol:"",inputError:void 0,slippage:i.ConstantsUtil.CONVERT_SLIPPAGE_TOLERANCE,tokens:void 0,popularTokens:void 0,suggestedTokens:void 0,foundTokens:void 0,myTokensWithBalance:void 0,tokensPriceMap:{},gasFee:"0",gasPriceInUSD:0,priceImpact:void 0,maxSlippage:void 0,providerFee:void 0},w=(0,b.proxy)({...v}),x={state:w,subscribe:a=>(0,b.subscribe)(w,()=>a(w)),subscribeKey:(a,b)=>(0,c.subscribeKey)(w,a,b),getParams(){let a=p.ChainController.state.activeChain,b=p.ChainController.getAccountData(a)?.caipAddress??p.ChainController.state.activeCaipAddress,c=j.CoreHelperUtil.getPlainAddress(b),f=(0,h.getActiveNetworkTokenAddress)(),g=r.ConnectorController.getConnectorId(p.ChainController.state.activeChain);if(!c)throw Error("No address found to swap the tokens from.");let i=!w.toToken?.address||!w.toToken?.decimals,k=!w.sourceToken?.address||!w.sourceToken?.decimals||!d.NumberUtil.bigNumber(w.sourceTokenAmount).gt(0),l=!w.sourceTokenAmount;return{networkAddress:f,fromAddress:c,fromCaipAddress:b,sourceTokenAddress:w.sourceToken?.address,toTokenAddress:w.toToken?.address,toTokenAmount:w.toTokenAmount,toTokenDecimals:w.toToken?.decimals,sourceTokenAmount:w.sourceTokenAmount,sourceTokenDecimals:w.sourceToken?.decimals,invalidToToken:i,invalidSourceToken:k,invalidSourceTokenAmount:l,availableToSwap:b&&!i&&!k&&!l,isAuthConnector:g===e.ConstantsUtil.CONNECTOR_ID.AUTH}},async setSourceToken(a){if(!a){w.sourceToken=a,w.sourceTokenAmount="",w.sourceTokenPriceInUSD=0;return}w.sourceToken=a,await y.setTokenPrice(a.address,"sourceToken")},setSourceTokenAmount(a){w.sourceTokenAmount=a},async setToToken(a){if(!a){w.toToken=a,w.toTokenAmount="",w.toTokenPriceInUSD=0;return}w.toToken=a,await y.setTokenPrice(a.address,"toToken")},setToTokenAmount(a){w.toTokenAmount=a?d.NumberUtil.toFixed(a,6):""},async setTokenPrice(a,b){let c=w.tokensPriceMap[a]||0;c||(w.loadingPrices=!0,c=await y.getAddressPrice(a)),"sourceToken"===b?w.sourceTokenPriceInUSD=c:"toToken"===b&&(w.toTokenPriceInUSD=c),w.loadingPrices&&(w.loadingPrices=!1),y.getParams().availableToSwap&&!w.switchingTokens&&y.swapTokens()},async switchTokens(){if(!w.initializing&&w.initialized&&!w.switchingTokens){w.switchingTokens=!0;try{let a=w.toToken?{...w.toToken}:void 0,b=w.sourceToken?{...w.sourceToken}:void 0,c=a&&""===w.toTokenAmount?"1":w.toTokenAmount;y.setSourceTokenAmount(c),y.setToTokenAmount(""),await y.setSourceToken(a),await y.setToToken(b),w.switchingTokens=!1,y.swapTokens()}catch(a){throw w.switchingTokens=!1,a}}},resetState(){w.myTokensWithBalance=v.myTokensWithBalance,w.tokensPriceMap=v.tokensPriceMap,w.initialized=v.initialized,w.initializing=v.initializing,w.switchingTokens=v.switchingTokens,w.sourceToken=v.sourceToken,w.sourceTokenAmount=v.sourceTokenAmount,w.sourceTokenPriceInUSD=v.sourceTokenPriceInUSD,w.toToken=v.toToken,w.toTokenAmount=v.toTokenAmount,w.toTokenPriceInUSD=v.toTokenPriceInUSD,w.networkPrice=v.networkPrice,w.networkTokenSymbol=v.networkTokenSymbol,w.networkBalanceInUSD=v.networkBalanceInUSD,w.inputError=v.inputError},resetValues(){let{networkAddress:a}=y.getParams(),b=w.tokens?.find(b=>b.address===a);y.setSourceToken(b),y.setToToken(void 0)},getApprovalLoadingState:()=>w.loadingApprovalTransaction,clearError(){w.transactionError=void 0},async initializeState(){if(!w.initializing){if(w.initializing=!0,!w.initialized)try{await y.fetchTokens(),w.initialized=!0}catch(a){w.initialized=!1,u.SnackController.showError("Failed to initialize swap"),t.RouterController.goBack()}w.initializing=!1}},async fetchTokens(){let{networkAddress:a}=y.getParams();await y.getNetworkTokenPrice(),await y.getMyTokensWithBalance();let b=w.myTokensWithBalance?.find(b=>b.address===a);b&&(w.networkTokenSymbol=b.symbol,y.setSourceToken(b),y.setSourceTokenAmount("0"))},async getTokenList(){let a=p.ChainController.state.activeCaipNetwork?.caipNetworkId;if(w.caipNetworkId!==a||!w.tokens)try{w.tokensLoading=!0;let b=await k.SwapApiUtil.getTokenList(a);w.tokens=b,w.caipNetworkId=a,w.popularTokens=b.sort((a,b)=>a.symbol<b.symbol?-1:+(a.symbol>b.symbol));let c=(a&&i.ConstantsUtil.SUGGESTED_TOKENS_BY_CHAIN?.[a]||[]).map(a=>b.find(b=>b.symbol===a)).filter(a=>!!a),d=(i.ConstantsUtil.SWAP_SUGGESTED_TOKENS||[]).map(a=>b.find(b=>b.symbol===a)).filter(a=>!!a).filter(a=>!c.some(b=>b.address===a.address));w.suggestedTokens=[...c,...d]}catch(a){w.tokens=[],w.popularTokens=[],w.suggestedTokens=[]}finally{w.tokensLoading=!1}},async getAddressPrice(a){let b=w.tokensPriceMap[a];if(b)return b;let c=await o.BlockchainApiController.fetchTokenPrice({addresses:[a]}),d=c?.fungibles||[],e=[...w.tokens||[],...w.myTokensWithBalance||[]],f=e?.find(b=>b.address===a)?.symbol,g=parseFloat((d.find(a=>a.symbol.toLowerCase()===f?.toLowerCase())?.price||0).toString());return w.tokensPriceMap[a]=g,g},async getNetworkTokenPrice(){let{networkAddress:a}=y.getParams(),b=await o.BlockchainApiController.fetchTokenPrice({addresses:[a]}).catch(()=>(u.SnackController.showError("Failed to fetch network token price"),{fungibles:[]})),c=b.fungibles?.[0],d=c?.price.toString()||"0";w.tokensPriceMap[a]=parseFloat(d),w.networkTokenSymbol=c?.symbol||"",w.networkPrice=d},async getMyTokensWithBalance(a){let b=await g.BalanceUtil.getMyTokensWithBalance(a),c=k.SwapApiUtil.mapBalancesToSwapTokens(b);c&&(await y.getInitialGasPrice(),y.setBalances(c))},setBalances(a){let{networkAddress:b}=y.getParams(),c=p.ChainController.state.activeCaipNetwork;if(!c)return;let e=a.find(a=>a.address===b);a.forEach(a=>{w.tokensPriceMap[a.address]=a.price||0}),w.myTokensWithBalance=a.filter(a=>a.address.startsWith(c.caipNetworkId)),w.networkBalanceInUSD=e?d.NumberUtil.multiply(e.quantity.numeric,e.price).toString():"0"},async getInitialGasPrice(){let a=await k.SwapApiUtil.fetchGasPrice();if(!a)return{gasPrice:null,gasPriceInUSD:null};switch(p.ChainController.state?.activeCaipNetwork?.chainNamespace){case e.ConstantsUtil.CHAIN.SOLANA:return w.gasFee=a.standard??"0",w.gasPriceInUSD=d.NumberUtil.multiply(a.standard,w.networkPrice).div(1e9).toNumber(),{gasPrice:BigInt(w.gasFee),gasPriceInUSD:Number(w.gasPriceInUSD)};case e.ConstantsUtil.CHAIN.EVM:default:let b=a.standard??"0",c=BigInt(b),f=BigInt(15e4),g=l.getGasPriceInUSD(w.networkPrice,f,c);return w.gasFee=b,w.gasPriceInUSD=g,{gasPrice:c,gasPriceInUSD:g}}},async swapTokens(){let a=p.ChainController.getAccountData()?.address,b=w.sourceToken,c=w.toToken,e=d.NumberUtil.bigNumber(w.sourceTokenAmount).gt(0);if(e||y.setToTokenAmount(""),!c||!b||w.loadingPrices||!e||!a)return;w.loadingQuote=!0;let f=d.NumberUtil.bigNumber(w.sourceTokenAmount).times(10**b.decimals).round(0);try{let e=await o.BlockchainApiController.fetchSwapQuote({userAddress:a,from:b.address,to:c.address,gasPrice:w.gasFee,amount:f.toString()});w.loadingQuote=!1;let g=e?.quotes?.[0]?.toAmount;if(!g)return void n.AlertController.open({displayMessage:"Incorrect amount",debugMessage:"Please enter a valid amount"},"error");let h=d.NumberUtil.bigNumber(g).div(10**c.decimals).toString();y.setToTokenAmount(h),y.hasInsufficientToken(w.sourceTokenAmount,b.address)?w.inputError="Insufficient balance":(w.inputError=void 0,y.setTransactionDetails())}catch(b){let a=await k.SwapApiUtil.handleSwapError(b);w.loadingQuote=!1,w.inputError=a||"Insufficient balance"}},async getTransaction(){let{fromCaipAddress:a,availableToSwap:b}=y.getParams(),c=w.sourceToken,d=w.toToken;if(a&&b&&c&&d&&!w.loadingQuote)try{let b;return w.loadingBuildTransaction=!0,b=await k.SwapApiUtil.fetchSwapAllowance({userAddress:a,tokenAddress:c.address,sourceTokenAmount:w.sourceTokenAmount,sourceTokenDecimals:c.decimals})?await y.createSwapTransaction():await y.createAllowanceTransaction(),w.loadingBuildTransaction=!1,w.fetchError=!1,b}catch(a){t.RouterController.goBack(),u.SnackController.showError("Failed to check allowance"),w.loadingBuildTransaction=!1,w.approvalTransaction=void 0,w.swapTransaction=void 0,w.fetchError=!0;return}},async createAllowanceTransaction(){let{fromCaipAddress:a,sourceTokenAddress:b,toTokenAddress:c}=y.getParams();if(a&&c){if(!b)throw Error("createAllowanceTransaction - No source token address found.");try{let d=await o.BlockchainApiController.generateApproveCalldata({from:b,to:c,userAddress:a}),e=j.CoreHelperUtil.getPlainAddress(d.tx.from);if(!e)throw Error("SwapController:createAllowanceTransaction - address is required");let f={data:d.tx.data,to:e,gasPrice:BigInt(d.tx.eip155.gasPrice),value:BigInt(d.tx.value),toAmount:w.toTokenAmount};return w.swapTransaction=void 0,w.approvalTransaction={data:f.data,to:f.to,gasPrice:f.gasPrice,value:f.value,toAmount:f.toAmount},{data:f.data,to:f.to,gasPrice:f.gasPrice,value:f.value,toAmount:f.toAmount}}catch(a){t.RouterController.goBack(),u.SnackController.showError("Failed to create approval transaction"),w.approvalTransaction=void 0,w.swapTransaction=void 0,w.fetchError=!0;return}}},async createSwapTransaction(){let{networkAddress:a,fromCaipAddress:b,sourceTokenAmount:c}=y.getParams(),d=w.sourceToken,e=w.toToken;if(!b||!c||!d||!e)return;let f=q.ConnectionController.parseUnits(c,d.decimals)?.toString();try{let c=await o.BlockchainApiController.generateSwapCalldata({userAddress:b,from:d.address,to:e.address,amount:f,disableEstimate:!0}),g=d.address===a,h=BigInt(c.tx.eip155.gas),i=BigInt(c.tx.eip155.gasPrice),k=j.CoreHelperUtil.getPlainAddress(c.tx.to);if(!k)throw Error("SwapController:createSwapTransaction - address is required");let m={data:c.tx.data,to:k,gas:h,gasPrice:i,value:g?BigInt(f??"0"):BigInt("0"),toAmount:w.toTokenAmount};return w.gasPriceInUSD=l.getGasPriceInUSD(w.networkPrice,h,i),w.approvalTransaction=void 0,w.swapTransaction=m,m}catch(a){t.RouterController.goBack(),u.SnackController.showError("Failed to create transaction"),w.approvalTransaction=void 0,w.swapTransaction=void 0,w.fetchError=!0;return}},onEmbeddedWalletApprovalSuccess(){u.SnackController.showLoading("Approve limit increase in your wallet"),t.RouterController.replace("SwapPreview")},async sendTransactionForApproval(a){let{fromAddress:b,isAuthConnector:c}=y.getParams();w.loadingApprovalTransaction=!0,c?t.RouterController.pushTransactionStack({onSuccess:y.onEmbeddedWalletApprovalSuccess}):u.SnackController.showLoading("Approve limit increase in your wallet");try{await q.ConnectionController.sendTransaction({address:b,to:a.to,data:a.data,value:a.value,chainNamespace:e.ConstantsUtil.CHAIN.EVM}),await y.swapTokens(),await y.getTransaction(),w.approvalTransaction=void 0,w.loadingApprovalTransaction=!1}catch(a){w.transactionError=a?.displayMessage,w.loadingApprovalTransaction=!1,u.SnackController.showError(a?.displayMessage||"Transaction error"),s.EventsController.sendEvent({type:"track",event:"SWAP_APPROVAL_ERROR",properties:{message:a?.displayMessage||a?.message||"Unknown",network:p.ChainController.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:y.state.sourceToken?.symbol||"",swapToToken:y.state.toToken?.symbol||"",swapFromAmount:y.state.sourceTokenAmount||"",swapToAmount:y.state.toTokenAmount||"",isSmartAccount:(0,h.getPreferredAccountType)(e.ConstantsUtil.CHAIN.EVM)===f.W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT}})}},async sendTransactionForSwap(a){if(!a)return;let{fromAddress:b,toTokenAmount:c,isAuthConnector:g}=y.getParams();w.loadingTransaction=!0;let i=`Swapping ${w.sourceToken?.symbol} to ${d.NumberUtil.formatNumberToLocalString(c,3)} ${w.toToken?.symbol}`,j=`Swapped ${w.sourceToken?.symbol} to ${d.NumberUtil.formatNumberToLocalString(c,3)} ${w.toToken?.symbol}`;g?t.RouterController.pushTransactionStack({onSuccess(){t.RouterController.replace("Account"),u.SnackController.showLoading(i),x.resetState()}}):u.SnackController.showLoading("Confirm transaction in your wallet");try{let c=[w.sourceToken?.address,w.toToken?.address].join(","),d=await q.ConnectionController.sendTransaction({address:b,to:a.to,data:a.data,value:a.value,chainNamespace:e.ConstantsUtil.CHAIN.EVM});return w.loadingTransaction=!1,u.SnackController.showSuccess(j),s.EventsController.sendEvent({type:"track",event:"SWAP_SUCCESS",properties:{network:p.ChainController.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:y.state.sourceToken?.symbol||"",swapToToken:y.state.toToken?.symbol||"",swapFromAmount:y.state.sourceTokenAmount||"",swapToAmount:y.state.toTokenAmount||"",isSmartAccount:(0,h.getPreferredAccountType)(e.ConstantsUtil.CHAIN.EVM)===f.W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT}}),x.resetState(),g||t.RouterController.replace("Account"),x.getMyTokensWithBalance(c),d}catch(a){w.transactionError=a?.displayMessage,w.loadingTransaction=!1,u.SnackController.showError(a?.displayMessage||"Transaction error"),s.EventsController.sendEvent({type:"track",event:"SWAP_ERROR",properties:{message:a?.displayMessage||a?.message||"Unknown",network:p.ChainController.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:y.state.sourceToken?.symbol||"",swapToToken:y.state.toToken?.symbol||"",swapFromAmount:y.state.sourceTokenAmount||"",swapToAmount:y.state.toTokenAmount||"",isSmartAccount:(0,h.getPreferredAccountType)(e.ConstantsUtil.CHAIN.EVM)===f.W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT}});return}},hasInsufficientToken:(a,b)=>l.isInsufficientSourceTokenForSwap(a,b,w.myTokensWithBalance),setTransactionDetails(){let{toTokenAddress:a,toTokenDecimals:b}=y.getParams();a&&b&&(w.gasPriceInUSD=l.getGasPriceInUSD(w.networkPrice,BigInt(w.gasFee),BigInt(15e4)),w.priceImpact=l.getPriceImpact({sourceTokenAmount:w.sourceTokenAmount,sourceTokenPriceInUSD:w.sourceTokenPriceInUSD,toTokenPriceInUSD:w.toTokenPriceInUSD,toTokenAmount:w.toTokenAmount}),w.maxSlippage=l.getMaxSlippage(w.slippage,w.toTokenAmount),w.providerFee=l.getProviderFee(w.sourceTokenAmount))}},y=(0,m.withErrorBoundary)(x);a.s(["SwapController",0,y],903158)}];

//# sourceMappingURL=89298_%40reown_appkit-controllers_dist_esm_src_controllers_SwapController_6d2707fb.js.map